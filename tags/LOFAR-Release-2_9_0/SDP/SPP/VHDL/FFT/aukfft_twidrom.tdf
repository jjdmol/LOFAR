-------------------------------------------------------------------------
-------------------------------------------------------------------------
--
-- Revision Control Information
--
-- Header
--
-- $Workfile:   aukfft_twidrom.tdf  $
--
-- $Revision:   1.9  $
--
-- $Date:   20 Mar 2002 14:24:52  $
--
-- $Project     :  FFT
--
-- Description  :  Subdesign : aukfft_twidrom
--
-- Copyright 2000 (c) Altera Corporation
-- All rights reserved
--
-------------------------------------------------------------------------
-------------------------------------------------------------------------

INCLUDE "altsyncram.inc";


FUNCTION lpm_rom 
(
	address[LPM_WIDTHAD-1..0], 
	inclock, 
	outclock, 
	memenab
)
RETURNS 
(
	q[LPM_WIDTH-1..0]
);

PARAMETERS
(
    addresswidth 			= 8,
    twiddlewidth 			= 16,
    sin_file 				= "../demonstrator/myfftcore_twidsin.hex",
    cos_file 				= "../demonstrator/myfftcore_twidcos.hex",
    stratix 				= 0,
    backward_compatible 	= 0
);

constant num_words = 2^(addresswidth-2);

-- for backward compatible non-stratix architecture
-- previous design address of rom not registered
constant reg_rom_addr = (backward_compatible == 1) ? "UNREGISTERED" : "REGISTERED";

-- for backward compatible implemented in stratix architecture
-- output of rom not registered
constant reg_stratix_rom_op = (backward_compatible == 1) ? "UNREGISTERED" : "CLOCK0";

-- increased pipelining in non-backward compatible design
constant delay_quad = (backward_compatible == 1) ? 1 : 4; 

subdesign aukfft_twidrom
(
    sysclk 						: INPUT;
    address[addresswidth..1] 	: INPUT;
    
    twreal[twiddlewidth..1] 	: OUTPUT;
    twimag[twiddlewidth..1] 	: OUTPUT;
)



VARIABLE
    quad_address[addresswidth-2..1] 	: node;
    quad_select[2..1] 					: node;
    dlyquad_select[delay_quad..1][2..1] : dffe;
    sel_reg 							: dffe;
    sel 								: node;
    
    quad_sin_reg[twiddlewidth..1]		: dffe;
    quad_cos_reg[twiddlewidth..1] 		: dffe;
    quad_sin[twiddlewidth..1] 			: node;
    quad_cos[twiddlewidth..1] 			: node;    

    regrealout[twiddlewidth..1] 		: dffe;
    regimagout[twiddlewidth..1] 		: dffe;
    
    mux_real[twiddlewidth..1] 			: node;
    mux_imag[twiddlewidth..1] 			: node;
    neg_real[twiddlewidth..1] 			: node;
    neg_imag[twiddlewidth..1] 			: node;
    mux_real_reg[twiddlewidth..1] 		: dffe;         
    mux_imag_reg[twiddlewidth..1] 		: dffe;  
    
 

    -- initialized altsynram if using stratix device family

    sinrom_stratix	: 	altsyncram 
    					WITH 
    					(
						WIDTH_A 				= twiddlewidth,
						WIDTHAD_A 				= addresswidth-2,
						NUMWORDS_A 				= num_words,
						INTENDED_DEVICE_FAMILY 	= "Stratix",
						OPERATION_MODE 			= "ROM",
						OUTDATA_REG_A 			= reg_stratix_rom_op,
						ADDRESS_ACLR_A 			= "NONE",
						OUTDATA_ACLR_A 			= "NONE",
						WIDTH_BYTEENA_A 		= 1,
						INIT_FILE 				= sin_file
						);
			
			
    cosrom_stratix 	: 	altsyncram 
    					WITH 
    					(
						WIDTH_A 				= twiddlewidth,
						WIDTHAD_A 				= addresswidth-2,
						NUMWORDS_A 				= num_words,
						INTENDED_DEVICE_FAMILY 	= "Stratix",
						OPERATION_MODE 			= "ROM",
						OUTDATA_REG_A 			= reg_stratix_rom_op,
						ADDRESS_ACLR_A 			= "NONE",
						OUTDATA_ACLR_A 			= "NONE",
						WIDTH_BYTEENA_A 		= 1,
						INIT_FILE 				= cos_file
						);

    -- lpm_rom used for non-stratix devices

    sinrom 			: 	lpm_rom 
    					WITH 
    					(
    					LPM_WIDTH 				= twiddlewidth,
                        LPM_WIDTHAD 			= addresswidth-2,
                        LPM_FILE 				= sin_file,
                        LPM_ADDRESS_CONTROL 	= reg_rom_addr,  
                        LPM_OUTDATA 			= "REGISTERED"
                        );
                        
    cosrom 			: 	lpm_rom 
    					WITH 
    					(
    					LPM_WIDTH 				= twiddlewidth,
                        LPM_WIDTHAD 			= addresswidth-2,
                        LPM_FILE 				= cos_file,
                        LPM_ADDRESS_CONTROL 	= reg_rom_addr,  
                        LPM_OUTDATA 			= "REGISTERED"
                      	);

BEGIN

    -- top two bits of address determine quadrant
    quad_select[]  					= address[addresswidth..addresswidth-1];
    
    -- remainder of bits determine address in quadrant    
    quad_address[] 					= address[addresswidth-2..1];


    -- DELAY THE SELECT SIGNALS TO REMAIN SYNCHRONISED WITH
    -- THE DATA WHICH IT WILL LATER MULTIPLEX

    --dlyquad_select is a shift register
    dlyquad_select[][].clk 			= sysclk;
    dlyquad_select[1][] 			= quad_select[];
    -- quadrant loaded into dlyquad_select[1]
    
    for i in 2 to delay_quad generate
    	if delay_quad > 1 generate
      	
    	    dlyquad_select[i][] 	= dlyquad_select[i-1][];    	
    	
    	end generate;
    end generate;




    if stratix == 1 generate
    	-- for stratix use altsyncram

    	assert report "using altsyncram"  severity info;
            
        sinrom_stratix.address_a[] 	= quad_address[]; 
        quad_sin[] 					= sinrom_stratix.q_a[];
                       
        cosrom_stratix.address_a[] 	= quad_address[]; 
        quad_cos[] 					= cosrom_stratix.q_a[];
    
    else generate
    	-- for non-stratix architecture use lpm_rom
    	assert report "using dpram"  severity info;    
    	sinrom.address[] 			= quad_address[];
    	quad_sin[] 					= sinrom.q[];      
    
    	cosrom.address[] 			= quad_address[];
    	quad_cos[] 					= cosrom.q[];    
    
    end generate;

    sinrom_stratix.clock0 			= sysclk;  
    cosrom_stratix.clock0 			= sysclk; 
    
    sinrom.outclock 				= sysclk;
    cosrom.outclock 				= sysclk;


    if backward_compatible == 1 generate
    	-- total latency 2 clock cycles
    	-- delay quad by 1 clock cycle
    	assert report "backward compatible"  severity info;    
    	mux_real[] 					= (quad_cos[] & !dlyquad_select[1][1]) # (quad_sin[] &  dlyquad_select[1][1]);    
    	mux_imag[] 					= (quad_cos[] &  dlyquad_select[1][1]) # (quad_sin[] & !dlyquad_select[1][1]); 
    
    	sel 						= dlyquad_select[1][1] XOR dlyquad_select[1][2]; 
    	
    	regimagout[] 				= (neg_imag[] & !dlyquad_select[1][2]) # (mux_imag[] & dlyquad_select[1][2]);
    	    
       
    else generate
    	-- pipelined twiddle 
    	-- delay quad by 4 in total
    	assert report "non-backward compatible"  severity info;
    	quad_sin_reg[] 				= quad_sin[];
    	quad_cos_reg[] 				= quad_cos[];
    	
        
    	mux_real_reg[] 				= (quad_cos_reg[] & !dlyquad_select[3][1]) # (quad_sin_reg[] &  dlyquad_select[3][1]);
    	mux_real[] 					= mux_real_reg[];
    	mux_imag_reg[] 				= (quad_cos_reg[] &  dlyquad_select[3][1]) # (quad_sin_reg[] & !dlyquad_select[3][1]);    
    	mux_imag[] 					= mux_imag_reg[];
    	
    	sel_reg 					= dlyquad_select[3][1] XOR dlyquad_select[3][2];
    	sel 						= sel_reg;
    	
    	regimagout[] 				= (neg_imag[] & !dlyquad_select[4][2]) # (mux_imag[] & dlyquad_select[4][2]);
    	
    	sinrom.inclock 				= sysclk;    	
    	cosrom.inclock 				= sysclk;    
        
    end generate;
	
	quad_sin_reg[].clk 				= sysclk;
	quad_cos_reg[].clk 				= sysclk;


    neg_real[] 						= -mux_real[];
    neg_imag[] 						= -mux_imag[];

    regrealout[].clk 				= sysclk;
    regimagout[].clk 				= sysclk;
    
    sel_reg.clk 					= sysclk;
    
    mux_real_reg[].clk 				= sysclk;
    mux_imag_reg[].clk 				= sysclk;
        
    regrealout[] 					= (neg_real[] & sel) # (mux_real[] & !sel);

    twreal[] 						= regrealout[];
    twimag[] 						= regimagout[];
    
END;
