<html>  

<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>IndexedDBView &lt;View, IdxContainer, HashOrNoHash&gt;</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p> 
<h1>IndexedDBView &lt;View, IdxContainer, HashOrNoHash&gt;</h1>



















<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td><img src="containers.gif" width="194" height="38"></td>
        <td align="right"><img src="type.gif" width="194"
        height="39"></td>
    </tr>
    <tr>
        <td valign="top"><b>Category</b>: containers</td>
        <td align="right" valign="top"><b>Component type</b>:
        type</td>
    </tr>
</table>
<h3>Description</h3>

<p>The <font size="2" face="Courier New">IndexedDBView </font>Container is a refinement 
  of a <a
href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">Unique Associative 
  Container</a> with the property that elements may be bound to an underlying 
  database and may be indexed by one or more criteria. Each index stores (and 
  sorts or hashes) references to the data in an underlying container built by 
  a <font face="Courier New, Courier, mono" size="2"><a href="ContainerFactory.htm">ContainerFactory</a></font>.</p>

<h3>Definition</h3>

<p>Defined in the <font size="2" face="Courier New">IndexedDBView.h
</font><font size="3">header file.</font></p>

<h3>Refinement of</h3>

<p><a
href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">Unique
Associative Container</a> </p>

<h3>Associated types</h3>

<p>In addition to those defined by <a
href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">Unique Associative 
  Container</a>:</p>
<table border="1">
  <a name="Args">
  <tr> 
    <td valign="top" width="73">Argument object type</td>
    <td valign="top" width="135"><font size="2" face="Courier New, Courier, mono">IndexedDBView::Args</font></td>
    <td valign="top" width="758"> 
      <p>Nested class for arguments object used to pass parameters 
        to the <font face="Courier New, Courier, mono" size="2">DBView</font> 
        constructor.</p>
      <p>Accessors to set arguments in an <font face="Courier New, Courier, mono" size="2">Args</font> 
        object (all return <font size="2" face="Courier New, Courier, mono">*this</font> 
        as an <font size="2" face="Courier New, Courier, mono">Args &amp;</font>):</p>
      <ul>
        <li><font face="Courier New, Courier, mono" size="2">view(const View &amp;view) 
          - corresponds to view parameter in main constructor - no default value</font></li>
        <li><font face="Courier New, Courier, mono" size="2">indexes(const string 
          &amp;IndexNamesAndFields) - corresponds to IndexNamesAndFields parameter 
          in main constructor - must be set for IndexedDBView to be valid</font></li>
        <li><font face="Courier New, Courier, mono" size="2">bound(BoundMode bm) 
          - corresponds to bm parameter in main constructor - default value: UNBOUND</font></li>
        <li><font face="Courier New, Courier, mono" size="2">key(KeyMode km) - 
          corresponds to km parameter in main constructor - default value: USE_ALL_FIELDS</font></li>
        <li><font face="Courier New, Courier, mono" size="2">params(const SetParamsFn 
          IndexedDBViewParams) - corresponds to IndexedDBViewParams parameter 
          in main constructor - default value: DefaultSetParams&lt;ParamObj&gt;()</font></li>
        <li><font face="Courier New, Courier, mono" size="2">fetch_mode(FetchMode 
          fm) - corresponds to fm parameter in main constructor - default value: 
          DEFAULT_FETCH_MODE (defined in dtl_config.h - <b>Note that for code 
          using older versions of DTL, you may need to #define DEFAULT_FETCH_MODE 
          to be SINGLE_FETCH or explicitly set your view to use SINGLE_FETCH if 
          bulk_copy() throws</b>)</font></li>
        <li><font face="Courier New, Courier, mono" size="2">fetch_records(size_t 
          fr) - corresponds to fr parameter in main constructor - default value: 
          100 </font></li>
      </ul>
      <p>To set the arguments, default construct an<font size="2" face="Courier New, Courier, mono"> 
        Args</font> object and then successively apply accessors to this object. 
        The parameters you reference will be set to the passed in values, all 
        others will receive their default values. For example, to construct a 
        indexed view of <font face="Courier New, Courier, mono" size="2">Example</font> 
        objects that references a <font size="2" face="Courier New, Courier, mono">DBView 
        </font>named<font face="Courier New, Courier, mono" size="2"> view</font>, 
        has a unique primary key from a column named <font face="Courier New, Courier, mono" size="2">INT_VALUE</font> 
        and has a function for the indexed view to set the query parameters named 
        <font face="Courier New, Courier, mono"> <font size="2">ExampleSetParams</font></font>, 
        you would say:</p>
      <pre><font size="2" face="Courier New, Courier, mono">typedef DBView&lt;Example&gt; DBV;</font></pre>
      <pre><font size="2" face="Courier New, Courier, mono">DBV view(DBV::Args().tables(&quot;DB_EXAMPLE&quot;).conn(myConn));</font></pre>
      <pre><font face="Courier New, Courier, mono" size="2">IndexedDBView&lt;DBV&gt; indexed_view(
   IndexedDBView&lt;DBV&gt;::Args().view(view).indexes(&quot;Unique PrimaryKey; INT_VALUE&quot;).params(cb_ptr_fun(ExampleSetParams))
); </font></pre>
      <p>The <font face="Courier New, Courier, mono" size="2">Args</font> class 
        is designed to emulate named arguments so you don't have to pass arguments 
        around that just use their default values. The constructor call above 
        would have to explicitly pass 3 arguments with their corresponding default 
        values, which is tedious, hard to read, and very error prone.</p>
    </td>
  </tr>
  </a>
</table>
<p>&nbsp; </p>

<h3>Example</h3>

<p><pre><code><span class="codeComment">// &quot;Example&quot; class to hold rows from our database table</span>
class Example
{
  public:                                        <span class="codeComment">// tablename.columnname:</span>
	int exampleInt;                         <span class="codeComment">// DB_EXAMPLE.INT_VALUE</span>
	string exampleStr;                      <span class="codeComment">// DB_EXAMPLE.STRING_VALUE</span>
	double exampleDouble;                   <span class="codeComment">// DB_EXAMPLE.DOUBLE_VALUE</span>
	long exampleLong;                       <span class="codeComment">// DB_EXAMPLE.EXAMPLE_LONG</span>
	TIMESTAMP_STRUCT exampleDate;           <span class="codeComment">// DB_EXAMPLE.EXAMPLE_DATE</span>

	Example(int exInt, const string &amp;exStr, double exDouble, long exLong,
		const TIMESTAMP_STRUCT &amp;exDate) :
	   exampleInt(exInt), exampleStr(exStr), exampleDouble(exDouble), exampleLong(exLong),
	   exampleDate(exDate)
	{ }

};

<span class="codeComment">// Parameter object to hold parameters for dynamic SQL query below </span>
class ParamObjExample
{
    public:
	int lowIntValue;
	int highIntValue;
	string strValue;
	TIMESTAMP_STRUCT dateValue;
};

<span class="codeComment">// Create an association between table columns and fields in our object</span>
class BCAExampleObj
{
public:
	void operator()(BoundIOs &amp;boundIOs, Example &amp;rowbuf)
    	{
	   boundIOs[&quot;INT_VALUE&quot;]	== rowbuf.exampleInt;
	   boundIOs[&quot;STRING_VALUE&quot;]	== rowbuf.exampleStr;
	   boundIOs[&quot;DOUBLE_VALUE&quot;]	== rowbuf.exampleDouble;
	   boundIOs[&quot;EXAMPLE_LONG&quot;]	== rowbuf.exampleLong;
	   boundIOs[&quot;EXAMPLE_DATE&quot;]	== rowbuf.exampleDate;
	}
};

<span class="codeComment">// Create an association between query parameters and fields in our parameters object</span>
class BPAExampleObj
{
public:
	void operator()(BoundIOs &amp;boundIOs, ParamObjExample &amp;paramObj)
	{
	  boundIOs[0] == paramObj.lowIntValue;
	  boundIOs[1] == paramObj.highIntValue;
	  boundIOs[2] == paramObj.strValue;
	  boundIOs[3] == paramObj.dateValue;
	}

};

<span class="codeComment">// Set parameters function for Example ... used by IndexedDBView&lt;Example&gt; to set dynamic query parameters
// Dynamic query parameters are indicated by (?) in our query string for the IndexedDBView</span>
void SetParamsExample(ParamObjExample &amp;params)
{
	<span class="codeComment">// set parameter values</span>
	params.lowIntValue = 2;
	params.highIntValue = 8;
	params.strValue = &quot;Example&quot;;
	
	TIMESTAMP_STRUCT paramDate = {2000, 1, 1, 0, 0, 0, 0};
	params.dateValue = paramDate;
}


<span class="codeComment">// Example of using an IndexDBView to read, insert and update records in a container / database</span>
void IndexedViewExample()
{
	typedef DBView&lt;Example, ParamObjExample&gt; DBV;

	DBV view(&quot;DB_EXAMPLE&quot;,   BCAExampleObj(), 
	  &quot;WHERE INT_VALUE BETWEEN (?) AND (?) OR &quot;
	  &quot;STRING_VALUE = (?) OR EXAMPLE_DATE &lt;= (?) ORDER BY EXAMPLE_LONG&quot;,
	  BPAExampleObj());

	IndexedDBView&lt;DBV&gt; indexed_view(view, &quot;UNIQUE PrimaryIndex; STRING_VALUE; AlternateIndex; EXAMPLE_LONG, EXAMPLE_DATE&quot;, 
	  BOUND, USE_ALL_FIELDS, cb_ptr_fun(SetParamsExample));
   		

	<span class="codeComment">// Find the item where the STRING_VALUE matches the string &quot;Foozle&quot;</span>
	IndexedDBView&lt;DBV&gt;::iterator idxview_it = indexed_view.find(string(&quot;Foozle&quot;));
		

	<span class="codeComment">// Update the item with the key of &quot;Foozle&quot;, to read &quot;Fizzle&quot; instead</span>
	if (idxview_it != indexed_view.end()) {
		Example replacement;
		replacement = *idxview_it;
		replacement.exampleStr = &quot;Fizzle&quot;;
		indexed_view.replace(idxview_it, replacement);
	}

	<span class="codeComment">// Now find a second set of items using AlternateIndex
	// The STL convention for equal_range is to return a pair consisting of:  
	// 1. an iterator referring to the beginning of the list of found items
	// 2. an iterator pointing to the end of the list of found items. 
	// We will remove all items in this range.</span>
	const TIMESTAMP_STRUCT date_criteria = {2000, 1, 1, 0, 0, 0, 0};
	long long_criteria = 33;
	pair&lt;IndexedDBView&lt;DBV&gt;::iterator, IndexedDBView&lt;DBV&gt;::iterator&gt; pr = 
		indexed_view.equal_range_AK (&quot;AlternateIndex&quot;, long_criteria, date_criteria);

	idxview_it = pr.first;

	cout &lt;&lt; &quot;*** Size before erase calls: &quot; &lt;&lt; indexed_view.size() &lt;&lt; &quot; ***&quot;
	     &lt;&lt; endl;
		
	<span class="codeComment">// Remove all items that match the criteria in our equal_range_AK lookup</span>
	while (idxview_it != pr.second)
	{
		<span class="codeComment">// As iterator is invalidated upon an erase(), use a
		// temporary iterator to point to DataObj to erase.
		// Increment idxview_it before we erase so it will still be valid
		// when we erase the DataObj.</span>
		IndexedDBView&lt;DBV&gt;::iterator deleteMe = idxview_it;

		idxview_it++;

		indexed_view.erase(deleteMe);

	}

	cout &lt;&lt; &quot;*** Size after erase calls: &quot; &lt;&lt; indexed_view.size() &lt;&lt; &quot; ***&quot;
	     &lt;&lt; endl;


	<span class="codeComment">// Finally, insert a new item into the container</span>
	pair&lt;IndexedDBView&lt;DBV&gt;::iterator, bool&gt; ins_pr;

	ins_pr = indexed_view.insert(Example(459, &quot;Unique String #1&quot;, 3.4, 1, date_criteria));

	cout &lt;&lt; &quot;insertion succeded = &quot; &lt;&lt; (ins_pr.second == true ? &quot;true&quot;: &quot;false&quot;) &lt;&lt; endl;

}
</code></pre> </p>

<h3>Public Base Classes</h3>

<p>None.</p>

<h3>Template parameters</h3>

<table border="1">
  <tr> 
    <th>Parameter </th>
    <th>Description </th>
    <th>Default </th>
  </tr>
  <tr> 
    <td valign="top"><tt>View</tt> </td>
    <td valign="top">The type of the SQL view (usually a <a
        href="DBView.htm"><font size="2" face="Courier New">DBView</font></a><font
        size="2" face="Courier New"> </font>instantiation which will be used as 
      the underlying view for the<font size="2"
        face="Courier New"> IndexedDBView</font>).</td>
    <td valign="top">&nbsp; </td>
  </tr>
  <tr> 
    <td valign="top"><font size="2" face="Courier New, Courier, mono">IdxContainer</font></td>
    <td valign="top">The type of the underlying associative container used by 
      each index to maintain its sorted collection of references to the data stored 
      in the indexed view.</td>
    <td valign="top">
      <p><font face="Times New Roman, Times, serif" size="3">On STLPort and GCC:</font><font face="Courier New, Courier, mono" size="2"> 
        hash_multiset&lt;DataObj *, hash_functor&lt;DataObj&gt;, eq_functor&lt;DataObj&gt; 
        &gt;</font></p>
      <p><font face="Times New Roman, Times, serif" size="3">All other configurations:</font><font face="Courier New, Courier, mono" size="2"> 
        multiset&lt;DataObj *, lt_functor&lt;DataObj&gt; &gt;</font></p>
    </td>
  </tr>
  <tr>
    <td valign="top"><font face="Courier New, Courier, mono" size="2">HashOrNoHash</font></td>
    <td valign="top">
      <p>Type of tag structure which specifies whether the <font size="2" face="Courier New, Courier, mono">IdxContainer</font> 
        is hashed or not. This parameter must be either <font face="Courier New, Courier, mono" size="2">HASH 
        <font size="3"> <font face="Times New Roman, Times, serif">or</font></font> 
        NO_HASH.</font></p>
      </td>
    <td valign="top"><font face="Times New Roman, Times, serif" size="3">On STLPort 
      and GCC:</font><font face="Courier New, Courier, mono" size="2"> HASH<br>
      <font size="3" face="Times New Roman, Times, serif">All other configurations:</font> 
      NO_HASH</font></td>
  </tr>
</table>

<p>&nbsp;</p>

<h3>Notation</h3>

<table border="0">
    <tr>
        <td valign="top"><tt>X</tt> </td>
        <td valign="top">A type that is a model of <font size="2"
        face="Courier New">IndexedDBView </font></td>
    </tr>
    <tr>
        <td valign="top"><tt>a</tt> </td>
        <td valign="top">Object of type <tt>X</tt> </td>
    </tr>
    <tr>
        <td valign="top"><tt>t</tt> </td>
        <td valign="top">Object of type <tt>X::value_type</tt> </td>
    </tr>
    <tr>
        <td valign="top"><tt>k</tt> </td>
        <td valign="top">Object of type <tt>X::key_type</tt> </td>
    </tr>
    <tr>
        <td valign="top"><tt>p</tt>, <tt>q</tt> </td>
        <td valign="top">Object of type <tt>X::iterator</tt> </td>
    </tr>
    <tr>
        <td valign="top"><tt>f1, f2, ..., fn</tt></td>
        <td valign="top">A primitive C type such as <font
        size="2" face="Courier New">int, double, float,</font>...
        or STL <font size="2" face="Courier New">string</font></td>
    </tr>
    <tr>
        <td valign="top"><tt>s</tt></td>
        <td valign="top">A STL <font size="2" face="Courier New">string</font></td>
    </tr>
</table>

<h3>Valid expressions</h3>

<p>In addition to the expressions defined in <a
href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">Unique
Associative Container</a>, the following expressions must be
valid. </p>

<table border="1">
  <tr> 
    <th>Name </th>
    <th>Expression </th>
    <th>Type requirements </th>
    <th>Return type </th>
  </tr>
  <tr> 
    <td valign="top">Main constructor </td>
    <td valign="top">
      <pre>X a( 
 DBView&lt;...&gt; &amp;view, 
 const string &amp;IndexNamesAndFields,
 BoundMode bm = UNBOUND, 
 KeyMode km = USE_ALL_FIELDS, 
 SetParamsFn IndexedDBViewParam = DefaultSetParams&lt;ParamObj&gt;(),
 FetchMode fm = DEFAULT_FETCH_MODE, size_t fr = 100)
</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">&nbsp; </td>
  </tr>
  <tr>
    <td valign="top">Main constructor accepting an arguments object</td>
    <td valign="top"><font face="Courier New, Courier, mono" size="2">X a(const 
      Args &amp;args)</font></td>
    <td valign="top">&nbsp;</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Find alternate key</td>
    <td valign="top"><tt>a.find_AK(s, k)</tt> </td>
    <td valign="top">&nbsp; </td>
    <td valign="top"><tt>const_iterator</tt> </td>
  </tr>
  <tr> 
    <td valign="top">Equal range alternate key</td>
    <td valign="top"><tt>a.equal_range_AK(s, k)</tt> </td>
    <td valign="top">&nbsp; </td>
    <td valign="top"><tt>pair&lt;const_iterator, const_iterator&gt;</tt>. </td>
  </tr>
  <tr> 
    <td valign="top">Find using key fields</td>
    <td valign="top"><tt>a.find(f1, ..., fn)</tt> </td>
    <td valign="top">&nbsp; </td>
    <td valign="top"><tt>const_iterator</tt> </td>
  </tr>
  <tr> 
    <td valign="top">Equal range using key fields</td>
    <td valign="top"><tt>a.equal_range(f1, ..., fn)</tt></td>
    <td valign="top">&nbsp; </td>
    <td valign="top"><tt>pair&lt;const_iterator, const_iterator&gt;</tt> </td>
  </tr>
  <tr> 
    <td valign="top">Find using alternate key fields</td>
    <td valign="top"><tt>a.find_AK(s, f1, ..., fn)</tt> </td>
    <td valign="top">&nbsp; </td>
    <td valign="top"><tt>const_iterator</tt> </td>
  </tr>
  <tr> 
    <td valign="top">Equal range using alternate key fields</td>
    <td valign="top"><tt>a.equal_range_AK(s, f1, ..., fn)</tt></td>
    <td valign="top">&nbsp; </td>
    <td valign="top"><tt>pair&lt;const_iterator, const_iterator&gt;</tt> </td>
  </tr>
  <tr> 
    <td valign="top">Replace element </td>
    <td valign="top"><tt>a.replace(p, k)</tt> </td>
    <td valign="top">&nbsp; </td>
    <td valign="top"><tt>pair&lt;const_iterator, bool&gt;</tt></td>
  </tr>
</table>

<h3>Expression semantics</h3>

<table border="1">
  <tr> 
    <th>Name </th>
    <th>Expression </th>
    <th>Precondition </th>
    <th>Semantics </th>
    <th>Postcondition </th>
  </tr>
  <tr> 
    <td valign="top">Main constructor </td>
    <td valign="top">
      <pre>X a(&amp;view, 
  &amp;IndexNamesAndFields, 
  bm, km, IndexedDBViewParam,
  fm, fr)

</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Creates an empty container bound to the <font
        size="2" face="Courier New">DBView</font> referenced by view. Creates 
      named indexes on all rows fetched from <font
        size="2" face="Courier New">DBView</font> using the <font
        size="2" face="Courier New">IndexedDBView</font> of index defintions in 
      <font size="2" face="Courier New">IndexNamesAndFields</font>. 
      <p><font size="2" face="Courier New">IndexNamesAndFields</font> takes the 
        form <font size="2" face="Courier New">&quot;UNIQUE IndexName1; IndexField1,IndexField2; 
        IndexName2; IndexField3, IndexField4, IndexField5&quot;</font>. The first 
        index in the list is used as the primary index for the default <font size="2" face="Courier New">find()</font> 
        method. The <font size="2" face="Courier New">UNIQUE</font> keyword is 
        optional and may be specified before any index name to indicate that keyfields 
        in this index represent a unique key that must be checked against before 
        any records are inserted or replaced in the container.</p>
      <p><font size="2" face="Courier New">bm =</font> <font
        size="2" face="Courier New">{ UNBOUND, BOUND }</font>. If the mode for 
        <font size="2" face="Courier New">IndexedDBView</font> to <font size="2" face="Courier New">BOUND</font>, 
        any changes made to elements in the container will be written back to 
        the database. If the mode is <font size="2"
        face="Courier New">UNBOUND</font>, any changes made are not written back 
        to the database.</p>
      <p><font size="2" face="Courier New">km = { USE_ALL_FIELDS, USE_PK_FIELDS_ONLY, 
        USE_AUTO_KEY }</font>. This affects what criteria are sent to the database 
        for use in updating or deleting records in <font size="2"
        face="Courier New">BOUND</font><font size="3"
        face="Courier New"> </font>mode. If <font size="2"
        face="Courier New">km</font> in <font size="2"
        face="Courier New">IndexedDBView</font> is set to <font
        size="2" face="Courier New">USE_ALL_FIELDS</font> then any updates or 
        deletes sent to the database will use all fields specified in the <font size="2" face="Courier New">DBView</font> 
        object in the criteria for the underlying SQL <font
        size="2" face="Courier New">UPDATE</font> or SQL <font
        size="2" face="Courier New">DELETE</font> statement. If <font
        size="2" face="Courier New">km</font> <font size="2"
        face="Courier New">USE_PK_FIELDS_ONLY</font> then only fields that are 
        in the primary index as defined by <font
        size="2" face="Courier New">IndexNamesAndFields</font> will be used to 
        update or delete records in the database. If <font size="2"
        face="Courier New">km</font> is <font
        size="2" face="Courier New">USE_AUTO_KEY: <font face="Times New Roman, Times, serif" size="3">a. 
        if the underlying <font face="Courier New, Courier, mono" size="2">DBView</font> 
        supports autokeys (which is only possible for <font size="2" face="Courier New, Courier, mono">DynamicDBView</font>'s 
        with the use of a DBMS that implements autokeys), only the object in question 
        is updated or deleted, b. otherwise, the key mode is coerced to <font size="2" face="Courier New, Courier, mono">USE_ALL_FIELDS</font> 
        as either the underlying<font size="2" face="Courier New, Courier, mono"> 
        DBView </font>or the DBMS don't support autokeys.</font></font></p>
      <p><font size="2" face="Courier New">IndexedDBViewParam</font>. Function 
        object that is called when the routine executes a fetch against the <font size="2" face="Courier New">DBView</font> 
        to retrieve records from the database. This is used by<font
        size="2" face="Courier New"> IndexedDBView</font> to set any parameters 
        that are needed by the <font size="2"
        face="Courier">DBView</font> object's query. If you already have a set 
        of parameters in a ParamObj then you can easily create this function object 
        by calling <font size="2" face="Courier New">SetParamsFromClass&lt;ParamObj&gt(params).</font></p>
      <p><font face="Courier New" size="2">fm = { SINGLE_FETCH, BULK_FETCH }. 
        <font face="Times New Roman, Times, serif" size="3">Mode used to fetch 
        the objects in the view. Conventional fetching used if <font face="Courier New, Courier, mono" size="2">SINGLE_FETCH 
        </font>set. If <font face="Courier New, Courier, mono" size="2">BULK_FETCH</font> 
        passed in, the view uses <font face="Courier New, Courier, mono" size="2">bulk_copy()</font> 
        to grab the elements. However, if <font face="Courier New, Courier, mono" size="2">DataObj 
        == variant_row</font>, fetch mode coerced to <font face="Courier New, Courier, mono" size="2">SINGLE_FETCH</font>..</font></font></p>
      <p><font face="Courier New, Courier, mono" size="2">fr <font face="Times New Roman, Times, serif" size="3">is 
        the number of objects to grab in each call to <font face="Courier New, Courier, mono" size="2">bulk_copy()</font> 
        if in <font face="Courier New, Courier, mono" size="2">BULK_FETCH</font> 
        mode. </font></font></p>
    </td>
    <td valign="top">The size of the container is <font
        size="4" face="Times New Roman"><tt>0.<font face="Times New Roman, Times, serif"> 
      Rows are not fetched until an attempt is made to call methods in the container.</font></tt></font><font size="4" face="Times New Roman, Times, serif"> 
      </font></td>
  </tr>
  <tr>
    <td valign="top">Main constructor accepting an arguments object</td>
    <td valign="top"><font face="Courier New, Courier, mono" size="2">X a(const 
      Args &amp;args)</font></td>
    <td valign="top"><font size="2" face="Courier New, Courier, mono">!args.INF.empty()</font></td>
    <td valign="top">
      <p>Same as above, with the parameters specified in an <font size="2" face="Courier New, Courier, mono">Args 
        </font>object.</p>
      <p>See description of <font size="2" face="Courier New, Courier, mono">Args</font> 
        nested type above for use.</p>
    </td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Find alternate key</td>
    <td valign="top"><tt>a.find_AK(s,k)</tt> </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Returns an iterator pointing to an element whose key is the 
      same as <tt>k</tt>, with a key match determined by using the index name 
      in s, or <tt>a.end()</tt> if no such element exists. </td>
    <td valign="top">Either the return value is <tt>a.end()</tt>, or else the 
      return value has a key that is the same as <tt>k</tt>. </td>
  </tr>
  <tr> 
    <td valign="top">Equal range alternate key</td>
    <td valign="top"><tt>a.equal_range_AK(s, k)</tt> </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Returns a pair <tt>P</tt> such that <tt>[P.first, P.second)</tt> 
      is a range containing all elements in <tt>a</tt> whose keys are the same 
      as <tt>k</tt>, with a key match determined by using the index name in s. 
      If no elements have the same key as <tt>k</tt>, the return value is an empty 
      range. </td>
    <td valign="top">If <tt>p</tt> is a dereferenceable iterator in <tt>a</tt>, 
      then either <tt>p</tt> lies in the range <tt>[P.first, P.second)</tt>, or 
      else <tt>*p</tt> has a key that is not the same as <tt>k</tt>. </td>
  </tr>
  <tr> 
    <td valign="top">Find using key fields</td>
    <td valign="top"><tt>a.find(f1, ..., fn)</tt> </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Returns an iterator pointing to an element whose key fields 
      match the values given by f1,..., fn, with a key match determined by using 
      the primary index, or <tt>a.end()</tt> if no such element exists. Key fields 
      are matched in the order that was given in the constructor for a.</td>
    <td valign="top">Either the return value is <tt>a.end()</tt>, or else the 
      return value has a key that is the same as <tt>f1, .. fn.</tt>. </td>
  </tr>
  <tr> 
    <td valign="top">Equal range using key fields</td>
    <td valign="top"><tt>a.equal_range(f1, ...,fn)</tt></td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Returns a pair <tt>P</tt> such that <tt>[P.first, P.second)</tt> 
      is a range containing all elements in <tt>a</tt> whose keys are the same 
      as <tt>k</tt>, with a key match determined by using the primary index. Key 
      fields are matched in the order that was given in the constructor for a. 
      If no elements have the same key as <tt>k</tt>, the return value is an empty 
      range. </td>
    <td valign="top">If <tt>p</tt> is a dereferenceable iterator in <tt>a</tt>, 
      then either <tt>p</tt> lies in the range <tt>[P.first, P.second)</tt>, or 
      else <tt>*p</tt> has a key that is not the same as <tt>k</tt>. </td>
  </tr>
  <tr> 
    <td valign="top">Find using alternate key fields</td>
    <td valign="top"><tt>a.find_AK(s, f1, ..., fn)</tt> </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Returns an iterator pointing to an element whose key fields 
      match the values given by f1,..., fn, with a key match determined by using 
      the index name in s, or <tt>a.end()</tt> if no such element exists. Key 
      fields are matched in the order that was given in the constructor for a.</td>
    <td valign="top">Either the return value is <tt>a.end()</tt>, or else the 
      return value has a key that is the same as <tt>f1, .. fn.</tt>. </td>
  </tr>
  <tr> 
    <td valign="top">Equal range using alternate key fields</td>
    <td valign="top"><tt>a.equal_range_AK(s, f1, ...,fn)</tt></td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Returns a pair <tt>P</tt> such that <tt>[P.first, P.second)</tt> 
      is a range containing all elements in <tt>a</tt> whose keys are the same 
      as <tt>k</tt>, with a key match determined by using the index name in s. 
      Key fields are matched in the order that was given in the constructor for 
      a. If no elements have the same key as <tt>k</tt>, the return value is an 
      empty range. </td>
    <td valign="top">If <tt>p</tt> is a dereferenceable iterator in <tt>a</tt>, 
      then either <tt>p</tt> lies in the range <tt>[P.first, P.second)</tt>, or 
      else <tt>*p</tt> has a key that is not the same as <tt>k</tt>. </td>
  </tr>
  <tr> 
    <td valign="top">Replace element </td>
    <td valign="top"><tt>a.replace(p, k)</tt></td>
    <td valign="top">&nbsp;<tt>p</tt> is a dereferenceable iterator in <tt>a</tt>. 
    </td>
    <td valign="top">Replaces the element in the container pointed to by p with 
      the new value in k. The return value is a <a href="http://www.sgi.com/tech/stl/pair.html"><tt>pair</tt></a> 
      <tt>P</tt>. <tt>P.first</tt> is an iterator pointing to the element whose 
      key is the same as the key of <tt>k</tt>. <tt>P.second</tt> is a <tt>bool</tt>: 
      it is <tt>true</tt> if <tt>p</tt> was actually updated in <tt>a</tt>, and 
      <tt>false</tt> if <tt>p</tt> was not updated in <tt>a</tt>, <i>i.e.</i> 
      if <tt>a</tt> already contained an element not equal to p with the same 
      key as <tt>k. This uniqueness constraint is checked against all UNIQUE indexes 
      specified in the IndexNamesAndFields parameter of the constructor</tt>. 
    </td>
    <td valign="top"><tt>P.first</tt> is a dereferenceable iterator. <tt>*(P.first)</tt> 
      has the same key as <tt>k</tt>. </td>
  </tr>
</table>

<h3>Members</h3>

<table border="1">
  <tr> 
    <th>Member </th>
    <th>Where defined </th>
    <th>Description </th>
  </tr>
  <tr> 
    <td valign="top"><tt>value_type</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">The type of object, <tt>T</tt>, stored in the IndexedDBView. 
    </td>
  </tr>
  <tr> 
    <td valign="top"><tt>key_type</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/AssociativeContainer.html">Associative 
      Container</a> </td>
    <td valign="top">The key type associated with <tt>value_type</tt>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>pointer</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Pointer to <tt>T</tt>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>reference</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Reference to <tt>T</tt> </td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_reference</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Const reference to <tt>T</tt> </td>
  </tr>
  <tr> 
    <td valign="top"><tt>size_type</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">An unsigned integral type. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>difference_type</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">A signed integral type. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>iterator</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Iterator used to iterate through a <font
        size="2" face="Courier New">IndexedDBView</font>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_iterator</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Const iterator used to iterate through a <font size="2" face="Courier">IndexedDBView.</font> 
      (<tt>Iterator</tt> and <tt>const_iterator</tt> are the same type.) </td>
  </tr>
  <tr> 
    <td valign="top"><tt>reverse_iterator</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</a> </td>
    <td valign="top">Iterator used to iterate backwards through a <font size="2" face="Courier New">IndexedDBView</font>. 
    </td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_reverse_iterator</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</a> </td>
    <td valign="top">Const iterator used to iterate backwards through a <font size="2" face="Courier New">IndexedDBView</font>. 
      (<tt>Reverse_iterator</tt> and <tt>const_reverse_iterator</tt> are the same 
      type.) </td>
  </tr>
  <tr> 
    <td valign="top"><tt>iterator begin()</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Returns an <tt>iterator</tt> pointing to the beginning of 
      the<font size="2" face="Courier New"> IndexedDBView.</font> </td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_iterator begin() const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Returns a <tt>const_iterator</tt> pointing to the beginning 
      of the<font size="2"
        face="Courier New"> IndexedDBView.</font> </td>
  </tr>
  <tr> 
    <td valign="top"><tt>iterator end()</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Returns an <tt>iterator</tt> pointing to the end of the <font size="2" face="Courier New">IndexedDBView</font>. 
    </td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_iterator end() const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Returns a <tt>const_iterator</tt> pointing to the end of 
      the<font size="2"
        face="Courier New"> IndexedDBView.</font> </td>
  </tr>
  <tr> 
    <td valign="top"><tt>reverse_iterator rbegin()</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</a> </td>
    <td valign="top">Returns a <tt>reverse_iterator</tt> pointing to the beginning 
      of the reversed <font size="2"
        face="Courier New">IndexedDBView</font>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_reverse_iterator rbegin() const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</a> </td>
    <td valign="top">Returns a <tt>const_reverse_iterator</tt> pointing to the 
      beginning of the reversed <font size="2"
        face="Courier New">IndexedDBView</font>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>reverse_iterator rend()</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</a> </td>
    <td valign="top">Returns a <tt>reverse_iterator</tt> pointing to the end of 
      the reversed <font size="2"
        face="Courier New">IndexedDBView</font>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_reverse_iterator rend() const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</a> </td>
    <td valign="top">Returns a <tt>const_reverse_iterator</tt> pointing to the 
      end of the reversed <font size="2"
        face="Courier New">IndexedDBView</font>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>iterator begin_AK(const string &amp;IndexNm)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Returns an <tt>iterator</tt> pointing to the beginning of 
      the<font size="2" face="Courier New"> DBIndex</font> 's list for the index name 
      passed in. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_iterator begin_AK(const string &amp;IndexNm) const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Returns a <tt>const_iterator</tt> pointing to the beginning 
      of the<font size="2"
        face="Courier New"> DBIndex</font> 's list for the index name passed in.</td>
  </tr>
  <tr> 
    <td valign="top"><tt>iterator end_AK(const string &amp;IndexNm)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Returns an <tt>iterator</tt> pointing to the end of the
	<font size="2" face="Courier New">DBIndex</font> 's list for the index name passed in.</td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_iterator end_AK(const string &amp;IndexNm) const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Returns a <tt>const_iterator</tt> pointing to the end of 
      the<font size="2"
        face="Courier New"> DBIndex</font> 's list for the index name passed in.</td>
  </tr>
  <tr> 
    <td valign="top"><tt>reverse_iterator rbegin_AK(const string &amp;IndexNm)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</a> </td>
    <td valign="top">Returns a <tt>reverse_iterator</tt> pointing to the beginning 
      of the reversed <font size="2"
        face="Courier New">DBIndex</font> 's list for the index name passed in.</td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_reverse_iterator rbegin_AK(const string &amp;IndexNm) const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</a> </td>
    <td valign="top">Returns a <tt>const_reverse_iterator</tt> pointing to the 
      beginning of the reversed <font size="2"
        face="Courier New">DBIndex</font> 's list for the index name passed in.</td>
  </tr>
  <tr> 
    <td valign="top"><tt>reverse_iterator rend_AK(const string &amp;IndexNm)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</a> </td>
    <td valign="top">Returns a <tt>reverse_iterator</tt> pointing to the end of 
      the reversed <font size="2"
        face="Courier New">DBIndex</font> 's list for the index name passed in.</td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_reverse_iterator rend_AK(const string &amp;IndexNm) const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</a> </td>
    <td valign="top">Returns a <tt>const_reverse_iterator</tt> pointing to the 
      end of the reversed <font size="2"
        face="Courier New">DBIndex</font> 's list for the index name passed in.</td>
  </tr>
  <tr> 
    <td valign="top"><tt>size_type size() const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Returns the size of the <font size="2"
        face="Courier New">IndexedDBView</font>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>size_type max_size() const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Returns the largest possible size of the <font size="2" face="Courier New">IndexedDBView</font>. 
    </td>
  </tr>
  <tr> 
    <td valign="top"><tt>bool empty() const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top"><tt>true</tt> if the <font size="2"
        face="Courier New">IndexedDBView's</font> size is <tt>0</tt>. </td>
  </tr>
  <tr> 
    <td valign="top"> 
      <pre><tt>X a( 
 DBView&lt;...&gt; &amp;view, 
 const string &amp;IndexNamesAndFields,
 BoundMode bm = UNBOUND, 
 KeyMode km = USE_ALL_FIELDS, 
 SetParamsFn IndexedDBViewParam = DefaultSetParams&lt;ParamObj&gt;())
</tt></pre>
    </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Creates an empty <font size="2"
        face="Courier New">IndexedDBView</font>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>IndexedDBView(const IndexedDBView&amp;)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">The copy constructor. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>IndexedDBView&amp; operator=(const IndexedDBView&amp;)</tt> 
    </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">The assignment operator </td>
  </tr>
  <tr> 
    <td valign="top"><tt>void swap(IndexedDBView&amp;)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Swaps the contents of two <font size="2"
        face="Courier New">IndexedDBView's</font>. </td>
  </tr>
  <tr> 
    <td valign="top"> 
      <pre>
pair&lt;iterator, bool&gt;
insert(const value_type&amp; x)
</pre>
    </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">Unique 
      Associative Container</a> </td>
    <td valign="top">Inserts <tt>x</tt> into the <font
        size="2" face="Courier New">IndexedDBView</font>. </td>
  </tr>
  <tr> 
    <td valign="top"> 
      <pre>
iterator insert(iterator pos, 
                const value_type&amp; x)
</pre>
    </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/UniqueSortedAssociativeContainer.html">Unique 
      Sorted Associative Container</a> </td>
    <td valign="top">Inserts <tt>x</tt> into the <font
        size="2" face="Courier New">IndexedDBView</font>, using <tt>pos</tt> as 
      a hint to where it will be inserted. </td>
  </tr>
  <tr> 
    <td valign="top"> 
      <pre>
template &lt;class <a
href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>&gt;
void insert(InputIterator, 
InputIterator)

</pre>
    </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/UniqueSortedAssociativeContainer.html">Unique 
      Sorted Associative Container</a> </td>
    <td valign="top">Inserts a range into the <font size="2"
        face="Courier New">IndexedDBView</font>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>void erase(iterator pos)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/AssociativeContainer.html">Associative 
      Container</a> </td>
    <td valign="top">Erases the element pointed to by <tt>pos</tt>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>size_type erase(const key_type&amp; k)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/AssociativeContainer.html">Associative 
      Container</a> </td>
    <td valign="top">Erases the element whose key is <tt>k</tt>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>void erase(iterator first, iterator last)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/AssociativeContainer.html">Associative 
      Container</a> </td>
    <td valign="top">Erases all elements in a range. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>void clear()</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/AssociativeContainer.html">Associative 
      Container</a> </td>
    <td valign="top">Erases all of the elements. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>iterator find(const key_type&amp; k) const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/AssociativeContainer.html">Associative 
      Container</a> </td>
    <td valign="top">Finds an element whose key is <tt>k</tt>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>iterator find(f1, f2, ..., fn) const</tt> </td>
    <td valign="top"><font size="2" face="Courier New">IndexedDBView </font></td>
    <td valign="top">Finds an element whose key fields match f1,...fn. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>iterator find_AK(const string &amp;s, const key_type&amp; 
      k) const</tt> </td>
    <td valign="top"><font size="2" face="Courier New">IndexedDBView </font></td>
    <td valign="top">Finds an element whose alternate key as specified in the 
      index name s, is <tt>k</tt>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>iterator find_AK(s, f1, f2, ..., fn) const</tt> </td>
    <td valign="top"><font size="2" face="Courier New">IndexedDBView </font></td>
    <td valign="top">Finds an element whose key fields match f1,...fn as specified 
      in the index name s.</td>
  </tr>
  <tr> 
    <td valign="top"><tt>size_type count(const key_type&amp; k) const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">Unique 
      Associative Container</a> </td>
    <td valign="top">Counts the number of elements whose key is <tt>k</tt>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>size_type count_AK(const string &amp;s, const key_type&amp; 
      k) const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html">Unique 
      Associative Container</a> </td>
    <td valign="top">Counts the number of elements whose key is <tt>k</tt> for 
      the key named s. </td>
  </tr>
  <tr> 
    <td valign="top"> 
      <pre>
pair&lt;iterator, iterator&gt; 
equal_range(const key_type&amp; k) const
</pre>
    </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/SortedAssociativeContainer.html">Sorted 
      Associative Container</a> </td>
    <td valign="top">Finds a range containing all elements whose key is <tt>k</tt>. 
    </td>
  </tr>
  <tr> 
    <td valign="top"> 
      <pre>
pair&lt;iterator, iterator&gt; 
equal_range(f1, ..., fn) const
</pre>
    </td>
    <td valign="top"><font size="2" face="Courier New">IndexedDBView </font></td>
    <td valign="top">Finds a range containing all elements whose key fields match<font size="2" face="Courier New"> 
      f1, ..., fn.</font> </td>
  </tr>
  <tr> 
    <td valign="top"> 
      <pre>
pair&lt;iterator, iterator&gt; 
equal_range_AK(const string &amp;s,
const key_type&amp; k) const
</pre>
    </td>
    <td valign="top"><font size="2" face="Courier New">IndexedDBView </font></td>
    <td valign="top">Finds a range containing all elements whose key is <tt>k</tt>, 
      using the alternate index specified in s. </td>
  </tr>
  <tr> 
    <td valign="top"> 
      <pre>
pair&lt;iterator, iterator&gt; 
equal_range_AK(s, f1, ..., fn) const
</pre>
    </td>
    <td valign="top"><font size="2" face="Courier New">IndexedDBView</font></td>
    <td valign="top">Finds a range containing all elements whose key fields match 
      f1, ..., fn using the alternate index specified in s.</td>
  </tr>
  <tr> 
    <td valign="top"><font size="2" face="Courier New">template&lt;class UserHandler&gt; 
      const UserHandler &amp; get_io_handler(UserHandler *dummy) const</font></td>
    <td valign="top"><font size="2" face="Courier New">DBView</font></td>
    <td valign="top">Returns the current<font size="2"
        face="Courier New"> IOHandler</font> for the underlying <font size="2"
        face="Courier New">DBView</font> cast to the actual type of the handler 
      based on the dummy pointer passed in. If the dynamic cast of the <font
        size="2" face="Courier New">IOHandler</font> object fails, an exception 
      will be thrown.</td>
  </tr>
  <tr> 
    <td valign="top"><font size="2" face="Courier New">IOHandler&lt;DataObj, ParamObj&gt; 
      &amp;get_io_handler() const</font></td>
    <td valign="top"><font size="2" face="Courier New">DBView</font></td>
    <td valign="top">Returns the current<font size="2"
        face="Courier New"> IOHandler</font> for the underlying <font size="2"
        face="Courier New">DBView</font> as a raw <font size="2" face="Courier New">IOHandler</font> 
      object. You must cast to the actual type of the handler to be able to access 
      any of your handler's public members.</td>
  </tr>
  <tr> 
    <td valign="top"> 
      <pre>
bool operator==(const IndexedDBView&amp;, 
                const IndexedDBView&amp;)
</pre>
    </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/ForwardContainer.html">Forward Container</a> 
    </td>
    <td valign="top">Tests two <font size="2"
        face="Courier New">IndexedDBView's</font> for equality. This is a global 
      function, not a member function. </td>
  </tr>
  <tr> 
    <td valign="top"> 
      <pre>
bool operator&lt;(const IndexedDBView&amp;, 
               const IndexedDBView&amp;)
</pre>
    </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/ForwardContainer.html">Forward Container</a> 
    </td>
    <td valign="top">Lexicographical comparison. This is a global function, not 
      a member function. </td>
  </tr>
  <tr> 
    <td valign="top"><font size="2" face="Courier New, Courier, mono">DataObj 
      GetDataObj() const</font></td>
    <td valign="top"><font size="2" face="Courier New">IndexedDBView</font></td>
    <td valign="top">Returns a prototype <font size="2" face="Courier New, Courier, mono">DataObj</font> 
      with its structure built if necessary (needed in the case of <font size="2" face="Courier New, Courier, mono">variant_row</font>).</td>
  </tr>
</table>

<h3>See also</h3>

<p><a
href="http://www.sgi.com/tech/stl/AssociativeContainer.html">Associative
Container</a>, <a
href="http://www.sgi.com/tech/stl/MultipleAssociativeContainer.html">Multiple
Associative Container</a>, <a
href="http://www.sgi.com/tech/stl/UniqueSortedAssociativeContainer.html">Unique
Sorted Associative Container</a>, <a
href="http://www.sgi.com/tech/stl/MultipleSortedAssociativeContainer.html">Multiple
Sorted Associative Container</a> <!--start footer--> </p>


<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright  2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body>
</html>
