<html>  
<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>ContainerFactory&lt;Index&gt;</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p> 
<h1>ContainerFactory&lt;Index&gt;</h1>


















<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td><img src="functors.gif" width="194" height="38"></td>
        <td align="right"><img src="concept.gif" width="194"
        height="39"></td>
    </tr>
    <tr>
        <td valign="top"><b>Category</b>: functors</td>
        <td align="right" valign="top"><b>Component type</b>:
        concept</td>
    </tr>
</table><h3>Description</h3>

<p>When using an <font size="2" face="Courier New, Courier, mono">IndexedDBView</font>, 
  you may want control over what kind of container is used to index elements within 
  the <font size="2" face="Courier New, Courier, mono">IndexedDBView</font>. A 
  common example would be that you have a large number of fields in an index and 
  you want to use a custom hashing function to look up elements quickly using 
  that index. <font size="2" face="Courier New">ContainerFactory&lt;Index&gt; 
  </font> gives you the ability to control any index within an <font size="2" face="Courier New, Courier, mono">IndexedDBView</font>. 
  It lets you control what type of container is used to index the elements (e.g. 
  multiset, hashmultiset, or any kind of user defined container) and it allows 
  you to specify what kinds of comparison and indexing functions you want to use 
  with that container. Internally, a <font size="2" face="Courier New">ContainerFactory&lt;Index&gt; 
  </font> is a function object that is used by each index in an <font face="Courier New, Courier, mono" size="2"><a href="IndexedDBView.htm">IndexedDBView&lt;View, 
  IdxContainer, HashOrNoHash&gt;</a> </font>. Each index in DTL is represented 
  internally by a <font size="2" face="Courier New, Courier, mono">DBIndex&lt;View, 
  IdxContainer, HashOrNoHash&gt;</font> which has an associative container of 
  type <font size="2" face="Courier New, Courier, mono">IdxContainer</font> that 
  holds pointers to <font size="2" face="Courier New, Courier, mono">DataObj</font>s 
  owned by the<font size="2" face="Courier New, Courier, mono"> IndexedDBView</font>. 
  Through the use of explicit specialization of this class you can build different 
  containers of type <font size="2" face="Courier New, Courier, mono">IdxContainer</font> 
  which may use their own comparison functions based on the index (usually by 
  it's name, accessible through the <font size="2" face="Courier New, Courier, mono">Index::GetName()</font> 
  method). The container factory makes the process of instantiating any kind of 
  underlying associative container uniform; whether it's sorted or hashed, or 
  even if the constructors for the containers take a number of differing arguments. 
  The generic implementation of <font size="2" face="Courier New">ContainerFactory&lt;Index&gt;</font> 
  contains overloads for both hashed and non-hashed containers. The compiler will 
  build the appropriate one based on the <font face="Courier New, Courier, mono" size="2">HASH/NO_HASH</font> 
  tag. If the <font size="2" face="Courier New, Courier, mono">IdxContainer</font> 
  type and the <font face="Courier New, Courier, mono" size="2">HASH/NO_HASH</font> 
  tag are not compatible (for example, specifying a hashed container for what's 
  actually a non-hashed container), the compiler will generate an error. The generic 
  implementation always uses the built in generic <font size="2" face="Courier New, Courier, mono">Index::lt()</font> 
  for the less-than comparison function on non-hashed containers and<font size="2" face="Courier New, Courier, mono"> 
  Index::hash()</font> and <font size="2" face="Courier New, Courier, mono">Index::eq() 
  </font>(default implementations of hashing and equality comparison for the index) 
  for hashed containers.</p>
<h3>Definition</h3>
<p>Defined in the <font size="2" face="Courier New">DBIndex.h </font><font size="3">header 
  file.</font></p>

<h3>Refinement of</h3>

<p>None.</p>

<h3>Associated types</h3>

<p><a href="IndexedDBView.htm"><font size="2" face="Courier New">IndexedDBView</font></a>, 
  <font face="Courier New, Courier, mono"> <font size="2">DBIndex </font></font></p>

<p>
<h3>Example: A customized ContainerFactory using a nonhashed IdxContainer type</h3>
<pre><code><span class="codeComment">// ... classes as in <a href="IndexedDBViewExample.htm">IndexedDBView example</a> ....</span>
typedef DBView&lt;Example, ParamObjExample&gt; ViewType;
typedef CBFunctor2wRet&lt;const Example *, const Example *, bool&gt; IVCompare;
typedef multiset&lt;Example *, IVCompare&gt; MultisetType; 
typedef DBIndex&lt;ViewType. MultisetType, NO_HASH &gt; IdxType;

<span class="codeComment">// reverse comparison on exampleStr</span>
bool reverse_compare_strings(const Example *pData1, const Example *pData2)
{
	return pData1-&gt;GetExampleStr() &gt; pData2-&gt;GetExampleStr();
}

<span class="codeComment">
// "specialized" ContainerFactory() tells the indices in the IndexedDBView
// to use a custom container for indexing records
// in this case, the container is a multiset which sorts in reverse order
// for the Primary Index and normal for all other indices
// assume the IndexedDBView&lt;ViewType, MultisetType, NO_HASH&gt; that uses this
// specialization of ContainerFactory has the following indices:<br>// PrimaryIndex = nonunique key with fields: STRING_VALUE = we want sorted
// based on reverse_compare_strings()
// AlternateIndex = unique key with fields: EXAMPLE_LONG, EXAMPLE_DATE =
// we want sorted based on the default DBIndex::lt() function
</span>
template&lt;&gt; class dtl::ContainerFactory&lt;IdxType&gt;
{
public:
	MultisetType operator()(IdxType *pDBIndex, NO_HASH h) 
	{
		 <span class="codeComment">
		 // for STRING_VALUE's, compare true if first exampleStr > second exampleStr
		 </span>
		 if (pDBIndex-&gt;GetName() == "PrimaryIndex")
			return MultisetType(cb_ptr_fun_w_ret(reverse_compare_strings));
		 else <span class="codeComment">// for all other indices, in this case, pDBIndex-&gt;GetName() == "AlternateIndex", use generic comparison</span>
			return MultisetType(cb_ptr_fun_w_ret(*pDBIndex, &amp;IdxType::lt));
	}
};
</code></pre>
 </p>
<p>
<h3>Example: A customized ContainerFactory using a hashed IdxContainer type</h3>
<pre><code><span class="codeComment">// ... classes as in <a href="IndexedDBViewExample.htm">IndexedDBView example</a> ....</span>
typedef DBView&lt;Example, ParamObjExample&gt; ViewType;
typedef CBFunctor1wRet&lt;const Example *, size_t&gt; IVHash;
typedef CBFunctor2wRet&lt;const Example *, const Example *, bool&gt; IVCompare;
typedef hash_multiset&lt;Example *, IVHash, IVCompare&gt; HashMultisetType; 
typedef DBIndex&lt;ViewType. HashMultisetType, HASH&gt; HashIdxType;

<span class="codeComment">// alternative hashing scheme on exampleStr
size_t my_hash_strings(const Example *pData1)
{
   string str = pData1-&gt;GetExampleStr();

   size_t sum = 0;

   // sum all the per character hash values together
   // a character c's hash value = 5*c + 13
   for (size_t i = 0; i &lt; str.length(); i++)
		sum += (5 * str[i] + 13);

   return sum;
}

// "specialized" ContainerFactory() tells IndexedDBView to use a custom
// container for indexing records
// in this case, the container is a hash_multiset which uses an alternative hash
// function for the Primary Index and normal for all other indices
</span>
template&lt;&gt; class dtl::ContainerFactory&lt;HashIdxType&gt;
{
public:
	HashMultisetType operator()(HashIdxType *pDBIndex, HASH h) 
	{
		 <span class="codeComment">// for STRING_VALUE's, hash on exampleStr using alternative hash function</span>
	
		 if (pDBIndex-&gt;GetName() == "PrimaryIndex")
			return HashMultisetType(MEDIUM_HASH_TABLE, cb_ptr_fun_w_ret(my_hash_strings),
			                        cb_ptr_fun_w_ret(*pDBIndex, &amp;HashIdxType::eq));
		 else <span class="codeComment">// for all other indices use generic hash and comparison</span>
			return HashMultisetType(MEDIUM_HASH_TABLE, cb_ptr_fun_w_ret(*pDBIndex, &amp;HashIdxType::hash),
			                        cb_ptr_fun_w_ret(*pDBIndex, &amp;HashIdxType::eq));
	}
};

</code></pre>
</p>
<h3>Public Base Classes</h3>
<p>None.</p>
<h3>Template parameters</h3>
<table border="1">
  <tr> 
    <th>Parameter </th>
    <th>Description </th>
    <th>Default </th>
  </tr>
  <tr> 
    <td valign="top"><tt>Index</tt> </td>
    <td valign="top">The type of the index that the underlying container is being 
      built for (always a <font size="2" face="Courier New, Courier, mono">DBIndex</font><font
        size="2" face="Courier New"> </font>instantiation).</td>
    <td valign="top">&nbsp; </td>
  </tr>
</table>
<h3>Members</h3>
<table border="1">
  <tr> 
    <th>Member </th>
    <th>Where defined </th>
    <th>Description </th>
  </tr>
  <tr> 
    <td valign="top"><font size="2" face="Courier New, Courier, mono">Index::index_container_type 
      operator()(Index *pDBIndex, HASH h)</font></td>
    <td valign="top"><font size="2" face="Courier New, Courier, mono">DBIndex</font></td>
    <td valign="top">Returns a freshly constructed hashed associative container 
      of type <font size="2" face="Courier New, Courier, mono">Index::index_container_type</font> 
      for the <font size="2" face="Courier New, Courier, mono">DataObj</font> 
      references built based on properties of the <font size="2" face="Courier New, Courier, mono">Index</font> 
      passed in.</td>
  </tr>
  <tr> 
    <td valign="top"><font size="2" face="Courier New, Courier, mono">Index::index_container_type 
      operator()(Index *pDBIndex, NO_HASH nh)</font></td>
    <td valign="top"><font size="2" face="Courier New, Courier, mono">DBIndex</font></td>
    <td valign="top">Returns a freshly constructed non-hashed associative container 
      of type <font size="2" face="Courier New, Courier, mono">Index::index_container_type</font> 
      for the <font size="2" face="Courier New, Courier, mono">DataObj</font> 
      references built based on properties of the <font size="2" face="Courier New, Courier, mono">Index</font> 
      passed in.</td>
  </tr>
</table>
<h3></h3>
<p>&nbsp;</p>

<h3>See also</h3>

<p><a href="BCA.htm"></a><a
href="IndexedDBView.htm"><font size="2"
face="Courier New">IndexedDBView</font><font size="2"><!--start footer--></font></a></p>


<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright © 2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body>
</html>
