<HTML>

 

<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>Exception Safety in DTL</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p> 
<H1>Exception Safety in DTL</H1>
<I><FONT ><STRONG><H1>by Mike Gradman and Corwin Joy</H1>
<P>(Adapted from </I></FONT></STRONG><A HREF="http://www.stlport.org/doc/exception_safety.html"><I><FONT  COLOR="#0000ff"><STRONG>Exception Safety in STLPort </I></FONT></STRONG></A><I><FONT ><STRONG>by Dave Abrahams)</P>
</I></FONT></STRONG><H2><A NAME="guarantees"></A>Basic Library Guarantees</H2>
<B><P>DTL makes the guarantee that</B> <B>no resources are leaked in the face of exceptions</B>.</P>
<B><P>This means:</P>

<UL>
</B><LI>By the time a container's destructor completes: </LI>

<UL>
<LI>It has returned all memory it has allocated to the appropriate deallocation function. </LI>
<LI>The destructor has been called for all objects constructed by the container. </LI></UL>

<LI>Algorithms destroy all temporary objects and deallocate all temporary memory even if the algorithm does not complete due to an exception. </LI>
<LI>Algorithms which construct objects (e.g. <TT>uninitialized_fill</TT>) either complete successfully or destroy any objects they have constructed at the time of the exception. </LI>
<LI>Algorithms which destroy objects always succeed. </LI></UL>

<H4>Additionally:</H4>

<UL>
<LI>Algorithms which operate on ranges of objects leave only fully-constructed objects in those ranges if they terminate due to an exception. </LI>
<LI>Containers continue to fulfill all of their requirements, even after an exception occurs during a mutating function. For example, an IndexedDBView will never give an inaccurate report of its size, or fail to meet its performance requirements because the tree that implements it has become unbalanced. </LI>
<LI>A stronger guarantee is available for some operations: that <I>if the operation terminates due to an exception, program state will remain unchanged</I>. For example, <TT>DBView&lt;...&gt;::set_io_handler()</TT> leaves the view unchanged if an exception is thrown, provided the library client fulfills the <A HREF="#basic_requirements">basic requirements</A> below. For some operations, the "<A HREF="#Strong Guarantee">strong guarantee</A>" is only available if additional requirements are filled. </LI></UL>

<B><FONT SIZE=5><P><A NAME="basic_requirements"></A>Basic Client Requirements</P>
</FONT><P>The </B><A HREF="#guarantees"><B>library guarantees</B></A><B> above are conditional on some requirements that library clients must fulfill.</P>

<UL>
</B><LI>Destructors of any client classes used by the library may not throw exceptions. This includes all classes used as library template parameters. </LI>
<LI>The underlying STL library used to compile DTL must be exception safe. It must make the exception safety guarantees provided by STLport or given in the C++ standard. </LI>
<LI>Autocommit must be turned off for any <FONT FACE="Courier New" SIZE=2 >DBConnection</FONT> objects used. Otherwise, operations may have side effects and leave the system in an inconsistent state, leaving us with no guarantees at all. </LI></UL>

<H2><A NAME="Strong_Guarantee"></A>The "Strong Guarantee"</H2>
<P>In many programs, some objects will be destroyed automatically during exception-unwinding. For these, the basic guarantee that resources won't be leaked is good enough. If a program hopes to survive an exception and continue running, though, it probably also uses long-lived containers which are expected to survive past exception-recovery in a known state. For example, a program could maintain a list of objects representing tasks it is working on. If adding a task to that list fails, the program may still need to rely on the list. If the list must survive an exception intact, we need the strong guarantee:</P>

<UL>
<I><LI>If an exception is thrown, the operation has no effects.</I> </LI></UL>

<P>You can get the strong guarantee by "brute force" for any container operation as follows, provided the container's <TT>swap()</TT> member function can't fail (this is true for most real-world containers):</P>
<TT><P>container_type container_copy( original_container ); <BR>
container_copy.mutating_operation(...); <BR>
original_container.swap( container_copy );</P>
</TT><P>Fortunately, many mutating operations give the strong guarantee with no additional requirements on the client. To get the strong guarantee for others, you can either use the above technique or conform to some <A HREF="#additional_requirements">additional requirements</A>. This guarantee is also known as the aCi guarantee, i.e. the operation is atomic - all or nothing, consistent, and effects are isolated. Details on this kind of ACID analysis can be found at <A HREF="http://www.gotw.ca/gotw/061.htm">"Guru of the Week #61"</A>.</P>
<P>&nbsp;</P>
<H2>Operations that give a "no-throw" guarantee</H2>
<TT><P>All swap() member functions and class destructors.</P>
</TT><P>&nbsp;</P>
<H2>Operations that give the "strong guarantee" if the <A HREF="#basic_requirements">basic requirements</A><I> </I>have been met.</H2>
<TT><P>All, unless otherwise listed.</P>
<P>Special note for </TT><FONT FACE="Courier New" SIZE=2>IndexedDBView&lt;View&gt; </FONT><TT>member functions. The strong guarantee here excludes call to fetch() -- most members call fetch() to initialize the object if it is not already built from the database which technically means the operation has a possibly non-atomic effect on the object. When we say these operations are atomic we exclude effects from the initial fetch().</P>
</TT><P>&nbsp;</P>
<H2>Operations that give no guarantee.</H2>

<UL>
<FONT FACE="Courier New" SIZE=2><LI>DB_iterator&lt;DataObj, ParamObj&gt;</FONT>::<TT>Params(const ParamObj &amp;params). This assigns into the ParamObj * held by the iterator. Guarantees here are only as strong as the assignment guarantees given by the client.</TT> </LI>
<TT><LI>DBView&lt;DataObj, ParamObj&gt;::insert/update/delete_iterator operator=(const DataObj &amp;data) -- proxy assignment operator for output iterators. This assigns into the DataObj * held by the iterator and then calls InsValidate on that data object. Guarantees are only as strong as given by these two functions -- however if assignment does not succeed entirely the exception will be caught and data will be marked as invalid and not allowed to be inserted. See the discussion below on exceptions with iterators for more on this topic.</TT> </LI></UL>

<P>&nbsp;</P>
<H2>Theory of Exception Handling for Input and Output Iterators</H2>
<FONT FACE="Courier New" SIZE=2 ><P>(Extracted from discussions in comp.c++.std. Many thanks to Dave Abrahams for his comments &amp;<BR>
criticisms. Any errors here are my own - and doubtless come from ignoring his advice :-) Corwin).</P>
<P>Some definitions:<BR>
InputIterator and OutputIterator - by this I will mean the generic InputIterator and OutputIterator concepts in STL. Specific examples in DTL are DBView::select, insert, update and delete.</FONT> <BR>
<BR>
<FONT FACE="Courier New" SIZE=2>i/o Iterator - shorthand for "InputIterator or OutputIterator" <BR>
<BR>
"Abraham's Strong Guarantee" or "aCi", by this I mean the ACID transactional guarantee as defined in "Guru of the Week #61",</FONT><A HREF="http://www.gotw.ca/gotw/061.htm"><FONT FACE="Courier New" SIZE=2>http://www.gotw.ca/gotw/061.htm</FONT></A><FONT FACE="Courier New" SIZE=2>, i.e. the operation is <BR>
a = atomic, if the operation fails the object will be in its initial state, otherwise in its final state <BR>
C = consistent, if op succeeds or fails the system will be in a 'Consistent' state with no integrity constraints violated, no memory leaked etc. <BR>
i = isolated, if operation fails, no side effects including any changes to the database. <BR>
<BR>
Claim 1:&nbsp; Currently the STL makes aCi guarantees for some of its operations. These aCi guarantees are only with respect to the STL object acted upon and make no promise about state of the iterators that they act upon.&nbsp; My claim is that if we require iterators to be aCi over a range, then STL operations over that range can be "jointly aCi" in that both the effect on the STL object and the effect on the iterator can be made simultaneously aCi. <BR>
<BR>
Claim 2: Often the "jointly aCi" guarantee over a range is not what you want for an algorithm.&nbsp; Instead, if we assume the each individual operation to read or write to our i/o Iterator is aCi, then we may want a "maximal" property which says that we will try to execute the maximum possible number of successful atomic transactions against the given iterator.&nbsp; In this case, without 'range atomicity' on the underlying iterator I think the best we can hope for is consistency at the end of the algorithm. <BR>
<BR>
Definition: An iterator is aCi over a range if it displays: <BR>
a: atomicity - the iterator must support transaction semantics.&nbsp; In other words the iterator must be able to mark the beginning on a transaction on a range, and have commands to commit and rollback changes posted to the range since the beginning of the transaction. <BR>
C: we say an iterator is consistent if all operations on that iterator are consistent over the range <BR>
i: we say that an iterator is isolated over a range if any changes made by that iterator are not visible outside of the iterator until committed. <BR>
Proof of Claim 1: 
if: if an iterator x, is aCi and an algorithm f, is aCi then we may obtain f(x) aCi via the following pseudo-code </P>
</FONT><CODE><PRE>
try {
&#9;f(x); // operation(s) to apply changes over a range
&#9;commit x;
}
catch(...) { 
&#9;// oops, we could not change the entire range, rollback any changes
&#9;rollback x;
}
</PRE>
</CODE><FONT FACE="Courier New" SIZE=2><P>Example of Claim 1.<BR>
Suppose we define a custom class called foo which can throw on construction and try to initialize an array of foo via a call to<BR>
foo *p = new foo[5];<BR>
What happens if the third element constructed throws? The compiler will then internally destruct the first and second elements built before the throw. So, conceptually, what the compiler's operator new does is this:</P>
</FONT><PRE>operator new[] { // new an array of objects
  try {
   iterator i = array.begin();
   *i = newly constructed object;
   i++;
  }
  catch(...) { 
   // oops, we couldn't construct all objects, attempt to roll-back by invoking destructors
   while (--i != array.rend() ) 
      destruct(*i);
  }
}
   </PRE>
<FONT FACE="Courier New" SIZE=2><P><BR>
Example of Claim 2.<BR>
<BR>
Now consider what happens when we invoke operator delete[] over a range<BR>
<BR>
foo *p = new foo[5]; delete[] p;<BR>
<BR>
What happens if the third element destructed throws? According to the standard, the results are undefined. One major reason for this is that the compiler does not have an easy way to "roll-back" range destruction operations as it cannot easily decrement the iterator and re-construct elements similar to what is done for the new[] operator. In other words, the "delete iterator" used by operator delete[] cannot give "range atomicity" as defined above. This is one reason why the conventional exception safety wisdom is to suppress errors in destructors so that we can get a "maximal guarantee" for operator delete[]. I.e. every item that can be successfully destructed in the array gets destroyed. <BR>
<BR>
Claim 2:&nbsp; There are going to be times when your i/o Iterator either cannot provide an atomic range guarantee, or you don't want your algorithm to act in an atomic fashion over a range. Instead, if we assume the each individual operation to read or write to our i/o Iterator is aCi, then we may want a "maximal" property which says that the maximum possible number of successful atomic transactions will be executed against the given iterator. </P>
<P>Definition: We say that an i/o Iterator is element-wise aCi if reading or writing an individual element is aCi.&nbsp; This means that for an OutputIterator, called out, *out = data, must be aCi.&nbsp; For an InputIterator, called in, data=*in, must be aCi. <BR>
<BR>
Definition: We say that an iterator has gone "bad" if it is no longer able to read from or write to its underlying data source.&nbsp; Concrete examples would be <BR>
(1) An ostream_iterator to a file where the underlying ostream can no longer write to the file. <BR>
(2) A database input iterator, where the connection to the database is lost and it can no longer read records from the database table it is pointing at. <BR>
(3) A directory iterator, such as the one by Dietmar Kuehl at </FONT><A HREF="http://www.boost.org/libs/dir_it/dir_it.html"><FONT FACE="Courier New" SIZE=2>http://www.boost.org/libs/dir_it/dir_it.html</FONT></A><FONT FACE="Courier New" SIZE=2>, where the connection to the underlying drive is lost and further filenames cannot be retrieved. </P>
<P>Definition: We say that an iterator read/write operation has "failed" if a particular data element cannot be read from or written to an iterator but the iterator has not gone "bad".&nbsp; Usually such a read "failure" will be caused by that particular element not matching a type or business rule that is required for each individual data object. <BR>
Examples: <BR>
(1) A database iterator tries to write the following rows to a table whose only field is a date field: '01-Jan-1980', 'lala',&nbsp; '01-Jan-1981'.&nbsp; Here the second element would 'fail' because it is not a valid date that can be written to the table. <BR>
(2) An istream_iterator&lt;int&gt; tries to read the following comma delimited elements from a file: 1, 2, lala, 4.&nbsp; The element 'lala' cannot be converted to an &lt;int&gt; and hence 'fails'. </P>
<P>Some iterators have a natural notion of atomic elements (rows in a table, filenames in a directory).&nbsp; For others, if an element 'fails' the bad data can affect other elements e.g. an istream_iterator tries to read 1, 2, 345, 6 where 4 is a corrupted byte that has replaced the comma delimiter between 3 and 5 leading to the incorrectly read number '345'.&nbsp; This lack of element atomicity is a property of the iterator being worked with and is independent of the 'fail' concept since an element can be 'successfully' read but still hold a bad value. To get the 'maximal' property we can do the following: <BR>
<BR>
1. Impose a client requirement that the user defined 'data' type cannot throw on construction or assignment. <BR>
<BR>
2. For InputIterators use the following logic for ++ (and for construction when reading the first element); On ++, try to read the next 'data' element.&nbsp; If fail(), push the resulting 'data' element into an error buffer and try to get the next element e.g. </P>
</FONT><PRE>while (iterator != end-of-stream) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read information into internal 'data' object;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (not fail() and not bad() )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (bad()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator = end-of-stream;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
&#9;&#9;error_buffer.push_back(error information string)
&#9;  } catch(..){
&#9;&#9;set_buffer_overflow_flag
&#9;  }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {
&#9;&#9;error_buffer.push_back(data + error information error information string); 
&#9;  } catch(..) {
&#9;&#9;set_buffer_overflow_flag
&#9;  }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}
</PRE>
<FONT FACE="Courier New" SIZE=2><P>(Here we assume the dereference operator *in, simply returns the contents of the internal buffer -- yes, we could code the read to happen on *in, but then we may end up having to return an empty object if the data-stream goes 'bad' and we do not want to throw.&nbsp; Here, setting end-of-stream for the bad() case lets us terminate the read in a no-throw() kind of way.). <BR>
<BR>
3. For OutputIterators use the similar logic for ++. On ++, try to write the next 'data' element.&nbsp; If fail() or bad(), push the resulting 'data' element into an error buffer similar to what is shown for InputIterator. <BR>
<BR>
4. Set up the i/o Iterators so that they do not throw on any of their operations. Then, if we invoke an algorithm f(InputIterator, OutputIterator) we will have the property that every element that could be read from the InputIterator was either fetched completely or logged to an error buffer (up to error buffer overflow).&nbsp; Similarly, every element that could be written to the OutputIterator was either written completely or logged to an error buffer.&nbsp; Here, one could imagine a *standard* function for accessing such an error buffer so that errors could be dealt with in a generic way. Still, this is not a very strong guarantee since f(In, Out) could abort for reasons unrelated to the iterators it is working on.&nbsp; In any case , I think the best we can hope for is consistency at the end of f(In, Out), which should be enforced by the item-wise aCi property of our iterator, regardless of whether we throw or not. </P>
</FONT><FONT ><P>&nbsp;</P>
</FONT><FONT FACE="Courier New" SIZE=2><H2>DTL Input and Output Iterators -- The Practice</H2>
<H3>DTL Iterators vs. Standard Streams - The Good, The Bad, and The Fail</H3>
</FONT><FONT FACE="Courier New" SIZE=2><P>When iterators encounter an error when either reading or writing to the database or in initializing or maintaining their state, they act like streams. Errors could occur either through the manipulation of a single element (the element fails to pass the test in an InsVal or SelVal method) or the iterator itself could end up in an unusable state (say, if the connection with the database is lost). This behavior is very much like the C++ standard library streams, which have similar characteristics in their possible states:</P>

<UL>
<LI>Previous operation was successful and the stream is alive and well - the stream is in a <STRONG>good</STRONG> state - corresponds to a successful read, write (or initialization) in DTL.</FONT><FONT > </LI>
</FONT><FONT FACE="Courier New" SIZE=2><LI>Single stream in or stream out operation failed but stream is salvageable - the stream is in a <STRONG>fail </STRONG>state - this condition corresponds to the DTL iterator scenario such as a failed InsVal or SelVal call.</FONT><FONT > </LI>
</FONT><FONT FACE="Courier New" SIZE=2><LI>The stream itself could become corrupted such as if trying to read from or write to a nonexistent file. If the stream reads from a file that is there when the stream was created, but then the carpet gets yanked out from the stream's feet by someone removing the file, the stream will spit out to a junk place on the disk or read trash from such a bogus location. In this case, the stream is said to be in a <STRONG>bad </STRONG>state. The DTL equivalent would occur in a situation such as losing the connection with the database. Any iterators which try to read or write using that invalid connection would become corrupted and thus leave themselves in an unrecoverable state.</FONT><FONT > </LI></UL>

</FONT><FONT FACE="Courier New" SIZE=2><P>So as with standard libary streams, iterators provide flags for each of these three states and their values are OR'ed together to get the appropriate effect: dtl_iostate::goodbit, dtl_iostate::failbit, and dtl_iostate::badbit. </FONT><FONT FACE="Courier New" SIZE=2>The iterators inherit from dtl_ios_base, which contains setstate(), rdbuf(), clear(), good(), fail(), and bad() functions that work just like their counterparts in std::ios_base except that setstate() and clear() do not throw if badbit or failbit are set. In the case of DTL, all of these state operations are nothrow.</P>
<STRONG><H2>Now Introducing Our Hero, IOHandler&lt;DataObj, ParamObj&gt;</H2>
</STRONG><FONT FACE="Courier New" SIZE=2><P>As described in the theory section above, there are fundamentally two main ways to deal with errors that occur while operating on an iterator.  The first method is to simply throw in the event of an error, which will usually abort any algorithm operating on that range / iterator.  In the throw case, we will usually want to rollback any operations performed on the range.  The first version of our hero, AlwaysThrowsHandler&lt;DataObj, ParamObj&gt, always tells the code that threw to rethrow the exception by returning dtl_ios_base::THROW_EXCEPTION. The assumption underlying this version of the error handler is that all errors should be passed back to the end-user who can then decide whether or not to roll back any changes made to the range.  Examples of range commit and rollback are shown later. The second way of dealing with errors is to simply log & suppress them with the assumption that they will be dealt with after the calling algorithm is done with the iterator.  This second method is supported by a version of our hero called LoggingHandler&lt;DataObj, ParamObj&gt;  which records errors to a vector&lt;string&gt; for later use and suppresses exceptions by returning dtl_ios_base::SUPPRESS_ERROR. To see how an error handler is defined we turn our X-ray vision on some example code:</P>
</FONT>
<FONT FACE="Courier New" SIZE=3>
<pre><code><span class="codeComment">// Let's Use our X-Ray Vision to Look at the Innards of our Hero</span>


template&lt;class DataObj, class ParamObj = DefaultParamObj&lt;DataObj&gt; &gt; class OurHeroicHandler
{
private:
	<span class="codeComment">// ... some state data, but assume handler is default constructible</span>
public:

	dtl_ios_base::MeansOfRecovery
		operator()(RootException &amp;ex, dtl_ios_base &amp;base,
		   DataObj &amp;data, ParamObj &amp;params)
	{
		<span class="codeComment">// example of what you might do in a handler</span>
		if (bad())
		{
			LogErrorToFile(ex);
			return dtl_ios_base::THROW_EXCEPTION;
		}
		else if (fail())
		{
			<span class="codeComment">// tries to make the DataObj valid and then reapplies previous operation
			// to base on the good object ... may still fail</span>
			bool failed = WorkMagicOnDataObjAndTryAgain(...);

			if (failed)
			{
				LogErrorToFile(ex);
				return dtl_ios_base::THROW_EXCEPTION;
			}
			else
				return dtl_ios_base::SUPPRESS_ERROR; <span class="codeComment">// success ... our superhero
								     // has saved the day!</span>
		}
	}
};
</code></pre>

 
</FONT>
<FONT FACE="Courier New" SIZE=2><P>The above handler instructs the code invoking the handler to still throw the exception if the iterator is in a bad state. In the case that the iterator has only failed and is salvageable, our hero weaves some magic on the DataObj and then reapplies the operation that failed on the iterator. If the retry of the operation succeeded, our hero has saved the day and the handler tells the invoking code that all is well. Otherwise, it is a dark day for the iterator and the invoking code will be told to throw. To tell what personality we would like our IOHandler to take for a given DB_iterator it, we simply invoke it.set_io_handler(), passing in an instance of our handler as the argument. Similarly, it.get_io_handler() will return the current handler for the iterator. Note that you must pass a NULL pointer to this method, e. g.: </P>
</FONT><FONT FACE="Courier New" SIZE=3><PRE>      it.get_io_handler((OurHeroicHandler&lt;DataObj, ParamObj&gt; *) NULL);</PRE></FONT>
<FONT FACE="Courier New" SIZE=2><P>Calling the similar members of the DBView&lt;DataObj, ParamObj&gt; template will set and get the default view for newly created iterators that refer to that view. Now you know everything needed to summon our superhero and to let him do his work to save the day!</P>
<FONT FACE="Courier New" SIZE=2><P>Now here's another example that shows the use of a logging handler class to report the exceptions that occur.<BR>
<FONT FACE="Courier New" SIZE=3>
<pre><code><span class="codeComment">// Example Code Using LoggingHandler on a DBView

// test of failed SelValidate() when reading data</span>
void TestBadSelValidate()
{
 	vector&lt;Example&gt; results;

	<span class="codeComment">// construct view
	// DBView&lt;Example&gt; is actually DBView&lt;Example, 
	// DefaultParamObj&lt;Example&gt; &gt; thanks to the default 
	// argument to the DBView template

	// use our bad BCA which references a nonexistent column name in DB_EXAMPLE</span>
	DBView&lt;Example&gt;
		view(&quot;DB_EXAMPLE&quot;, BCAExampleObj(),
		&quot;WHERE INT_VALUE BETWEEN (?) AND (?) AND &quot;
		&quot;STRING_VALUE = (?) OR EXAMPLE_DATE &lt; (?) ORDER BY EXAMPLE_LONG&quot;,
		BPAExampleObj(), BadSelValidate());

	view.set_io_handler(LoggingHandler&lt;Example&gt;());

	<span class="codeComment">// loop through query results and add them to our vector
	// in this loop, read_it.GetLastCount() records read from DB</span>

	DBView&lt;Example&gt;::select_iterator read_it = view.begin();

	<span class="codeComment">// set parameter values for the WHERE clause in our SQL query</span>
	read_it.Params().lowIntValue = 2;
	read_it.Params().highIntValue = 8;
	read_it.Params().strValue = &quot;Example&quot;;
	
	TIMESTAMP_STRUCT paramDate = {2000, 1, 1, 0, 0, 0, 0};
	read_it.Params().dateValue = paramDate;

	for ( ; read_it != view.end(); read_it++)
	{
		try
		{
		  <span class="codeComment">// note that the read_iterator::GetLastCount()  is incremented in operator++()
		  // remember that the record is fetched and thus the count incremented
		  // before operator*() is applied to the read_iterator</span>

		  cout &lt;&lt; &quot;Reading element #&quot; &lt;&lt; read_it.GetLastCount() &lt;&lt; endl;
		  
		  cout &lt;&lt; &quot;read_it-&gt;exampleInt = &quot; &lt;&lt; read_it-&gt;exampleInt &lt;&lt; endl;
		  cout &lt;&lt; &quot;read_it-&gt;exampleStr = &quot; &lt;&lt; read_it-&gt;exampleStr &lt;&lt; endl;
		  
		  results.push_back(*read_it);
		}
		catch (RootException &amp;ex)
		{
		  cout &lt;&lt; &quot;Caught Exception!!!!&quot; &lt;&lt; endl;
		  cout &lt;&lt; ex.what() &lt;&lt; endl;
		}
	}

	LoggingHandler&lt;Example&gt; handler = 
		read_it.get_io_handler((LoggingHandler&lt;Example&gt; *) NULL);

	typedef LoggingHandler&lt;Example&gt;::LoggedTriple LoggedTriple;

	vector&lt;LoggedTriple&gt; errors = handler.GetLog();

	for (vector&lt;LoggedTriple&gt;::iterator log_it = errors.begin(); log_it != errors.end();
			log_it++)
	{
		LoggedTriple error = *log_it;

		cout &lt;&lt; &quot;Error msg = &quot; &lt;&lt; error.errmsg &lt;&lt; endl;
		cout &lt;&lt; &quot;Example = &quot; &lt;&lt; error.dataObj &lt;&lt; endl;
	}

}
</code></pre>
</FONT>
</FONT><FONT FACE="Courier New"><H3>Range commit and rollback</H3>
</FONT><FONT FACE="Courier New" SIZE=2><P>You can emulate transactions over ranges of operations using DBConnection::CommitAll() and DBConnection::RollbackAll().</P>
</FONT>
<FONT FACE="Courier New" SIZE=3>
<pre><code><span class="codeComment">// Range Transaction over a DBConnection: Insertion into a DBView </span>

const TIMESTAMP_STRUCT chrysalis = {2002, 4, 3, 0, 0, 0, 0};
const TIMESTAMP_STRUCT mikero = {2001, 11, 2, 0, 0, 0, 0};
const TIMESTAMP_STRUCT victory = {2001, 3, 10, 0, 0, 0, 0};

<span class="codeComment">// this example shows range insert transactions in action</span>
void RangeInsertExample()
{
	DBConnection conn;
        conn.Connect("UID=example;PWD=example;DSN=example;");

	typedef DBView&lt;Example&gt; DBV;

	DBV view("DB_EXAMPLE", DefaultBCA&lt;Example&gt;(), 
	   "", DefaultBPA&lt;DefaultParamObj&lt;Example&gt; &gt;(), DefaultSelValidate&lt;Example&gt;(),
	   DefaultInsValidate&lt;Example&gt;(), conn);

	cout &lt;&lt; "Examples in view before attempted range insert:" &lt;&lt; endl;

	copy(view.begin(), view.end(), ostream_iterator&lt;Example&gt;(cout, "\n"));

	vector&lt;Example&gt; read_from_DB_before;

	copy(view.begin(), view.end(), back_inserter(read_from_DB_before));

	<span class="codeComment">// examples that we want to insert into the DB ...
	// we want an all or nothing on these guys!</span>
	vector&lt;Example&gt; all_or_nothing_examples;

	<span class="codeComment">// third element will fail to be inserted, should force rollback</span>
	all_or_nothing_examples.push_back(Example(79, "FUBAR", 2.2, 99, mikero));
	all_or_nothing_examples.push_back(Example(81, "All Messed Up", 21.09, 75, chrysalis));
	all_or_nothing_examples.push_back(Example(85, "Bad Boy", -21.22, 11, victory));
	all_or_nothing_examples.push_back(Example(99, "Good One", 77.99, 41, victory));
	
	<span class="codeComment">// must write all the elements to succeed in the transaction</span>
	// else we rollback
	try { 
      
	  DBV::insert_iterator write_it = view;

	  write_it.set_io_handler(AlwaysThrowsHandler<Example>());

	  for (vector&lt;Example&gt;::iterator ins_it = all_or_nothing_examples.begin(); 
	      ins_it != all_or_nothing_examples.end(); ins_it++, write_it++)
		  {	  
			 *write_it = *ins_it;
		  }

          conn.CommitAll(); <span class="codeComment">// we assume commit and rollback must always succeed to avoid two-phase commit type logic</span>
	}
        catch(RootException &ex) 
	{ 
	  cout &lt;&lt; ex &lt;&lt; endl;
          conn.RollbackAll(); 
	}

	cout &lt;&lt; "Examples in view after attempted range insert:" &lt;&lt; endl;

	copy(view.begin(), view.end(), ostream_iterator&lt;Example&gt;(cout, "\n"));

	vector&lt;Example&gt; read_from_DB_after;

	copy(view.begin(), view.end(), back_inserter(read_from_DB_after));

	cout &lt;&lt; "Changes resulting from attempted range insert:" &lt;&lt; endl;
   
        TableDiff(cout, read_from_DB_before, read_from_DB_after);
} 

</code></pre></FONT> 
<FONT FACE="Courier New" SIZE=2><P>DTL does not provide built in support of range transactions for IndexedDBViews. (We thought about it, but the performance penalty was too high).Instead, you can get the effect of commit and rollback by copying your IndexedDBView's "initial" values to a backup IndexedDBView. To rollback, simply swap the backup IndexedDBView into the IndexedDBView that you made changes to. You will also have to call DBConnection::RollbackAll() to propagate the rollback to the database. This technique is used in the examples below.</FONT></P>
<FONT FACE="Courier New" SIZE=3>
<pre><code><span class="codeComment">// Range Transaction over a DBConnection: Insertion into a IndexedDBView </span>

const TIMESTAMP_STRUCT chrysalis = {2002, 4, 3, 0, 0, 0, 0};
const TIMESTAMP_STRUCT mikero = {2001, 11, 2, 0, 0, 0, 0};
const TIMESTAMP_STRUCT victory = {2001, 3, 10, 0, 0, 0, 0};

<span class="codeComment">// range transaction example for an indexed view</span>
void RangeIndexInsertExample()
{
	DBConnection conn;
        conn.Connect("UID=example;PWD=example;DSN=example;");

	typedef DBView&lt;Example&gt; DBV;

	DBV view("DB_EXAMPLE", DefaultBCA&lt;Example&gt;(), 
	   "", DefaultBPA&lt;DefaultParamObj&lt;Example&gt; &gt;(), DefaultSelValidate&lt;Example&gt;(),
	   DefaultInsValidate&lt;Example&gt;(), conn);

	view.set_io_handler(AlwaysThrowsHandler&lt;Example&gt;());

	IndexedDBView&lt;DBV&gt; idxview(view, 
		"PrimaryIndex; STRING_VALUE; UNIQUE AlternateIndex; EXAMPLE_LONG, EXAMPLE_DATE",
		BOUND);

	cout &lt;&lt; "Examples in view before attempted range insert:" &lt;&lt; endl;

	copy(idxview.begin(), idxview.end(), ostream_iterator&lt;Example&gt;(cout, "\n"));

	vector&lt;Example&gt; read_from_DB_before;

	copy(idxview.begin(), idxview.end(), back_inserter(read_from_DB_before));

	<span class="codeComment">// examples that we want to insert into the DB ...
	// we want an all or nothing on these guys!</span>
	vector&lt;Example&gt; all_or_nothing_examples;

	<span class="codeComment">// third element will fail to be inserted, should force rollback</span>
	all_or_nothing_examples.push_back(Example(79, "FUBAR", 2.2, 99, mikero));
	all_or_nothing_examples.push_back(Example(81, "All Messed Up", 21.09, 75, chrysalis));
	all_or_nothing_examples.push_back(Example(85, "Bad Boy", -21.22, 11, victory));
	all_or_nothing_examples.push_back(Example(99, "Good One", 77.99, 41, victory));
	
	<span class="codeComment">// must write all the elements to succeed in the transaction
	// else we rollback</span>

	IndexedDBView&lt;DBV&gt; tmp(idxview); <span class="codeComment">// make copy so we can rollback to idxview on failure</span>

	try { 
	  for (vector&lt;Example&gt;::iterator ins_it = all_or_nothing_examples.begin(); 
	      ins_it != all_or_nothing_examples.end(); ins_it++)
		  {	  
			 idxview.insert(*ins_it); <span class="codeComment">// work with tmp</span>
		  }

          conn.CommitAll(); <span class="codeComment">// we assume commit and rollback must always succeed to avoid two-phase commit type logic</span>
	}
        catch(RootException &ex) 
	{ 
	  cout &lt;&lt; ex &lt;&lt; endl;
	  idxview.swap(tmp); <span class="codeComment">// this will rollback to original results in memory</span>
          conn.RollbackAll(); 
	}

	cout &lt;&lt; "Examples in view after attempted range insert:" &lt;&lt; endl;

	copy(idxview.begin(), idxview.end(), ostream_iterator&lt;Example&gt;(cout, "\n"));

	vector&lt;Example&gt; read_from_DB_after;

	copy(idxview.begin(), idxview.end(), back_inserter(read_from_DB_after));

	cout &lt;&lt; "Changes resulting from attempted range insert:" &gt;&gt; endl;
   
        TableDiff(cout, read_from_DB_before, read_from_DB_after);
}

</code></pre> 
<pre><code><span class="codeComment">// Range Transaction over a DBConnection: Updating in a IndexedDBView </span>

const TIMESTAMP_STRUCT chrysalis = {2002, 4, 3, 0, 0, 0, 0};
const TIMESTAMP_STRUCT mikero = {2001, 11, 2, 0, 0, 0, 0};
const TIMESTAMP_STRUCT victory = {2001, 3, 10, 0, 0, 0, 0};

<span class="codeComment">// range update</span>
void RangeIndexUpdateExample()
{
	DBConnection conn;
        conn.Connect("UID=example;PWD=example;DSN=example;");

	typedef DBView&lt;Example&gt; DBV;

	DBV view("DB_EXAMPLE", DefaultBCA&lt;Example&gt;(), 
	   "", DefaultBPA&lt;DefaultParamObj&lt;Example&gt; &gt;(), DefaultSelValidate&lt;Example&gt;(),
	   DefaultInsValidate&lt;Example&gt;(), conn);

	view.set_io_handler(AlwaysThrowsHandler&lt;Example&gt;());

	IndexedDBView&lt;DBV&gt; idxview(view, 
		"PrimaryIndex; STRING_VALUE; UNIQUE AlternateIndex; EXAMPLE_LONG, EXAMPLE_DATE",
		BOUND);

	cout &lt;&lt; "Examples in view before attempted range insert:" &lt;&lt; endl;

	copy(idxview.begin(), idxview.end(), ostream_iterator&lt;Example&gt;(cout, "\n"));

	vector&lt;Example&gt; read_from_DB_before;

	copy(idxview.begin(), idxview.end(), back_inserter(read_from_DB_before));

	<span class="codeComment">// examples that we want to insert into the DB ...
	// we want an all or nothing on these guys!
	// string indicates key of element to replace, Example is object to replace the object
	// to replace with</span>
	map&lt;string, Example&gt; all_or_nothing_examples;

	<span class="codeComment">// third element will fail to be updated, should force rollback</span>
	all_or_nothing_examples["Bedazzled"] = Example(79, "FUBAR", 2.2, 99, mikero);
	all_or_nothing_examples["Corwin"] = Example(81, "All Messed Up", 21.09, 75, chrysalis);
	all_or_nothing_examples["Jordan"] = Example(85, "Bad Boy", -21.22, 11, victory);
	all_or_nothing_examples["Mirror Image"] = Example(99, "Good One", 77.99, 41, victory);
	
	<span class="codeComment">// must update all the elements to succeed in the transaction
	// else we rollback</span>

	IndexedDBView&lt;DBV&gt; tmp(idxview); <span class="codeComment">// make copy so we can rollback to idxview on failure</span>

	<span class="codeComment">// march through vector and replace elements appropriately</span>
	try {
	  map&lt;string, Example&gt;::iterator map_it;
	  
	  for (map_it = all_or_nothing_examples.begin(); 
	       map_it != all_or_nothing_examples.end(); 
		   map_it++)
		  {	  
		     IndexedDBView&lt;DBV&gt;::iterator find_it = idxview.find((*map_it).first);

			 if (find_it != idxview.end())
				 idxview.replace(find_it, (*map_it).second);
		  }

          conn.CommitAll(); <span class="codeComment">// we assume commit and rollback must always succeed to avoid two-phase commit type logic</span>
	}
        catch(RootException &ex) 
	{ 
	  cout &lt;&lt; ex &lt;&lt; endl;
	  idxview.swap(tmp); <span class="codeComment">// this will rollback to original results in memory</span>
          conn.RollbackAll(); 
	}

	cout &lt;&lt; "Examples in view after attempted range update:" &lt;&lt; endl;

	copy(idxview.begin(), idxview.end(), ostream_iterator&lt;Example&lt;(cout, "\n"));

	vector&lt;Example&lt; read_from_DB_after;

	copy(idxview.begin(), idxview.end(), back_inserter(read_from_DB_after));

	cout &lt;&lt; "Changes resulting from attempted range update:" &lt;&lt; endl;
   
        TableDiff(cout, read_from_DB_before, read_from_DB_after);
}
</code></pre> 
</FONT>

And that's it!  Congratulations you made it to the end of the document!
(We thought no-one ever would get here!)


<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright © 2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body>
</HTML>
