<html>

 

<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>DBView&lt;DataObj,ParamObj&gt;::select_iterator</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p>
<h1>DBView&lt;DataObj, ParamObj&gt;::select_iterator</h1>

 

















<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td><img src="iterator.gif" width="194" height="38"></td>
        <td align="right"><img src="type.gif" width="194"
        height="39"></td>
    </tr>
    <tr>
        <td valign="top"><b>Category</b>: iterators</td>
        <td align="right" valign="top"><b>Component type</b>:
        type</td>
    </tr>
</table>
<h3>Description</h3>

<p><tt>DBView&lt;DataObj, ParamObj&gt;::select_iterator</tt> is
an <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input
Iterator</a> that performs the reading of objects of type <font
size="2" face="Courier New">DataObj</font> from a particular <font
size="2" face="Courier New">DBView</font><font size="2"> </font>(and
thus the database). The <font size="2" face="Courier New">select_iterator
</font>generates the following SQL statement to read records from
the database: <font size="2" face="Courier New">&quot;SELECT
&quot; + &quot;&lt;field1_fromBCA&gt;, &lt;field2_fromBCA&gt;,
... &quot; + &quot;FROM &quot; +
&quot;&lt;tablename1_from_view&gt;, &lt;tablename2_from_view&gt;,
... &quot; + posfix_clause_from_view. (But see <a href="DBView.htm#BuildSpecialQry">
BuildSpecialQry</a> for how to override this.) </font>Note that all of the
restrictions of an <a
href="http://www.sgi.com/tech/stl/InputIterator.html">Input
Iterator</a> must be obeyed, including the restrictions on the
ordering of <tt>operator*</tt> and <tt>operator++</tt>
operations. </p>

<h3>Definition</h3>

<p>Defined in the <font size="2" face="Courier New">select_iterator.h
</font>header file. </p>

<h3>Example:</h3>
<h3><i>Mapping a Table to a User Defined Object in Four Easy Steps:</i></h3>
<p><font face="Times Roman">1. Define an object to hold the rows from your query.</font></p>

<p><font face="Times Roman">2. Define an association
between fields in your query and fields in your object. This is
what we call a 'BCA', which is short for Bind Column Addresses.
In the example below, this is done via the functor &quot;BCAExample&quot;.
The job of the BCA is to equate SQL fields with object fields via
the '==' operator which will then establish ODBC bindings to move
data to or from a user query.</font></p>

<p><font face="Times Roman">3. Create a view to select
records from. This view is built from the template DBView and
establishes which table(s) you want to access, what fields you
want to look at (via the BCA), and an optional where clause to
further limit the set of records that you are working with.</font></p>

<p><font face="Times Roman">4. Use the DBView container
to obtain an iterator to SELECT, INSERT, UPDATE or DELETE records
from your view. These iterators may be used to either populate
STL containers or apply algorithms from the Standard Template
library.<br></p>

<pre><code><strong>
In all the examples that follow we will assume that our database contains a table called DB_EXAMPLE of the form

SQL&gt; desc db_example;
Name                            Type
------------------------------- --------
INT_VALUE                       INTEGER
STRING_VALUE                    VARCHAR
DOUBLE_VALUE                    FLOAT
EXAMPLE_LONG                    INTEGER
EXAMPLE_DATE                    DATE

<span class="codeComment">// STEP 1 ////
// &quot;Example&quot; structure to hold rows from our database table</span>
struct Example
{
                                        <span class="codeComment">// tablename.columnname:</span>
	int exampleInt;                 <span class="codeComment">// DB_EXAMPLE.INT_VALUE</span>
	string exampleStr;              <span class="codeComment">// DB_EXAMPLE.STRING_VALUE</span>
	double exampleDouble;           <span class="codeComment">// DB_EXAMPLE.DOUBLE_VALUE</span>
	long exampleLong;               <span class="codeComment">// DB_EXAMPLE.EXAMPLE_LONG</span>
	TIMESTAMP_STRUCT exampleDate;   <span class="codeComment">// DB_EXAMPLE.EXAMPLE_DATE</span>
};

<span class="codeComment">// STEP 2 ////</span>
<span class="codeComment">// Create an association between table columns and fields in our object</span>
template&lt;&gt; class dtl::DefaultBCA&lt;Example&gt;
{
public:
	void operator()(BoundIOs &amp;cols, Example &amp;rowbuf)
    	{
	   cols[&quot;INT_VALUE&quot;] == rowbuf.exampleInt;
	   cols[&quot;STRING_VALUE&quot;] == rowbuf.exampleStr;
	   cols[&quot;DOUBLE_VALUE&quot;] == rowbuf.exampleDouble;
	   cols[&quot;EXAMPLE_LONG&quot;] == rowbuf.exampleLong;
	   cols[&quot;EXAMPLE_DATE&quot;] == rowbuf.exampleDate;
	}
};

<span class="codeComment">// STEP 3 &amp; 4
// Read the contents of the DB_EXAMPLE table and return a vector of the
// resulting rows</span>
vector&lt;Example&gt; ReadData() {
	// Read the data
	vector&lt;Example&gt; results;
	DBView&lt;Example&gt; view(&quot;DB_EXAMPLE&quot;);

	DBView&lt;Example&gt;::select_iterator read_it = view.begin();
	for ( ; read_it != view.end();  ++read_it)
	{
		results.push_back(*read_it);
	}
	return results;
}
</code></pre></strong>

<h3>Template parameters</h3>

<table border="2">
    <tr>
        <th>Parameter </th>
        <th>Description </th>
        <th>Default </th>
    </tr>
    <tr>
        <td valign="top"><tt>DataObj</tt> </td>
        
    <td valign="top">The type of object that will be written to the <font size="2" face="Courier New">DBView</font>. 
      This object will be bound through use of the <a
        href="BCA.htm"><font size="1" face="Courier New">BCA</font></a><font
        size="2"> </font>to the appropriate columns in the database. The set of 
      value types of an <tt>DBView::select_iterator</tt> consists of a single 
      type, <font size="2"
        face="Courier New">DataObj</font>. </td>
        <td valign="top">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top"><tt>ParamObj</tt> </td>
        <td valign="top">The type of object that will be used to
        specify the postfix parameters to the <font size="2"
        face="Courier New">DBView</font>.</td>
        <td valign="top"><font size="2" face="Courier New">DefaultParamObj&lt;DataObj&gt;</font>&nbsp;
        </td>
    </tr>
</table>

<h3>Model of</h3>

<p><a href="http://www.sgi.com/tech/stl/InputIterator.html">Input
Iterator</a> </p>

<h3>Type requirements</h3>

<p><font size="2" face="Courier New">DataObj </font>and <font
size="2" face="Courier New">ParamObj</font> must each fulfill the
following requirements:. </p>

<ul>
    <li>Be of a type that is not primitive or of type <font
        size="2" face="Courier New">string</font><font size="2">.</font></li>
    <li><font size="3">Have a publicly accessible copy
        constructor (the default is OK).</font></li>
    <li><font size="3">Have a publicly accessible assignment
        operator (the default is OK).</font></li>
</ul>

<h3>Public base classes</h3>

<p><font size="2" face="Courier New">DB_iterator&lt;DataObj,
ParamObj&gt;, iterator&lt;input_iterator_tag, DataObj&gt;</font></p>

<h3>Members</h3>

<table border="2">
    <tr>
        <th>Member </th>
        <th>Where defined </th>
        <th>Description </th>
    </tr>
    <tr>
        <td valign="top"><tt>DBView::select_iterator()</tt> </td>
        <td valign="top"><tt>select_iterator</tt> </td>
        <td valign="top"><font size="3">Default constructor.</font></td>
    </tr>    <tr>
        
    <td valign="top"><tt>DBView::select_iterator(DBView&lt;DataObj, ParamObj&gt; 
      &amp;view, bool bPrepare = false)</tt> </td>
        <td valign="top"><tt>select_iterator</tt> </td>
        <td valign="top"><font size="3">See below.</font></td>
    </tr>
    <tr>
        <td valign="top"><tt>DBView::select_iterator(const
        DBView::select_iterator&amp;)</tt> </td>
        <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input
        Iterator</a> </td>
        <td valign="top">The copy constructor. <font size="3">See
        Note </font><a href="#2"><font size="3">[2]</font></a><font
        size="3">.</font></td>
    </tr>
    <tr>
        <td valign="top"><tt>DBView::select_iterator&amp;
        operator=(const DBView select_iterator&amp;)</tt> </td>
        <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input
        Iterator</a> </td>
        
    <td valign="top">The assignment operator <font size="3">See Note </font><a href="#5"><font size="3">[5]</font></a><font
        size="3">.</font></td>
    </tr>
    <tr>
        <td valign="top"><tt>const DataObj &amp;operator*()</tt> </td>
        <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input
        Iterator</a></td>
        <td valign="top">Dereferencing operator. Returns the <font
        size="2" face="Courier New">DataObj </font><font size="3">pointed
        to in the </font><font size="2" face="Courier New">DBView</font><font
        size="3">. This operator forbids assigning to the
        iterator's </font><font size="2" face="Courier New">DataObj.</font></td>
    </tr>
    <tr>
        <td valign="top"><tt>CountedPtr&lt;DataObj&gt; operator-&gt;()</tt> </td>
        <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input
        Iterator</a>, <font size="2" face="Courier New">DB_iterator</font></td>
        <td valign="top">Dereferencing operator. Returns a
        pointer to the <font size="1" face="Courier New">DataObj </font><font
        size="3">read from the </font><font size="2"
        face="Courier New">DBView</font><font size="3">.</font></td>
    </tr>
    <tr>
        <td valign="top"><tt>DBView::select_iterator&amp;
        operator++()</tt> </td>
        <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input
        Iterator</a></td>
        
    <td valign="top">Preincrement. Reads a <font size="2"
        face="Courier New">DataObj </font><font size="3">from the </font><font
        size="2" face="Courier New">DBView. </font><font size="3">See Note </font><a href="#1"><font size="3">[1]</font></a><font
        size="3">.</font></td>
    </tr>
    <tr>
        
    <td valign="top"><tt>DataObjPtr operator++(int)</tt> </td>
        <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input
        Iterator</a></td>
        
    <td valign="top">Postincrement Reads a <font size="2"
        face="Courier New">DataObj </font><font size="3">from the </font><font
        size="2" face="Courier New">DBView.</font><font size="3"> Returns a proxy 
      in order to remember the <font face="Courier New, Courier, mono" size="2">DataObj</font> 
      for future dereference operations in the same expression. See Note </font><a href="#1"><font size="3">[1]</font></a><font
        size="3">.</font></td>
    </tr>
    <tr>
        
    <td valign="top"><tt>friend bool operator==(const DBView::select_iterator 
      &amp;i1, const DBView::select_iterator &amp;i2)</tt> </td>
        <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input
        Iterator</a></td>
        <td valign="top">Returns whether the two iterators are
        equal, that is, do they refer to the same<font size="2"
        face="Courier New"> DataObj</font>? <font size="3">See
        Note </font><a href="#3"><font size="3">[3]</font></a><font
        size="3">.</font></td>
    </tr>
    <tr>
        
    <td valign="top"><tt>friend bool operator!=(const DBView::select_iterator 
      &amp;i1, const DBView::select_iterator &amp;i2)</tt> </td>
        <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input
        Iterator</a></td>
        <td valign="top">Returns whether the two iterators are <strong>not
        </strong>equal. Equivalent to <font size="2"
        face="Courier New">!(i1 == i2).</font></td>
    </tr>

</table>

<h3>New members</h3>

<p>These members are not defined in the <a
href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> requirements 
  or in <font size="2" face="Courier New">DB_iterator&lt;DataObj, ParamObj&gt;</font>, 
  but are specific to <tt>DBView::select_iterator</tt>. 
<table border="2">
    <tr>
        <th>Function </th>
        <th>Description </th>
    </tr>
    <tr>
        
    <td valign="top"><tt>DBView::select_iterator(DBView&lt;DataObj, ParamObj&gt; 
      &amp;view, bool bPrepare = false)</tt> </td>
        
    <td valign="top">Creates an <font size="2"
        face="Courier New">select_iterator </font><font size="3">which refers 
      to</font><font size="2" face="Courier New"> view</font><font
        size="1" face="Courier New">. </font><font
        face="Courier New"><font face="Times New Roman, Times, serif">Set</font></font><font size="2"
        face="Courier New"> bPrepare <font face="Times New Roman, Times, serif" size="3">to</font> 
      true </font><font size="3">if you want the iterator to use <font face="Courier New, Courier, mono" size="2">SQLPrepare()</font> 
      and <font face="Courier New, Courier, mono" size="2">SQLExecute()</font> 
      in the event you are executing the statement many times. Otherwise, the 
      iterator will use <font size="2" face="Courier New, Courier, mono">SQLExecDirect()</font>.</font> 
      <font size="3">See Note </font><a href="#2"><font size="3">[2]</font></a><font
        size="3">.</font></td>
    </tr>
    <tr>
        <td valign="top"><tt>void swap(DBView::select_iterator
        &amp;other)</tt></td>
        <td valign="top">Swap <font size="2" face="Courier New">*this</font>
        with <font size="2">other</font>.</td>
    </tr>
</table>

<h3>Notes</h3>

<p><a name="1"></a>[1] This is the operation that actually reads
the <font size="2" face="Courier New">DataObj </font><font
size="3">from the database via the </font><font size="2"
face="Courier New">DBView</font><font size="3">. Each </font><font
size="2" face="Courier New">DBView::select_iterator</font><font
size="1" face="Courier New"> </font><font size="3">internally
owns a </font><font size="2" face="Courier New">DBStmt</font><font
size="3"> object which is allocated and prepared when the
underlying ODBC statement handle is first needed and not before.
The handle is not opened until absolutely needed in order to make
copying and assigning these iterators an inexpensive operation.
The </font><font size="2" face="Courier New">DBStmt </font><font
size="3">is executed on each call to </font><font size="2"
face="Courier New">operator++()</font><font size="3">, whether
the prefix or postfix version.</font></p>

<p><a name="2"></a>[2] There is also a variant of this
constructor which takes a second argument specifying a dummy
whether the iterator is at the beginning or end of the <font
size="2" face="Courier New">DBView</font><font size="2">. </font><font
size="3">It is used internally and should never be called by the
end user.</font></p>

<p><a name="3"></a>[3] According to the C++ standard, <font
        size="3"> Table 72, Section 24.1.1, page 511</font>, certain invariants 
  must be maintained for an <a
href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>. The 
  <font size="2" face="Courier New">select_iterator</font> implementation both 
  adheres to the following invariants as well as taking advantage of them (assume 
  <font size="2"
face="Courier New">x</font> and <font size="2" face="Courier New">y </font>are 
  both <font size="2" face="Courier New">select_iterators</font>):</p>

<ul>
  <li>Identity: <font size="2" face="Courier New">x == y </font><font
        size="3">if and only if</font><font size="2"
        face="Courier New"> *x <font face="Times New Roman, Times, serif" size="3">is 
    equivalent to</font> *y.</font><font
        size="3"> This doesn't necessarily mean that you will always get the same 
    answer from each, as is the case for the standard library's <font face="Courier New, Courier, mono" size="2">std::istream_iterato</font>r 
    template.</font></li>
  <li> <font size="3">Assignable and Equality Comparable: If you perform </font><font size="2" face="Courier New">x 
    = y, </font><font
        size="3">then </font><font size="2" face="Courier New">x == y. </font><font size="3">See 
    the comments below for how this invariant is preserved.</font></li>
  <li><font size="3">Increment Equality Not Guaranteed: </font><font
        size="2" face="Courier New">x == y </font><font size="3">does <strong>not</strong> 
    imply </font><font size="2"
        face="Courier New">++x == ++y.</font></li>
</ul>

<p><font size="3">We use a reference counted pointer to the data and copy this 
  pointer on assignment of the iterator to obtain the Identity invariant. However, 
  this does not work when we copy<font face="Courier New, Courier, mono" size="2"> 
  DBView::begin()</font> because a new recordset may be opened. In this case, 
  we may not have <font face="Courier New, Courier, mono" size="2">*x == *y </font>although 
  <font size="2" face="Courier New, Courier, mono">*x</font> and <font size="2" face="Courier New, Courier, mono">*y</font> 
  are equivalent in the conceptual sense as the first element of a recordset. 
  </font></p>

<p><a name="4"></a>[4] This function is a bit peculiar for <font
size="2" face="Courier New">select_iterators. </font><font
size="3">For the notion of a </font><font size="2"
face="Courier New">DBView's</font><font size="3"> </font><font
size="2" face="Courier New">begin()</font><font size="3"> and </font><font
size="2" face="Courier">end() </font><font size="3">iterators,</font><font
size="2" face="Courier New"> begin() </font><font size="3">must
point to the first </font><font size="2" face="Courier New">DataObj</font><font
size="3"> in the view and </font><font size="2" face="Courier">end()
</font><font size="3">to one past the last </font><font size="2"
face="Courier New">DataObj </font><font size="3">in the view. To
provide this conceptual behavior, the dereferencing operators
must be able to grab the first record from the database if the
iterator hasn't done so already. So the </font><font size="2"
face="Courier New">ReadData() </font><font size="3">function in
the above example code will say its reading elements 0, 2, 3, 4,
etc., rather than the 1, 2, 3, 4, etc., you would expect. This
behavior occurs as the following happens:</font></p>

<ul>
    <li><font size="3">The program enters the first time through
        the loop. The iterator hasn't needed to access the
        database, so no elements have been read yet. Thus </font><font
        size="2" face="Courier New">GetLastCount() == 0. </font><font
        size="3">Thus, the program prints </font><font size="2"
        face="Courier New">&quot;Reading element #0&quot;.</font></li>
    <li><font size="2" face="Courier New">operator*() </font><font
        size="3">executes, reading the first </font><font
        size="2" face="Courier New">DataObj </font><font size="3">from
        the database. So far then, the iterator has grabbed one </font><font
        size="2" face="Courier New">DataObj </font><font size="3">so
        far.</font></li>
    <li><font size="3">Then, after the next few statements work
        with the fetched </font><font size="2" face="Courier New">DataObj,
        </font><font size="3">the program prepares for the next
        iteration of the loop by incrementing</font><font
        size="2"> </font><font size="3">the</font><font size="2">
        </font><font size="2" face="Courier New">select_iterator</font><font
        size="3">, thus fetching another </font><font size="2"
        face="Courier New">DataObj. </font><font size="3">Now two</font><font
        size="2" face="Courier New"> DataObj's </font><font
        size="3">have been read and the next invocation of</font><font
        size="2" face="Courier New"> GetLastCount() </font><font
        size="3">returns</font><font size="2" face="Courier New">
        2. </font><font size="3">The program now displays </font><font
        size="2" face="Courier New">&quot;Reading element
        #2&quot;.</font></li>
    <li><font size="3">From there in this and all future
        iterations of the loop:</font><font size="2"
        face="Courier New"> operator*() </font><font size="3">just
        returns the value of the already fetched </font><font
        size="2" face="Courier New">DataObj. </font><font
        size="3">It does not read another </font><font size="2"
        face="Courier New">DataObj </font><font size="3">at all
        from the database. Only one object will be read overall
        per iteration in the loop, that done by </font><font
        size="2" face="Courier New">operator++().</font></li>
</ul>
<p><a name="5"></a>[5] It is more efficient to reset your iterator to <font face="Courier New, Courier, mono" size="2">DBView::begin()</font> 
  if you are iterating over a view several times. When you perform the assigment 
  <font size="2"> <font face="Courier New, Courier, mono">select_iterator = view.begin()</font></font>, 
  the code will automatically reset the underlying recordset for you. This can 
  represent a significant performance gain because then the database cursor does 
  not have to be reparsed &amp; reconstructed every time we wish to revisit the 
  view (possibly with different selection parameters).</p>
<h3>See also</h3>

<p><a href="db_iterator.htm"><font size="2" face="Courier New">DB_iterator</font></a>,
<a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output
Iterator</a>, <a
href="http://www.sgi.com/tech/stl/InputIterator.html">Input
Iterator</a>.<br>
<br>
</p>


<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright © 2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body></html>
