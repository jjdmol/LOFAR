<HTML><HEAD><TITLE>CALLBACKS IN C++ USING TEMPLATE FUNCTORS</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="MSHTML 5.50.4207.2601" name=GENERATOR></HEAD>
<BODY>
<H2>CALLBACKS IN C++ USING TEMPLATE FUNCTORS</H2>
<P><STRONG>Copyright 1994 Rich Hickey</STRONG></P>
<P><STRONG>INTRODUCTION</STRONG></P>
<P>One of the many promises of Object-Oriented programming is that it will allow 
for plug-and-play software design with re-usable components. Designers will pull 
objects from their library 'shelves' and hook them together to make software. In 
C++, this hooking together of components can be tricky, particulary if they are 
separately designed. We are still a long way from interoperable libraries and 
application components. Callbacks provide a mechanism whereby independently 
developed objects may be connected together. They are vital for plug and play 
programming, since the likelihood of Vendor A implementing their library in 
terms of Vendor B's classes, or your home-brewed classes, is nil. </P>
<P>Callbacks are in wide use, however current implementations differ and most 
suffer from shortcomings, not the least of which is their lack of generality. 
This article describes what callbacks are, how they are used, and the criteria 
for a good callback mechanism. It summarizes current callback methods and their 
weaknesses. It then describes a flexible, powerful and easy-to-use callback 
technique based on template functors - objects that behave like functions. </P>
<P><STRONG>CALLBACK FUNDAMENTALS </STRONG></P>
<P><I>What Are Callbacks?</I></P>
<P>When designing application or sub-system specific components we often know 
all of the classes with which the component will interact and thus explicity 
code interfaces in terms of those classes. When designing general purpose or 
library components however, it is often necessary or desirable to put in hooks 
for calling unknown objects. What is required is a way for one component to call 
another without having been written in terms of, or with knowledge of, the other 
component's type. Such a 'type-blind' call mechanism is often referred to as a 
callback. </P>
<P>A callback might be used for simple notification, two-way communication, or 
to distribute work in a process. For instance an application developer might 
want to have a <CODE>Button</CODE> component in a GUI library call an 
application-specific object when clicked upon. The designer of a data entry 
component might want to offer the capability to call application objects for 
input validation. Collection classes often offer an <CODE>apply()</CODE> 
function, which 'applies' a member function of an application object to the 
items they contain. </P>
<P>A callback, then, is a way for a component designer to offer a generic 
connection point which developers can use to establish communication with 
application objects. At some subsequent point, the component 'calls back' the 
application object. The communication takes the form of a function call, since 
this is the way objects interact in C++. </P>
<P>Callbacks are useful in many contexts. If you use any commercial class 
libraries you have probably seen at least one mechanism for providing callbacks. 
All callback implementations must address a fundamental problem posed by the C++ 
type system: How can you build a component such that it can call a member 
function of another object whose type is unknown at the time the component is 
designed? C++'s type system requires that we know something of the type of any 
object whose member functions we wish to call, and is often criticized by fans 
of other OO languages as being too inflexible to support true component-based 
design, since all the components have to 'know' about each other. C++'s strong 
typing has too many advantages to abandon, but addressing this apparent lack of 
flexibility may encourage the proliferation of robust and interoperable class 
libraries. </P>
<P>C++ is in fact quite flexible, and the mechanism presented here leverages its 
flexibility to provide this functionality without language extension. In 
particular, templates supply a powerful tool for solving problems such as this. 
If you thought templates were only for container classes, read on! </P>
<P><I>Callback Terminology</I> </P>
<P>There are three elements in any callback mechanism - the caller, the callback 
function, and the callee. </P>
<P>The <EM>caller</EM> is usually an instance of some class, for instance a 
library component (although it could be a function, like <CODE>qsort()</CODE>), 
that provides or requires the callback; i.e. it can, or must, call some third 
party code to perform its work, and uses the callback mechanism to do so. As far 
as the designer of the caller is concerned, the callback is just a way to invoke 
a process, referred to here as the <EM>callback function</EM>. The caller 
determines the signature of the callback function i.e. its argument(s) and 
return types. This makes sense, because it is the caller that has the work to 
do, or the information to convey. For instance, in the examples above, the 
<CODE>Button</CODE> class may want a callback function with no arguments and no 
return. It is a simple notification function used by the <CODE>Button</CODE> to 
indicate it has been clicked upon. The <CODE>DataEntryField</CODE> component 
might want to pass a <CODE>String</CODE> to the callback function and get a 
<CODE>Boolean</CODE> return. </P>
<P>A caller may require the callback for just the duration of one function, as 
with ANSI C's <CODE>qsort()</CODE>, or may want to hold on to the callback in 
order to call back at some later time, as with the <CODE>Button</CODE> class. 
</P>
<P>The <EM>callee</EM> is usually a member function of an object of some class, 
but it can also be a stand-alone function or static member function, that the 
application designer wishes to be called by the caller component. Note that in 
the case of a non-static member function a particular object/member-function 
pair is the callee. The function to be called must be compatible with the 
signature of the callback function specified by the caller. </P>
<P><I>Criteria for a Good Callback Mechanism</I> </P>
<P>A callback mechanism in the object oriented model should support both 
component and application design. Component designers should have a standard, 
off-the-shelf way of providing callback services, requiring no invention on 
their part. Flexibility in specifying the number and types of argument and 
return values should be provided. Since the component may be designed for use in 
as-yet-unthought-of applications, the component designer should neither need to 
know, nor dictate, the types of the objects which may be 'called back' by the 
component. </P>
<P>Application developers, given a component with this standard callback 
mechanism and some instance of a class with a member function compatible with 
the callback function signature, should have to do no custom 'glue' coding in 
order to connect the two together. Nor should they have to modify the callee 
class or hand-derive a new class. If they want to have the callback invoke a 
stand-alone, non-member function, that should be supported as well. </P>
<P>To support this behavior the callback mechanism should be: </P>
<P><I><B>Object Oriented</B></I> - Our applications are built with objects. In a 
C++ application most functionality is contained in member functions, which 
cannot be invoked via normal ptr-to-functions. Non-static member functions 
operate upon objects, which have state. Calling such functions is more than just 
invoking a process, it is operating upon a particular object, thus an 
object-oriented callback must contain information about which object to call. 
</P>
<P><I><B>Type Safe</B></I> - Type safety is a fundamental feature and benefit of 
C++ and any robust C++ callback mechanism must be type safe. That means we must 
ensure that objects are used in compliance with their specified interfaces, and 
that type rules are enforced for arguments, return values, and conversions. The 
best way to ensure this is to have the compiler do the work at compile time. 
</P>
<P><I><B>Non-Coupling</B></I> - This is the fundamental goal of callbacks - to 
allow components designed in ignorance of each other to be connected together. 
If the mechanism somehow introduces a dependancy between caller and callee it 
has failed in its basic mission. </P>
<P><I><B>Non-Type-Intrusive</B></I> - Some mechanisms for doing callbacks 
require a modification to, or derivation of, the caller or callee types. The 
fact that an object is connected to another object in a particular application 
often has nothing to do with its type. As we'll see below, mechanisms that are 
type intrusive can reduce the flexibility and increase the complexity of 
application code. </P>
<P><I><B>Generic</B></I> - The primary differences between different callback 
situations are the types involved. This suggests that the callback mechanism 
should be parameterized using templates. Templates insure consistent interfaces 
and names in all callback situations, and provide a way to have any necessary 
support code be generated by the compiler, not the user. </P>
<P><I><B>Flexible</B></I> - Experience has shown that callback systems that 
require an exact match between callback function and callee function signatures 
are too rigid for real-world use. For instance you may encounter a callback that 
passes a <CODE>Derived *</CODE> that you want to connect to a callee function 
that takes a <CODE>Base *</CODE>. </P>
<P><STRONG>CURRENT MECHANISMS</STRONG> </P>
<P><I>Function Model</I> </P>
<P>The simplest callback mechanism is a pointer-to-function, a la ANSI C's 
<CODE>qsort()</CODE>. Getting a stand-alone function to act upon a particular 
object, however, usually involves kludges like using static or global pointers 
to indicate the target object, or having the callback function take an extra 
parameter (usually a pointer to the object to act upon). The static/global 
pointer method breaks down when the callback relationship exists across calls, 
i.e. 'I want to connect this Button to this X and this other Button to this 
other X, for the duration of the app'. The extra paramter method, if done 
type-safely, introduces undesirable coupling between the caller and callee 
types. </P>
<P><CODE>qsort()</CODE> achieves its genericity by foregoing type safety. i.e., 
in order for it to be ignorant of the types it is manipulating it takes untyped 
(<CODE>void *</CODE>) arguments. There is nothing to prevent someone from 
calling <CODE>qsort()</CODE> on an array of apples and passing a pointer to a 
function that compares oranges! </P>
<P>An example of this typeless mechanism you'll frequently see is the 'apply' 
function in collections. The purpose of an apply function is to allow a 
developer to pass a callback to a collection and have it be 'applied' to (called 
on) each item in the collection. Unfortunately it often looks like this: </P><PRE>void apply(void (*func)(T &amp;theItem,void *extraStuff),void *theStuff);
                            </PRE>
<P>Chances are really good you don't have a function like <CODE>func</CODE> 
sitting around, so you'll have to write one (lots of casting required). And make 
sure you pass it the right stuff. Ugh. </P>
<P><I>Single Rooted Hierarchy</I> </P>
<P>Beware of callback mechanisms that appear type safe but are in fact not. 
These mechanisms usually involve some base-of-all-classes like Object or 
EventHandler, and utilize casts from ptr-to-member-of-derived to 
ptr-to-member-of-base. Experience has indicated that single-rooted systems are 
unworkable if components are to come from multiple sources. </P>
<P><I>Parameterize the Caller</I> </P>
<P>The component designer could parameterize the component on the type of the 
callee. Such parameterization is inappropriate in many situations and callbacks 
are one of them. Consider: </P><PRE>class Button{
public:
	virtual void click();
//...
};

template &lt;class T&gt;
class ButtonThatCallsBack:public class Button{
public:
	ButtonThatCalls(T *who,void (T::*func)(void)):
		callee(who),callback(func){}
	void click()
		{
		(callee-&gt;*callback)();
		}
private:
	T *callee;
        void (T::*callback)(void);
};

class CDPlayer{
public:
	void play();
	//...
};

//Connect a CDPlayer and a Button
CDPlayer cd;
ButtonThatCallsBack&lt;CDPlayer&gt; button(&amp;cd,&amp;CDPlayer::play);
button.click();	//calls cd.play()
</PRE>
<P>A <CODE>ButtonThatCallsBack&lt;CDPlayer&gt;</CODE> would thus 'know' about 
<CODE>CDPlayer</CODE> and provides an interface explicitly based on it. The 
problem is that this introduces rigidity in the system in that the callee type 
becomes part of the caller type, i.e. it is 'type-intrusive'. All code that 
creates <CODE>ButtonThatCallsBack</CODE> objects must be made aware of the 
callee relationship, increasing coupling in the system. A 
<CODE>ButtonThatCallsBack&lt;X&gt; </CODE>is of a different type than a 
<CODE>ButtonThatCallsBack&lt;Y&gt;</CODE>, thus preventing by-value 
manipulation. </P>
<P>If a component has many callback relationships it quickly becomes unworkable 
to parameterize them all. Consider a <CODE>Button</CODE> that wants to maintain 
a dynamic list of callees to be notified upon a click event. Since the callee 
type is built into the <CODE>Button</CODE> class type, this list must be either 
homogeneous or typeless. </P>
<P>Library code cannot even create <CODE>ButtonThatCallsBack</CODE> objects 
because their instantiation depends on application types. This is a severe 
constraint. Consider GUI library code that reads a dialog description from a 
resource file and creates a <CODE>Dialog</CODE> object. How can it know that you 
want the <CODE>Buttons</CODE> in that <CODE>Dialog</CODE> to call back 
<CODE>CDPlayers</CODE>? It can't, therefore it can't create the 
<CODE>Buttons</CODE> for you. </P>
<P><I>Callee Mix-In</I> </P>
<P>The caller component designer can invent an abstract base class to be the 
target of the callback, and indicate to application developers that they mix-in 
this base in order to connect their class with the component. I call this the 
"callee mix-in." </P>
<P>Here the designer of the <CODE>Button</CODE> class wants to offer a click 
notification callback, and so defines a nested class <CODE>Notifiable</CODE> 
with a pure virtual function <CODE>notify()</CODE> that has the desired 
signature. Clients of the <CODE>Button</CODE> class will have to pass to its 
constructor a pointer to a <CODE>Notifiable</CODE>, which the 
<CODE>Button</CODE> will use (at some point later on) for notification of 
clicks: </P><PRE>class Button{
public:
	class Notifiable{
	public:
		virtual void notify()=0;
		};
	Button(Notifiable *who):callee(who){}
	void click()
		{callee-&gt;notify();}
private:
	Notifiable *callee;
};

Given :

class CDPlayer{
public:
	void play();
	//...
};
</PRE>
<P>an application developer wishing to have a <CODE>Button</CODE> call back a 
<CODE>CDPlayer</CODE> would have to derive a new class from both 
<CODE>CDPlayer</CODE> and <CODE>Button::Notifiable</CODE>, overriding the pure 
virtual function to do the desired work: </P><PRE>class MyCDPlayer:public CDPlayer,public Button::Notifiable{
public:
	void notify()
		{play();}
};
</PRE>
<P>and use this class rather than <CODE>CDPlayer</CODE> in the application: </P><PRE>MyCDPlayer cd;
Button button(&amp;cd);
button.click();	//calls cd.play()
</PRE>
<P>This mechanism is type safe, achieves the decoupling of <CODE>Button</CODE> 
and <CODE>CDPlayer</CODE>, and is good magazine article fodder. It is almost 
useless in practice, however. </P>
<P>The problem with the callee mix-in is that it, too, is type-intrusive, i.e. 
it impacts the type of the callee, in this case by forcing derivation. This has 
three major flaws. First, the use of multiple inheritance, particularly if the 
callee is a callee of multiple components, is problematic due to name clashes 
etc. Second, derivation may be impossible, for instance if the application 
designer gets <CODE>CDPlayers</CODE> from an unchangeable, untouchable API 
(library designers note: this is a big problem with mix-in based mechanisms in 
general). The third problem is best demonstrated. Consider this version of 
<CODE>CDPlayer</CODE>: </P><PRE>class CDPlayer{
public:
	void play();
	void stop();
	//...
};
</PRE>
<P>It doesn't seem unreasonable to have an application where one 
<CODE>Button</CODE> calls <CODE>CDPlayer::play()</CODE> and another 
<CODE>CDPlayer::stop()</CODE>. The mix-in mechanism fails completely here, since 
it can only support a single mapping between caller/callee/member-function, i.e. 
<CODE>MyCDPlayer</CODE> can have only one <CODE>notify()</CODE>. </P>
<P><STRONG>CALLBACKS USING TEMPLATE FUNCTORS </STRONG></P>
<P>When I first thought about the inter-component callback problem I decided 
that what was needed was a language extension to support 'bound-pointers', 
special pointers representing information about an object and a member function 
of that object, storable and callable much like regular pointers to functions. 
ARM 5.5 commentary has a brief explanation of why bound pointers were left out. 
</P>
<P>How would bound pointers work? Ideally you would initialize them with either 
a regular pointer-to-function or a reference to an object and a 
pointer-to-member-function. Once initialized, they would behave like normal 
pointer-to-functions. You could apply the function call <CODE>operator()</CODE> 
to them to invoke the function. In order to be suitable for a callback 
mechanism, the information about the type of the callee would _not_ be part of 
the type of the bound-pointer. It might look something like this: </P><PRE>// Warning - NOT C++

class Fred{
public:
	void foo();
};

Fred fred;
void (* __bound fptr)() = &amp;fred.foo;
</PRE>
<P>Here <CODE>fptr</CODE> is a bound-pointer to a function that takes no 
arguments and returns <CODE>void</CODE>. Note that <CODE>Fred</CODE> is not part 
of <CODE>fptr's</CODE> type. It is initialized with the object <CODE>fred</CODE> 
and a pointer-to-member-function-of-Fred, <CODE>foo</CODE>. Saying: </P><PRE>fptr();
</PRE>
<P>would invoke <CODE>foo</CODE> on <CODE>fred</CODE>. </P>
<P>Such bound-pointers would be ideal for callbacks: </P><PRE>// Warning - NOT C++

class Button{
public:
	Button(void (* __bound uponClickDoThis)() )
		:notify(uponClickDoThis)
		{}
	void click()
		{
		notify();
		}
private:
	void (* __bound notify)();
};

class CDPlayer{
public:
	void play();
};

CDPlayer cd;
Button button(&amp;cd.play);
button.click();	    //calls cd.play()
</PRE>
<P>Bound-pointers would require a non-trivial language extension and some tricky 
compiler support. Given the extreme undesirability of any new language features 
I'd hardly propose bound-pointers now. Nevertheless I still consider the 
bound-pointer concept to be the correct solution for callbacks, and set out to 
see how close I could get in the current and proposed language. The result is 
the Callback library described below. As it turns out, the library solution can 
not only deliver the functionality shown above (albeit with different syntax), 
it proved more flexible than the language extension would have been! </P>
<P>Returning from the fantasy world of language extension, the library must 
provide two things for the user. The first is some construct to play the role of 
the 'bound-pointer'. The second is some method for creating these 
'bound-pointers' from either a regular pointer-to-function or an object and a 
pointer-to-member-function. </P>
<P>In the 'bound-pointer' role we need an object that behaves like a function. 
Coplien has used the term <EM>functor</EM> to describe such objects. For our 
purposes a functor is simply an object that behaves like a pointer-to-function. 
It has an <CODE>operator()</CODE> (the function call operator) which can be used 
to invoke the function to which it points. The library provides a set of 
template <CODE>Functor</CODE> classes. They hold any necessary callee data and 
provide pointer-to-function like behavior. Most important, their type has no 
connection whatsoever to the callee type. Components define their callback 
interface using the <CODE>Functor</CODE> classes. </P>
<P>The construct provided by the library for creating functors is an overloaded 
template function, <CODE>makeFunctor()</CODE>, which takes as arguments the 
callee information (either an object and a ptr-to-member-function, or a 
ptr-to-function) and returns something suitable for initializing a 
<CODE>Functor</CODE> object. </P>
<P>The resulting mechanism is very easy to use. A complete example: </P><PRE>#include &lt;callback.h&gt;	//include the callback library header
#include &lt;iostream.h&gt;

class Button{
public:
	Button(const Functor0 &amp;uponClickDoThis)
		:notify(uponClickDoThis)
		{}
	void click()
		{
		notify();	//a call to operator()
		}
private:
	Functor0 notify;	//note - held by value
};

//Some application stuff we'd like to connect to Button:

class CDPlayer{ public:
	void play(){cout&lt;&lt;"Playing"&lt;&lt;endl;}
	void stop(){cout&lt;&lt;"Stopped"&lt;&lt;endl;}
};

void wow()
	{cout&lt;&lt;"Wow!"&lt;&lt;endl;}

void main()
	{
	CDPlayer cd;

	//makeFunctor from object and ptr-to-member-function

	Button playButton(makeFunctor(cd,&amp;CDPlayer::play));
	Button stopButton(makeFunctor(cd,&amp;CDPlayer::stop));

	//makeFunctor from pointer-to-function

	Button wowButton(makeFunctor(&amp;wow));

	playButton.click();	//calls cd.play()
	stopButton.click();	//calls cd.stop()
	wowButton.click();	//calls wow()
	}
</PRE>
<P>Voila! A component (<CODE>Button</CODE>) has been connected to application 
objects and functions it knows nothing about and that know nothing about 
<CODE>Button</CODE>, without any custom coding, derivation or modification of 
the objects involved. And it's type safe. </P>
<P>The <CODE>Button</CODE> class designer specifies the callback interface in 
terms of <CODE>Functor0</CODE>, a functor that takes no arguments and returns 
<CODE>void</CODE>. It stores the functor away in its member <CODE>notify</CODE>. 
When it comes time to call back, it simply calls <CODE>operator()</CODE> on the 
functor. This looks and feels just like a call via a pointer-to-function. </P>
<P>Connecting something to a component that uses callbacks is simple. You can 
just initialize a <CODE>Functor</CODE> with the result of an appropriate call to 
<CODE>makeFunctor()</CODE>. There are two flavors of <CODE>makeFunctor()</CODE>. 
You can call it with a ptr-to-stand-alone function: </P><PRE>	makeFunctor(&amp;wow)
</PRE>
<P>OR with an object and a pointer-to-member function: </P><PRE>	makeFunctor(cd,&amp;CDPlayer::play)
</PRE>
<P>I must come clean at this point, and point out that the syntax above for 
<CODE>makeFunctor()</CODE> is possible only in the proposed language, because it 
requires template members (specifically, the <CODE>Functor</CODE> constructors 
would have to be templates). In the current language the same result can be 
achieved by passing to <CODE>makeFunctor()</CODE> a dummy parameter of type 
ptr-to-the-Functor-type-you-want-to-create. This iteration of the callback 
library requires you pass <CODE>makeFunctor()</CODE> the dummy as the first 
parameter. Simply cast <CODE>0</CODE> to provide this argument: </P><PRE>	makeFunctor((Functor0 *)0,&amp;wow)

	makeFunctor((Functor0 *)0,cd,&amp;CDPlayer::play);
</PRE>
<P>I will use this current-language syntax from here on. </P>
<P>The <CODE>Button</CODE> class above only needs a callback function with no 
arguments that returns <CODE>void</CODE>. Other components may want to pass data 
to the callback or get a return back. The only things distinguishing one functor 
from another are the number and types of the arguments to 
<CODE>operator()</CODE> and its return type, if any. This indicates that 
functors can be represented in the library by (a set of) templates: </P><PRE>//Functor classes provided by the Callback library:

Functor0	//not a template - nothing to parameterize
Functor1&lt;P1&gt;
Functor2&lt;P1,P2&gt;
Functor3&lt;P1,P2,P3&gt;
Functor4&lt;P1,P2,P3,P4&gt;
Functor0wRet&lt;RT&gt;
Functor1wRet&lt;P1,RT&gt;
Functor2wRet&lt;P1,P2,RT&gt;
Functor3wRet&lt;P1,P2,P3,RT&gt;
Functor4wRet&lt;P1,P2,P3,P4,RT&gt;
</PRE>
<P>These are parameterized by the types of their arguments (<CODE>P1</CODE> etc) 
and return value (<CODE>RT</CODE>) if any. The numbering is necessary because we 
can't overload template class names on number of parameters. '<CODE>wRet</CODE>' 
is appended to distinguish those with return values. Each has an 
<CODE>operator()</CODE> with the corresponding signature, for example: </P><PRE>template &lt;class P1&gt;
class Functor1{
public:
	void operator()(P1 p1)const;
	//...
};

template &lt;class P1,class P2,class RT&gt;
class Functor2wRet{
public:
	RT operator()(P1 p1,P2 p2)const;
	//...
};
</PRE>
<P>These <CODE>Functor</CODE> classes are sufficient to meet the callback needs 
of component designers, as they offer a standard and consistent way to offer 
callback services, and a simple mechanism for invoking the callback function. 
Given these templates in the library, a component designer need only pick one 
with the correct number of arguments and specify the desired types as 
parameters. Here's the <CODE>DataEntryField</CODE> that wants a validation 
callback that takes a <CODE>const String &amp;</CODE> and returns a 
<CODE>Boolean</CODE>: </P><PRE>#include &lt;callback.h&gt;

class DataEntryField{
public:
	DataEntryField(const Functor1wRet&lt;const String &amp;,Boolean&gt; &amp;v):
		validate(v){}
	void keyHit(const String &amp; stringSoFar)
		{
		if(validate(stringSoFar))
			// process it etc...
		}
private:
	Functor1wRet&lt;const String &amp;,Boolean&gt; validate;
	//validate has a
	//Boolean operator()(const String &amp;)
};
</PRE>
<P>These trivial examples just scratch the surface of what you can do given a 
general purpose callback library such as this. Consider their application to 
state machines, dispatch tables etc. </P>
<P>The callback library is 100% compile-time type safe. (Where compile time 
includes template-instantiation time). If you try to make a functor out of 
something that is not compatible with the functor type you will get a compiler 
error. All correct virtual function behavior is preserved. </P>
<P>The system is also type flexible. You'll note that throughout this article I 
have said 'type compatible' rather than 'exactly-matching' when talking about 
the relationship between the callback function and the callee function. 
Experience has shown that requiring an exact match makes callbacks too rigid for 
practical use. If you have done much work with pointer-to-function based 
interfaces you've probably experienced the frustration of having a pointer to a 
function 'that would work' yet was not of the exact type required for a match. 
</P>
<P>To provide flexibility the library supports building a functor out of a 
callee function that is 'type compatible' with the target functor - it need not 
have an exactly matching signature. By type compatible I mean a function with 
the same number of arguments, of types reachable from the functor's argument 
types by implicit conversion. The return type of the function must be implicitly 
convertible to the return type of the functor. A functor with no return can be 
built from a function with a return - the return value is safely ignored. </P><PRE>//assumes Derived publicly derived from Base
void foo(Base &amp;);
long bar(Derived &amp;);

Functor1&lt;Derived&amp;&gt; f1 =
        makeFunctor((Functor1&lt;Derived&amp;&gt; *)0,&amp;foo);
	//ok - will implicitly convert

f1 = makeFunctor((Functor1&lt;Derived&amp;&gt; *)0,&amp;bar);
	//ok - ignores return
</PRE>
<P>Any necessary argument conversions or ignoring of returns is done by the 
compiler, i.e. there is no coercion done inside the mechanism or by the user. If 
the compiler can't get from the arguments passed to the functor to the arguments 
required by the callee function, the code is rejected at compile time. By 
allowing the compiler to do the work we get all of the normal conversions of 
arguments - derived to base, promotion and conversion of built-in types, and 
user-defined conversions. </P>
<P>The type-flexibility of the library is something that would not have been 
available in a language extension rendition of bound pointers. </P>
<P>Rounding out the functionality of the <CODE>Functor</CODE> classes are a 
default constructor that will also accept <CODE>0</CODE> as an initializer, 
which puts the <CODE>Functor</CODE> in a known 'unset' state, and a conversion 
to <CODE>Boolean</CODE> which can be used to test whether the 
<CODE>Functor</CODE> is 'set'. The <CODE>Functor</CODE> classes do not rely on 
any virtual function behavior to work, thus they can be held and copied 
by-value. Thus a <CODE>Functor</CODE> has the same ease-of-use as a regular 
pointer-to-function. </P>
<P>At this point you know everything you need to use the callback library. All 
of the code is in one file, <CODE>callback.h</CODE>. To use a callback in a 
component class, simply instantiate a <CODE>Functor</CODE> with the desired 
argument types. To connect some stuff to a component that uses 
<CODE>Functors</CODE> for callbacks, simply call <CODE>makeFunctor()</CODE> on 
the stuff. Easy. </P>
<P><I>Power Templates </I></P>
<P>As usual, what is easy for the user is often tricky for the implementor. 
Given the black-box descriptions above of the <CODE>Functor</CODE> classes and 
<CODE>makeFunctor()</CODE> it may be hard to swallow the claims of type-safety, 
transparent conversions, correct virtual function behavior etc. A look behind 
the curtain reveals not only how it works, but also some neat template 
techniques. Warning: most people find the pointer-to-member and template syntax 
used in the implementation daunting at first. </P>
<P>Obviously some sort of magic is going on. How can the <CODE>Functor</CODE> 
class, with no knowledge of the type or signature of the callee, ensure a type 
safe call to it, possibly with implicit conversions of the arguments? It can't, 
so it doesn't. The actual work must be performed by some code that knows both 
the functor callback signature and everything about the callee. The trick is to 
get the compiler to generate that code, and have the <CODE>Functor</CODE> to 
point to it. Templates can help out all around. </P>
<P>The mechanism is spread over three components - the <CODE>Functor</CODE> 
class, a <CODE>Translator</CODE> class, and the <CODE>makeFunctor()</CODE> 
function. All are templates. </P>
<P>The <CODE>Functor</CODE> class is parameterized on the types of the callback 
function signature, holds the callee data in a typeless manner, and defines a 
typed <CODE>operator()</CODE> but doesn't actually perform the work of calling 
back. Instead it holds a pointer to the actual callback code. When it comes time 
to call back, it passes the typeless data (itself actually), as well as the 
callback arguments, to this pointed-to function. </P>
<P>The <CODE>Translator</CODE> class is derived from <CODE>Functor</CODE> but is 
parameterized on both the <CODE>Functor</CODE> type _and_ the callee types. It 
knows about everything, and is thus able to define a fully type-safe static 
'thunk' function that takes the typeless <CODE>Functor</CODE> data and the 
callback arguments. It constructs its <CODE>Functor</CODE> base class with a 
pointer to this static function. The thunk function does the work of calling 
back, turning the typeless <CODE>Functor</CODE> data back into a typed callee 
and calling the callee. Since the <CODE>Translator</CODE> does the work of 
converting the callee data to and from untyped data the conversions are 
considered 'safe'. The <CODE>Translator</CODE> isA <CODE>Functor</CODE>, so it 
can be used to initialize a <CODE>Functor</CODE>. </P>
<P>The <CODE>makeFunctor()</CODE> function takes the callee data, creates a 
<CODE>Translator</CODE> out of it and returns the <CODE>Translator</CODE>. Thus 
the <CODE>Translator</CODE> object exists only briefly as the return value of 
<CODE>makeFunctor()</CODE>, but its creation is enough to cause the compiler to 
lay down the static 'thunk' function, the address of which is carried in the 
<CODE>Functor</CODE> that has been initialized with the <CODE>Translator</CODE>. 
</P>
<P>All of this will become clearer with the details. </P>
<P>For each of the 10 <CODE>Functor</CODE> classes there are 2 
<CODE>Translator</CODE> classes and 3 versions of <CODE>makeFunctor()</CODE>. 
We'll examine a slice of the library here, <CODE>Functor1</CODE> and its 
associated <CODE>Translators</CODE> and <CODE>makeFunctors</CODE>. The other 
<CODE>Functors</CODE> differ only in the number of args and return values. </P>
<P><I>The Functors</I> </P>
<P>Since the <CODE>Functor</CODE> objects are the only entities held by the 
caller, they must contain the data about the callee. With some care we can 
design a base class which can hold, in a typeless manner, the callee data, 
regardless of whether the callee is a ptr-to-function or 
object/ptr-to-member-function combo: </P><PRE>//typeless representation of a function or object/mem-func

class FunctorBase{
public:
	typedef void (FunctorBase::*_MemFunc)();
	typedef void (*_Func)();
	FunctorBase():callee(0),func(0){}
	FunctorBase(const void *c,const void *f,size_t sz)
		{
		if(c)	//must be callee/memfunc
			{
			callee = (void *)c;
			memcpy(memFunc,f,sz);
			}
		else	//must be ptr-to-func
			{
			func = f;
			}
		}
	//for evaluation in conditions
	//will be changed to bool when bool exists
	operator int()const{return func||callee;}

	class DummyInit{
	};
////////////////////////////////////////////////////////////////
// Note: this code depends on all ptr-to-mem-funcs being same size
// If that is not the case then make memFunc as large as largest
////////////////////////////////////////////////////////////////

	union{
	const void *func;
	char memFunc[sizeof(_MemFunc)];
	};
	void *callee;
};
</PRE>
<P>All <CODE>Functors</CODE> are derived (protected) from this base. 
<CODE>FunctorBase</CODE> provides a constructor from typeless args, where if 
<CODE>c</CODE> is <CODE>0</CODE> the callee is a pointer-to-function and 
<CODE>f</CODE> is that pointer, else <CODE>c</CODE> is pointer to the callee 
object and <CODE>f</CODE> is a pointer to a pointer-to-member function and 
<CODE>sz</CODE> is that ptr-to-member-function's size (in case an implementation 
has pointer-to-members of differing sizes). It has a default constructor which 
inits to an 'unset' state, and an <CODE>operator int</CODE> to allow for testing 
the state (set or unset). </P>
<P>The <CODE>Functor</CODE> class is a template. It has a default constructor 
and the required <CODE>operator()</CODE> corresponding to its template 
parameters. It uses the generated copy constructor and assignment operators. 
</P><PRE>/************************* one arg - no return *******************/
template &lt;class P1&gt;
class Functor1:protected FunctorBase{
public:
	Functor1(DummyInit * = 0){}
	void operator()(P1 p1)const
		{
		thunk(*this,p1);
		}
	FunctorBase::operator int;
protected:
	typedef void (*Thunk)(const FunctorBase &amp;,P1);
	Functor1(Thunk t,const void *c,const void *f,size_t sz):
		FunctorBase(c,f,sz),thunk(t){}
private:
	Thunk thunk;
};
</PRE>
<P>The <CODE>Functor</CODE> class has a protected constructor that takes the 
same typeless args as <CODE>FunctorBase</CODE>, plus an additional first 
argument. This argument is a pointer to function (the thunk function) that takes 
the same arguments as the <CODE>operator()</CODE>, plus an additional first 
argument of type <CODE>const FunctorBase &amp;</CODE>. The <CODE>Functor</CODE> 
stores this away (in thunk) and implements <CODE>operator()</CODE> by calling 
<CODE>thunk()</CODE>, passing itself and the other arguments. Thus it is this 
<CODE>thunk()</CODE> function that does the work of 'calling back'. </P>
<P>A key issue at this point is whether <CODE>operator()</CODE> should be 
virtual. In the first iteration of my mechanism the <CODE>Functor</CODE> classes 
were abstract and the <CODE>operator()</CODE>'s pure virtual. To use them for 
callbacks a set of derived template classes parameterized on the callee type was 
provided. This required that functors always be passed and held by reference or 
pointer and never by value. It also required the caller component or the client 
code maintain the derived object for as long as the callback relationship 
existed. I found the maintenance and lifetime issues of these functor objects to 
be problematic, and desired by-value syntax. </P>
<P>In the current mechanism the <CODE>Functor</CODE> classes are concrete and 
the <CODE>operator()</CODE> is non-virtual. They can be treated and used just 
like ptr-to-functions. In particular, they can be stored by value in the 
component classes. </P>
<P><I>The Translators</I> </P>
<P>Where does the <CODE>thunk()</CODE> come from? It is generated by the 
compiler as a static member of a template 'translator' class. For each 
<CODE>Functor</CODE> class there are two translator classes, one for stand-alone 
functions (<CODE>FunctionTranslator</CODE>) and one for member functions 
(<CODE>MemberTranslator</CODE>). The translator classes are parameterized by the 
type of the <CODE>Functor</CODE> as well as the type(s) of the callee. With this 
knowledge they can, in a fully type-safe manner, perform two important tasks. 
</P>
<P>First, they can initialize the <CODE>Functor</CODE> data. They do this by 
being publicly derived from the <CODE>Functor</CODE>. They are constructed with 
typed callee information and which they pass (untyped) to the functor's 
protected constructor. </P>
<P>Second, they have a static member function <CODE>thunk()</CODE>, which, when 
passed a <CODE>FunctorBase</CODE>, converts its callee data back into typed 
information, and executes the callback on the callee. It is a pointer to this 
static function which is passed to the <CODE>Functor</CODE> constructor. </P><PRE>template &lt;class P1,class Func&gt;
class FunctionTranslator1:public Functor1&lt;P1&gt;{
public:
	FunctionTranslator1(Func f):Functor1&lt;P1&gt;(thunk,0,f,0){}
	static void thunk(const FunctorBase &amp;ftor,P1 p1)
		{
		(Func(ftor.func))(p1);
		}
};
</PRE>
<P><CODE>FunctionTranslator</CODE> is the simpler of the two. It is 
parameterized by the argument type of the <CODE>Functor</CODE> and some 
ptr-to-function type (<CODE>Func</CODE>). Its constructor takes an argument of 
type <CODE>Func</CODE> and passes it and a pointer to its static 
<CODE>thunk()</CODE> function to the base class constructor. The thunk function, 
given a <CODE>FunctorBase</CODE> ftor, casts ftor's func member back to its 
correct type (<CODE>Func</CODE>) and calls it. There is an assumption here that 
the <CODE>FunctorBase</CODE> ftor is one initialized by the constructor (or a 
copy). There is no danger of it being otherwise, since the functors are always 
initialized with matching callee data and thunk functions. This is what is 
called a 'safe' cast, since the same entity that removed the type information 
also re-instates it, and can guarantee a match. If <CODE>Func</CODE>'s signature 
is incompatible with the call, i.e. if it cannot be called with a single 
argument of type <CODE>P1</CODE>, then <CODE>thunk()</CODE> will not compile. If 
implicit conversions are required the compiler will perform them. Note that if 
<CODE>func</CODE> has a return it is safely ignored. </P><PRE>template &lt;class P1,class Callee, class MemFunc&gt;
class MemberTranslator1:public Functor1&lt;P1&gt;{
public:
	MemberTranslator1(Callee &amp;c,const MemFunc &amp;m):
		Functor1&lt;P1&gt;(thunk,&amp;c,&amp;m,sizeof(MemFunc)){}
	static void thunk(const FunctorBase &amp;ftor,P1 p1)
		{
		Callee *callee = (Callee *)ftor.callee;
		MemFunc &amp;memFunc(*(MemFunc*)(void *)(ftor.memFunc));
		(callee-&gt;*memFunc)(p1);
		}
};
</PRE>
<P><CODE>MemberTranslator</CODE> is parameterized by the argument type of the 
<CODE>Functor</CODE>, some class type (<CODE>Callee</CODE>), and some 
ptr-to-member-function type (<CODE>MemFunc</CODE>). Not surprisingly it's 
constructor is passed 2 arguments, a <CODE>Callee</CODE> object (by reference) 
and a ptr-to-member-function, both of which are passed, along with the thunk 
function, to the base class constructor. Once again, the <CODE>thunk</CODE> 
function casts the typeless info back to life, and then calls the member 
function on the object, with the passed parameter. </P>
<P>Since the <CODE>Translator</CODE> objects <EM>are</EM> <CODE>Functor</CODE> 
objects, and fully 'bound' ones at that, they are suitable initializers for 
their corresponding <CODE>Functor</CODE>, using the <CODE>Functor</CODE>'s copy 
constructor. We needn't worry about the 'chopping' effect since the data is all 
in the base class portion of the <CODE>Translator</CODE> class and there are no 
virtual functions involved. Thus they are perfect candidates for the return 
value of <CODE>makeFunctor()</CODE>! </P>
<P><I>The makeFunctor Functions</I> </P>
<P>For each <CODE>Functor</CODE> class there are three versions of 
<CODE>makeFunctor()</CODE>, one for ptr-to-function and a const and non-const 
version for the object/ptr-to-member-function pair. </P><PRE>template &lt;class P1,class TRT,class TP1&gt;
inline FunctionTranslator1&lt;P1,TRT (*)(TP1)&gt;
makeFunctor(Functor1&lt;P1&gt;*,TRT (*f)(TP1))
	{
	return FunctionTranslator1&lt;P1,TRT (*)(TP1)&gt;(f);
	}
</PRE>
<P>The function version is straightforward. It uses the dummy argument to tell 
it the type of the functor and merely returns a corresponding 
<CODE>FunctionTranslator</CODE>. I mentioned above that the <CODE>Func</CODE> 
type parameter of <CODE>FunctionTranslator</CODE> was invariably a 
ptr-to-function type. This version of <CODE>makeFunctor()</CODE> ensures that by 
explicity specifying it as such. </P><PRE>template &lt;class P1,class Callee,class TRT,class CallType,class TP1&gt;
inline MemberTranslator1&lt;P1,Callee,TRT (CallType::*)(TP1)&gt;
makeFunctor(Functor1&lt;P1&gt;*,Callee &amp;c,TRT (CallType::* const &amp;f)(TP1))
	{
	typedef TRT (CallType::*MemFunc)(TP1);
	return MemberTranslator1&lt;P1,Callee,MemFunc&gt;(c,f);
	}
</PRE>
<P>This is the gnarliest bit. Here <CODE>makeFunctor</CODE> is parameterized 
with the type of the argument to the <CODE>Functor</CODE>, the type of the 
callee, the type of the class of which the member-function is a member, the 
argument and return types of the member function. Whew! We're a long way from 
<CODE>Stack&lt;T&gt;</CODE> land! Like the ptr-to-function version, it uses the 
dummy first argument of the constructor to determine the type of the 
<CODE>Functor</CODE>. The second argument is a <CODE>Callee</CODE> object (by 
reference). The third argument is this thing: </P><PRE>TRT (CallType::* const &amp;f)(TP1)
</PRE>
<P>Here <CODE>f</CODE> is a reference to a constant pointer to a member function 
of <CODE>CallType</CODE> taking <CODE>TP1</CODE> and returning <CODE>TRT</CODE>. 
You might notice that pointer-to-member-functions are all handled by reference 
in the library. On some implementations they can be expensive to pass by value 
and copy. The significant feature here is that the function need not be of type 
pointer-to-member-of-Callee. This allows <CODE>makeFunctor</CODE> to match on 
(and ultimately work with) a ptr-to-member-function of some base of 
<CODE>Callee</CODE>. It then typedefs that bit and returns an appropriate 
<CODE>MemberTranslator</CODE>. </P><PRE>template &lt;class P1,class Callee,class TRT,class CallType,class TP1&gt;
inline MemberTranslator1&lt;P1,const Callee,TRT (CallType::*)(TP1)const&gt;
makeFunctor(Functor1&lt;P1&gt;*,const Callee &amp;c,TRT (CallType::* const &amp;f)(TP1)const)
	{
	typedef TRT (CallType::*MemFunc)(TP1)const;
	return MemberTranslator1&lt;P1,const Callee,MemFunc&gt;(c,f);
	}
</PRE>
<P>This last variant just ensures that if the <CODE>Callee</CODE> is const the 
member function is also (note the <CODE>const</CODE> at the end of the third 
argument to the constructor - that's where it goes!). </P>
<P>That, for each of ten <CODE>Functors</CODE>, is the whole implementation. 
</P>
<P><STRONG>Can Your Compiler Do This?</STRONG> </P>
<P>The callback library has been successfully tested with IBM CSet++ 2.01, 
Borland C++ 4.02 (no, its not twice as good ;-), and Watcom C++32 10.0. It is 
ARM compliant with the exception of expecting trivial conversions of template 
function arguments, which is the behavior of most compilers. I am interested in 
feedback on how well it works with other implementations. </P>
<P><STRONG>Summary</STRONG> </P>
<P>Callbacks are a powerful and necessary tool for component based 
object-oriented development in C++. They can be a tremendous aid to the 
interoperability of libraries. The template functor system presented here meets 
all the stated criteria for a good callback mechanism - it is object-oriented, 
compile-time type-safe, generic, non-type-intrusive, flexible and easy to use. 
It is sufficiently general to be used in any situation calling for callbacks. It 
can be implemented in the current language, and somewhat more elegantly in the 
proposed language. </P>
<P>This implementation of callbacks highlights the power of C++ templates - 
their type-safety, their code-generation ability and the flexibility they offer 
by accepting ptr-to-function and ptr-to-member-function type parameters. </P>
<P>Ultimately the greatest benefit is gained when class libraries start using a 
standard callback system. If callbacks aren't in the components, they can't be 
retrofitted. Upon publication of this article I am making this Callback library 
freely available in the hope that it will be adopted by library authors and 
serve as a starting point for discussion of a standard callback system. </P>
<HR>

<P><STRONG>References</STRONG> </P>
<P>Stroustrup, B. The Design and Evolution of C++, Addison-Wesley, Reading, MA 
1994 </P>
<P>Coplien, J.O. Advanced C++ Programming Styles and Idioms, Addison-Wesley, 
Reading, MA 1992 </P>
<P>Ellis, M.A. and B. Stroustrup. The Annotated C++ Reference Manual, 
Addison-Wesley, Reading, MA 1990 </P>
<P>Lippman, S.B. C++ Primer 2nd Edition, Addison-Wesley, Reading, MA 1991 </P>
<HR>

<P><STRONG>Acknowledgments</STRONG> </P>
<P>Thanks to my fellow developers at RCS and to <A 
href="http://www.comeaucomputing.com/">Greg Comeau</A> for reviewing and 
commenting on this article. </P>
<HR>

<P><STRONG>About the Author</STRONG> </P>
<P>Rich is Technical Design Lead at Radio Computing Services, a leading software 
vendor in the radio industry. He designed and teaches the Advanced C++ course at 
New York University's Information Technologies Institute. </P>He can be reached 
at: 
<ADDRESS><A 
href="mailto:rhickey@bestweb.net">mailto:rhickey@bestweb.net</A></ADDRESS>
<P></P> </BODY></HTML>
