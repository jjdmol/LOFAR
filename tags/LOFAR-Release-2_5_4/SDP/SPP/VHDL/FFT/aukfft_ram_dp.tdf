-------------------------------------------------------------------------
-------------------------------------------------------------------------
--
-- Revision Control Information
--
-- Header
--
-- $Workfile:   aukfft_ram_dp.tdf  $
--
-- $Revision:   1.5  $
--
-- $Date:   20 Mar 2002 14:25:20  $
--
-- $Title       :  
--
-- $Project     :  FFT
--
-- Description  :  Subdesign : aukfft_ram_dp
--
-- Copyright 2000 (c) Altera Corporation
-- All rights reserved
--
-------------------------------------------------------------------------
-------------------------------------------------------------------------




FUNCTION lpm_ram_dp
(
	wren,
	data[LPM_WIDTH-1..0],
	wraddress[LPM_WIDTHAD-1..0],
	wrclock,
	wrclken,
	rden,
	rdaddress[LPM_WIDTHAD-1..0],
	rdclock,
	rdclken
)
WITH
(
	LPM_WIDTH,
	LPM_WIDTHAD,
	LPM_NUMWORDS,
	LPM_FILE,
	LPM_INDATA,
	LPM_WRADDRESS_CONTROL,
	LPM_RDADDRESS_CONTROL,
	LPM_OUTDATA
)
RETURNS (q[LPM_WIDTH-1..0]);

FUNCTION altsyncram 
(
	wren_a,
	wren_b,
	data_a[OPERATION_MODE != "ROM" ? WIDTH_A - 1 : 0..0], 
	data_b[(OPERATION_MODE == "BIDIR_DUAL_PORT") ? WIDTH_B - 1 : 0..0], 
    address_a[WIDTHAD_A - 1..0], 
    address_b[(OPERATION_MODE == "BIDIR_DUAL_PORT" # OPERATION_MODE== "DUAL_PORT") ? WIDTHAD_B - 1 : 0..0],
    clock0, 
    clock1, 
    clocken0,
    clocken1, 
    rden_b, 
    aclr0, 
    aclr1, 
    byteena_a[OPERATION_MODE != "ROM" ? ((WIDTH_A > 15) ? ((WIDTH_BYTEENA_A > 1 ? WIDTH_BYTEENA_A-1 : 0)) : 0 ): 0..0], 
    byteena_b[OPERATION_MODE == "BIDIR_DUAL_PORT" ? ((WIDTH_B > 15)?(WIDTH_BYTEENA_B > 1 ? WIDTH_BYTEENA_B-1 : 0) : 0 ): 0..0] 
)
WITH
( 
	OPERATION_MODE,
	WIDTH_A,
	WIDTHAD_A,
	NUMWORDS_A,
	INDATA_ACLR_A,
	WRCONTROL_ACLR_A,
    ADDRESS_ACLR_A,
    WIDTH_B,
    WIDTHAD_B,
    NUMWORDS_B, 
    INDATA_REG_B,
    INDATA_ACLR_B, 
    WRCONTROL_WRADDRESS_REG_B,
    WRCONTROL_ACLR_B,
    ADDRESS_ACLR_B,
    OUTDATA_REG_A, 
    OUTDATA_ACLR_A,
    BYTEENA_ACLR_A,
    RDCONTROL_REG_B,
    RDCONTROL_ACLR_B,
    ADDRESS_REG_B,
    OUTDATA_REG_B,
    OUTDATA_ACLR_B,
    BYTEENA_REG_B,
    BYTEENA_ACLR_B,
    INIT_FILE, 
    INIT_FILE_LAYOUT,
    MAXIMUM_DEPTH,
    WIDTH_BYTEENA_A,
    WIDTH_BYTEENA_B,
    BYTE_SIZE,
    READ_DURING_WRITE_MODE_MIXED_PORTS,
    RAM_BLOCK_TYPE,
    DEVICE_FAMILY 
)
RETURNS 
(
	q_a[WIDTH_A - 1..0],
	q_b[(OPERATION_MODE == "DUAL_PORT" # OPERATION_MODE == "BIDIR_DUAL_PORT") ? WIDTH_B - 1 : 0..0] 
);



PARAMETERS
(
    datawidth 		= 16,
    addresswidth 	= 8,
    stratix 		= 0
);




subdesign aukfft_ram_dp
(
    sysclk 								: INPUT;
                                    	
    read 								: INPUT;
    write 								: INPUT;
                                    	
    writeaddress[addresswidth..1] 		: INPUT;
    writereal[datawidth..1] 			: INPUT;
    writeimag[datawidth..1] 			: INPUT;
                                    	
    readaddress[addresswidth..1] 		: INPUT;
    readreal[datawidth..1] 				: OUTPUT;
    readimag[datawidth..1] 				: OUTPUT;
                                    	                                    	
    fftwriteenable   					: INPUT;

    fftreadaddress[addresswidth..1] 	: INPUT;
    fftwriteaddress[addresswidth..1] 	: INPUT;

    fftwritedatareal[datawidth..1] 		: INPUT;
    fftwritedataimag[datawidth..1] 		: INPUT;

    fftreaddatareal[datawidth..1] 		: OUTPUT;
    fftreaddataimag[datawidth..1] 		: OUTPUT;
)

VARIABLE

    ramux[addresswidth..1] 				: node;
    readrealdata[datawidth..1] 			: node;
    readimagdata[datawidth..1] 			: node;

    wamux[addresswidth..1] 				: node;
    wrmux[datawidth..1] 				: node;
    wimux[datawidth..1] 				: node;

    wren 								: node;

    real_ram	:	altsyncram
    				WITH 
    				(
					OPERATION_MODE 						= "DUAL_PORT",
					MAXIMUM_DEPTH 						= (2^addresswidth)*datawidth,
					WIDTH_A 							= datawidth,
					WIDTHAD_A 							= addresswidth,
					NUMWORDS_A 							= 2^addresswidth,
					WIDTH_B 							= datawidth,
					WIDTHAD_B 							= addresswidth,
					NUMWORDS_B 							= 2^addresswidth,
					WIDTH_BYTEENA_A 					= 1,
					OUTDATA_REG_B 						= "CLOCK0",
					INDATA_ACLR_A 						= "NONE",
					WRCONTROL_ACLR_A 					= "NONE",
					ADDRESS_ACLR_A 						= "NONE",
					ADDRESS_REG_B 						= "CLOCK0",
					ADDRESS_ACLR_B 						= "NONE",
					OUTDATA_ACLR_B 						= "NONE",
					READ_DURING_WRITE_MODE_MIXED_PORTS 	= "DONT_CARE",
					RAM_BLOCK_TYPE 						= "AUTO",
					INTENDED_DEVICE_FAMILY 				= "Stratix"
					);

    imag_ram 	: 	altsyncram 
    				WITH 
    				(
					OPERATION_MODE 						= "DUAL_PORT",
					MAXIMUM_DEPTH 						= (2^addresswidth)*datawidth,
					WIDTH_A 							= datawidth,
					WIDTHAD_A 							= addresswidth,
					NUMWORDS_A 							= 2^addresswidth,
					WIDTH_B 							= datawidth,
					WIDTHAD_B 							= addresswidth,
					NUMWORDS_B 							= 2^addresswidth,
					WIDTH_BYTEENA_A 					= 1,
					OUTDATA_REG_B 						= "CLOCK0",
					INDATA_ACLR_A 						= "NONE",
					WRCONTROL_ACLR_A 					= "NONE",
					ADDRESS_ACLR_A 						= "NONE",
					ADDRESS_REG_B 						= "CLOCK0",
					ADDRESS_ACLR_B 						= "NONE",
					OUTDATA_ACLR_B 						= "NONE",
					READ_DURING_WRITE_MODE_MIXED_PORTS 	= "DONT_CARE",
					RAM_BLOCK_TYPE 						= "AUTO",
					INTENDED_DEVICE_FAMILY 				= "Stratix"
					);


BEGIN

    --*************
    --***  MUX  ***
    --*************

    -- MUX the read address
    --*********************
    ramux[] 					= (readaddress[] & read) # (fftreadaddress[] & !read);


    -- MUX the write address and data
    --*******************************
    wamux[] 					= (writeaddress[] & write) # (fftwriteaddress[] & !write);
    wrmux[] 					= (writereal[] & write) # (fftwritedatareal[] & !write);
    wimux[] 					= (writeimag[] & write) # (fftwritedataimag[] & !write);

    wren 						= write # fftwriteenable;


    -- assign data output
    --*******************
    readreal[] 					= readrealdata[];
    readimag[] 					= readimagdata[];
    fftreaddatareal[] 			= readrealdata[];
    fftreaddataimag[] 			= readimagdata[];


    --**************
    --*** MEMORY ***
    --**************

    real_ram.clock0 			= sysclk;
    imag_ram.clock0 			= sysclk;

    if stratix == 1 generate
    -- use altsyncram in stratix device
    
    	readrealdata[] 			= real_ram.q_b[];
    	real_ram.wren_a 		= wren;
		real_ram.address_a[] 	= wamux[];
		real_ram.address_b[] 	= ramux[];
		real_ram.data_a[] 		= wrmux[];
    
   		readimagdata[] 			= imag_ram.q_b[];
    	imag_ram.wren_a 		= wren;
		imag_ram.address_a[] 	= wamux[];
		imag_ram.address_b[] 	= ramux[];
		imag_ram.data_a[] 		= wimux[];

    
    else generate
    -- use lpm_ram for other device families

    	readrealdata[] 			= lpm_ram_dp
    							  (
    							      wren,
    							      wrmux[],
    							      wamux[],
    							      sysclk,
    							      1,  --wrclken,
    							      1,  --rden,
    							      ramux[],
    							      sysclk,
    							      1   --rdclken
    							  )
    							  WITH
    							  (
    							      LPM_WIDTH 			= datawidth,
    							      LPM_WIDTHAD 			= addresswidth,
    							      LPM_INDATA 			= "REGISTERED",
    							      LPM_WRADDRESS_CONTROL = "REGISTERED",
    							      LPM_RDADDRESS_CONTROL = "REGISTERED",
    							      LPM_OUTDATA 			= "REGISTERED"
    							  );
    	
    	
    	
    	readimagdata[]			= lpm_ram_dp
    							  (
								      wren,
								      wimux[],
								      wamux[],
								      sysclk,
								      1,  --wrclken,
								      1,  --rden,
								      ramux[],
								      sysclk,
								      1   --rdclken
    							  )
    							  WITH
    							  (
								      LPM_WIDTH 			= datawidth,
								      LPM_WIDTHAD 			= addresswidth,
								      LPM_INDATA 			= "REGISTERED",
								      LPM_WRADDRESS_CONTROL = "REGISTERED",
								      LPM_RDADDRESS_CONTROL = "REGISTERED",
								      LPM_OUTDATA 			= "REGISTERED"
    							  );

    end generate;  
END;

