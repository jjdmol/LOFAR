/****************************************************************************/
/* ZEPTOOS:zepto-info */
/*     This file is part of ZeptoOS: The Small Linux for Big Computers.
 *     See www.mcs.anl.gov/zeptoos for more information.
 */
/* ZEPTOOS:zepto-info */
/* */
/* ZEPTOOS:zepto-fillin */
/*     $Id: buffers.c,v 1.9 2007/06/27 15:10:45 iskra Exp $
 *     ZeptoOS_Version: 1.2
 *     ZeptoOS_Heredity: FOSS_ORIG
 *     ZeptoOS_License: GPL
 */
/* ZEPTOOS:zepto-fillin */
/* */
/* ZEPTOOS:zepto-gpl */
/*      Copyright: Argonne National Laboratory, Department of Energy,
 *                 and UChicago Argonne, LLC.  2004, 2005, 2006, 2007
 *      ZeptoOS License: GPL
 * 
 *      This software is free.  See the file ZeptoOS/misc/license.GPL
 *      for complete details on your rights to copy, modify, and use this
 *      software.
 */
/* ZEPTOOS:zepto-gpl */
/****************************************************************************/

#define _GNU_SOURCE /* For posix_memalign.  */
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

#include <errno.h>
#include <pthread.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <assert.h>
#include <string.h>

#include "bgl.h"
#include "zoid.h"
#include "zoid_api.h"

#define NR_OF_SEG_DESCS 256
#define MEM_SIZE 448*1024*1024
#define MEM_START 0xA4000000


static struct zoid_buffer* empty_queue_1 = NULL;
static struct zoid_buffer* empty_queue_2 = NULL;
static pthread_mutex_t empty_queue_mutex = PTHREAD_MUTEX_INITIALIZER;


typedef struct seg_desc_s {
    void *addr;
    size_t size;
    struct seg_desc_s *next;
} seg_desc;

static struct alloc_data {
  seg_desc *unused_seg_desc_list;
  seg_desc *free_seg_list;
  seg_desc *allocated_seg_list;
} *alloc_data;

static void *zoid_mem;
static lock_pair allocater_locks;



static inline void flush_L1(void) {
    void *p = zoid_mem;
    
    while(p < zoid_mem + sizeof(struct alloc_data) + NR_OF_SEG_DESCS * sizeof(seg_desc)) {
	asm volatile("dcbf 0,%0\n" :: "r" (p));
	p += L1_CACHE_LINE_SIZE;
    }
}


#if 0
static void print_lists() {
    seg_desc *p;

    fprintf(stderr, "Free:");
    p = alloc_data->free_seg_list;
    while(p) {
	fprintf(stderr, " %p(%u)", p->addr, p->size);
	p = p->next;
    }
    fprintf(stderr, "\n");

    fprintf(stderr, "Allocated:");
    p = alloc_data->allocated_seg_list;
    while(p) {
	fprintf(stderr, " %p(%u)", p->addr, p->size);
	p = p->next;
    }
    fprintf(stderr, "\n\n");
}
#endif


static void return_unused_seg_desc(seg_desc* seg_desc) {
    assert(seg_desc);

    seg_desc->next = alloc_data->unused_seg_desc_list;
    alloc_data->unused_seg_desc_list = seg_desc;
}


static seg_desc *get_seg_desc(void) {
    seg_desc *tmp;

    assert(alloc_data->unused_seg_desc_list);

    tmp = alloc_data->unused_seg_desc_list;
    alloc_data->unused_seg_desc_list = alloc_data->unused_seg_desc_list->next;
    return tmp;
}


static void add_to_free_seg_list(seg_desc *seg) {
    seg_desc *p = alloc_data->free_seg_list;
    seg_desc *prev = NULL;
    seg_desc *tmp;
    
    while(p && seg->addr > p->addr) {
	prev = p;
	p = p->next;
    }

    if(prev) {
	if(prev->addr + prev->size == seg->addr) {
	    prev->size += seg->size;
	    return_unused_seg_desc(seg);
	    seg = prev;
	} else {
	    prev->next = seg;
	    seg->next = p;
	}
    } else {
	alloc_data->free_seg_list = seg;
	seg->next = p;
    }

    if(seg->next && seg->addr + seg->size == seg->next->addr) {
	tmp = seg->next;
	seg->size += tmp->size;
	seg->next = tmp->next;
	return_unused_seg_desc(tmp);
    }
}


void __zoid_free(void *addr) {
    seg_desc *p, *prev;

    enter_critical_section(&allocater_locks);
    flush_L1();
    
    p = alloc_data->allocated_seg_list;
    prev = NULL;

    while(p && p->addr != addr) {
	prev = p;
	p = p->next;
    }

    assert(p);

    if(prev)
	prev->next = p->next;
    else
	alloc_data->allocated_seg_list = p->next;

    flush_L1_region(p->addr, p->size);

    add_to_free_seg_list(p);

    flush_L1();
    leave_critical_section(&allocater_locks);
}


void *__zoid_alloc(size_t size) {
    seg_desc *p, *prev, *new;

    assert(size > 0);

    size += 31;
    size &= ~31;

    enter_critical_section(&allocater_locks);
    flush_L1();

    p = alloc_data->free_seg_list;
    prev = NULL;

    while(p && p->size < size) {
	prev = p;
	p = p->next;
    }

    if(!p) {
	leave_critical_section(&allocater_locks);
	return NULL;
    }

    if(p->size == size) {
	if(prev)
	    prev->next = p->next;
	else
	    alloc_data->free_seg_list = p->next;

	new = p;
    } else {
	new = get_seg_desc();
	new->size = size;
	new->addr = p->addr;
	p->addr += size;
	p->size -= size;
    }

    new->next = alloc_data->allocated_seg_list;
    alloc_data->allocated_seg_list = new;

    flush_L1();
    leave_critical_section(&allocater_locks);

    return new->addr;
}


void allocater_init(void) {
    int i;
    seg_desc *seg_descs;

    zoid_mem = (void*)MEM_START;

    alloc_data = (struct alloc_data*)zoid_mem;
    seg_descs = (seg_desc*)(zoid_mem + sizeof(struct alloc_data));
    
    alloc_data->free_seg_list = &seg_descs[0];
    alloc_data->free_seg_list->addr = (void*)
	(((unsigned int)(&seg_descs[NR_OF_SEG_DESCS] + 31)) & ~31);
    alloc_data->free_seg_list->size = zoid_mem + MEM_SIZE - 
	alloc_data->free_seg_list->addr;
    alloc_data->free_seg_list->next = NULL;

    alloc_data->unused_seg_desc_list = NULL;
    alloc_data->allocated_seg_list = NULL;

    for(i = 1; i < NR_OF_SEG_DESCS; i++)
	return_unused_seg_desc(&seg_descs[i]);

    init_lock_pair(&allocater_locks);
}


void *__zoid_allocate_buffer(size_t size) {
    struct zoid_buffer* buffer;
    int remainder;
    
    assert(size <= max_buffer_size_2);
    
    remainder = size % TREE_DATA_SIZE;
    if(remainder)
      size += TREE_DATA_SIZE - remainder;
    
    buffer = (struct zoid_buffer*)__zoid_alloc(sizeof(struct zoid_buffer) + size);
    assert(buffer);

    buffer->next = NULL;
    buffer->size = size;
    buffer->errnum = buffer->excessive_size = 0;
    buffer->userbuf_out = NULL;
    buffer->userbuf_out_cb = NULL;
    buffer->userbuf_out_priv = NULL;
    buffer->userbuf_in = NULL;
    buffer->ack_sent = 0;

    return buffer->data;
}


void __zoid_release_buffer(void* buffer) {
    struct zoid_buffer* entry;

    if (!buffer)
	return;

    entry = get_zoid_buffer(buffer);

    if (entry->userbuf_out) {
	assert(0);
    }

    __zoid_free(entry);
}


struct zoid_buffer*
get_zoid_buffer(void* buffer)
{
    if (buffer)
	buffer -= offsetof(struct zoid_buffer, data);
    return buffer;
}


void init_zoid_buf_pipe(zoid_buf_pipe *pipe, lock_pair *locks) {
    pipe->first = NULL;
    pipe->last = NULL;
    pipe->locks = locks;
}


void enqueue_zoid_buf(zoid_buf_pipe *pipe, struct zoid_buffer *buffer) {
    buffer->next = NULL;
    
    enter_critical_section(pipe->locks);
    
    if (pipe->first) {
	pipe->last->next = buffer;
	flush_L1_region(&(pipe->last->next), 
			sizeof(pipe->last->next));
    } else {
	pipe->first = buffer;
    }
    pipe->last = buffer;

    flush_zoid_buf(buffer);

    leave_critical_section(pipe->locks);
}


struct zoid_buffer *dequeue_zoid_buf(zoid_buf_pipe *pipe) {
    struct zoid_buffer *buffer;
    
    enter_critical_section(pipe->locks);
    
    buffer = pipe->first;
    if(buffer == (struct zoid_buffer*)1) {
	leave_critical_section(pipe->locks);
	return (struct zoid_buffer*)1;
    }

    if(buffer) {
	flush_L1_region(buffer, sizeof(struct zoid_buffer));
	pipe->first = buffer->next;
    }

    leave_critical_section(pipe->locks);

    return buffer;
}
