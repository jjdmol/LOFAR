/* TBB_Writer_main.cc
 * 
 * LOFAR Transient Buffer Boards (TBB) Data Writer  Copyright (C) 2012
 * ASTRON (Netherlands Institute for Radio Astronomy)
 * P.O. Box 2, 7990 AA Dwingeloo, The Netherlands.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with the LOFAR software suite.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * $Id: TBB_Writer_main.cc 14523 2012-03-14 18:58:53Z amesfoort $
 *
 * @author Alexander S. van Amesfoort
 * Parts derived from the BF writer written by Jan David Mol, and from
 * TBB writers written by Lars Baehren, Andreas Horneffer, and Joseph Masters.
 */

/*
 * NOTE: Only transient data mode has been implemented and tested.
 * TODO: Some code for spectral mode is implemented, but it could never be tested and the TBB HDF5 format considers transient data only.
 */

#define _POSIX_C_SOURCE				1	// sigaction(2), gmtime_r(3)
#define _GNU_SOURCE					1	// getopt_long(3)

#include <lofar_config.h>				// before any other include

#include <cstddef>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cmath>
#include <sys/types.h>
#include <csignal>
#include <ctime>						// strftime()
#include <sys/stat.h>
#include <unistd.h>
#include <climits>
#include <cerrno>
#include <getopt.h>

#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <map>

#include <boost/lexical_cast.hpp>

#include <Common/SystemUtil.h>
#include <Common/StringUtil.h>
#include <Common/StreamUtil.h>
#include <Common/Thread/Thread.h>
#include <Common/Exceptions.h>
#include <Common/NewHandler.h>

#include <Storage/TBB_Writer.h>
#include <Storage/TBB_StaticMapping.h>
#include <Storage/IOPriority.h>

#if defined HAVE_PKVERSION
#include "Package__Version.h"		// generated by cmake
#endif

#define TBB_DEFAULT_BASE_PORT		0x7bb0	// i.e. tbb0
#define TBB_DEFAULT_LAST_PORT		0x7bbb	// 0x7bbf for NL, 0x7bbb for int'l stations

using namespace std;

struct progArgs {
	string outDir;
	string parsetFilename;
	string conMapFilename;
	string proto;
	uint16_t port;
	struct timeval timeoutVal;
	bool keepRunning;
	bool rawDataFiles;
};

// Install a new handler to produce backtraces for std::bad_alloc.
LOFAR::NewHandler badAllocExcHandler(LOFAR::BadAllocException::newHandler);

static void termSigsHandler(int sig_nr) {
	if (sig_nr == SIGALRM) {
		// do nothing
	}
}

/*
 * Register signal handlers for SIGINT and SIGTERM to gracefully terminate early,
 * so we can break out of blocking system calls and exit without corruption of already written output.
 * Leave SIGQUIT (Ctrl-\) untouched, so users can still easily quit immediately.
 */
static void setTermSigsHandler() {
	struct sigaction sa;

	sa.sa_handler = termSigsHandler;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	int err = sigaction(SIGINT,  &sa, NULL); // keyb INT (typically Ctrl-C)
	err    |= sigaction(SIGTERM, &sa, NULL);
	err    |= sigaction(SIGALRM, &sa, NULL); // for setitimer(); don't use sleep(3) and friends
	if (err != 0) {
		LOG_WARN("TBB: Failed to register SIGINT/SIGTERM handler to allow manual, early, graceful program termination.");
	}
}

#if 0
/*
 * Return station names that will send data to this host.
 * 
 * This function will be redundant once the mapping info is available through the parset.
 * Multiple stations may be sending to the same locus node (i.e. TBB writer).
 * This mapping is indicated in MAC/Deployment/data/StaticMetaData/TBBConnections.dat
 */
static vector<string> getTBB_StationNames(const string& tbbMappingFilename) {
	vector<string> stationNames;

	LOFAR::TBB_StaticMapping tbbMapping(tbbMappingFilename);
	if (tbbMapping.empty()) {
		throw LOFAR::IOException("Failed to derive any node-to-station mappings from the static TBB mapping file");
	}

	string myHname(LOFAR::myHostname(true));
	stationNames = tbbMapping.getStationNames(myHname);
	if (stationNames.empty()) {
		// Likely, it only knows e.g. 'tbbsinknode123' instead of 'tbbsinknode123.example.com', so retry.
		myHname = LOFAR::myHostname(false);
		stationNames = tbbMapping.getStationNames(myHname);
		if (stationNames.empty()) {
			throw LOFAR::IOException("Failed to retrieve station names that will send TBB data to this node");
		}
	}

	return stationNames;
}
#endif

static vector<string> getTBB_InputStreamNames(const string& proto, uint16_t portsBase) {
	/*
	 * Proto: TBB always arrives over UDP (but command-line override).
	 * 
	 * Ports: Each board sends data to port TBB_DEFAULT_BASE_PORT + itsBoardNr, so that's where put a r/w thread pair each to listen.
	 * The number of TBB boards can be retrieved using LCS/ApplCommon/src/StationConfig.cc: nrTBBs = StationInfo.getInt("RS.N_TBBOARDS");
	 * but we know that stations have 6 (NL stations) or 12 (EU stations) TBB boards, so simply use defines.
	 */
	vector<string> allInputStreamNames;

	uint16_t portsEnd = portsBase + TBB_DEFAULT_LAST_PORT - TBB_DEFAULT_BASE_PORT;
	for (uint16_t port = portsBase; port <= portsEnd; port++) {
		// 0.0.0.0: It would be better to restrict to station IPs/network, but need netmask lookup and need to allow localhost.
		string streamName(proto + ":0.0.0.0:" + LOFAR::formatString("%hu", port));
		allInputStreamNames.push_back(streamName);
	}

	return allInputStreamNames;
}

static void doTBB_Run(const vector<string>& inputStreamNames, const LOFAR::RTCP::Parset& parset,
			const string& outdir, bool dumpRaw, const struct timeval& timeoutVal) {
	string logPrefix("TBB obs " + LOFAR::formatString("%u", parset.observationID()) + " main thread: ");

	// Mask all signals to inherit for workers. This forces signals to be delivered to the main thread.
	// Wrap to make sure we always (try to) restore the signal mask.
	struct SigToggle {
		sigset_t sigset_old;

		SigToggle() {
			sigset_t sigset_all_masked;
			sigfillset(&sigset_all_masked);
			if (pthread_sigmask(SIG_SETMASK, &sigset_all_masked, &sigset_old) != 0) {
				// The LOFAR sys uses another way to control us, so do not make this fatal.
				LOG_WARN_STR(logPrefix << "pthread_sigmask() failed to mask signals to inherit for worker threads.");
			}
		}

		~SigToggle() {
			if (pthread_sigmask(SIG_SETMASK, &sigset_old, NULL) != 0) {
				// No exc in destr. If restoring fails and --keeprunning, we remain deaf.
				LOG_WARN_STR(logPrefix << "pthread_sigmask() failed to restore signals. We may be deaf to signals.");
			}
		}
	};

	int err = 1;
	try {
		SigToggle sigt;

		// Kick off the writer threads, etc.
		// When this obj goes out of scope, writer threads are cancelled and joined with.
		TBB_Writer writer(inputStreamNames, parset, outdir, dumpRaw);

		/*
		 * We don't know how much data comes in, so cancel workers when all are idle for a while (timeoutVal).
		 * In some situations, threads can become active again after idling a bit, so periodically monitor thread timeout stamps.
		 * Poor man's sync, but per-thread timers to break read() to notify us of idleness does not work.
		 * This (sucks and :)) could be improved once the LOFAR system tells us how much data will be dumped, or when done.
		 */
		struct itimerval timer = {timeoutVal, timeoutVal};
		if (setitimer(ITIMER_REAL, &timer, NULL) != 0) {
			throw LOFAR::SystemCallException("setitimer failed");
		}

		bool anyFrameReceived = false; // don't quit if there is no data immediately after starting
		size_t nrWorkersDone;
		do {
			pause();

			nrWorkersDone = 0;
			for (size_t i = 0; i < inputStreamNames.size(); i++) {
				struct timeval now;
				gettimeofday(&now, NULL);
				time_t lastActive_sec = writer.getTimeoutStampSec(i);
				if (lastActive_sec != 0) {
					anyFrameReceived = true;
				}
				if (anyFrameReceived && lastActive_sec <= now.tv_sec - timeoutVal.tv_sec) {
					nrWorkersDone += 1;
				}
			}
		} while (nrWorkersDone < inputStreamNames.size());

		err = 0;
	} catch (LOFAR::Exception& exc) {
		LOG_FATAL_STR(logPrefix << "LOFAR::Exception: " << exc.text());
	} catch (DAL::DALException& exc) {
		LOG_FATAL_STR(logPrefix << "DALException: " << exc.what());
	} catch (exception& exc) {
		LOG_FATAL_STR(logPrefix << "std::exception: " << exc.what());
	} catch (...) {
		LOG_FATAL_STR(logPrefix << "non-std::exception");
	}

	return err;
}

static void printUsage(const char* progname) {
	cout << "Usage: " << progname << " [--help] [--version] [--outputdir=/data/tbbout/xxx] [--parsetfile=/home/user/tbb/obsxxx.parset]"
		" [--conmapfile=/etc/xxx/TBBConnections.dat] [--proto=udp] [--portbase=0x7bb0] [--timeout=10] [--rawdata=1] [--keeprunning=1]" << endl;
}

static int parseArgs(int argc, char *argv[], struct progArgs* args) {
	int rv = 0;

	// Default values
	args->outDir = "";
	args->parsetFilename = "";	// there is no default parset filename, so not passing it is fatal
	args->conMapFilename = "";	// default is to find the filename at $LOFARROOT/etc/StaticMetaData/TBBConnections.dat
	args->proto = "udp";
	args->port = TBB_DEFAULT_BASE_PORT;
	args->timeoutVal.tv_sec = 10; // after this default of inactivity cancel all input threads and close output files
	args->timeoutVal.tv_usec = 0;
	args->rawDataFiles = true;
	args->keepRunning = true;

	static struct option long_opts[] = {
		// {const char *name, int has_arg, int *flag, int val}
		{"help",        no_argument,       NULL, 'h'},
		{"version",     no_argument,       NULL, 'v'},

		{"outputdir",   required_argument, NULL, 'd'},
		{"parsetfile",  required_argument, NULL, 'c'}, // 'c'onfig
		{"conmapfile",  required_argument, NULL, 'm'}, // 'm'ap // TODO: remove, also from printUsage() and progArgs, and "hvd:c:m:..."
		{"proto",       required_argument, NULL, 'p'},
		{"portbase",    required_argument, NULL, 'b'}, // 'b'ase
		{"timeout",     required_argument, NULL, 't'},

		{"rawdata",     optional_argument, NULL, 'r'},
		{"keeprunning", optional_argument, NULL, 'k'},

		{NULL, 0, NULL, 0}
	};

	opterr = 0; // prevent error printing to stderr by getopt_long()
	int opt;
	while ((opt = getopt_long(argc, argv, "hvd:c:m:p:b:t:r::k::", long_opts, NULL)) != -1) {
		switch (opt) {
		case 'h':
		case 'v':
			cout << "LOFAR TBB_Writer version: 1.0" << endl; // TODO: version
			if (rv == 0) {
				rv = 2;
			}
			break;
		case 'd':
			args->outDir = optarg;
			if (args->outDir[args->outDir.size() - 1] != '/') {
				args->outDir.push_back('/');
			}
			break;
		case 'c':
			args->parsetFilename = optarg;
			break;
		case 'm':
			args->conMapFilename = optarg;
			break;
		case 'p':
			if (strcmp(optarg, "tcp") == 0 || strcmp(optarg, "udp") == 0) {
				args->proto = optarg;
			} else {
				cerr << "Invalid protocol option: " << optarg << endl;
				rv = 1;
			}
			break;
		case 'b':
			try {
				args->port = boost::lexical_cast<uint16_t>(optarg);
				if (args->port > 65536 - (TBB_DEFAULT_LAST_PORT - TBB_DEFAULT_BASE_PORT)) {
					throw boost::bad_lexical_cast(); // abuse exc type to have single catch
				}
			} catch (boost::bad_lexical_cast& /*exc*/) {
				cerr << "Invalid port option: " << optarg << endl;
				rv = 1;
			}
			break;
		case 't':
			try {
				args->timeoutVal.tv_sec = boost::lexical_cast<unsigned long>(optarg);
			} catch (boost::bad_lexical_cast& /*exc*/) {
				cerr << "Invalid timeout option: " << optarg << endl;
				rv = 1;
			}
			break;
		case 'r':
			if (optarg == NULL || optarg[0] == '\0') {
				args->rawDataFiles = true;
				break;
			}
			try {
				args->rawDataFiles = boost::lexical_cast<bool>(optarg);
			} catch (boost::bad_lexical_cast& /*exc*/) {
				cerr << "Invalid rawdata option: " << optarg << endl;
				rv = 1;
			}
			break;
		case 'k':
			if (optarg == NULL || optarg[0] == '\0') {
				args->keepRunning = true;
				break;
			}
			try {
				args->keepRunning = boost::lexical_cast<bool>(optarg);
			} catch (boost::bad_lexical_cast& /*exc*/) {
				cerr << "Invalid keeprunning option: " << optarg << endl;
				rv = 1;
			}
			break;
		default: // '?'
			cerr << "Invalid program argument: " << argv[optind-1] << endl;
			rv = 1;
		}
	}

	if (optind < argc) {
		cerr << "Failed to recognize options:";
		while (optind < argc) {
			cerr << " " << argv[optind++];
		}
		cerr << endl;
		rv = 1;
	}

	return rv;
}

static char stdoutbuf[1024], stderrbuf[1024];

int main(int argc, char* argv[]) {
	struct progArgs args;
	int err;

	setvbuf(stdout, stdoutbuf, _IOLBF, sizeof stdoutbuf);
	setvbuf(stderr, stderrbuf, _IOLBF, sizeof stderrbuf);

#if defined HAVE_LOG4CPLUS
	INIT_LOGGER(string(getenv("LOFARROOT") ? : ".") + "/etc/Storage_main.log_prop");
#endif

	err = parseArgs(argc, argv, &args);
	if (err != 0) {
		if (err == 2) err = 0;
		printUsage(argv[0]);
		return err;
	}

	setTermSigsHandler();

	LOFAR::RTCP::Parset parset;
	try {
		parset = LOFAR::RTCP::Parset(args.parsetFilename);
	} catch (exception& exc) {
		LOG_FATAL_STR("TBB: Failed to load parset file: " << exc.what());
		return 1;
	}

#if 0
	/*
	 * Retrieve the station name that will send data to this host (input thread will check this at least once).
	 * Getting this from static meta data is inflexible.
	 */
	string tbbMappingFilename(args.conMapFilename);
	if (tbbMappingFilename.empty()) {
		const string defaultTbbMappingFilename("TBBConnections.dat");
		char* lrpath = getenv("LOFARROOT");
		if (lrpath != NULL) {
			tbbMappingFilename = string(lrpath) + "/etc/StaticMetaData/";
		}
		tbbMappingFilename.append(defaultTbbMappingFilename);
	}
	vector<string> stationNames(getTBB_StationNames(tbbMappingFilename));
#endif

	const vector<string> inputStreamNames(getTBB_InputStreamNames(args.proto, args.port));

	// We don't run alone, so increase the QoS we get from the OS to decrease the chance of data loss.
	setIOpriority();
	setRTpriority();
	lockInMemory();

	const unsigned maxErrorsSeen = 1000; // Nr of dumps per obs was estimated to fit in 3 digits.
	err = 0;
	do {
		err += doTBB_Run(inputStreamNames, parset, args.outdir, args.rawDataFiles, args.timeoutVal);
	} while (args.keepRunning && err < maxErrorsSeen);
	if (err == maxErrorsSeen) {
		LOG_FATAL("TBB: Reached max nr of errors seen. Shutting down to avoid filling the disk with logging crap.");
	}

	return err == 0 ? 0 : 1;
}
