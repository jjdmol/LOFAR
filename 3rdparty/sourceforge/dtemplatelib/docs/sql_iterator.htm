<html> 

<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>DBView&lt;DataObj,ParamObj&gt;::sql_iterator</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p><h1>DBView&lt;DataObj, ParamObj&gt;::sql_iterator</h1>



















<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td><img src="iterator.gif" width="194" height="38"></td>
        <td align="right"><img src="type.gif" width="194"
        height="39"></td>
    </tr>
    <tr>
        <td valign="top"><b>Category</b>: iterators</td>
        <td align="right" valign="top"><b>Component type</b>:
        type</td>
    </tr>
</table>
<h3>Description</h3>

<p><tt>DBView&lt;DataObj, ParamObj&gt;::sql_iterator</tt> is both an <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input 
  Iterator</a> and <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output 
  Iterator</a> that repeatedly executes a SQL string to read or write data against a particular <font
size="2" face="Courier New">DBView</font><font size="2"> </font>.
  The SQL string that is used by this iterator is controlled by the <tt>DBView</tt> constructor.
  Because the SQL string can be arbitrary (SELECT, INSERT, UPDATE, DELETE or other SQL commands) <tt>sql_iterator</tt>
  can do anything the other DTL iterators do and much more.  In practice, the primary
  application for <tt>sql_iterator</tt> is for use in calling stored procedures.</p>
<p>As with the other subclasses of <font size="2" face="Courier New">DB_iterator</font>, parameters and columns are bound respectively through the 
  use of BPAs and BCAs. However, for <tt>sql_iterator</tt>, it is possible to 
  specify parameter bindings either in the BCA or BPA. This flexiblity is necessary because a
  user defined SQL statement may contain all parameters e.g. "INSERT INTO TABLENAME VALUES(?, ?)" or 
  "{call InsertProcedure(?, ?)}" and we want to allow these parameters to be written through a DataObj
  for compatibitility with the other <tt>DBView</tt> iterator types.  Conceptually, we recommend 
  that you place information that you wish to read or write into the <tt>DataObj</tt> class and
  information that you want to use for WHERE clause conditions into the <tt>ParamObj</tt> class. 
  One important note is that the BCA and BPA will determine how sql_iterator behaves
  for operator++.  If your BCA and BPA contain only parameters, then operator++ will simply call SQLExecute().  This matches the behavior
  given by <tt>insert_iterator, update_iterator, and delete_iterator</tt>.  Therefore, your SQL statement
  will not get executed until the first call to operator++ if it contains only parameters. If your BCA and BPA have at least one
  bound column (i.e. BoundIO["ColumnName"] == row.ColumnName) then operator++ will use SQLFetch() logic.  
  This matches the behavior given by <tt>select_iterator</tt> which means the SQL statement will get executed
  only once when the iterator is initialized and subseqent calls to operator++ will read additional values through
  the use of SQLFetch(). (If your SQL statement exposes multiple result sets these may be retrieved through the use of the
  MoreResults() function described below).
  <p>Because <tt>sql_iterator</tt> 
  can run against arbitrary SQL statements it must distinguish what kinds of parameters are being bound.  The three possible
  types of parameters are INPUT, OUTPUT and INPUT/OUTPUT. To make this distinction, <tt>sql_iterator</tt> introduces
  directional binding syntax for its parameters.</p>
<p>Each possible form of information flow between <font face="Courier New, Courier, mono" size="2">boundIO</font> 
  and <font size="2" face="Courier New, Courier, mono">DataObj/ParamObj</font> 
  corresponds to whether the parameter passed in to the query is an input, 
  output, or input/output parameter. The user must be able to define 
  the direction of information flow for parameters in cases such as stored procedure 
  calls. The new binding syntax DTL provides shows the flow of information very 
  clearly:</p>
<table width="75%" border="1">
  <tr> 
    <td width="43%"><b>Expressions</b></td>
    <td width="15%"><b>Parameter Type</b></td>
    <td width="42%"><b>Description</b></td>
  </tr>
  <tr> 
    <td width="43%"> 
      <p><font face="Courier New, Courier, mono" size="2">boundIOs[colName] &lt;&lt; 
        dataObj.member</font></p>
      <p><font face="Courier New, Courier, mono" size="2">boundIOs[paramNum] &lt;&lt; 
        paramObj.member </font></p>
    </td>
    <td width="15%">INPUT</td>
    <td width="42%">The <font face="Courier New, Courier, mono" size="2">DataObj/ParamObj 
      </font>member supplies data needed by the SQL query.</td>
  </tr>
  <tr> 
    <td width="43%"> 
      <p><font face="Courier New, Courier, mono" size="2">boundIOs[colName] &gt;&gt; 
        dataObj.member</font></p>
      <p><font face="Courier New, Courier, mono" size="2">boundIOs[paramNum] &gt;&gt; 
        paramObj.member </font></p>
    </td>
    <td width="15%">OUTPUT</td>
    <td width="42%">The<font face="Courier New, Courier, mono" size="2"> DataObj/ParamObj</font> 
      member receives data back from the SQL query.</td>
  </tr>
  <tr> 
    <td width="43%" height="86"> 
      <p><font face="Courier New, Courier, mono" size="2">boundIOs[colName] == 
        dataObj.member</font></p>
      <p><font face="Courier New, Courier, mono" size="2">boundIOs[paramNum] == 
        paramObj.member </font></p>
    </td>
    <td width="15%" height="86">INPUT/OUTPUT</td>
    <td width="42%" height="86">The <font face="Courier New, Courier, mono" size="2">DataObj/ParamObj</font> 
      member both supplies data to and receives back data from the SQL query.</td>
  </tr>
</table>
<p>You should always use this new syntax with any BCA's and BPA's you define. 
  To maintain backwards compatibility with BCA's and BPA's for <font face="Courier New, Courier, mono" size="2">select_iterator's, 
  insert_iterator's, delete_iterator's, <font face="Times New Roman, Times, serif" size="3">and</font> 
  update_iterator's, <font face="Times New Roman, Times, serif" size="3">the use 
  of </font><font face="Courier New, Courier, mono" size="2">&quot;boundIOs[colName] 
  == dataObj.member&quot;</font> <font face="Times New Roman, Times, serif" size="3">and</font> 
  &quot;boundIOs[paramNum] == paramObj.member&quot; <font face="Times New Roman, Times, serif" size="3">is 
  still legal. The direction of information flow can be inferred from the type 
  of iterator used in those cases. However, the directional syntax is mandatory 
  for <font face="Courier New, Courier, mono" size="2">sql_iterators <font face="Times New Roman, Times, serif" size="3">as 
  no information flow semantics can be inferred from a general SQL query. Examples 
  in this documentation may use both forms of syntax where legal.</font></font></font></font></p>
 

<h3>Definition</h3>

<p>Defined in the <font size="2" face="Courier New">sql_iterator.h </font>header 
  file. </p>

<h3>Examples:</h3>

<h3>Example: Selecting records from a view using a sql_iterator</h3>
<pre><code>
<span class="codeComment">// Define an object to hold our row data -- used for joined table examples</span>
class JoinExample
{
public:                    // tablename.columnname:
 int exampleInt;           // DB_EXAMPLE.INT_VALUE
 string exampleStr;        // DB_EXAMPLE.STRING_VALUE
 double exampleDouble;     // DB_EXAMPLE.DOUBLE_VALUE
 unsigned long sampleLong; // DB_SAMPLE.SAMPLE_LONG
 double extraDouble;       // DB_SAMPLE.EXTRA_FLOAT
};

<span class="codeComment">// Here we define a custom parameter object for use with our JoinExample </span>
class JoinParamObj
{
public:
 int intValue;
 string strValue;
 int sampleInt;
 string sampleStr;
};

<span class="codeComment">// BCA for JoinExample ... needed to store bindings between
// query fields and members in JoinExample objects</span>
class BCAJoinExample
{
public:
 void operator()(BoundIOs &amp;cols, JoinExample &amp;row)
 {
  cols["INT_VALUE"]    &gt;&gt; row.exampleInt;
  cols["STRING_VALUE"] &gt;&gt; row.exampleStr;
  cols["DOUBLE_VALUE"] &gt;&gt; row.exampleDouble;
  cols["SAMPLE_LONG"]  &gt;&gt; row.sampleLong;
  cols["EXTRA_FLOAT"]  &gt;&gt; row.extraDouble;
 }
};

<span class="codeComment">// BPA for JoinParamObj ... set SQL Query parameters from object</span>
class BPAJoinParamObj
{
public:
 void operator()(BoundIOs &amp;params, JoinParamObj &amp;paramObj)
 {
  params[0] &lt;&lt; paramObj.intValue;
  params[1] &lt;&lt; paramObj.strValue;
  params[2] &lt;&lt; paramObj.sampleInt;
  params[3] &lt;&lt; paramObj.sampleStr;
 }
};

<span class="codeComment">// Read JoinExample objects from the database using a query that
// joins the DB_EXAMPLE and DB_SAMPLE tables</span>
vector<joinexample> ReadJoinedData()
{
 vector<joinexample> results;

 <span class="codeComment">// construct view
 // note here that we use a custom parameter class for JoinExample
 // rather than DefaultParamObj<JoinExample></span>

 DBView&lt;JoinExample, ParamObj&gt; view("SELECT INT_VALUE, STRING_VALUE, DOUBLE_VALUE, "
    "SAMPLE_LONG, EXTRA_FLOAT FROM DB_EXAMPLE, DB_SAMPLE WHERE (INT_VALUE = (?) AND STRING_VALUE = (?)) AND "
    "(SAMPLE_INT = (?) OR SAMPLE_STR = (?)) "
    "ORDER BY SAMPLE_LONG", BCAJoinExample(), "",
    BPAJoinParamObj());


 <span class="codeComment">// loop through query results and add them to our vector</span>
 DBView&lt;JoinExample, JoinParamObj&gt;::sql_iterator read_it  = view.begin();

 <span class="codeComment">// assign paramteter values as represented by the (?) placeholders
 // in the where clause for our view</span>
 read_it.Params().intValue = 3;
 read_it.Params().strValue = "Join Example";
 read_it.Params().sampleInt = 1;
 read_it.Params().sampleStr = "Joined Tables";

 for ( ; read_it != view.end(); ++read_it)
 { 
  results.push_back(*read_it);
 }

 return results;
}
</code></pre>
</h3>
 
<h3><font face="Times New Roman, Times, serif">Example: Reading a set of records
 from an Oracle stored procedure.</font><br>
  </h3>
<pre><code>
<span class="codeComment">// Oracle stored procedure we wish to test</span>
<span class="codeComment">// for more information on this example, see the following <a href="OracleResultSets.htm">Oracle documentation</a></span>
#if 0
 Create or replace package ExampleInfo as

   Type ExampleRec is record

   (
   INT_VALUE     integer,

   STRING_VALUE   varchar2(50)

   );

   Type ExampleCursor is ref cursor return 

   ExampleRec;

   End ExampleInfo;

   

   Create or replace procedure ExampleInfoProc

   (LONG_CRITERIA IN integer, empcursor IN OUT 

   ExampleInfo.ExampleCursor)

   As

   Begin

   Open empcursor For

   select INT_VALUE, STRING_VALUE 

   from db_example

   where EXAMPLE_LONG = LONG_CRITERIA;

   End;
#endif

class ProcBCA {
public:
 void operator()(BoundIOs &amp;cols, variant_row &amp;row)
 {
  cols["INT_VALUE"] &gt;&gt; row._int();
  cols["STRING_VALUE"] &gt;&gt; row._string();
  
  cols.BindVariantRow(row);
 }
};

class ProcParams {
public:
	long long_criteria;
};

class ProcBPA {
public:
 void operator()(BoundIOs &amp;cols, ProcParams &amp;row)
 {
  cols[0] &lt;&lt; row.long_criteria;
 }
};

<span class="codeComment">// Read the contents of a table and print the resulting rows
// *** you must have Oracle ODBC driver version 8.1.5.3.0 for this to work ***
// The reason why is that the stored procedure shown above returns a "cursor"
// to pass back multiple rows which is only supported in Oracle ODBC driver
// version 8.1.5.3.0 or higher.  (Merant drivers for Oracle also support this syntax.)</span>
void StoredProcReadData() {

        <span class="codeComment">// Note: ExampleInfoProc takes an integer as an input parameter to determine
        // what records to return, and returns a cursor to a set of rows as an
        // output parameter. The output cursor is bound implicitly as a set of columns.</span>
	DBView&lt;variant_row, ProcParams&gt; view("{call ExampleInfoProc(?)}", 
		ProcBCA(), "", ProcBPA());

	variant_row s(view.GetDataObj());

	<span class="codeComment">// Print out the column names</span>
	vector&lt;string&gt; colNames = s.GetNames();
	for (vector&lt;string&gt;::iterator name_it = colNames.begin(); name_it != colNames.end(); ++name_it)
		cout &lt;&lt; (*name_it) &lt;&lt; " ";
	cout &lt;&lt; endl;

	<span class="codeComment">// Print out all rows and columns from our query</span>
	DBView&lt;variant_row, ProcParams&gt;::sql_iterator print_it = view.begin();
	print_it.Params().long_criteria = 22;

	for (; print_it != view.end(); ++print_it)
	{
		 variant_row r = *print_it;
		 for (size_t i = 0; i < r.size(); ++i)
		 	cout &lt;&lt; r[i] &lt;&lt; " ";
		 cout &lt;&lt; endl;
	}
}

</code></pre>
 
<h3><font face="Times New Roman, Times, serif">Example: A count query using 
  a stored procedure.  This illustrates the use of input and output parameters.</font><br>
 </h3>
<pre><code>class EmptyDataObj
{

};

class ProcOutBCA
{
public:
   void operator()(BoundIOs &amp;boundIOs, EmptyDataObj &amp;rowbuf)
   {

   }
};

class ProcOutParams {
public:
	long long_criteria;
	int numRecords;
	
	friend ostream &operator<<(ostream &amp;o, const ProcOutParams &amp;params)
	{
       cout &lt;&lt; "ProcOutParams(" &lt;&lt; params.long_criteria &lt;&lt; ", " &lt;&lt; params.numRecords &lt;&lt; ")";
	   return o;
	}
};

class ProcOutBPA {
public:
 void operator()(BoundIOs &amp;cols, ProcOutParams &amp;params)
 {
  cols[0] &lt;&lt; params.long_criteria;
  cols[1] &gt;&gt; params.numRecords;
 }
};

<span class="codeComment">// Oracle stored procedure we wish to test</span>
#if 0
   Create or replace procedure ExampleInfoProcOutParams

   (LONG_CRITERIA IN integer, NUM_RECORDS OUT integer)

   As
  
   Begin

   select count(*)

   into NUM_RECORDS

   from db_example

   where EXAMPLE_LONG = LONG_CRITERIA;

   End;
#endif

<span class="codeComment">// simply does a select count(*) from db_example where example_long = 22</span>
void StoredProcCountRecords() {

	DBView&lt;EmptyDataObj, ProcOutParams&gt; view("{call ExampleInfoProcOutParams(?, ?)}", 
		ProcOutBCA(), "", ProcOutBPA());

	<span class="codeComment">// execute our stored procedure</span>
	DBView&lt;EmptyDataObj, ProcOutParams&gt;::sql_iterator print_it = view.begin();

	print_it.Params().long_criteria = 22;

	*print_it = EmptyDataObj(); <span class="codeComment">// force the statement to execute </span>
    ++print_it;

	cout &lt;&lt; "number of records with EXAMPLE_LONG = 22 is " 
		 &lt;&lt; print_it.Params().numRecords &lt;&lt; endl;
}

</code></pre>
<h3>Example: Use of MoreResults() with a stored procedure</h3>
<pre><code>
<span class="codeComment">// *** Note: This example is specific to SQL Server ***</span>
<span class="codeComment">// for more information on processing return values from
// SQL Server stored procedures, see this <a href="http://msdn.microsoft.com/library/psdk/sql/ht_odbcht10_7183.htm">documentation</a></span>

<span class="codeComment">// stored procedure being called in this example
#if 0
DROP PROCEDURE TestParm 

-- Example procedure returns three things:
-- 1. A set of records from the select statement: "SELECT STRING_VALUE FROM DB_EXAMPLE"
-- After all records have been retrieved, output paramenters are returned:
-- 2. OutParm
-- 3. Return value for function
CREATE PROCEDURE TestParm @OutParm int OUTPUT AS
SELECT STRING_VALUE FROM db_example
SELECT @OutParm = 66
RETURN 99


DECLARE @RetVal INT

DECLARE @Param INT

  

-- Execute the procedure, which returns

-- the result set from the first SELECT.

EXEC @RetVal = TestParm @OutParm = @Param OUTPUT

  

-- Use the return code and output parameter.

PRINT 'The return value from the procedure was: ' +

                 CONVERT(CHAR(6), @RetVal)

PRINT 'The value of the output parameter in the procedure was: ' +

                 CONVERT(CHAR(6), @Param)

#endif
</span>

class TestParmBCA {
public:
 void operator()(BoundIOs &amp;cols, variant_row &amp;row)
 {
  cols["STRING_VALUE"] == row._string();
  cols[0] &gt;&gt; row._int();
  cols[1] &gt;&gt; row._int();

  cols.BindVariantRow(row);
 }
};

<span class="codeComment">// Read the contents of a table and print the resulting rows</span>
void StoredProcReadTestParm() {

 DBView&lt;variant_row&gt; view("{? = call TestParm(?)}",
  TestParmBCA());

<span class="codeComment">
 // NOTE: We need to construct r from the view itself since we
 // don't know what fields the table will contain.
 // We therefore make a call to the DataObj() function to have the
 // table return us a template row with the correct number of fields
 // and field types.
 // We use this construction since we can't be guaranteed that the table
 // is non-empty & we want to still display column names in this case.
</span>
 variant_row s(view.GetDataObj());

 <span class="codeComment">// Print out the column names</span>
 vector&lt;string&gt; colNames = s.GetNames();
 for (vector&lt;string&gt;::iterator name_it = colNames.begin(); name_it !=
      colNames.end(); ++name_it)
        cout << (*name_it) << " ";
 cout &lt;&lt; endl;

 <span class="codeComment">// Print out all rows and columns from our query</span>
 DBView&lt;variant_row&gt;::sql_iterator print_it = view;

<span class="codeComment">
 // By default DTL uses server side cursors for SQL Server so that more than
 // one iterator can be active at a time.  This is set in the constructor
 // for DBStmt.
 // Here we require a client side cursor because our stored procedure returns
 // multiple result sets.  Therfore we clear out the setting to use server
 // side cursors in which case SQL server will default to a client side cursor.
 // For details on server side versus client side cursors
 // see <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/oledbsql/9_ole_07_212r.asp">Rowsets and SQL Server Cursors</a>
 </span>
 print_it.GetStmt().ClearStmtAttrs();

 variant_row r = view.GetDataObj();
 r[0] = 0;
 r[1] = 0;

 for (++print_it; print_it != view.end(); ++print_it)
 {
  r = *print_it;
  for (size_t i = 0; i &lt; r.size(); ++i)
    cout &lt;&lt; r[i] &lt;&lt; " ";
  cout &lt;&lt; endl;
 }

 cout &lt;&lt; endl;
 cout &lt;&lt; "After call to MoreResults(), "
  "SQL-Server gives results in output parameters & return code." << endl;
 print_it.MoreResults();
 r = *print_it;
 for (size_t i = 0; i &lt; r.size(); ++i)
    cout &lt;&lt; r[i] &lt;&lt; " ";
 cout &lt;&lt; endl;

}
</code></pre>
 
<h3>Template parameters</h3>

<table border="2">
    <tr>
        <th>Parameter </th>
        <th>Description </th>
        <th>Default </th>
    </tr>
    <tr>
        <td valign="top"><tt>DataObj</tt> </td>
        <td valign="top">The type of object that will be written
        to the <font size="2" face="Courier New">DBView</font>.
        This object will be bound through use of the <a
        href="BCA.htm"><font size="1" face="Courier New">BCA</font></a><font
        size="2"> </font>to the appropriate columns in the
        database. The set of value types of an <tt>DBView::insert_iterator</tt>
        consists of a single type, <font size="2"
        face="Courier New">DataObj</font>. </td>
        <td valign="top">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top"><tt>ParamObj</tt> </td>
        <td valign="top">The type of object that will be used to
        specify the postfix parameters to the <font size="2"
        face="Courier New">DBView</font>.</td>
        <td valign="top"><font size="2" face="Courier New">DefaultParamObj&lt;DataObj&gt;</font>&nbsp;
        </td>
    </tr>
</table>

<h3>Model of</h3>

<p><a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, 
  <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. 
</p>

<h3>Type requirements</h3>

<p><font size="2" face="Courier New">DataObj </font>and <font
size="2" face="Courier New">ParamObj</font> must each fulfill the
following requirements:. </p>

<ul>
    <li>Be of a type that is not primitive or of type <font
        size="2" face="Courier New">string</font><font size="2">.</font></li>
    <li><font size="3">Have a publicly accessible copy
        constructor (the default is OK).</font></li>
    <li><font size="3">Have a publicly accessible assignment
        operator (the default is OK).</font></li>
</ul>

<h3>Public base classes</h3>

<p><font size="2" face="Courier New">DB_iterator&lt;DataObj,
ParamObj&gt;, iterator&lt;input_iterator_tag, DataObj&gt;</font></p>

<h3>Members</h3>

<table border="2">
  <tr> 
    <th>Member </th>
    <th>Where defined </th>
    <th>Description </th>
  </tr>
  <tr> 
    <td valign="top"><tt>DBView::sql_iterator()</tt> </td>
    <td valign="top"><tt>sql_iterator</tt> </td>
    <td valign="top"><font size="3">Default constructor.</font></td>
  </tr>
  <tr> 
    <td valign="top"><tt>DBView::sql_iterator(DBView&lt;DataObj, ParamObj&gt; 
      &amp;view, bool bPrepare = true)</tt> </td>
    <td valign="top"><tt>sql_iterator</tt> </td>
    <td valign="top"><font size="3">See below.</font></td>
  </tr>
  <tr> 
    <td valign="top"><tt>DBView::sql_iterator(DBView&lt;DataObj, ParamObj&gt;::select_iterator&amp;)</tt> 
    </td>
    <td valign="top"><tt>sql_iterator</tt> </td>
    <td valign="top">See below.<tt><font size="3"><font face="Times New Roman, Times, serif"></font></font></tt></td>
  </tr>
  <tr> 
    <td valign="top"><tt>DBView::sql_iterator()</tt> </td>
    <td valign="top"><tt>sql_iterator</tt> </td>
    <td valign="top"><font size="3">Default constructor.</font></td>
  </tr>
  <tr> 
    <td valign="top"><tt>DBView::sql_iterator(const DBView::sql_iterator&amp;)</tt> 
    </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> 
    </td>
    <td valign="top">The copy constructor. <font size="3">See Note </font><a href="#2"><font size="3">[2]</font></a><font
        size="3">.</font></td>
  </tr>
  <tr> 
    <td valign="top"><tt>DBView::sql_iterator&amp; operator=(const DBView sql_iterator&amp;)</tt> 
    </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> 
    </td>
    <td valign="top">The assignment operator </td>
  </tr>
  <tr> 
    <td valign="top"><font face="Courier New, Courier, mono" size="2">DBView::sql_iterator 
      &operator*()</font></td>
    <td valign="top"> 
      <p><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, 
        <a
        href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> 
      </p>
      </td>
    <td valign="top">Proxy operators necessary to emulate <font
        size="2" face="Courier New">*it = data.</font> Return <font
        size="2" face="Courier New">*this</font><font size="3">. </font></td>
  </tr>
  <tr> 
    <td valign="top"><tt> operator DataObj()</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/OutputIterator.html">Input Iterator</a></td>
    <td valign="top">Conversion operator necessary to emulate <font face="Courier New, Courier, mono" size="2">data 
      = *it</font>. Note that if you need to access a field of <font face="Courier New, Courier, mono" size="2">*it</font>, 
      you must either assign the result to a<font face="Courier New, Courier, mono" size="2"> 
      DataObj</font> or use a <font face="Courier New, Courier, mono" size="2">static_cast&lt;DataObj&gt;(*it)</font>. 
      Or better yet, use <font size="2" face="Courier New, Courier, mono">operator-&gt;()</font>. 
      Only should get used as an input operation.</td>
  </tr>
  <tr>
    <td valign="top"><tt>DBView::sql_iterator&amp; operator=(const DataObj &amp;dataObj)</tt> 
    </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a></td>
    <td valign="top">Proxy operators necessary to emulate <font
        size="2" face="Courier New">*it = data.</font> Return <font
        size="2" face="Courier New">*this</font><font size="3">. Executes the 
      query with the <font size="2"
        face="Courier New">DataObj </font><font size="3">to the </font><font
        size="2" face="Courier New">DBView. </font><font size="3">Note that this 
      version is only used in output operations. See Note </font><a href="#1"><font size="3">[1]</font></a><font
        size="3">.</font></font></td>
  </tr>
  <tr> 
    <td valign="top"><tt>CountedPtr&lt;DataObj&gt; operator-&gt;()</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> 
    </td>
    <td valign="top">Dereferencing operator. Returns a pointer to the <font size="2" face="Courier New, Courier, mono">DataObj</font><font size="1" face="Courier New"> 
      </font><font
        size="3">read from the </font><font size="2"
        face="Courier New">DBView</font><font size="3">.</font></td>
  </tr>
  <tr> 
    <td valign="top"><tt>DBView::sql_iterator&amp; operator++()</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, 
      <a
        href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> 
    </td>
    <td valign="top">Preincrement. Reads an <font size="2"
        face="Courier New">DataObj </font><font size="3">from the </font><font
        size="2" face="Courier New">DBView </font><font size="3">if an input operation. 
      Return <font face="Courier New, Courier, mono" size="2">*this.</font> See 
      Note </font><a href="#1"><font size="3">[1]</font></a><font
        size="3">.</font></td>
  </tr>
  <tr> 
    <td valign="top"><tt>DataObjPtr DBView::sql_iterator operator++(int)</tt> 
    </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, 
      <a
        href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> 
    </td>
    <td valign="top">Postincrement Reads an <font size="2"
        face="Courier New">DataObj </font><font size="3">from the </font><font
        size="2" face="Courier New">DBView </font><font size="3">if an input operation. 
      Returns a proxy in order to remember the <font face="Courier New, Courier, mono" size="2">DataObj</font> 
      for future dereference operations in the same expression. See Note </font><a href="#1"><font size="3">[1]</font></a><font
        size="3">.</font></td>
  </tr>
  <tr> 
    <td valign="top"><tt>friend bool operator==(const select_iterator &amp;i1, 
      const select_iterator &amp;i2)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a></td>
    <td valign="top">Returns whether the two iterators are equal, that is, do 
      they refer to the same<font size="2"
        face="Courier New"> DataObj</font>?</td>
  </tr>
  <tr> 
    <td valign="top"><tt>friend bool operator!=(const select_iterator &amp;i1, 
      const select_iterator &amp;i2)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a></td>
    <td valign="top"> 
      <p>Returns whether the two iterators are <strong>not </strong>equal. Equivalent 
        to <font size="2"
        face="Courier New">!(i1 == i2).</font></p>
    </td>
  </tr>
  <tr> 
    <td valign="top"><tt>bool MoreResults()</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a></td>
    <td valign="top">See below.<font size="2"
        face="Courier New"></font></td>
  </tr>
  <tr> 
    <td valign="top"><tt>void swap(DBView::sql_iterator &amp;other)</tt></td>
    <td valign="top"><tt>sql_iterator</tt></td>
    <td valign="top">See below.</td>
  </tr>
</table>

<h3>New members</h3>

<p>These members are not defined in the <a
        href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> 
  or <a
href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> requirements 
  or in <font size="2" face="Courier New">DB_iterator&lt;DataObj, ParamObj&gt;</font>, 
  but are specific to <tt>DBView::sql_iterator</tt>. 
<table border="2">
  <tr> 
    <th>Function </th>
    <th>Description </th>
  </tr>
  <tr> 
    <td valign="top"><tt>DBView::sql_iterator(DBView&lt;DataObj, ParamObj&gt; 
      &amp;view, bool bPrepare = true)</tt> </td>
    <td valign="top">Creates an <font size="2"
        face="Courier New">sql_iterator </font><font size="3">which refers to</font><font size="2" face="Courier New"> 
      view</font><font
        size="1" face="Courier New">.</font><font
        face="Courier New"><font face="Times New Roman, Times, serif">Set</font></font><font size="2"
        face="Courier New"> bPrepare <font face="Times New Roman, Times, serif" size="3">to</font> 
      true </font><font size="3">if you want the iterator to use <font face="Courier New, Courier, mono" size="2">SQLPrepare()</font> 
      and <font face="Courier New, Courier, mono" size="2">SQLExecute()</font> 
      in the event you are executing the statement many times. Otherwise, the 
      iterator will use <font size="2" face="Courier New, Courier, mono">SQLExecDirect()</font>.</font> 
      <font size="3">See Note </font><a href="#2"><font size="3">[2]</font></a><font
        size="3">.</font></td>
  </tr>
  <tr> 
    <td valign="top"><tt>DBView::sql_iterator(DBView&lt;DataObj, ParamObj&gt;::select_iterator&amp;)</tt> 
    </td>
    <td valign="top">Constructs a <tt>sql_iterator</tt> from the s<tt>elect_iterator 
      <font size="3"> <font face="Times New Roman, Times, serif">passed in. This 
      new iterator will behave like a s<tt>elect_iterator</tt></font></font></tt>.</td>
  </tr>
  <tr> 
    <td valign="top"><tt>void swap(DBView::sql_iterator &amp;other)</tt></td>
    <td valign="top">Swap <font size="2" face="Courier New">*this</font> with 
      <font size="2">other</font>.</td>
  </tr>
  <td valign="top"><tt>bool MoreResults()</tt></td>
    <td valign="top">Gets the next result set if any. Returns true if another 
      result set is available, false otherwise. This is primarly useful if the 
      SQL string contains multiple SELECT statements or if the SQL string calls 
      a stored procedure that returns multiple result sets. For details, see the 
      example above and the <a href="http://msdn.microsoft.com/library/psdk/dasdk/odch9mk3.htm">SQLMoreResults()</a> 
      statement in the ODBC documentation.</td>
  </tr>
</table>

<h3>Notes</h3>

<p><a name="1"></a>[1] <font face="Courier New, Courier, mono" size="2">operator++() 
  </font> actually reads the <font size="2" face="Courier New">DataObj </font><font
size="3">from database via the </font><font size="2"
face="Courier New">DBView <font face="Times New Roman, Times, serif" size="3">if 
  the iterator is performing an input operation</font></font><font size="3">. 
  However, if the iterator is outputting to the database, it actually writes to 
  the database on <font face="Courier New, Courier, mono" size="2">operator=()</font>. 
  Note that previous versions of DTL performed their output operations to the 
  DB on <font size="2" face="Courier New, Courier, mono">operator++()</font>. 
  Each </font><font
size="2" face="Courier New">DBView::sql_iterator</font><font
size="1" face="Courier New"> </font><font size="3">internally owns a </font><font size="2" face="Courier New">DBStmt</font><font
size="3"> object which is allocated and prepared when the underlying ODBC statement 
  handle is first needed and not before. The handle is not opened until absolutely 
  needed in order to make copying and assigning these iterators an inexpensive 
  operation.</font></p>
<font
size="3">

<p><a name="2"></a>[2] There is also a variant of this
constructor which takes a second argument specifying a dummy
whether the iterator is at the beginning or end of the <font
size="2" face="Courier New">DBView</font><font size="2">. </font><font
size="3">It is used internally and should never be called by the
end user.</font></p>


<h3>See also</h3>

<p><a href="db_iterator.htm"><font size="2" face="Courier New">DB_iterator</font></a>,
<a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output
Iterator</a>, <a
href="http://www.sgi.com/tech/stl/InputIterator.html">Input
Iterator</a>.<br>
<br>
</p>


<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright © 2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body></font></html>
