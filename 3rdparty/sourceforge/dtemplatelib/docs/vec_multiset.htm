<html>
 

<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>vec_multiset&lt;Key, Pred, A, Container&gt;</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p> 
<h1>vec_multiset&lt;Key, Pred, A, Container&gt;</h1>



















<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td><img src="containers.gif" width="194" height="38"></td>
        <td align="right"><img src="type.gif" width="194"
        height="39"></td>
    </tr>
    <tr>
        <td valign="top"><b>Category</b>: containers</td>
        <td align="right" valign="top"><b>Component type</b>:
        type</td>
    </tr>
</table>
<h3>Description</h3>
<h4>Rationale</h4>

<p>The <font size="2" face="Courier New">vec_multiset</font> is an STL compatible 
  container that emulates a <font size="2" face="Courier New, Courier, mono">std::multiset</font> 
  using a sorted <font size="2" face="Courier New, Courier, mono">std::vector. 
  </font>This container works best when you have a setup phase where you are inserting 
  elements followed by a lookup phase with few insertions or deletions. The rationale 
  for this container is that it can provide much better performance than a <font size="2" face="Courier New, Courier, mono">std::multiset</font> 
  in terms of both memory and speed.</p>
<h4>When should you use <font face="Courier New, Courier, mono">vec_multiset</font>?</h4>
<p>1. If you insert many elements without any lookups in a &quot;setup&quot; phase 
  followed by a &quot;lookup&quot; phase where you search for elements in the 
  container with few changes to the container. <font size="2" face="Courier New, Courier, mono">Vec_multiset 
  </font>is optimized for this case in terms of performance and memory usage. 
  <i><b>Sorted containers are often used in a very regular fashion: population 
  before lookup.</b></i></p>
<p>2. Hashed containers are not suitable for your application because you need 
  guaranteed worst case lookup time, or you are unwilling to have the memory overhead 
  associated with a <font size="2" face="Courier New, Courier, mono">std::hash_set</font>.</p>
<h4>When should you NOT use <font face="Courier New, Courier, mono">vec_multiset</font>?</h4>
<p>1. If exception safety is an issue, you are better off with <font face="Courier New, Courier, mono" size="2">std::multiset</font>. 
  <font face="Courier New, Courier, mono"> <font size="2">Vec_multiset</font></font> 
  is only exception-safe for POD's.</p>
<p>2. If you intermix insertions/erasures and lookups arbitrarily. <font size="2" face="Courier New, Courier, mono">Std::multiset</font> 
  handles this case better than <font size="2" face="Courier New, Courier, mono">vec_multiset</font>. 
</p>
<p>3. If you need pointer or reference validity throughout the lifetime of the 
  container, use <font size="2" face="Courier New, Courier, mono">std::multiset</font>. 
  <font size="2" face="Courier New, Courier, mono">Vec_multiset</font>'s underlying 
  container can shift the data elements around in memory. However, if you write 
  your code in a more modern fashion to use iterators rather than pointers, you 
  can still use <font size="2" face="Courier New, Courier, mono">vec_multiset</font>.</p>
<p>4. Iterators for <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
  are not guaranteed to be valid until after the first lookup into the container. 
  So, if you need to capture iterators during the setup phase of the container 
  (i.e. iterators returned by insert() before the container has been sorted) you 
  must use <font size="2" face="Courier New, Courier, mono">std::multiset</font>. 
  If you only need iterators to<font face="Courier New, Courier, mono" size="2"> 
  begin() </font>or <font size="2" face="Courier New, Courier, mono">end()</font>, 
  you can still use <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
  as those operations will trigger a sort on the container.</p>
<h3></h3>
<h4>Performance of <font face="Courier New, Courier, mono">vec_multiset</font> 
  vs. <font size="2" face="Courier New, Courier, mono">std::multiset</font></h4>
<p>Many applications use <font size="2" face="Courier New, Courier, mono">std::multiset</font> 
  by first inserting elements into the container, then performing lookups in that 
  container. This is the behavior that<font size="2" face="Courier New, Courier, mono"> 
  vec_multiset</font> is optimized to handle. The designers of <font size="2" face="Courier New, Courier, mono">std::multiset 
  </font>designed their container to handle generic sequences of inserts, erases, 
  and lookups in an arbitrary order. Thus, they used a tree for all operations. 
  The tree design carries with it much memory overhead resulting in poor memory 
  contiguity and lookups that are much slower than can be achieved by a <font size="2" face="Courier New, Courier, mono">std::vector</font>. 
</p>
<p><font size="2" face="Courier New, Courier, mono">Vec_multiset </font>makes 
  some assumptions which allow it to perform its job in an efficient manner. <font size="2" face="Courier New, Courier, mono">Vec_multiset</font> 
  assumes that the user will first populate the container and then perform lookups, 
  it doesn't have to keep the elements sorted until lookup time. <font size="2" face="Courier New, Courier, mono">Vec_multiset</font> 
  can perform inserts in amortized constant time because it just pushes the item 
  onto the end of the underlying container. Furthermore, <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
  can store its elements contiguously in memory. Lookups occur in logarithmic 
  time because the STL algorithms invoked by the<font size="2" face="Courier New, Courier, mono"> 
  vec_multiset </font>use binary searches, but without the memory thrashing that 
  <font size="2" face="Courier New, Courier, mono">std::multiset</font> can suffer 
  from. After the first lookup operation, <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
  will insert any additional elements into the proper place in the underlying 
  vector to keep the container sorted, which takes linear time. These additional 
  inserts after the first lookup are slow, but that is OK as we expect very few 
  insertions into the container once we begin lookups into the <font size="2" face="Courier New, Courier, mono">vec_multiset</font>. 
  Similarly, erasures from a <font size="2" face="Courier New, Courier, mono">vec_multiset 
  </font>occur in linear time, but again, we don't expect many calls to <font size="2" face="Courier New, Courier, mono">vec_multiset::erase() 
  </font>once the vector is sorted.</p>
<p>The following performance results (times listed in seconds) compare the performance 
  of <font size="2" face="Courier New, Courier, mono">vec_multiset&lt;int&gt;</font> 
  with <font size="2" face="Courier New, Courier, mono">std::multiset&lt;int&gt;</font> 
  in the case of 6,000,000 inserts followed by 6,000,000 calls to the member <font size="2" face="Courier New, Courier, mono">find()</font> 
  function on each container. To make an equal playing field in the timing data 
  for insertion, the time to sort the underlying vector (which occurs right before 
  the first lookup) is included in the totals. Note that the <font size="2" face="Courier New, Courier, mono">std::stable_sort() 
  </font>used to implement the sorting in vec_multiset should occur in linear 
  time. The table below presents the test results for different ratios of lookups 
  to inserts. We ran these tests in Debug build in Microsoft Visual C++ v 6.0 
  SP 5 using STLPort 4.0. We used the optimizations of 'Maximize Speed' and 'Any 
  Suitable' inlining. We also compare against STLPort 4.0's<font size="2" face="Courier New, Courier, mono"> 
  hash_multiset&lt;int&gt;</font> container. The tests performed the same number 
  of lookups as inserts and the actual times recorded in those runs appear in 
  the 1:1 row of the table. We then extrapolated the results in the other rows 
  (2:1, 3:1, 4:1, and 5:1) by multiplying the lookup times by the appropriate 
  factor and adding these totals to the insertion times for our runs. .</p>
<table width="75%" border="1">
  <tr> 
    <td>ratio of lookups to inserts</td>
    <td>multiset inserts</td>
    <td> 
      <p>vec_multiset inserts</p>
    </td>
    <td>hash_multiset inserts</td>
    <td>multiset lookups</td>
    <td>vec_multiset lookups</td>
    <td>hash_multiset lookups</td>
    <td>multiset total</td>
    <td>vec_multiset total</td>
    <td>hash_multiset total</td>
  </tr>
  <tr> 
    <td>1:1</td>
    <td>15</td>
    <td>6</td>
    <td>4</td>
    <td>2</td>
    <td>2</td>
    <td>1</td>
    <td>17</td>
    <td>8</td>
    <td>5</td>
  </tr>
  <tr> 
    <td>2:1</td>
    <td>15</td>
    <td>6</td>
    <td>4</td>
    <td>4</td>
    <td>4</td>
    <td>2</td>
    <td>19</td>
    <td>10</td>
    <td>6</td>
  </tr>
  <tr> 
    <td>3:1</td>
    <td>15</td>
    <td>6</td>
    <td>4</td>
    <td>6</td>
    <td>6</td>
    <td>3</td>
    <td>21</td>
    <td>12</td>
    <td>7</td>
  </tr>
  <tr> 
    <td>4:1</td>
    <td>15</td>
    <td>6</td>
    <td>4</td>
    <td>8</td>
    <td>8</td>
    <td>4</td>
    <td>23</td>
    <td>14</td>
    <td>8</td>
  </tr>
  <tr> 
    <td>5:1</td>
    <td>15</td>
    <td>6</td>
    <td>4</td>
    <td>10</td>
    <td>10</td>
    <td>5</td>
    <td>25</td>
    <td>16</td>
    <td>9</td>
  </tr>
</table>
<p> <font face="Courier New, Courier, mono"> <font size="2">Vec_multiset </font></font>still 
  can't beat a hashed container with a good hashing function as the numbers for<font size="2" face="Courier New, Courier, mono"> 
  hash_multiset</font> prove. The numbers above indicate that <font size="2" face="Courier New, Courier, mono">vec_multiset 
  </font>is a significant improvement over<font size="2" face="Courier New, Courier, mono"> 
  std::multiset</font> for insertions. <font size="2" face="Courier New, Courier, mono">Vec_multiset</font>'s 
  usual case of constant time insertion beats the logarithmic time of <font size="2" face="Courier New, Courier, mono">std::multiset</font>'s 
  corresponding calls.<font face="Courier New, Courier, mono" size="2"> Vec_multiset</font> 
  matches the good logarithmic performance of lookup calls in <font size="2" face="Courier New, Courier, mono">std::multiset</font>. 
  We were surprised that the <font size="2" face="Courier New, Courier, mono">std::multiset</font> 
  lookups did not suffer from the performance penalty expected from memory thrashing. 
  The<font size="2" face="Courier New, Courier, mono"> vec_multiset </font>matches 
  the ideal performance that would be achieved by manually using a <font size="2" face="Courier New, Courier, mono">std::vector</font> 
  and the appropriate algorithm calls on it (<font size="2" face="Courier New, Courier, mono">std::stable_sort()</font>, 
  <font face="Courier New, Courier, mono"> <font size="2">std::lower_bound()</font></font>, 
  and friends).</p>
<h4><b>Implementation of <font face="Courier New, Courier, mono">vec_multiset</font></b></h4>
<p>The container takes advantage of the assumption that first the user populates 
  the container, and then perform lookups in it. When the user is populating the 
  container, the <font size="2" face="Courier New, Courier, mono">vec_multiset 
  </font>simply tacks newly inserted elements onto the end of the container. The 
  first time the user invokes a lookup method on the container (also including 
  <font size="2" face="Courier New, Courier, mono">vec_multiset::begin()</font> 
  and <font size="2" face="Courier New, Courier, mono">vec_multiset::end()</font>), 
  the container sorts itself. The lookup operations simply call the appropriate 
  STL algorithms, passing the predicate function through along with the <font size="2" face="Courier New, Courier, mono">begin()</font> 
  and <font size="2" face="Courier New, Courier, mono">end()</font> iterators 
  of the underlying vector which actually holds the elements. The user may still 
  insert or erase elements after the first lookup, but now the container inserts 
  any new items into their proper sorted positions.</p>
<p><font size="2" face="Courier New, Courier, mono">Vec_multiset </font>provides 
  iterators that are always valid unless:</p>
<p>1. The container hasn't been sorted yet. This happens as the sort will rearrange 
  the items in the container through a call to<font size="2" face="Courier New, Courier, mono"> 
  std::stable_sort()</font>, which is oblivious to the structure of <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
  or its iterators.</p>
<p>or</p>
<p>2. The element pointed to has been removed from the container. This is true 
  for iterators of the standard STL containers, including <font size="2" face="Courier New, Courier, mono">std::multiset</font>.</p>
<p>To accomplish this, a <font size="2" face="Courier New, Courier, mono">vec_multiset::iterator</font> 
  stores the index of the element within the <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
  it belongs to (actually in its underlying container), rather than a raw pointer 
  to the element. The iterator thus doesn't care about actual memory addresses 
  of the elements, which is especially important when the<font face="Courier New, Courier, mono" size="2"> 
  vec_multiset</font>'s underlying container shifts elements to a new block of 
  memory due to getting full. However, elements in the underlying vector get shifted 
  on insertions and deletions from the container. The index of the element an 
  iterator refers to thus may change during one of these operations. The <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
  keeps a log of all insertions and erasures that are performed on it after the 
  container is sorted so that iterators may use this information to properly update 
  their indices (or invalidate themselves if the element referred to was erased).</p>
<h4>Memory usage vs. <font face="Courier New, Courier, mono">std::multiset</font></h4>
<p>For the following discussion, assume that a pointer takes 4 bytes of memory 
  and we're basing our data here on Microsoft Visual C++ 6.0 SP5's implementation 
  of <font size="2" face="Courier New, Courier, mono">std::vector </font>and <font face="Courier New, Courier, mono" size="2">std::multiset</font>. 
  We also ignore the comparison function and allocator members. We specifically 
  compare a <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
  whose underlying container is a <font size="2" face="Courier New, Courier, mono">std::vector</font>.</p>
<p>In general, <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
  incurs less memory overhead than <font size="2" face="Courier New, Courier, mono">std::multiset</font>. 
  <font face="Courier New, Courier, mono"> <font size="2">Std::multiset</font></font> 
  contains the red-black tree which holds the data elements as a member. In turn, 
  the tree holds a pointer to its root. The overhead for this pointer is thus 
  4 bytes.. The per-element overhead for<font size="2" face="Courier New, Courier, mono"> 
  std::multiset</font> is whatever the overhead for a single tree node is. A tree 
  node contains pointers to the left, right, and parent nodes of the element as 
  well as the color flag (red or black). Thus, we have a total of 16 bytes overhead 
  per element in the <font size="2" face="Courier New, Courier, mono">std::multiset</font> 
  assuming the color flag takes up 4 bytes (enums are 4 bytes in Visual C++).</p>
<p><i><b>Thus, the total overhead for <font size="2" face="Courier New, Courier, mono">std::multiset</font> 
  = 4 bytes for the pointer to the tree root + 16 bytes * number of elements in 
  the container.</b></i></p>
<p><font size="2" face="Courier New, Courier, mono">Vec_multiset</font> is forgiving 
  in its use of memory. The total overhead is that of the change log (a <font size="2" face="Courier New, Courier, mono">std::vector&lt;iter_change&gt;</font> 
  recording insertions/erasures after the first lookup into the vec_multiset), 
  the overhead of the underlying <font size="2" face="Courier New, Courier, mono">std::vector</font> 
  which contains the data stored in the <font size="2" face="Courier New, Courier, mono">vec_multiset</font>, 
  and the memory taken up by a flag indicating whether the underlying vector's 
  data is sorted or not (a<font size="2" face="Courier New, Courier, mono"> bool</font>, 
  which in Visual C++ is 1 byte).</p>
<p>As both the change log and elements contained in a <font size="2" face="Courier New, Courier, mono">vec_multiset 
  </font>are stored in an underlying <font size="2" face="Courier New, Courier, mono">std::vector</font>, 
  first we need to compute the overhead for the <font size="2" face="Courier New, Courier, mono">std::vector</font> 
  template. A <font size="2" face="Courier New, Courier, mono">std::vector</font> 
  contains three iterators, which are implemented as pointers, referring to the 
  begin, end, and last (end of storage) elements in the underlying array, taking 
  up 12 bytes total. As the elements are stored in the underlying array, there 
  is no per-element overhead.</p>
<p>The overhead for the change log will thus be 12 bytes plus the number of elements 
  in the change log which should be relatively small as long as the <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
  is used as intended (few inserts/erasures after first lookup). Next we need 
  to know the size of an element in the change log. Each entry in the change log 
  contains an enum indicating whether the change was an insertion or an erasure, 
  the index where the insertion/erasure is occurring (of type <font size="2" face="Courier New, Courier, mono">size_t</font>, 
  4 bytes in Visual C++), and the number of elements inserted/erased during this 
  operation (of type <font face="Courier New, Courier, mono" size="2">size_t</font>). 
  Thus, each log entry takes up 4 bytes for the insert/erase flag + 4 bytes for 
  the insert/erase index + 4 bytes for the value indicating number elements inserted 
  = 12 bytes.</p>
<p>Therefore, the overhead due to the change log = 12 bytes for std::vector overhead 
  + 12 bytes * number of insertions and erasures after first lookup</p>
<p>The overhead for the underlying data vector = 12 bytes.</p>
<p>Thus, the total overhead for <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
  =12 bytes for the change log vector's overhead itself + 12 bytes * number of 
  insertions and erasures after first lookup * sizeof(iter_change) + 12 bytes 
  for the <font size="2" face="Courier New, Courier, mono">std::vector</font> 
  which contains the data elements + 1 byte for the sorted flag</p>
<p>Combining like terms:</p>
<p><i><b>Total overhead for<font size="2" face="Courier New, Courier, mono"> vec_multiset 
  </font>= 25 bytes + 12 bytes * number of insertions and erasures after first 
  lookup.</b></i></p>
<p>Comparing the results shows that in general, <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
  incurs far less memory overhead than<font size="2" face="Courier New, Courier, mono"> 
  std::multiset </font>if very few insertions and erasures are done after the 
  first lookup (remember, that's the intended case for <font size="2" face="Courier New, Courier, mono">vec_multiset</font>!). 
  Especially note that there is absolutely no per-element overhead for a <font size="2" face="Courier New, Courier, mono">vec_multiset</font>, 
  which is a major plus! Compare that with the overhead of 16 bytes per element 
  in <font size="2" face="Courier New, Courier, mono">std::multiset</font>.</p>
<h4>Iterator Stability</h4>
<pre><font face="Times New Roman, Times, serif" size="3">We could have used two different methods to achieve iterator stability
with</font> vec_multiset:

<font face="Times New Roman, Times, serif" size="3">1.  A method David Abrahams proposes for iterator stability
(<font size="2" face="Courier New, Courier, mono">indirect_container</font> and <font size="2" face="Courier New, Courier, mono">indirect_iterator</font> .. storing a
container of iterators to the data elements).  This
means that the user has to populate a data container
such as a <font face="Courier New, Courier, mono" size="2">std::vector&lt;T&gt;</font> and then create some other
container whose elements actually refer to elements in
that first data vector, such as a
<font size="2" face="Courier New, Courier, mono">std::set&lt;T&gt;::iterator</font>.  This method is a lean
and mean way to get iterator (or pointer) stability. 
However, it comes at at possible cost of a loss of
memory contiguity (depending on the allocator) which
can slow down memory accesses and also extra address
arithmetic the machine must perform. 

2.  Our method references the data elements directly. 
<font size="2" face="Courier New, Courier, mono">Vec_multiset&lt;T&gt;</font> internally stores an underlying
<font size="2" face="Courier New, Courier, mono">std::vector&lt;T&gt;<t></font> which actually contains the data.  The
<font size="2" face="Courier New, Courier, mono">vec_multiset&lt;T&gt;::iterator</font> stores several simple pieces
of information:
* a pointer to the<font size="2" face="Courier New, Courier, mono"> vec_multiset</font> that it is referring to
* the index of the element in the <font size="2" face="Courier New, Courier, mono">vec_multiset</font>'s
underlying vector<t>
* an int that tells where to look in the referred to
container's change log of inserts/erasures after the
first lookup in the container so the iterator may
update its position and thus maintain iterator
stability.

This method guarantees both iterator stability and
contiguity of memory at very little expense.  The key
here is that there are no address computations
necessary each time elements are compared vs. the
indirect_iterator method which must dereference an
iterator/pointer.

We believed that the direct storing of the vector data
would be much more efficient rather than the
<font size="2" face="Courier New, Courier, mono">indirect_container</font> approach.

So we performed a benchmark test to compare the two
methods.

For this test, we used a sample of 15,000,000 <font size="2" face="Courier New, Courier, mono">int</font>s and
used a <font size="2" face="Courier New, Courier, mono">std::vector&lt;int&gt;</font><int> as our base container for the
<font size="2" face="Courier New, Courier, mono">indirect_iterator</font>-like simulation to eliminate
contiguity as a factor.

For the direct storing method (the method we used to
implement <font size="2" face="Courier New, Courier, mono">vec_multiset</font>), we did the following:

1. Inserted the<font face="Courier New, Courier, mono" size="2"> int</font>s into the vector using
<font size="2" face="Courier New, Courier, mono">std::vector&lt;int&gt;::push_back()</font>.
2. Called<font size="2" face="Courier New, Courier, mono"> std::stable_sort() </font>from <font size="2" face="Courier New, Courier, mono">begin()</font> to <font size="2" face="Courier New, Courier, mono">end()</font> on
the vector
3. Did 15,000,000 <font size="2" face="Courier New, Courier, mono">std::lower_bound()</font> calls on the
<font size="2" face="Courier New, Courier, mono">begin()</font> to <font face="Courier New, Courier, mono" size="2">end()</font> range to locate a number.  

We timed each step and then added the results together
to get the overall total for this method.

To simulate the <font size="2" face="Courier New, Courier, mono">indirect_container</font> method, we had to:

1. Populate a <font face="Courier New, Courier, mono" size="2">std::vector&lt;int&gt;</font> with the 15,000,000 elements
using <font size="2" face="Courier New, Courier, mono">std::vector&lt;int&gt;::push_back()</font>.
2. For each element <font size="2" face="Courier New, Courier, mono">vec[i]</font> in the vector vec, we
inserted <font size="2" face="Courier New, Courier, mono">&vec[i]</font> into a <font size="2" face="Courier New, Courier, mono">vector&lt;int *&gt;</font> called <font size="2" face="Courier New, Courier, mono">pvec</font>.
3. Call <font size="2" face="Courier New, Courier, mono">std::stable_sort(pvec.begin(), pvec.end(), 
IntStarLess())</font> where <font size="2" face="Courier New, Courier, mono">IntStarLess::operator()(pInt1,
pInt2)</font> is true iff <font face="Courier New, Courier, mono" size="2">*p1 &lt; *p2</font>.
4. Perform 15,000,000 <font size="2" face="Courier New, Courier, mono">std::lower_bound()</font> calls over the
<font size="2" face="Courier New, Courier, mono">pvec.begin()</font> to <font size="2" face="Courier New, Courier, mono">pvec.end()</font> range with an IntStarLess
as the predicate.

Again, we timed each step and summed the results
together for the overall time.

We performed the same operations using each method
using the same data set and calls to
<font size="2" face="Courier New, Courier, mono">std::lower_bound()</font>.

The results we got back were astonishing which
confirmed our reasoning:

<font size="2" face="Courier New, Courier, mono">---- vector&lt;int&gt; ----
vec.push_back(): 26
stable_sort(vec.begin(), vec.end()): 20
lower_bound(): 6
*** Total time for vector&lt;int&gt; impl.: 52 ***

---- vector<int *>&lt;int *&gt; ----
vec_ptrs.push_back(): 8
stable_sort(vec_ptrs.begin(), vec_ptrs.end()): 55
lower_bound(): 44
Subtotal time for vector&lt;int *&gt; ops: 107
(but we're not done as we must add in the vector&lt;int *&gt;
push_back time of: 26)
*** Total time for vector&lt;int *&gt; impl.: 133 ***</font>

As you can see, the <font size="2" face="Courier New, Courier, mono">std::stable_sort()</font> and
<font size="2" face="Courier New, Courier, mono">std::lower_bound()</font> calls for the direct approach
easily outperformed the corresponding calls for the
<font size="2" face="Courier New, Courier, mono">indirect_iterator</font> simulation.  Also, there is the
additional overhaead in the indirect method of having
to <font size="2" face="Courier New, Courier, mono">push_back</font> the objects onto the data vector even
before it starts working with the pointers.

The performance test proved that the direct approach
we used for <font size="2" face="Courier New, Courier, mono">vec_multiset</font> is much faster and more
efficient than the use of creatures like
<font size="2" face="Courier New, Courier, mono">indirect_iterator</font>.

Caveats to these results:
1. With larger objects, the <font size="2" face="Courier New, Courier, mono">indirect_iterator</font> method
probably would perform much faster as the sort only
swaps pointers.  The direct storing method's sort call
actually has to swap the objects themselves, which can
definitely be much more expensive. In the case of our
example above this penalty does not appear since ints
are small.

2. As Dave Abrahams pointed out, if your container
holds something like<font face="Courier New, Courier, mono" size="2"> std::string</font> objects, then holding a
vector of pointers (e.g. <font size="2" face="Courier New, Courier, mono">std::string *</font>) may not lose you
much anyway since the underlying objects are in fact
holding the data via pointers.</font>
</pre>
<h3>Example </h3>
 
<pre>
using namespace std;


int main()
{
  vec_multiset&lt;int&gt; vms;
  <span class="codeComment">
  // &quot;setup&quot; phase ... populate our container
  </span>
  vms.insert(23);
  vms.insert(94);
  vms.insert(76);
  vms.insert(10);
  vms.insert(91);
  vms.insert(12);
  vms.insert(76);
  
  <span class="codeComment">// more inserts here
  // ...
   
  // &quot;lookup&quot; phase ... use our container to find different elements

  // print out container elements ... they'll appear in sorted order
  </span>
  cout &lt;&lt; &quot;Container elements: &quot; &lt;&lt; endl;

  copy(vms.begin(), vms.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;));
  cout &lt;&lt; endl;

  if (vms.find(12) != vms.end())<br>	cout &lt;&lt; &quot;Found element with value 12&quot; &lt;&lt; endl;
  else
    cout &lt;&lt; &quot;Could not find element with value 12&quot; &lt;&lt; endl;

  pair&lt;vec_multiset&lt;int&gt;::iterator, vec_multiset&lt;int&gt;::iterator&gt; pr =
	vms.equal_range(76);

  cout &lt;&lt; &quot;Elements with value 76: &quot; &lt;&lt; endl;
  copy(pr.first, pr.second, ostream_iterator&lt;int&gt;(cout, &quot; &quot;));

  cout &lt;&lt; endl;
  <span class="codeComment">
  // more lookups here, possibly calls to vms.lower_bound(), vms.count(), etc.
  </span>      
  return 0;  
}

</pre>
<h3>Definition</h3>

<p>Defined in the <font size="2" face="Courier New">vec_multiset.h </font><font size="3">header 
  file.</font></p>

<h3>Model of</h3>

<p><a
href="http://www.sgi.com/tech/stl/MultipleSortedAssociativeContainer.html">Multiple 
  Sorted Associative Container</a>, <a
href="http://www.sgi.com/tech/stl/SimpleAssociativeContainer.html">Simple Associative Container</a></p>

<h3>Associated types</h3>

<p>Those defined by <a
href="http://www.sgi.com/tech/stl/MultipleSortedAssociativeContainer.html">Multiple 
  Sorted Associative Container</a> and <a
href="http://www.sgi.com/tech/stl/SimpleAssociativeContainer.html">Simple Associative Container</a>.</p>
<h3>Public Base Classes</h3>

<p>None.</p>

<h3>Template parameters</h3>

<table border="1">
  <tr> 
    <th>Parameter </th>
    <th>Description </th>
    <th>Default </th>
  </tr>
  <tr> 
    <td valign="top"><font size="2" face="Courier New, Courier, mono">Key</font></td>
    <td valign="top">The type of elements within the<font size="2" face="Courier New, Courier, mono"> 
      vec_multiset</font>.</td>
    <td valign="top">&nbsp; </td>
  </tr>
  <tr> 
    <td valign="top"><font size="2" face="Courier New, Courier, mono">Pred</font></td>
    <td valign="top">The key comparison function, a <a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">Strict 
      Weak Ordering</a> whose argument type is<font face="Courier New, Courier, mono" size="2"> 
      key_type</font>; it returns <font size="2" face="Courier New, Courier, mono">true 
      </font>if its first argument is less than its second argument, and <font face="Courier New, Courier, mono" size="2">false 
      </font>otherwise. This is also defined as <font size="2" face="Courier New, Courier, mono">vec_multiset::key_compare 
      </font>and <font face="Courier New, Courier, mono" size="2">vec_multiset::value_compare</font>.</td>
    <td valign="top"><font face="Courier New, Courier, mono" size="2">std::less&lt;Key&gt; 
      &gt;</font></td>
  </tr>
  <tr> 
    <td valign="top"><font face="Courier New, Courier, mono" size="2">A</font></td>
    <td valign="top"> 
      <p>The allocator used by the container.<font face="Courier New, Courier, mono" size="2"></font></p>
    </td>
    <td valign="top"> 
      <p><font face="Courier New, Courier, mono" size="2">std::allocator&lt;Key&gt; 
        &gt; </font></p>
    </td>
  </tr>
  <tr>
    <td valign="top"><font size="2" face="Courier New, Courier, mono">Container</font></td>
    <td valign="top">The underlying container used by the <font size="2" face="Courier New, Courier, mono">vec_multiset</font> 
      <font face="Times New Roman, Times, serif">to actually hold the elements.</font> 
    </td>
    <td valign="top"><font size="2" face="Courier New, Courier, mono">std::vector&lt;Key, 
      A&gt; </font></td>
  </tr>
</table>

<p>&nbsp;</p>

<h3>Members and Usage</h3>

<p>Identical to those declared for<font face="Courier New, Courier, mono" size="2"> 
  <a href="http://www.sgi.com/tech/stl/multiset.html"> std::multiset</a></font>.</p>

<h3>See also</h3>

<p><a
href="http://www.sgi.com/tech/stl/MultipleSortedAssociativeContainer.html">Multiple 
  Sorted Associative Container</a>, <a
href="http://www.sgi.com/tech/stl/SimpleAssociativeContainer.html">Simple Associative Container</a>.</p>
<h3>Bibliography</h3>
<p>The idea for this container came from concepts discussed in:</p>
<p>Meyers, Scott. <i>Effective STL</i>, Item 23, pp. 100-106. Addison-Wesley, 
  Boston: 2001.</p>
<p> <!--start footer--> </p>

<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright © 2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body></html>