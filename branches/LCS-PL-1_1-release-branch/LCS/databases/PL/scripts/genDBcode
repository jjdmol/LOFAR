#!/usr/bin/ksh
#
# genDBcode: Generate the glue layer between your appl. and the PL layer
#
# Copyright (C) 2003-2004
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Generates DTL code for storing/saving an object to a database
# Uses a .map file to lookup the references and a .fun file
# for looking up the routines that should be generated
#
# Syntax: genDBcode [-d destdir] [-S] [-f] P mapfile [class]
# or
# Syntax: genDBcode [-d destdir] [-f] R mapfile functionfile [class]
#
# $Id$
#
VERSION="v2.9"
DEBUGMODE=false

#
# RECaddBCA class
#
# Add code that constructs a BCA class for the DTL layer.
#
RECaddBCA()
{
	Class=$1
	
	echo "// The ${Class}_BCA structure 'binds' the database columns"
	echo "// to the members of the ${Class} class."
	echo "class ${Class}_BCA {"
	echo "public:"
	echo "	void operator()(dtl::BoundIOs& cols, ${Class}& rowbuf) {"
	# get all 'basic' members of the class
	grep ^$Class ${MAPWRKFILE} | grep "!!" | while read line
	do
		ColName=`echo $line | cut -d"!" -f6`
		DBRepMember=`echo $line | cut -d"!" -f4 | sed "s/[\.:]/_/g"`
		echo "		cols[\"${ColName}\"]	== rowbuf.${DBRepMember};"
	done
	echo "	}"
	echo "};\n"
}

#
# RECaddFunctionPrototype class functname action clause-length
#
# Add the prototype of a function
#
RECaddFunctionPrototype()
{
 	Class=$1
	Function=$2
	Action=$3
	ClauseLen=$4

	case ${Action} in
	I|D) echo "void ${FunctName}(const ${Class}&	theRecord);"	;;
	U)   if [ "${ClauseLen}" == "0" ]; then
			echo "void ${FunctName}(const ${Class}&	theRecord);"
		 else
			echo "void ${FunctName}(const ${Class}&	theRecord, const std::string whereClause);"
		 fi
		 ;;
	S)   if [ "${ClauseLen}" == "0" ]; then
			echo "vector< ${Class} > ${FunctName}();"
		 else
			echo "vector< ${Class} > ${FunctName}(const std::string whereClause);"
		 fi
		 ;;
	esac
}

#
# RECaddInsertRoutine class functionname
#
# Add code that will insert the current object in the database.
#
RECaddInsertRoutine()
{
	Class=$1
	FunctName=$2
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d"!" -f2`

	echo "//"
	echo "// Routine for insert this ${Class} object in the database."
	echo "//"
	echo "void ${FunctName}(const ${Class}&	insRec) {"
	echo "	DBView< ${Class} >	insView(\"${Table}\", ${Class}_BCA());"
	echo "	DBView< ${Class} >::insert_iterator	insIter = insView;\n"

	echo "	*insIter = insRec;"
	echo "}\n"
}

#
# RECaddDeleteRoutine class functionname clause
#
# Add code that will delete the current object from the database
#
RECaddDeleteRoutine()
{
	Class=$1
	FunctName=$2
	Clause=`echo $3 | cut -d"#" -f1`
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d"!" -f2`

	echo "//"
	echo "// Routine for deleting this ${Class} object from the database."
	echo "//"
	echo "void ${FunctName}(const ${Class}&	delRec) {"
	echo "	DBView< ${Class} >	delView(\"${Table}\", ${Class}_BCA());"
	echo "	DBView< ${Class} >::delete_iterator	delIter = delView;\n"
	echo "	${Class}		delCondition;"
	echo ""
	echo "	delCondition = delRec;		// @@@ Modify to meet your requirements!"
	echo ""
	echo "	*delIter = delCondition;"
	echo "}\n"
}

#
# RECaddSearchRoutine class functionname clause
#
# Add code for a search routine. 
RECaddSearchRoutine()
{
	Class=$1
	FunctName=$2
	Clause=`echo $3 | cut -d"#" -f1`
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d"!" -f2`

	# When the user did not specify a where-clause in the functionfile a function
	# with a where-clause parameter is created.
	if [ ${#Clause} == 0 ]; then
		echo "vector< ${Class} > ${FunctName}(string whereClause) {"
		echo "	vector< ${Class} > 		results;"
		echo "	DBView< ${Class} >			view(\"${Table}\", ${Class}_BCA(),"
		echo "								whereClause);"
	else
		echo "vector< ${Class} > ${FunctName}() {"
		echo "	vector< ${Class} > 		results;"
		echo "	DBView< ${Class} >			view(\"${Table}\", ${Class}_BCA(),"
		echo "								\"${Clause}\");"
	fi
	echo "	DBView< ${Class} >::select_iterator	readIter = view.begin();\n"
	echo "	for ( ; readIter != view.end(); ++readIter) {"
	echo "		results.push_back(*readIter);"
	echo "	}"
	echo "	return results;"
	echo "}\n"
}

#
# RECaddUpdateRoutine class functionname clause
#
# Add code to update an object to the database.
#
RECaddUpdateRoutine()
{
	Class=$1
	FunctName=$2
	Clause=`echo $3 | cut -d"#" -f1`
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d"!" -f2`

	echo "//"
	echo "// Routine for updating this ${Class} object in the database."
	echo "//"
	# When the user did not specify a where-clause in the functionfile a function
	# with a where-clause parameter is created.
	if [ ${#Clause} == 0 ]; then
		echo "void ${FunctName}(const ${Class}&	theRecord, string whereClause) {"
		echo "	DBView< ${Class} >			view(\"${Table}\", ${Class}_BCA(),"
		echo "								whereClause);"
	else
		echo "void ${FunctName}(const ${Class}&	theRecord) {"
		echo "	DBView< ${Class} >			view(\"${Table}\", ${Class}_BCA(),"
		echo "								\"${Clause}\");"
	fi
	echo "	DBView< ${Class} >::update_iterator	updIter = view;"
	echo ""
	echo "	// update the database"
	echo "	*updIter=theRecord;"
	echo "}\n"
}

#---------------------- Persistency layer routines ----------------------------
#
# TPOaddDTLstruct class
#
TPOaddDTLstruct()
{
	Class=$1
	
	echo ""
	echo "// The DBRep< ${Class} > structure is a contigious representation of"
	echo "// all fields that should be stored to the database"

	# define a struct with the PO fields and the DataObj fields
	echo "template <>"
	echo "struct DBRep< ${Class} > {"
	
	# every structs needs a bindCols functor.
	echo "	void bindCols(dtl::BoundIOs& cols);"

	# add all 'basic' members of the DataObj
	grep ^$Class ${MAPWRKFILE} | grep "!!" | while read line
	do
		MemType=`echo $line | cut -d"!" -f3`
		DBRepMember=`echo $line | cut -d"!" -f${SYMBNAMEFLD} | sed "s/[\.:]/_/g"`
		echo "	${MemType}			${DBRepMember};"
	done

	echo "};"
	echo ""
}

#
# TPOaddBCA class
#
TPOaddBCA()
{
	Class=$1
	
	echo "// bindCols() 'binds' the database columns represented by a cols"
	echo "// to the members of the DBRep< ${Class} > class."
	echo "void DBRep< ${Class} >::bindCols(dtl::BoundIOs& cols) {"

	# add all 'basic' members of the class
	grep ^$Class ${MAPWRKFILE} | grep "!!" | while read line
	do
		ColName=`echo $line | cut -d"!" -f6`
		DBRepMember=`echo $line | cut -d"!" -f${SYMBNAMEFLD} | sed "s/[\.:]/_/g"`
		echo "	cols[\"${ColName}\"]	== ${DBRepMember};"
	done

	echo "}"
	echo ""
}

#
# TPOaddToDatabaseRep class 
#
# Adds code that copies the values from the real data-objects and the
# persistency object to a local DBRep<xxx> class.
#
TPOaddToDatabaseRep() 
{
	Class=$1

	echo ""
	echo "// toDBRep copies the fields of the ${Class} class to the"
	echo "// DBRep< ${Class} > structure"
	echo "void TPersistentObject< ${Class} >::toDBRep(DBRep< ${Class} >& dest) const"
	echo "{"

	# add all 'basic' members of the Dataobj
	grep ^$Class ${MAPWRKFILE} | grep "!!" | while read line
	do
		Member=`echo $line | cut -d"!" -f4`
		DBRepMember=`echo $line | cut -d"!" -f${SYMBNAMEFLD} | sed "s/[\.:]/_/g"`
		echo "	dest.${DBRepMember}	= data().${Member};"
	done
	echo "}\n"
}

#
# TPOaddFromDatabaseRep class
#
# Adds code that copies the values from the local DBRep<xxx> class to the
# real data-objects and the persistency object.
#
TPOaddFromDatabaseRep() 
{
	Class=$1
	Action=$2

	echo ""
	echo "// fromDBRep copies the fields of the DBRep< ${Class} > structure"
	echo "// to the ${Class} class."
	echo "void TPersistentObject< ${Class} >::fromDBRep(const DBRep< ${Class} >& src)"
	echo "{"

	# add all 'basic' members of the Dataobj
	grep ^$Class ${MAPWRKFILE} | grep "!!" | while read line
	do
		Member=`echo $line | cut -d"!" -f4`
		DBRepMember=`echo $line | cut -d"!" -f${SYMBNAMEFLD} | sed "s/[\.:]/_/g"`
		echo "	data().${Member}	= src.${DBRepMember};"
	done
	echo "}\n"
}

#
# TPOaddInitRoutine class
#
# Adds code that initializes the internals of a TPersistentObject
#
TPOaddInitRoutine() 
{
	Class=$1
	Action=$2

	echo ""
	echo "// Initialize the internals of TPersistentObject< ${Class} >"
	echo "void TPersistentObject< ${Class} >::init()"
	echo "{"

	# generate initialization code for all classes and base classes.
	grep ^$Class ${MAPWRKFILE} | grep -v "!!" | while read line
	do
		RelClass=`echo $line | cut -d'!' -f3`
		Member=`echo $line | cut -d'!' -f4`
		Relation=`echo $line | cut -d'!' -f6`

		echo "	{"
		echo "	// create new TPersistentObject for ${Relation} ${RelClass}"
		if [ "${Relation}" == "BaseClass" ]; then
			echo "	Pointer p(new TPersistentObject< ${RelClass} >(data()));"
		else
			echo "	Pointer p(new TPersistentObject< ${RelClass} >(data().${Member}));"
		fi
		echo "	// associate ${RelClass}'s owner object-id with ${Class}'s objectid"
		echo "	p->metaData().ownerOid() = metaData().oid();"
		echo "	// add newly created TPersistentObject to container of ownedPOs."
		echo "	ownedPOs().push_back(p);"
		echo "	}"
	done

	grep ^$Class ${MAPWRKFILE} | head -1 | read line
	Table=`echo $line | cut -d'!' -f2`
	echo "	// set the correct database table name"
	echo "	tableName(\"${Table}\");"
	echo "}"
	echo ""
}

#
# TPOaddAttributemap class
#
# Adds code that copies initializes the attribute map from TPO<x>
#
TPOaddAttributemap() 
{
	Class=$1

	echo ""
	echo "// Initialize the attribute map for TPersistenObject< ${Class} >"
	echo "template<>"
	echo "void TPersistentObject< ${Class} >::initAttribMap()"
	echo "{"

	# add all 'basic' members of the Dataobj
	grep ^$Class ${MAPWRKFILE} | grep "!!" | while read line
	do
		Member=`echo $line | cut -d"!" -f${SYMBNAMEFLD}`
		Colname=`echo $line | cut -d"!" -f6`
		echo "	theirAttribMap[\"${Member}\"]	= \"${Colname}\";"
	done

	# add code for all classes and base classes.
	grep ^$Class ${MAPWRKFILE} | grep -v "!!" | while read line
	do
		Member=`echo $line | cut -d"!" -f${SYMBNAMEFLD}`
		RelType=`echo $line | cut -d"!" -f6`
		if [ "${UseSymbNames}" == "true" ]; then
			SubClass=`echo $line | cut -d'!' -f3`
		else
			SubClass=${Member}
		fi
		if [ "${RelType}" == "BaseClass" ]; then
			echo "	theirAttribMap[\"${SubClass}::\"]	="
			echo "		\"@\" + string(typeid(TPersistentObject< ${SubClass} >).name());"
		else
			echo "	theirAttribMap[\"${Member}\"]	="
			echo "		\"@\" + string(typeid(TPersistentObject< ${SubClass} >).name());"
		fi
	done
	echo "}\n"
}

#---------------------------- Global routines ---------------------------------
#
# initTmpfile
#
# Writes an informational header to the tempfile in case the file was not
# removed by this script.
#
initTmpfile()
{
	echo "#This temporarely file was generated by genDBcode"
	echo "#It should have been cleaned up by genDBcode, please remove it"
	echo "#ClassName!TableName!Ctype!MemberName!SymbName!ColumnName!SubclassName!DBtype!File"
}

#
# initSrcfile filetype filename
#
# Adds an informational header to the C++ source- of headerfile.
# and includes the correct headerfiles.
#
initSrcfile()
{
	FileType=$1
	File=$2

	echo -n "//# This file was generated by genDBcode ${VERSION} on " ; date
	echo "//# with the command: ${COMMAND} ${LAYER} ${MAPFILE} ${FUNFILE} ${CLASS}"
	echo -n "//# from the directory: " ; pwd
	[ "${UseSymbNames}" != "true" ] && 
		echo "//# The code does NOT use the symbolic names from the mapfile."
	echo "//#"
	echo "//# EDITING THIS FILE MANUALLY IS AT YOUR OWN RISK"
	echo "//# IT MIGHT BE OVERWRITTEN BY THE NEXT MAKE OF YOUR PROJECT"
	echo "//#"

	# include the headerfiles in the C++ sourcefile
	if [ "${FileType}" == "cc" ]; then
		if [ "${LAYER}" == "R" ]; then
			echo "#include <dtl/DTL.h>"
			echo "#include \"${FILEPREFIX}${File}.h\""
			return
		fi

		# By combining the contents of the ClassLocationFile and the contents
		# of the MapWrkfile we can figure out which files to include.
		# First we look in the ClassLocation file which classes are defined
		# in the given File ($2), next we check for these classes in which
		# files their sub-classses are defined.

		>${INCLUDEWRKFILE}							# clear the work file
		# find the classes defined in the File ($2)
		grep "!${File}.h" ${CLASSLOCATIONWRKFILE} | while read cl_line
		do
			Class=`echo $cl_line | cut -d"!" -f1`
			# find their subclasses
			grep "^${Class}!" ${MAPWRKFILE} | grep -v "!!" | while read m_line
			do
				SubClass=`echo $m_line | cut -d'!' -f3`
				# where is this sub class located? 
				sl_line=`grep "^${SubClass}!" ${CLASSLOCATIONWRKFILE}`
				SubClassLocation=`echo $sl_line | cut -d"!" -f2`
				# user may have been messing around in the mapfile, check it
				if [ -z "${SubClassLocation}" ]; then
					Warning "//#WARNING:Definition of class ${SubClass} in unknown headerfile"
				else
					if [ "${SubClassLocation}" != "${File}.h" ]; then
						echo "#include \"${FILEPREFIX}${SubClassLocation}\"" >>${INCLUDEWRKFILE}
					fi
				fi
			done
		done
		# Finally add the found files only once
		cat ${INCLUDEWRKFILE} | sort | uniq -u
		rm ${INCLUDEWRKFILE}						# cleanup the mess

		# And include our own header file also ofcourse.
		echo "#include \"${FILEPREFIX}${File}.h\""
		if [ "${LAYER}" == "P" ]; then
			echo "#include <PL/TPersistentObject.h>"
		fi
		echo ""
	else	# its a headerfile
		TimeStamp=`date +%y%m%d%H%M%S`
		typeset -u FileLabel=${FILEPREFIX}${TimeStamp}_${File}_H
		echo "//# only include this file once"
		echo "#if !defined(${FileLabel})"
		echo "#define ${FileLabel}"
		echo ""
		echo "#include \"${File}.h\""
		if [ "${LAYER}" == "P" ]; then
			echo "#include <PL/DBRep.h>"
		else
			echo "#include <vector.h>"
		fi
		echo ""
	fi
}

#
# closeHeaderfile class
#
# write the last '#endif' to the headerfile
#
closeHeaderfile()
{
	Class=$1

	if [ "${LAYER}" == "P" ]; then
		echo "#include \"${FILEPREFIX}${Class}.tcc\"	// Include template code"
		echo ""
	fi
	echo "#endif"
}

#
# openNamespace
#
openNamespace()
{
	echo "namespace LOFAR {"
	if [ "${LAYER}" == "P" ]; then
		echo "	namespace PL {"
	else
		echo "  namespace REC {"
	fi
	echo ""
}

#
# closeNamespace
#
closeNamespace()
{
	echo ""
	if [ "${LAYER}" == "P" ]; then
		echo "	} // close namespace PL"
	else
		echo "	} // close namespace REC"
	fi
	echo "}	// close namespace LOFAR"
	echo ""
}

#
# cleanupWorkFiles
#
# Removes all temporary workfiles
#
cleanupWorkFiles()
{
	if [ "${DEBUGMODE}" != "true" ]; then
		rm -f ${MAPWRKFILE} ${ALLFILESWRKFILE} ${CLASSLOCATIONWRKFILE} \
			  ${INCLUDEWRKFILE} ${WARNINGFILE}
	else
		echo "DEBUGMODE, NOT REMOVING TEMPFILES IN /tmp"
	fi
}

#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
#
cleanlist()
{
	cut -d"#" -f1 $1 | awk '{ if (NF > 0) print $0 }'
}

#
# convertMapfile mapfile
#
# Convert the user format from the mapfile into something more convenient
# and store this in the tempfile.
#
# Allowed linesyntax of  the mapfile:
#	Class	<ClassName>
#	Table	<TableName>
#	File	<Filename>
#	<Ctype>	<MemberName> <Symb.Name> <ColumnName> <DBtype>
#	<Ctype>	<MemberName> <Symb.Name> Class		  <ClassName>
#	<Ctype>	<MemberName> <Symb.Name> BaseClass	  <ClassName>
#
# Syntax of the constructed temp-file:
# ClassName!TableName!Ctype!MemberName!SymbName!ColumnName!SubclassName!DBtype!File
#
# ATTENTION: The are some issues to remind:
#	Ctype      may be of the form xxx:yyy (like std::string)
#	MemberName may be of the form X::y or X.y when the user merged some 
#			   tables manually
#
# NOTE: THIS ROUTINE ALSO EXISTS IN genDBsql
#
convertMapfile()
{
	Mapfile=$1

	cleanlist ${Mapfile} | while read label name symbname dbname fldtype
	do
		# comment is stripped off, check rest of line
		if [ -z "$label" -o -z "$name" ]; then		# need two fields
			continue
		fi

		case $label in
		Class|class|CLASS)				# Class keyword
			CurClass=$name
			;;
		Table|table|TABLE)				# Table keyword
			CurTable=$name
			;;
		File|file|FILE)					# File keyword
			CurFile=$name				
			# NOTE: we assume that File always comes after Class!!!
			echo "${CurClass}!${CurFile}" >> ${CLASSLOCATIONWRKFILE}
			;;
		*)								# no keyword, assume fieldname
			ctype=$label				# less confusing
			typeset -l SubClass=`echo $dbname | cut -d" " -f1`
			# what kind of field is this?
			if [ "${SubClass}" == "class" -o "${SubClass}" == "baseclass" ]; then
				# it's a (sub)class, get its name.
				SubClassName=`echo $fldtype | cut -d" " -f1`
				echo "$CurClass!$CurTable!$ctype!$name!$symbname!$dbname!$SubClassName!BIGINT!$CurFile"
			else
				echo "$CurClass!$CurTable!$ctype!$name!$symbname!$dbname!!$fldtype!$CurFile"
			fi
			;;
		esac
	done
}

#
# ControlledFilesetDeletion FileName
#
# Asks the user if the file may be removed. If not the program is terminated.
# When the FORCE option is on the file is removed without interference of the user.
# Note: this routine is slightly different from the routines in the other genDBxxx
#	scripts because it checks for 2 files, the .h and .tcc file.
ControlledFilesetDeletion()
{
	FileName=$1

	# Does file exist
	if [ ! -f "${FileName}.h" -a ! -f "${FileName}.${FILEPOSTFIX}" ]; then
		return
	fi

	# If FORCE option is off let the user decide.
	if [ "${FORCE}" != "true" ]; then
		ready=false
		while [ "$ready" == "false" ]
		do
			echo -n "Targetfile(s) ${FileName}.?? already exists, remove it (y/n)? "
			read answer
			case $answer in
			y|Y|yes|Yes)	ready=true
							;;
			n|N|no|No)		Fail "Targetfile(s) ${FileName}.?? may not be overwritten"
							;;
			esac
		done
	fi
	echo "Removing file ${FileName}.h"
	echo "Removing file ${FileName}.${FILEPOSTFIX}"
	rm -f ${FileName}.h ${FileName}.${FILEPOSTFIX}
}


# Fail msg
#
# Shows the message on stdout and exits
Fail()
{
	echo "FAIL: $*"
	cleanupWorkFiles
	exit 1
}

# Warning msg
#
# Stores the warning in the WARNINGSFILE and shows it in stdout
#
Warning()
{
	Msg=$1

	echo ${Msg} >>${WARNINGFILE}
	echo ${Msg}
}

# SyntaxError msg
#
# Shows the right syntax on stdout together with the given msg.
# Exits afterwards.
SyntaxError()
{
	Msg=$1

	[ -z "${Msg}" ] || echo "ERROR: ${Msg}"
	echo "Syntax: $(basename $0) [-d destdir] [-S] [-f] P mapfile [class]"
	echo "or"
	echo "Syntax: $(basename $0) [-d destdir] [-f] R mapfile functionfile [class]"
	echo "  -S	Do *NOT* use symbolic names in the generated code (P-layer)."
	echo "  -f	Force removal of target(s) if it already exists"
	echo ""
	exit 1
}

#------------------------------- MAIN program ---------------------------------
#
# Check invocation syntax: genDBcode [-d destdir] [-S] [-f] P mapfile [class]
# Check invocation syntax: genDBcode [-d destdir] [-f] R mapfile funfile [class]
#

# Check option argument
DESTDIR="."							# assume no destination directory
SYMBNAMEFLD=5						# assume use of symbolic names
UseSymbNames=true					# need a test later on in the code
FORCE=false							# assume the user wants to decide
COMMAND=$(basename $0)				# reconstruction of the commandline
eval set argv=`getopt "d:fS" $*`	# reformat arguments
shift
while [ "$1" != "--" ]
do
	case "$1" in
		-d)	DESTDIR=$2
			[ -d ${DESTDIR} ] || 
					SyntaxError "Destination directory >${DESTDIR}< does not exist"
			shift 2
			COMMAND="${COMMAND} -d ${DESTDIR}"
			;;
		-f)	FORCE=true
			shift 1
			COMMAND="${COMMAND} -f"
			;;
		-S)	SYMBNAMEFLD=4
			UseSymbNames=false
			echo "Generated code does NOT using symbolic names"
			shift 1
			COMMAND="${COMMAND} -S"
			;;
	esac
done
shift								# remove --

# Need at least two arguments
[ $# -ge 2 ] || SyntaxError "Need at least the layer arguments and a mapfile."

typeset -u LAYER=$1
MAPFILE=$2

# Check Layer type
case "${LAYER}" in
R)		FILEPREFIX="Rec"
		FILEPOSTFIX="cc"		;;
P)		FILEPREFIX="PO_"
		FILEPOSTFIX="tcc"		;;
*)		SyntaxError "Layer should be R(ecord) or P(ersistency), not >${LAYER}<"
esac

# Check other arguments
case $# in
	2)	if [ "${LAYER}" == "R" ]; then		# only genDBcode P mapfile is allowed
			SyntaxError "Wrong number of arguments"
		fi
		;;
	3)  if [ "${LAYER}" == "R" ]; then		# genDBcode R mapfile funfile
			FUNFILE=$3
			GREPMASK=""
			CLASS=""
		else								# genDBcode P mapfile class
			FUNFILE=""
			GREPMASK=" | grep ^$3"
			CLASS=$3
		fi
		;;
	4)  if [ "${LAYER}" == "R" ]; then		# genDBcode R mapfile funfile class
			FUNFILE=$3
			GREPMASK=" | grep ^$4"
			CLASS=$4
		else								# genDBcode P mapfile ???
			SyntaxError "Too many arguments"
		fi
		;;
	*)	SyntaxError "Wrong number of arguments"
		;;
esac

# Mapfile must exist
[ -s ${MAPFILE} ] || SyntaxError "File ${MAPFILE} doesn't exist"

# Functionfile must exist
[ "X${FUNFILE}" != "X" -a ! -s "${FUNFILE}" ] && 
									SyntaxError "File ${FUNFILE} doesn't exist"

# All arguments seem ok, continue processing
# Initialize some variables
ALLFILESWRKFILE=/tmp/created.LCS.$$				# List of all created files
CLASSLOCATIONWRKFILE=/tmp/classloc.LCS.$$		# which class is defined in which file
INCLUDEWRKFILE=/tmp/include.LCS.$$				# which hdr files to include in a src.
MAPWRKFILE=/tmp/mapinfo.LCS.$$					# converted mapfile for easy access
WARNINGFILE=/tmp/warning.LCS.$$					# contains all occured warnings

# Make sure there are no old workfiles left
cleanupWorkFiles

# Set trap handler before we create anything
trap "cleanupWorkFiles ; exit" 1 2 3 13 15

# convert the human readable format of the mapfile into something
# more convenient for shell-programming
echo "Analysing mapfile"
initTmpfile					> ${MAPWRKFILE}
convertMapfile ${MAPFILE}	>>${MAPWRKFILE}

# Now the converted mapfile exists we can check for file duplicates.
# If targets exist, let the user or the FORCE option decide what to do
# Note: we have to do this a bit clumsy because ControlledFileDeletion
#	does a 'read' and 'read's may not be nested.
echo "Checking existing targetfiles"
cleanlist ${MAPWRKFILE} | cut -d'!' -f9 | sed "s/\.h$//" >>${ALLFILESWRKFILE}
while [ -s ${ALLFILESWRKFILE} ]
do
	File=`head -1 ${ALLFILESWRKFILE}`
	ControlledFilesetDeletion ${DESTDIR}/${FILEPREFIX}${File}
	sed "1,1D" ${ALLFILESWRKFILE} >>${ALLFILESWRKFILE}2		# cut off 1st line
	mv ${ALLFILESWRKFILE}2 ${ALLFILESWRKFILE}
done

# Finally we're gonna do the real work. All duplicate files are removed and the
# user mapfile is converted into something more convenient. We use the mapfile 
# as primairy input for creating the right glue-code.
PrevClass="Unknown"
eval "cleanlist $MAPWRKFILE $GREPMASK" | \
while read line
do
	# Where is this line about?
	Class=`echo $line | cut -d'!' -f1`
	File=`echo $line | cut -d'!' -f9 | sed "s/\.h$//"`
	SOURCEFILE=${DESTDIR}/${FILEPREFIX}${File}.${FILEPOSTFIX}
	HEADERFILE=${DESTDIR}/${FILEPREFIX}${File}.h

	# Brand new file or already created?
	grep ${File} ${ALLFILESWRKFILE} >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		initSrcfile "cc"	${File}		> ${SOURCEFILE}
		openNamespace					>>${SOURCEFILE}
		initSrcfile "h"		${File} 	> ${HEADERFILE}
		openNamespace					>>${HEADERFILE}
		echo ${File}					>>${ALLFILESWRKFILE}
	fi

	if [ "${PrevClass}" != "${Class}" ]; then
		echo "Creating code for class ${Class}"
		case ${LAYER} in
		R)	RECaddBCA 				${Class}	>>${SOURCEFILE}
			# look in function file for the definitions of the functions to create.
			eval "grep \"^"${Class}"\" $FUNFILE $GREPMASK" | \
			while read class action functname clause
			do
				# dispatch the action
				typeset -u action=${action}						# to uppercase
				case $action in
				I) RECaddInsertRoutine $class $functname 			>>${SOURCEFILE}	;;
				U) RECaddUpdateRoutine $class $functname "$clause"	>>${SOURCEFILE}	;;
				D) RECaddDeleteRoutine $class $functname "$clause"	>>${SOURCEFILE}	;;
				S) RECaddSearchRoutine $class $functname "$clause"	>>${SOURCEFILE}	;;
				*) echo "ERROR:Unknown function >$action< for class >$class< in file >$FUNFILE<"
				   ;;
				esac
				RECaddFunctionPrototype $class $functname $action ${#clause} >>${HEADERFILE}
			done
			;;
		P)	TPOaddBCA 						${Class} 	>>${SOURCEFILE}
			TPOaddToDatabaseRep				${Class} 	>>${SOURCEFILE} 
			TPOaddFromDatabaseRep			${Class} 	>>${SOURCEFILE} 
			TPOaddInitRoutine				${Class} 	>>${SOURCEFILE} 
			TPOaddAttributemap				${Class} 	>>${SOURCEFILE} 
			TPOaddDTLstruct					${Class} 	>>${HEADERFILE}
			;;
		esac
		PrevClass=${Class}
	fi
done

# Finish all created .tcc files
cat ${ALLFILESWRKFILE} | while read File
do
	SOURCEFILE=${DESTDIR}/${FILEPREFIX}${File}.${FILEPOSTFIX}
	HEADERFILE=${DESTDIR}/${FILEPREFIX}${File}.h
	closeNamespace 			>>${SOURCEFILE}
	closeNamespace			>>${HEADERFILE}
	closeHeaderfile	${File}	>>${HEADERFILE}
done

[ -s "${WARNINGFILE}" ] && cat ${WARNINGFILE}

# Finally cleanup our mess
cleanupWorkFiles
