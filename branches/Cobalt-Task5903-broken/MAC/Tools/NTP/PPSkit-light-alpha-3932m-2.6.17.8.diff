: Differences between tags 'r2_6_17_8' and 'PPS_light'
: Using module 'Kernel' in CVS repository '/usr/src/repositories/LinuxCVS'
: This patch was created automatically at Mon Aug 14 21:09:30 CEST 2006
: ($Id: make-CVS-diff,v 2.4 2006/08/12 13:21:37 windl Exp $)
Index: linux/CREDITS
diff -u linux/CREDITS:1.1.1.21 linux/CREDITS:1.1.1.21.2.1
--- linux/CREDITS:1.1.1.21	Wed Aug  9 21:07:03 2006
+++ linux/CREDITS	Sat Aug 12 16:49:43 2006
@@ -3581,7 +3581,7 @@
 N: Ulrich Windl
 E: Ulrich.Windl@rz.uni-regensburg.de
 P: 1024/E843660D CF D7 43 A1 5A 49 14 25  7C 04 A0 6E 4C 3A AC 6D
-D: Supports NTP on Linux.  Added PPS code.  Fixed bugs in adjtimex().
+D: Supports NTP on Linux.  Implemented PPS API (RFC 2783).
 S: Alte Regensburger Str. 11a
 S: 93149 Nittenau
 S: Germany
Index: linux/Documentation/ioctl-number.txt
diff -u linux/Documentation/ioctl-number.txt:1.1.1.9 linux/Documentation/ioctl-number.txt:1.1.1.9.2.1
--- linux/Documentation/ioctl-number.txt:1.1.1.9	Wed Aug  9 21:08:50 2006
+++ linux/Documentation/ioctl-number.txt	Sat Aug 12 16:49:54 2006
@@ -76,7 +76,7 @@
 0x20	all	drivers/cdrom/cm206.h
 0x22	all	scsi/sg.h
 '#'	00-3F	IEEE 1394 Subsystem	Block for the entire subsystem
-'1'	00-1F	<linux/timepps.h>	PPS kit from Ulrich Windl
+'1'	00-1F	linux/timepps.h		PPS kit (PPS API) from Ulrich Windl
 					<ftp://ftp.de.kernel.org/pub/linux/daemons/ntp/PPS/>
 '8'	all				SNP8023 advanced NIC card
 					<mailto:mcr@solidum.com>
Index: linux/Documentation/magic-number.txt
diff -u linux/Documentation/magic-number.txt:1.1.1.3 linux/Documentation/magic-number.txt:1.1.1.3.4.1
--- linux/Documentation/magic-number.txt:1.1.1.3	Sun Jan 15 07:16:02 2006
+++ linux/Documentation/magic-number.txt	Sat Aug 12 16:49:54 2006
@@ -76,6 +76,7 @@
 ISICOM_MAGIC          0x4d54      isi_port          include/linux/isicom.h
 PTY_MAGIC             0x5001                        drivers/char/pty.c
 PPP_MAGIC             0x5002      ppp               include/linux/if_pppvar.h
+PPSCLOCK_MAGIC        0x5003      pps               include/linux/timepps.h
 SERIAL_MAGIC          0x5301      async_struct      include/linux/serial.h
 SSTATE_MAGIC          0x5302      serial_state      include/linux/serial.h
 SLIP_MAGIC            0x5302      slip              drivers/net/slip.h
Index: linux/arch/alpha/kernel/time.c
diff -u linux/arch/alpha/kernel/time.c:1.1.1.9 linux/arch/alpha/kernel/time.c:1.1.1.9.2.1
--- linux/arch/alpha/kernel/time.c:1.1.1.9	Wed Aug  9 21:07:36 2006
+++ linux/arch/alpha/kernel/time.c	Sat Aug 12 16:50:00 2006
@@ -384,6 +384,7 @@
 
 	xtime.tv_sec = mktime(year, mon, day, hour, min, sec);
 	xtime.tv_nsec = 0;
+	timevar_init();		/* initialize kernel time variables */
 
         wall_to_monotonic.tv_sec -= xtime.tv_sec;
         wall_to_monotonic.tv_nsec = 0;
Index: linux/arch/arm/kernel/time.c
diff -u linux/arch/arm/kernel/time.c:1.1.1.7 linux/arch/arm/kernel/time.c:1.1.1.7.2.1
--- linux/arch/arm/kernel/time.c:1.1.1.7	Wed Aug  9 21:07:21 2006
+++ linux/arch/arm/kernel/time.c	Sat Aug 12 16:50:03 2006
@@ -496,6 +496,7 @@
 
 void __init time_init(void)
 {
+	timevar_init();		/* initialize kernel time variables */
 	if (system_timer->offset == NULL)
 		system_timer->offset = dummy_gettimeoffset;
 	system_timer->init();
Index: linux/arch/arm26/kernel/time.c
diff -u linux/arch/arm26/kernel/time.c:1.1.1.1 linux/arch/arm26/kernel/time.c:1.1.1.1.4.1
--- linux/arch/arm26/kernel/time.c:1.1.1.1	Sun Jan 15 07:16:02 2006
+++ linux/arch/arm26/kernel/time.c	Sat Aug 12 16:50:13 2006
@@ -220,7 +220,7 @@
 	ioc_writeb(LATCH & 255, IOC_T0LTCHL);
         ioc_writeb(LATCH >> 8, IOC_T0LTCHH);
         ioc_writeb(0, IOC_T0GO);
-
+	timevar_init();		/* initialize kernel time variables */
 
         setup_irq(IRQ_TIMER, &timer_irq);
 }
Index: linux/arch/frv/kernel/time.c
diff -u linux/arch/frv/kernel/time.c:1.1.1.2 linux/arch/frv/kernel/time.c:1.1.1.2.2.1
--- linux/arch/frv/kernel/time.c:1.1.1.2	Wed Aug  9 21:07:24 2006
+++ linux/arch/frv/kernel/time.c	Sat Aug 12 16:50:19 2006
@@ -137,6 +137,7 @@
 		year += 100;
 	xtime.tv_sec = mktime(year, mon, day, hour, min, sec);
 	xtime.tv_nsec = 0;
+	timevar_init();		/* initialize kernel time variables */
 
 	/* install scheduling interrupt handler */
 	setup_irq(IRQ_CPU_TIMER0, &timer_irq);
Index: linux/arch/h8300/kernel/time.c
diff -u linux/arch/h8300/kernel/time.c:1.1.1.1 linux/arch/h8300/kernel/time.c:1.1.1.1.4.1
--- linux/arch/h8300/kernel/time.c:1.1.1.1	Sun Jan 15 07:16:02 2006
+++ linux/arch/h8300/kernel/time.c	Sat Aug 12 16:50:22 2006
@@ -64,6 +64,7 @@
 		year += 100;
 	xtime.tv_sec = mktime(year, mon, day, hour, min, sec);
 	xtime.tv_nsec = 0;
+	timevar_init();		/* initialize kernel time variables */
 
 	platform_timer_setup(timer_interrupt);
 }
Index: linux/arch/i386/kernel/time.c
diff -u linux/arch/i386/kernel/time.c:1.1.1.11 linux/arch/i386/kernel/time.c:1.1.1.11.2.1
--- linux/arch/i386/kernel/time.c:1.1.1.11	Wed Aug  9 21:07:25 2006
+++ linux/arch/i386/kernel/time.c	Sat Aug 12 16:50:26 2006
@@ -28,6 +28,8 @@
  * 1998-12-24 Copyright (C) 1998  Andrea Arcangeli
  *	Fixed a xtime SMP race (we need the xtime_lock rw spinlock to
  *	serialize accesses to xtime/lost_ticks).
+ * 2006-02-07	Ulrich Windl
+ *	Merged portions of PPSkit-2.1 for Linux 2.4.
  */
 
 #include <linux/errno.h>
@@ -37,7 +39,7 @@
 #include <linux/string.h>
 #include <linux/mm.h>
 #include <linux/interrupt.h>
-#include <linux/time.h>
+#include <linux/timex.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/smp.h>
@@ -126,7 +128,6 @@
 {
 	unsigned long seq;
 	unsigned long usec, sec;
-	unsigned long max_ntp_tick;
 
 	do {
 		unsigned long lost;
@@ -141,22 +142,15 @@
 		 * so make sure not to go into next possible interval.
 		 * Better to lose some accuracy than have time go backwards..
 		 */
-		if (unlikely(time_adjust < 0)) {
-			max_ntp_tick = (USEC_PER_SEC / HZ) - tickadj;
-			usec = min(usec, max_ntp_tick);
-
-			if (lost)
-				usec += lost * max_ntp_tick;
-		}
-		else if (unlikely(lost))
-			usec += lost * (USEC_PER_SEC / HZ);
+		if (unlikely(lost))
+			usec += lost * tick_usec;
 
 		sec = xtime.tv_sec;
 		usec += (xtime.tv_nsec / 1000);
 	} while (read_seqretry(&xtime_lock, seq));
 
-	while (usec >= 1000000) {
-		usec -= 1000000;
+	while (usec >= USEC_PER_SEC) {
+		usec -= USEC_PER_SEC;
 		sec++;
 	}
 
@@ -190,7 +184,7 @@
 	set_normalized_timespec(&xtime, sec, nsec);
 	set_normalized_timespec(&wall_to_monotonic, wtm_sec, wtm_nsec);
 
-	ntp_clear();
+	set_ntp_unsync();
 	write_sequnlock_irq(&xtime_lock);
 	clock_was_set();
 	return 0;
@@ -481,6 +475,7 @@
 #endif
 	xtime.tv_sec = get_cmos_time();
 	xtime.tv_nsec = (INITIAL_JIFFIES % HZ) * (NSEC_PER_SEC / HZ);
+	timevar_init();		/* initialize kernel time variables */
 	set_normalized_timespec(&wall_to_monotonic,
 		-xtime.tv_sec, -xtime.tv_nsec);
 
Index: linux/arch/ia64/kernel/time.c
diff -u linux/arch/ia64/kernel/time.c:1.1.1.11 linux/arch/ia64/kernel/time.c:1.1.1.11.2.1
--- linux/arch/ia64/kernel/time.c:1.1.1.11	Wed Aug  9 21:07:30 2006
+++ linux/arch/ia64/kernel/time.c	Sat Aug 12 16:50:28 2006
@@ -247,6 +247,7 @@
 	register_percpu_irq(IA64_TIMER_VECTOR, &timer_irqaction);
 	efi_gettimeofday(&xtime);
 	ia64_init_itm();
+	timevar_init();		/* initialize kernel time variables */
 
 	/*
 	 * Initialize wall_to_monotonic such that adding it to xtime will yield zero, the
Index: linux/arch/m32r/kernel/time.c
diff -u linux/arch/m32r/kernel/time.c:1.1.1.2 linux/arch/m32r/kernel/time.c:1.1.1.2.2.1
--- linux/arch/m32r/kernel/time.c:1.1.1.2	Wed Aug  9 21:07:26 2006
+++ linux/arch/m32r/kernel/time.c	Sat Aug 12 16:50:33 2006
@@ -263,6 +263,7 @@
 
 	xtime.tv_sec = mktime(year, mon, day, hour, min, sec);
 	xtime.tv_nsec = (INITIAL_JIFFIES % HZ) * (NSEC_PER_SEC / HZ);
+	timevar_init();		/* initialize kernel time variables */
 	set_normalized_timespec(&wall_to_monotonic,
 		-xtime.tv_sec, -xtime.tv_nsec);
 
Index: linux/arch/m68k/kernel/time.c
diff -u linux/arch/m68k/kernel/time.c:1.1.1.4 linux/arch/m68k/kernel/time.c:1.1.1.4.4.1
--- linux/arch/m68k/kernel/time.c:1.1.1.4	Sun Jan 15 07:16:02 2006
+++ linux/arch/m68k/kernel/time.c	Sat Aug 12 16:50:37 2006
@@ -86,6 +86,7 @@
 		xtime.tv_nsec = 0;
 	}
 	wall_to_monotonic.tv_sec = -xtime.tv_sec;
+	timevar_init();		/* initialize kernel time variables */
 
 	mach_sched_init(timer_interrupt);
 }
Index: linux/arch/m68knommu/kernel/time.c
diff -u linux/arch/m68knommu/kernel/time.c:1.1.1.1 linux/arch/m68knommu/kernel/time.c:1.1.1.1.4.1
--- linux/arch/m68knommu/kernel/time.c:1.1.1.1	Sun Jan 15 07:16:02 2006
+++ linux/arch/m68knommu/kernel/time.c	Sat Aug 12 16:50:40 2006
@@ -115,6 +115,7 @@
 	xtime.tv_sec = mktime(year, mon, day, hour, min, sec);
 	xtime.tv_nsec = 0;
 	wall_to_monotonic.tv_sec = -xtime.tv_sec;
+	timevar_init();		/* initialize kernel time variables */
 
 	mach_sched_init(timer_interrupt);
 }
Index: linux/arch/mips/kernel/time.c
diff -u linux/arch/mips/kernel/time.c:1.1.1.10 linux/arch/mips/kernel/time.c:1.1.1.10.2.1
--- linux/arch/mips/kernel/time.c:1.1.1.10	Wed Aug  9 21:07:33 2006
+++ linux/arch/mips/kernel/time.c	Sat Aug 12 16:50:46 2006
@@ -637,6 +637,7 @@
 
 	xtime.tv_sec = rtc_mips_get_time();
 	xtime.tv_nsec = 0;
+	timevar_init();		/* initialize kernel time variables */
 
 	set_normalized_timespec(&wall_to_monotonic,
 	                        -xtime.tv_sec, -xtime.tv_nsec);
Index: linux/arch/parisc/kernel/time.c
diff -u linux/arch/parisc/kernel/time.c:1.1.1.4 linux/arch/parisc/kernel/time.c:1.1.1.4.2.1
--- linux/arch/parisc/kernel/time.c:1.1.1.4	Wed Aug  9 21:07:41 2006
+++ linux/arch/parisc/kernel/time.c	Sat Aug 12 16:50:50 2006
@@ -242,5 +242,6 @@
 	        xtime.tv_sec = 0;
 		xtime.tv_nsec = 0;
 	}
+	timevar_init();		/* initialize kernel time variables */
 }
 
Index: linux/arch/powerpc/kernel/time.c
diff -u linux/arch/powerpc/kernel/time.c:1.1.1.2 linux/arch/powerpc/kernel/time.c:1.1.1.2.2.1
--- linux/arch/powerpc/kernel/time.c:1.1.1.2	Wed Aug  9 21:07:48 2006
+++ linux/arch/powerpc/kernel/time.c	Sat Aug 12 16:50:53 2006
@@ -1026,6 +1026,7 @@
 
 	xtime.tv_sec = tm;
 	xtime.tv_nsec = 0;
+	timevar_init();		/* initialize kernel time variables */
 	do_gtod.varp = &do_gtod.vars[0];
 	do_gtod.var_idx = 0;
 	do_gtod.varp->tb_orig_stamp = tb_last_jiffy;
Index: linux/arch/ppc/kernel/time.c
diff -u linux/arch/ppc/kernel/time.c:1.1.1.13 linux/arch/ppc/kernel/time.c:1.1.1.13.4.1
--- linux/arch/ppc/kernel/time.c:1.1.1.13	Sun Jan 15 07:16:02 2006
+++ linux/arch/ppc/kernel/time.c	Sat Aug 12 16:50:55 2006
@@ -339,6 +339,7 @@
 		sys_tz.tz_dsttime = 0;
 		xtime.tv_sec -= timezone_offset;
         }
+	timevar_init();		/* initialize kernel time variables */
         set_normalized_timespec(&wall_to_monotonic,
                                 -xtime.tv_sec, -xtime.tv_nsec);
 }
Index: linux/arch/s390/kernel/time.c
diff -u linux/arch/s390/kernel/time.c:1.1.1.11 linux/arch/s390/kernel/time.c:1.1.1.11.2.1
--- linux/arch/s390/kernel/time.c:1.1.1.11	Wed Aug  9 21:07:34 2006
+++ linux/arch/s390/kernel/time.c	Sat Aug 12 16:50:59 2006
@@ -376,6 +376,7 @@
 	set_time_cc = init_timer_cc - 0x8126d60e46000000LL +
 		(0x3c26700LL*1000000*4096);
         tod_to_timeval(set_time_cc, &xtime);
+	timevar_init();		/* initialize kernel time variables */
         set_normalized_timespec(&wall_to_monotonic,
                                 -xtime.tv_sec, -xtime.tv_nsec);
 
Index: linux/arch/sh/kernel/time.c
diff -u linux/arch/sh/kernel/time.c:1.1.1.7 linux/arch/sh/kernel/time.c:1.1.1.7.2.1
--- linux/arch/sh/kernel/time.c:1.1.1.7	Wed Aug  9 21:07:18 2006
+++ linux/arch/sh/kernel/time.c	Sat Aug 12 16:51:04 2006
@@ -175,6 +175,7 @@
 		xtime.tv_sec = mktime(2000, 1, 1, 0, 0, 0);
 		xtime.tv_nsec = 0;
 	}
+	timevar_init();		/* initialize kernel time variables */
 
         set_normalized_timespec(&wall_to_monotonic,
                                 -xtime.tv_sec, -xtime.tv_nsec);
Index: linux/arch/sh64/kernel/time.c
diff -u linux/arch/sh64/kernel/time.c:1.1.1.4 linux/arch/sh64/kernel/time.c:1.1.1.4.2.1
--- linux/arch/sh64/kernel/time.c:1.1.1.4	Wed Aug  9 21:07:35 2006
+++ linux/arch/sh64/kernel/time.c	Sat Aug 12 16:51:08 2006
@@ -514,6 +514,7 @@
 
 	xtime.tv_sec = get_rtc_time();
 	xtime.tv_nsec = 0;
+	timevar_init();		/* initialize kernel time variables */
 
 	setup_irq(TIMER_IRQ, &irq0);
 	setup_irq(RTC_IRQ, &irq1);
Index: linux/arch/sparc/kernel/time.c
diff -u linux/arch/sparc/kernel/time.c:1.1.1.7 linux/arch/sparc/kernel/time.c:1.1.1.7.4.1
--- linux/arch/sparc/kernel/time.c:1.1.1.7	Sun Jan 15 07:16:02 2006
+++ linux/arch/sparc/kernel/time.c	Sat Aug 12 16:51:13 2006
@@ -398,6 +398,7 @@
 	year = MSTK_CVT_YEAR( MSTK_REG_YEAR(mregs) );
 	xtime.tv_sec = mktime(year, mon, day, hour, min, sec);
 	xtime.tv_nsec = (INITIAL_JIFFIES % HZ) * (NSEC_PER_SEC / HZ);
+	timevar_init();		/* initialize kernel time variables */
         set_normalized_timespec(&wall_to_monotonic,
                                 -xtime.tv_sec, -xtime.tv_nsec);
 	mregs->creg &= ~MSTK_CREG_READ;
Index: linux/arch/sparc64/kernel/time.c
diff -u linux/arch/sparc64/kernel/time.c:1.1.1.15 linux/arch/sparc64/kernel/time.c:1.1.1.15.2.1
--- linux/arch/sparc64/kernel/time.c:1.1.1.15	Wed Aug  9 21:07:40 2006
+++ linux/arch/sparc64/kernel/time.c	Sat Aug 12 16:51:16 2006
@@ -666,6 +666,7 @@
 
 	xtime.tv_sec = mktime(year, mon, day, hour, min, sec);
 	xtime.tv_nsec = (INITIAL_JIFFIES % HZ) * (NSEC_PER_SEC / HZ);
+	timevar_init();		/* initialize kernel time variables */
 	set_normalized_timespec(&wall_to_monotonic,
  	                        -xtime.tv_sec, -xtime.tv_nsec);
 
Index: linux/arch/um/kernel/time.c
diff -u linux/arch/um/kernel/time.c:1.1.1.2 linux/arch/um/kernel/time.c:1.1.1.2.2.1
--- linux/arch/um/kernel/time.c:1.1.1.2	Wed Aug  9 21:07:18 2006
+++ linux/arch/um/kernel/time.c	Sat Aug 12 16:51:20 2006
@@ -113,6 +113,7 @@
 	do_posix_clock_monotonic_gettime(&now);
 	wall_to_monotonic.tv_sec = -now.tv_sec;
 	wall_to_monotonic.tv_nsec = -now.tv_nsec;
+	timevar_init();		/* initialize kernel time variables */
 }
 
 /* Defined in linux/ktimer.h, which can't be included here */
Index: linux/arch/v850/kernel/time.c
diff -u linux/arch/v850/kernel/time.c:1.1.1.1 linux/arch/v850/kernel/time.c:1.1.1.1.4.1
--- linux/arch/v850/kernel/time.c:1.1.1.1	Sun Jan 15 07:16:02 2006
+++ linux/arch/v850/kernel/time.c	Sat Aug 12 16:51:25 2006
@@ -187,5 +187,6 @@
 void time_init (void)
 {
 	mach_gettimeofday (&xtime);
+	timevar_init();		/* initialize kernel time variables */
 	mach_sched_init (&timer_irqaction);
 }
Index: linux/arch/x86_64/kernel/time.c
diff -u linux/arch/x86_64/kernel/time.c:1.1.1.5 linux/arch/x86_64/kernel/time.c:1.1.1.5.2.1
--- linux/arch/x86_64/kernel/time.c:1.1.1.5	Wed Aug  9 21:07:41 2006
+++ linux/arch/x86_64/kernel/time.c	Sat Aug 12 16:51:28 2006
@@ -907,6 +907,7 @@
 
 	xtime.tv_sec = get_cmos_time();
 	xtime.tv_nsec = 0;
+	timevar_init();		/* initialize kernel time variables */
 
 	set_normalized_timespec(&wall_to_monotonic,
 	                        -xtime.tv_sec, -xtime.tv_nsec);
Index: linux/arch/xtensa/kernel/time.c
diff -u linux/arch/xtensa/kernel/time.c:1.1.1.2 linux/arch/xtensa/kernel/time.c:1.1.1.2.2.1
--- linux/arch/xtensa/kernel/time.c:1.1.1.2	Wed Aug  9 21:07:42 2006
+++ linux/arch/xtensa/kernel/time.c	Sat Aug 12 16:51:31 2006
@@ -80,6 +80,7 @@
 				break;
 
 	xtime.tv_nsec = 0;
+	timevar_init();		/* initialize kernel time variables */
 	last_rtc_update = xtime.tv_sec = sec_n;
 	last_ccount_stamp = get_ccount();
 
Index: linux/drivers/char/Kconfig
diff -u linux/drivers/char/Kconfig:1.1.1.2 linux/drivers/char/Kconfig:1.1.1.2.2.1
--- linux/drivers/char/Kconfig:1.1.1.2	Wed Aug  9 21:08:20 2006
+++ linux/drivers/char/Kconfig	Sat Aug 12 16:51:34 2006
@@ -1034,5 +1034,17 @@
 	  sysfs directory, /sys/devices/platform/telco_clock, with a number of
 	  files for controlling the behavior of this hardware.
 
+config PPSAPI
+	tristate "PPS API (RFC 2783) support"
+	help
+	  Select this option if you want to use PPS API (RFC 2783).
+
+config PPSAPI_DEBUG
+	bool "Enable debugging PPS API support"
+	depends on PPSAPI
+	---help---
+	  Activating this option enables generation of additional debugging
+	  messages.  Those messages are typically only interesting to
+	  kernel hackers, or for trouble-shooting.  You should say no here.
 endmenu
 
Index: linux/drivers/char/Makefile
diff -u linux/drivers/char/Makefile:1.1.1.16 linux/drivers/char/Makefile:1.1.1.16.2.1
--- linux/drivers/char/Makefile:1.1.1.16	Wed Aug  9 21:08:20 2006
+++ linux/drivers/char/Makefile	Sat Aug 12 16:51:34 2006
@@ -96,6 +96,7 @@
 
 obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM)		+= tpm/
+obj-$(CONFIG_PPSAPI)		+= ppsapi.o
 
 # Files generated that shall be removed upon make clean
 clean-files := consolemap_deftbl.c defkeymap.c qtronixmap.c
Index: linux/drivers/char/lp.c
diff -u linux/drivers/char/lp.c:1.1.1.12 linux/drivers/char/lp.c:1.1.1.12.4.1
--- linux/drivers/char/lp.c:1.1.1.12	Sun Jan 15 07:16:02 2006
+++ linux/drivers/char/lp.c	Sat Aug 12 16:51:34 2006
@@ -97,7 +97,7 @@
  * generates the irq on the _rising_ edge of the STROBE. Now lp handle
  * this case fine too.
  *
- *					15 Oct 1998, Andrea Arcangeli
+api *					15 Oct 1998, Andrea Arcangeli
  *
  * The so called `buggy' handshake is really the well documented
  * compatibility mode IEEE1284 handshake. They changed the well known
@@ -134,6 +134,10 @@
 #undef LP_STATS
 #include <linux/lp.h>
 
+#ifdef CONFIG_PPSAPI_PARALLEL
+#include <linux/ppsapi.h>
+#endif
+
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -556,6 +560,24 @@
 	lp_claim_parport_or_block (&lp_table[minor]);
 	parport_negotiate (lp_table[minor].dev->port, IEEE1284_MODE_COMPAT);
 	lp_table[minor].current_mode = IEEE1284_MODE_COMPAT;
+#ifdef CONFIG_PPSAPI_PARALLEL
+	{
+		struct pps *pps;
+
+		pps = ((struct parport_pc_private *)
+		       lp_table[minor].dev->port->private_data)->pps;
+		if (pps != NULL && pps->magic == PPSCLOCK_MAGIC) {
+			if (pps_kc_is_bound_to(pps))
+				pps_kc_unbind();
+			kfree(pps);
+			((struct parport_pc_private *)
+			 lp_table[minor].dev->port->private_data)->pps = NULL;
+#ifdef CONFIG_PPSAPI_PARALLEL_DEBUG
+			printk(KERN_DEBUG "lp_release: pps at %p freed\n", pps);
+#endif /* CONFIG_PPSAPI_PARALLEL_DEBUG */
+		}
+	}
+#endif
 	lp_release_parport (&lp_table[minor]);
 	kfree(lp_table[minor].lp_buffer);
 	lp_table[minor].lp_buffer = NULL;
@@ -661,10 +683,224 @@
 			}
 			lp_table[minor].timeout = to_jiffies;
 			break;
+#ifdef CONFIG_PPSAPI_PARALLEL
+#define AQUIRE_LOCK	lp_claim_parport_or_block(&lp_table[minor])
+#define RELEASE_LOCK	lp_release_parport(&lp_table[minor]);
+#ifdef CONFIG_PPSAPI_PARALLEL_DEBUG
+#define PPSAPI_IOCTL_RETURN(unlock, fn, tag)	\
+	do { \
+		printk(KERN_DEBUG "ioctl(PPS_IOC_%s) returns %d (%s)\n",\
+		       fn, retval, tag);\
+		if (unlock) RELEASE_LOCK;\
+		goto lp_ioctl_return;\
+	} while (0);
+#else
+#define PPSAPI_IOCTL_RETURN(unlock, fn, tag)	\
+	do { \
+		if (unlock) RELEASE_LOCK;\
+		goto lp_ioctl_return;\
+	} while (0);
+#endif
+
+	case PPS_IOC_CREATE:
+	{
+		struct parport *port;
+
+		AQUIRE_LOCK;
+		port = lp_table[minor].dev->port;
+		retval = pps_api_create(&((struct parport_pc_private *)
+					  port->private_data)->pps,
+					file->f_mode & FMODE_WRITE,
+					PPS_CAPTUREASSERT|PPS_OFFSETASSERT|
+					PPS_ECHOASSERT|
+					PPS_CANWAIT|PPS_TSFMT_TSPEC);
+		PPSAPI_IOCTL_RETURN(1, "CREATE", "final");
+	}
+
+	case PPS_IOC_DESTROY:
+	{
+		struct parport *port;
+
+		if ((file->f_mode & FMODE_WRITE) == 0) {
+			retval = -EBADF;
+			PPSAPI_IOCTL_RETURN(0, "DESTROY", "!FMODE_WRITE");
+		}
+		AQUIRE_LOCK;
+		port = lp_table[minor].dev->port;
+		retval = pps_api_destroy(&((struct parport_pc_private *)
+					   port->private_data)->pps);
+		PPSAPI_IOCTL_RETURN(1, "DESTROY", "final");
+	}
+
+	case PPS_IOC_FETCH:
+	{
+		struct pps *pps;
+		struct pps_fetch_args parms;
+		long timeout;
+
+		retval = copy_from_user(&parms, (struct pps_fetch_args *) arg,
+					sizeof(struct pps_fetch_args)) ?
+			-EFAULT : 0;
+		if (unlikely(retval))
+			PPSAPI_IOCTL_RETURN(0, "FETCH", "copy user args");
+		AQUIRE_LOCK;
+		pps = ((struct parport_pc_private *)
+		       lp_table[minor].dev->port->private_data)->pps;
+#ifdef CONFIG_PPSAPI_PARALLEL_DEBUG
+		printk(KERN_DEBUG "PPS_IOC_FETCH: pps = %p\n", pps);
+#endif /* CONFIG_PPSAPI_PARALLEL_DEBUG */
+		if (unlikely(pps == NULL || pps->magic != PPSCLOCK_MAGIC))
+		{
+			retval = -EOPNOTSUPP;
+			PPSAPI_IOCTL_RETURN(1, "FETCH", "no PPSCLOCK_MAGIC");
+		}
+		if (unlikely(parms.tsformat != PPS_TSFMT_TSPEC)) {
+			retval = -EINVAL;
+			PPSAPI_IOCTL_RETURN(1, "FETCH", "bad tsformat");
+		}
+		timeout = HZ * parms.timeout.tv_sec;
+		timeout += parms.timeout.tv_nsec / (1000000000 / HZ);
+		if (timeout != 0) {
+			RELEASE_LOCK;
+			if (parms.timeout.tv_sec == -1)
+				interruptible_sleep_on(&pps->state.ewait);
+			else {
+				timeout = interruptible_sleep_on_timeout(
+					&pps->state.ewait,
+					timeout);
+				if (timeout <= 0) {
+					retval = -ETIMEDOUT;
+					/* flags already restored */
+					PPSAPI_IOCTL_RETURN(0, "FETCH",
+							    "timeout");
+				}
+			}
+			AQUIRE_LOCK;
+			pps = ((struct parport_pc_private *)
+			       lp_table[minor].dev->port->private_data)->pps;
+			if (unlikely(pps == NULL || pps->magic != PPSCLOCK_MAGIC))
+			{
+#ifdef CONFIG_PPSAPI_PARALLEL_DEBUG
+				printk(KERN_DEBUG "PPS_IOC_FETCH: "
+				       "port %p lacks pps\n",
+				       &lp_table[minor]);
+#endif /* CONFIG_PPSAPI_PARALLEL_DEBUG */
+				retval = -EOPNOTSUPP;
+				PPSAPI_IOCTL_RETURN(1, "FETCH",
+						    "no PPSCLOCK_MAGIC");
+			}
+			if (signal_pending(current)) {
+				retval = -EINTR;
+				PPSAPI_IOCTL_RETURN(1, "FETCH",
+						    "signal pending");
+			}
+		}
+		parms.pps_info_buf = pps->state.info;
+		RELEASE_LOCK;
+		retval = copy_to_user((struct pps_fetch_args *) arg,
+				      &parms, sizeof(struct pps_fetch_args)) ?
+		         -EFAULT : 0;
+		PPSAPI_IOCTL_RETURN(0, "FETCH", "final");
+	}
+
+	case PPS_IOC_SETPARMS:
+	{
+		struct pps_params parms;
+		struct parport *port;
+
+		retval = copy_from_user(&parms, (struct pps_params *) arg,
+					sizeof(struct pps_params)) ?
+			 -EFAULT : 0;
+		if (retval)
+			PPSAPI_IOCTL_RETURN(0, "SETPARMS", "copy user args");
+		if ((file->f_mode & FMODE_WRITE) == 0) {
+			retval = -EBADF;
+			PPSAPI_IOCTL_RETURN(0, "SETPARMS", "!FMODE_WRITE");
+		}
+		AQUIRE_LOCK;
+		port = lp_table[minor].dev->port;
+		retval = pps_api_setparams(((struct parport_pc_private *)
+					    port->private_data)->pps,
+					   &parms);
+		/* It seems interrupts are not enabled after open */
+		if (retval == 0 && parms.mode & PPS_CAPTUREASSERT) {
+			/* enable interrupts */
+#ifdef CONFIG_PPSAPI_PARALLEL_DEBUG
+			printk(KERN_INFO
+			       "PPS_IOC_SETPARAMS: enable_interrupts()\n");
+#endif /* CONFIG_PPSAPI_PARALLEL_DEBUG */
+			parport_enable_irq(port);
+		}
+		PPSAPI_IOCTL_RETURN(1, "SETPARMS", "final");
+	}
+
+	case PPS_IOC_GETPARMS:
+	{
+		const struct pps *pps;
 
+		AQUIRE_LOCK;
+		pps = ((struct parport_pc_private *)
+		       lp_table[minor].dev->port->private_data)->pps;
+#ifdef CONFIG_PPSAPI_PARALLEL_DEBUG
+		printk(KERN_DEBUG "PPS_IOC_GETPARAMS: pps = %p\n", pps);
+#endif /* CONFIG_PPSAPI_PARALLEL_DEBUG */
+		if (pps == NULL || pps->magic != PPSCLOCK_MAGIC) {
+			retval = -EOPNOTSUPP;
+			PPSAPI_IOCTL_RETURN(1, "GETPARMS", "no PPSCLOCK_MAGIC");
+		}
+		RELEASE_LOCK;
+		retval = copy_to_user((pps_params_t *) arg, &(pps->state.parm),
+				      sizeof(struct pps_params)) ? -EFAULT : 0;
+		PPSAPI_IOCTL_RETURN(0, "GETPARMS", "final");
+	}
+
+	case PPS_IOC_GETCAP:
+	{
+		const struct pps *pps;
+		int may_bits, must_bits;
+
+		AQUIRE_LOCK;
+		pps = ((struct parport_pc_private *)
+		       lp_table[minor].dev->port->private_data)->pps;
+#ifdef CONFIG_PPSAPI_PARALLEL_DEBUG
+		printk(KERN_DEBUG "PPS_IOC_GETCAP: pps = %p\n", pps);
+#endif /* CONFIG_PPSAPI_PARALLEL_DEBUG */
+		if (pps == NULL || pps->magic != PPSCLOCK_MAGIC) {
+			retval = -EOPNOTSUPP;
+			PPSAPI_IOCTL_RETURN(1, "GETCAP", "no PPSCLOCK_MAGIC");
+		}
+		may_bits = pps_allowed_mode(pps, file->f_mode & FMODE_WRITE,
+					    &must_bits);
+		RELEASE_LOCK;
+		retval = copy_to_user((int *) arg, &may_bits, sizeof(int));
+		PPSAPI_IOCTL_RETURN(0, "GETCAP", "final");
+	}
+
+	case PPS_IOC_KC_BIND:
+	{
+		struct pps_bind_args parms;
+		struct parport *port;
+
+		retval = copy_from_user(&parms, (struct pps_bind_args *) arg,
+					sizeof(struct pps_bind_args)) ?
+		      -EFAULT : 0;
+		if (retval)
+			PPSAPI_IOCTL_RETURN(0, "KC_BIND", "copy user args");
+		if ((file->f_mode & FMODE_WRITE) == 0) {
+			retval = -EBADF;
+			PPSAPI_IOCTL_RETURN(0, "KC_BIND", "!FMODE_WRITE");
+		}
+		AQUIRE_LOCK;
+		port = lp_table[minor].dev->port;
+		retval = pps_api_kc_bind(((struct parport_pc_private *)
+					  port->private_data)->pps, &parms);
+		PPSAPI_IOCTL_RETURN(1, "KC_BIND", "final");
+	}
+#endif /* CONFIG_PPSAPI_PARALLEL */
 		default:
 			retval = -EINVAL;
 	}
+lp_ioctl_return:
 	return retval;
 }
 
Index: linux/drivers/char/ppsapi.c
diff -u /dev/null linux/drivers/char/ppsapi.c:1.1.4.2
--- /dev/null	Mon Aug 14 21:09:34 2006
+++ linux/drivers/char/ppsapi.c	Sat Aug 12 16:51:34 2006
@@ -0,0 +1,241 @@
+/*
+ * PPS API (RFC 2783) support module
+ *
+ * Copyright (C) 2004, 2006 by Ulrich Windl
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/time.h>
+#include <linux/ppsapi.h>
+
+/* some unique pointer to device */
+const struct pps	*pps_kc_hardpps_dev = NULL;
+/* mode bits for kernel consumer */
+int	pps_kc_hardpps_mode;
+EXPORT_SYMBOL(pps_kc_hardpps_dev);
+EXPORT_SYMBOL(pps_kc_hardpps_mode);
+
+/* Is any kernel consumer bound? */
+int	pps_kc_is_bound(void)
+{
+	return pps_kc_hardpps_dev != NULL;
+}
+EXPORT_SYMBOL(pps_kc_is_bound);
+
+/* Is any kernel consumer bound to given pps? */
+int	pps_kc_is_bound_to(const struct pps *pps)
+{
+	return pps_kc_hardpps_dev == pps;
+}
+EXPORT_SYMBOL(pps_kc_is_bound_to);
+
+/* Bind kernel consumer to given pps with given mode */
+void	pps_kc_bind_to(const struct pps *pps, int mode)
+{
+	pps_kc_hardpps_dev = pps;
+	pps_kc_hardpps_mode = mode;
+#ifdef CONFIG_PPSAPI_DEBUG
+	printk(KERN_DEBUG "pps_kc_bind_to: bound dev=%p, mode 0x%x\n",
+	       pps_kc_hardpps_dev, pps_kc_hardpps_mode);
+#endif /* CONFIG_PPSAPI_DEBUG */
+}
+EXPORT_SYMBOL(pps_kc_bind_to);
+
+/* Unbind kernel consumer */
+void	pps_kc_unbind(void)
+{
+#ifdef CONFIG_PPSAPI_DEBUG
+	printk(KERN_DEBUG "pps_kc_unbind: unbound dev=%p, mode 0x%x\n",
+	       pps_kc_hardpps_dev, pps_kc_hardpps_mode);
+#endif /* CONFIG_PPSAPI_DEBUG */
+	pps_kc_hardpps_dev = NULL;
+	pps_kc_hardpps_mode = 0;
+}
+EXPORT_SYMBOL(pps_kc_unbind);
+
+/* Return allowed mode bits for given pps struct, file's writability, and
+ * current user.  Bits set in `*obligatory' must be set.  Returned bits may
+ * be set.
+ */
+int pps_allowed_mode(const struct pps *pps, int writable, int *obligatory)
+{
+	int	cap = pps->state.cap;
+
+	cap &= ~PPS_CANWAIT;				/* always RO */
+	*obligatory = PPS_TSFMT_TSPEC;		/* only supported format */
+	if (!writable) {	/* read-only mode */
+		cap = *obligatory = pps->state.parm.mode;
+	} else if (!capable(CAP_SYS_TIME)) {	/* may not manipulate time */
+		int	fixed_bits;
+		int	active_flags = pps->state.parm.mode;
+
+		if (pps_kc_hardpps_dev == pps) {
+			fixed_bits = PPS_OFFSETASSERT|PPS_OFFSETCLEAR;
+			fixed_bits &= active_flags;
+			*obligatory |= fixed_bits;
+		}
+	}
+	return cap;
+}
+EXPORT_SYMBOL(pps_allowed_mode);
+
+/* does pps refer to a valid struct pps? */
+static inline int pps_good_magic(const struct pps *pps)
+{
+	return pps != NULL && pps->magic == PPSCLOCK_MAGIC;
+}
+
+/* try to set up pps struct at *pps */
+int pps_api_create(struct pps **pps, int writable, int capabilities)
+{
+#ifdef CONFIG_PPSAPI_DEBUG
+	printk(KERN_DEBUG "pps_api_create: current pps == %p\n", *pps);
+#endif /* CONFIG_PPSAPI_DEBUG */
+	if (*pps != NULL) {
+#ifdef CONFIG_PPSAPI_DEBUG
+		printk(KERN_DEBUG "pps_api_create: pps->magic == 0x%x\n",
+		       (*pps)->magic);
+#endif /* CONFIG_PPSAPI_DEBUG */
+		/* share the handle if valid, otherwise fail */
+		return (*pps)->magic == PPSCLOCK_MAGIC ? 0 : -EBADF;
+	}
+	if (!writable) {
+		return -EBADF;
+	}
+	if (unlikely((*pps = (struct pps *) kmalloc(sizeof(struct pps),
+						    GFP_KERNEL)) == NULL)) {
+		printk(KERN_ERR "pps_api_create: kmalloc(pps) failed\n");
+		return -ENOMEM;
+	}
+#ifdef CONFIG_PPSAPI_DEBUG
+	printk(KERN_DEBUG "pps_api_create: new pps at %p = %p\n",
+	       pps, *pps);
+#endif /* CONFIG_PPSAPI_DEBUG */
+	/* clear all parameters */
+	memset(*pps, 0, sizeof(struct pps));
+	(*pps)->magic = PPSCLOCK_MAGIC;
+	(*pps)->state.parm.api_version = PPS_API_VERS_1;
+	(*pps)->state.parm.mode = PPS_TSFMT_TSPEC;
+	(*pps)->state.cap = capabilities;
+	init_waitqueue_head(&(*pps)->state.ewait);
+	return 0;
+}
+EXPORT_SYMBOL(pps_api_create);
+
+/* try to destroy pps struct at *pps */
+int pps_api_destroy(struct pps **pps)
+{
+#ifdef CONFIG_PPSAPI_DEBUG
+	printk(KERN_DEBUG "pps_api_destroy: pps at %p = %p\n", pps, *pps);
+#endif /* CONFIG_PPSAPI_DEBUG */
+	if (!pps_good_magic(*pps)) {
+		return -EOPNOTSUPP;
+	}
+	if (waitqueue_active(&(*pps)->state.ewait)) {
+#ifdef CONFIG_PPSAPI_DEBUG
+		printk(KERN_DEBUG "PPS_IOC_DESTROY: wait queue at %p busy\n",
+		       &(*pps)->state.ewait);
+#endif /* CONFIG_PPSAPI_DEBUG */
+		return -EBUSY;
+	}
+	/* draft 03 says the settings are unaffected. */
+	return 0;
+}
+EXPORT_SYMBOL(pps_api_destroy);
+
+/* set pps parameters from *parp */
+int pps_api_setparams(struct pps *pps, struct pps_params *parp)
+{
+	int may_bits, must_bits;
+
+#ifdef CONFIG_PPSAPI_DEBUG
+	printk(KERN_DEBUG "pps_api_setparams: pps = %p\n", pps);
+#endif /* CONFIG_PPSAPI_DEBUG */
+	if (!pps_good_magic(pps)) {
+		return -EOPNOTSUPP;
+	}
+#ifdef CONFIG_PPSAPI_DEBUG
+	printk(KERN_DEBUG
+	       "pps_api_setparams: pps = %p, mode = %#x, cap = %#x\n",
+	       pps, parp->mode, pps->state.cap);
+#endif /* CONFIG_PPSAPI_DEBUG */
+	if (parp->api_version != PPS_API_VERS_1) {
+		return -EINVAL;
+	}
+	if ((parp->mode & ~pps->state.cap) != 0) {
+		return -EINVAL;
+	}
+	if ((parp->mode & (PPS_TSFMT_TSPEC|PPS_TSFMT_NTPFP)) == 0 ) {
+		/* section 3.3 of RFC 2783 interpreted */
+		parp->mode |= PPS_TSFMT_TSPEC;
+	}
+	may_bits = pps_allowed_mode(pps, 1, &must_bits);
+#ifdef CONFIG_PPSAPI_DEBUG
+	printk(KERN_DEBUG
+	       "pps_api_setparams: pps = %p, allowed = %#x, must = %#x\n",
+	       pps, may_bits, must_bits);
+#endif /* CONFIG_PPSAPI_DEBUG */
+	if ((parp->mode & must_bits) != must_bits ||
+	    (parp->mode & ~may_bits) != 0) {
+		return -EPERM;
+	}
+	if (capable(CAP_SYS_TIME)) {
+		/* allow setting offsets */
+		pps->state.parm = *parp;
+	} else {
+		pps->state.parm.api_version = parp->api_version;
+		pps->state.parm.mode = parp->mode;
+		/* not offsets! */
+	}
+	return 0;
+}
+EXPORT_SYMBOL(pps_api_setparams);
+
+/* bind kernel consumer to pps device according to given bind ags */
+int pps_api_kc_bind(struct pps *pps, struct pps_bind_args *bap)
+{
+#ifdef CONFIG_PPSAPI_DEBUG
+	printk(KERN_DEBUG "pps_api_kc_bind: pps = %p\n", pps);
+	printk(KERN_DEBUG
+	       "pps_api_kc_bind: current dev = %p, mode = 0x%x\n",
+	       pps_kc_hardpps_dev, pps_kc_hardpps_mode);
+#endif /* CONFIG_PPSAPI_DEBUG */
+	if (!pps_good_magic(pps)) {
+		return -EOPNOTSUPP;
+	}
+	/* generic parameter validation */
+	if (bap->tsformat != PPS_TSFMT_TSPEC ||
+	    (bap->edge & ~PPS_CAPTUREBOTH) != 0 ||
+#if 0
+	    bap->consumer < PPS_KC_HARDPPS ||
+	    bap->consumer > PPS_KC_HARDPPS_FLL ||
+#endif
+	    bap->consumer != PPS_KC_HARDPPS) {
+		return -EINVAL;
+	}
+	/* permission check */
+	if (!capable(CAP_SYS_TIME)) {
+		return -EPERM;
+	}
+	/* detailed parameter check */
+	if (bap->edge == 0) {
+		if (!pps_kc_is_bound() || pps_kc_is_bound_to(pps)) {
+			pps_kc_unbind();
+		} else {	/* another consumer bound */
+			return -EINVAL;
+		}
+	} else {
+		if (!pps_kc_is_bound() || pps_kc_is_bound_to(pps)) {
+			pps_kc_bind_to(pps, bap->edge);
+		} else {
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL(pps_api_kc_bind);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("PPS API (RFC 2783) support module");
+MODULE_AUTHOR("Ulrich Windl");
Index: linux/drivers/parport/Kconfig
diff -u linux/drivers/parport/Kconfig:1.1.1.2 linux/drivers/parport/Kconfig:1.1.1.2.2.1
--- linux/drivers/parport/Kconfig:1.1.1.2	Wed Aug  9 21:08:48 2006
+++ linux/drivers/parport/Kconfig	Sat Aug 12 16:51:39 2006
@@ -32,6 +32,25 @@
 
 	  If unsure, say Y.
 
+config PPSAPI_PARALLEL
+	bool "PPS API (RFC 2783) support on parallel port"
+	depends on PARPORT_PC
+	select PPSAPI
+	---help---
+	  The PPS (Pulse-Per-Second) API provides a user-level interface
+	  for getting the exact time of some one-bit-event ("assert" or
+	  "clear").  Here the PC parallel port's ACK line is used to provide
+	  "assert" events only.
+	  Typically you do not need this.
+
+config PPSAPI_PARALLEL_DEBUG
+	bool "Enable debugging PPS API support on parallel port"
+	depends on PPSAPI_PARALLEL
+	---help---
+	  Activating this option enables generation of additional debugging
+	  messages.  Those messages are typically only interesting to
+	  kernel hackers, or for trouble-shooting.  You should say no here.
+
 config PARPORT_PC
 	tristate "PC-style hardware"
 	depends on PARPORT && (!SPARC64 || PCI) && !SPARC32 && !M32R && !FRV
Index: linux/drivers/parport/parport_pc.c
diff -u linux/drivers/parport/parport_pc.c:1.1.1.19 linux/drivers/parport/parport_pc.c:1.1.1.19.2.1
--- linux/drivers/parport/parport_pc.c:1.1.1.19	Wed Aug  9 21:08:48 2006
+++ linux/drivers/parport/parport_pc.c	Sat Aug 12 16:51:39 2006
@@ -65,6 +65,11 @@
 #include <linux/via.h>
 #include <asm/parport.h>
 
+#ifdef CONFIG_PPSAPI_PARALLEL
+#include <linux/timex.h>	/* time_interpolator_get_offset() */
+#include <linux/ppsapi.h>
+#endif
+
 #define PARPORT_PC_MAX_PORTS PARPORT_MAX
 
 #ifdef CONFIG_ISA_DMA_API
@@ -271,8 +276,89 @@
  * of these are in parport_pc.h.
  */
 
+#ifdef	CONFIG_PPSAPI_PARALLEL
+/* update PPS info from the event time stamp stored in etime and ecount. */
+static inline void pps_update_event(struct parport *port, unsigned char status)
+{
+	struct pps	*pps;
+	int mode;
+
+	if (unlikely((pps = ((struct parport_pc_private *)
+			     port->private_data)->pps) == NULL ||
+		     pps->magic != PPSCLOCK_MAGIC)) {
+#ifdef CONFIG_PPSAPI_PARALLEL_DEBUG
+		printk(KERN_ERR
+		       "pps_update_event(): illegal pps for port %p\n", port);
+#endif /* CONFIG_PPSAPI_PARALLEL_DEBUG */
+		return;
+	}
+	mode = pps->state.parm.mode;
+	if ((mode & PPS_ECHOASSERT) != 0) {
+		/* echo event via SEL bit */
+		parport_pc_write_control(port,
+					 parport_pc_read_control(port) |
+					 PARPORT_CONTROL_SELECT);
+		/* signal no event */
+		if ((status & PARPORT_STATUS_ACK) != 0)
+			parport_pc_write_control(port,
+						 parport_pc_read_control(port) &
+						 ~PARPORT_CONTROL_SELECT);
+	}
+	if ((status & PARPORT_STATUS_ACK) != 0)	{
+		struct timespec ts;
+		ts = pps->state.etime;
+		pps->state.info.current_mode = mode;
+		if ((mode & PPS_OFFSETASSERT) != 0) {
+			ts.tv_nsec += pps->state.parm.assert_offset.tv_nsec;
+			if (ts.tv_nsec >= NSEC_PER_SEC) {
+				ts.tv_nsec -= NSEC_PER_SEC;
+				++ts.tv_sec;
+			} else if (ts.tv_nsec < 0) {
+				ts.tv_nsec += NSEC_PER_SEC;
+				--ts.tv_sec;
+			}
+		}
+#ifdef CONFIG_NTP_PPS	/* handle PPS pulse */
+		if ((pps_kc_hardpps_mode & PPS_CAPTUREASSERT) != 0 &&
+		    pps_kc_hardpps_dev == pps)
+			hardpps(&ts, pps->state.ecount);
+#endif
+		if ((mode & PPS_CAPTUREASSERT) != 0) {
+			pps->state.info.assert_timestamp = ts;
+			++pps->state.info.assert_sequence;
+			if (waitqueue_active(&pps->state.ewait))
+				wake_up_interruptible(&pps->state.ewait);
+		}
+#ifdef CONFIG_PPSAPI_PARALLEL_DEBUG
+		printk(KERN_DEBUG
+		       "ASSERT event #%lu for %p at %lu.%09ld (%9ld)\n",
+		       pps->state.info.assert_sequence, pps, ts.tv_sec,
+		       ts.tv_nsec, pps->state.ecount);
+#endif /* CONFIG_PPSAPI_PARALLEL_DEBUG */
+	}
+}
+#endif /* CONFIG_PPSAPI_PARALLEL */
+
 static irqreturn_t parport_pc_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
+#ifdef CONFIG_PPSAPI_PARALLEL
+	struct pps *pps = (struct pps *) ((struct parport_pc_private *)
+					  ((struct parport *)
+					   dev_id)->private_data)->pps;
+	unsigned char status;
+
+	status = parport_pc_read_status((struct parport *) dev_id);
+	if (pps != NULL && pps->magic == PPSCLOCK_MAGIC) {
+		pps->state.ecount = do_clock_gettime(CLOCK_REALTIME,
+						     &pps->state.etime);
+#ifdef CONFIG_PPSAPI_PARALLEL_DEBUG
+		printk(KERN_DEBUG
+		       "parport_pc_interrupt: status=%#02x, pps=%p\n",
+		       status, pps);
+#endif /* CONFIG_PPSAPI_PARALLEL_DEBUG */
+		pps_update_event((struct parport *) dev_id, status);
+	}
+#endif /* CONFIG_PPSAPI_PARALLEL */
 	parport_generic_irq(irq, (struct parport *) dev_id, regs);
 	/* FIXME! Was it really ours? */
 	return IRQ_HANDLED;
@@ -2182,6 +2268,9 @@
 	priv->dma_buf = NULL;
 	priv->dma_handle = 0;
 	priv->dev = dev;
+#ifdef	CONFIG_PPSAPI_PARALLEL
+	priv->pps = NULL;
+#endif
 	INIT_LIST_HEAD(&priv->list);
 	priv->port = p;
 	p->base_hi = base_hi;
Index: linux/drivers/serial/8250.c
diff -u linux/drivers/serial/8250.c:1.1.1.2 linux/drivers/serial/8250.c:1.1.1.2.2.1
--- linux/drivers/serial/8250.c:1.1.1.2	Wed Aug  9 21:08:48 2006
+++ linux/drivers/serial/8250.c	Sat Aug 12 16:51:44 2006
@@ -42,6 +42,13 @@
 #include <linux/nmi.h>
 #include <linux/mutex.h>
 
+#ifdef	CONFIG_PPSAPI_SERIAL
+#include <linux/time.h> 	/* struct timeval, do_gettimeofday(),
+				   hardpps() */
+#include <linux/timex.h>	/* time_interpolator_get_offset() */
+#include <linux/ppsapi.h>	/* PPS API */
+#endif
+
 #include <asm/io.h>
 #include <asm/irq.h>
 
@@ -1274,6 +1281,98 @@
 		__stop_tx(up);
 }
 
+#ifdef	CONFIG_PPSAPI_SERIAL
+/* update PPS info from the event time stamp stored in etime and ecount. */
+static inline void pps_update_event(struct uart_8250_port *up,
+				    int modem_status)
+{
+	struct tty_struct const	*const tty	= up->port.info->tty;
+	struct pps	*pps;
+	int mode;
+
+	if (unlikely((pps = (struct pps *) tty->disc_data) == NULL ||
+		     pps->magic != PPSCLOCK_MAGIC)) {
+#ifdef CONFIG_PPSAPI_SERIAL_DEBUG
+		printk(KERN_ERR
+		       "pps_update_event(): illegal disc_data for port %p\n",
+		       up);
+#endif /* CONFIG_PPSAPI_SERIAL_DEBUG */
+		return;
+	}
+	mode = pps->state.parm.mode;
+	if ((mode & (PPS_ECHOASSERT|PPS_ECHOCLEAR)) != 0) {
+		/* echo event via cleared RTS bit */
+		up->mcr_mask |= UART_MCR_RTS;		/* signal no event */
+		if (((modem_status & UART_MSR_DCD) != 0) ==
+		    ((mode & PPS_ECHOASSERT) != 0))
+			up->mcr_mask &= ~UART_MCR_RTS;	/* signal event */
+		serial_out(up, UART_MCR, up->mcr_mask | up->mcr_force);
+	}
+	if ((modem_status & UART_MSR_DCD) != 0)	{
+		struct timespec ts;
+
+		ts = pps->state.etime;
+		pps->state.info.current_mode = mode;
+		if ((mode & PPS_OFFSETASSERT) != 0) {
+			ts.tv_nsec += pps->state.parm.assert_offset.tv_nsec;
+			if (ts.tv_nsec >= NSEC_PER_SEC) {
+				ts.tv_nsec -= NSEC_PER_SEC;
+				++ts.tv_sec;
+			} else if (ts.tv_nsec < 0) {
+				ts.tv_nsec += NSEC_PER_SEC;
+				--ts.tv_sec;
+			}
+		}
+#ifdef CONFIG_NTP_PPS	/* handle PPS pulse */
+		if ((pps_kc_hardpps_mode & PPS_CAPTUREASSERT) != 0 &&
+		    pps_kc_hardpps_dev == (const struct pps *) pps)
+			hardpps(&ts, pps->state.ecount);
+#endif
+		if ((mode & PPS_CAPTUREASSERT) != 0) {
+			pps->state.info.assert_timestamp = ts;
+			++pps->state.info.assert_sequence;
+			if (waitqueue_active(&pps->state.ewait))
+				wake_up_interruptible(&pps->state.ewait);
+		}
+#ifdef CONFIG_PPSAPI_SERIAL_DEBUG
+		printk(KERN_DEBUG
+		       "ASSERT event #%lu for %p at %lu.%09ld (%9ld)\n",
+		       pps->state.info.assert_sequence, pps, ts.tv_sec,
+		       ts.tv_nsec, pps->state.ecount);
+#endif /* CONFIG_PPSAPI_SERIAL_DEBUG */
+	} else {
+		struct timespec ts;
+		ts = pps->state.etime;
+		pps->state.info.current_mode = mode;
+		if ((mode & PPS_OFFSETCLEAR) != 0) {
+			ts.tv_nsec += pps->state.parm.clear_offset.tv_nsec;
+			if (ts.tv_nsec >= NSEC_PER_SEC) {
+				ts.tv_nsec -= NSEC_PER_SEC;
+				++ts.tv_sec;
+			} else if (ts.tv_nsec < 0) {
+				ts.tv_nsec += NSEC_PER_SEC;
+				--ts.tv_sec;
+			}
+		}
+		if ((pps_kc_hardpps_mode & PPS_CAPTURECLEAR) != 0 &&
+		    pps_kc_hardpps_dev == (const struct pps *) pps)
+			hardpps(&ts, pps->state.ecount);
+		if ((mode & PPS_CAPTURECLEAR) != 0) {
+			pps->state.info.clear_timestamp = ts;
+			++pps->state.info.clear_sequence;
+			if (waitqueue_active(&pps->state.ewait))
+				wake_up_interruptible(&pps->state.ewait);
+		}
+#ifdef CONFIG_PPSAPI_SERIAL_DEBUG
+		printk(KERN_DEBUG
+		       "CLEAR event #%lu for %p at %lu.%09ld (%9ld)\n",
+		       pps->state.info.clear_sequence, pps, ts.tv_sec,
+		       ts.tv_nsec, pps->state.ecount);
+#endif /* CONFIG_PPSAPI_SERIAL_DEBUG */
+	}
+}
+#endif /* CONFIG_PPSAPI_SERIAL */
+
 static unsigned int check_modem_status(struct uart_8250_port *up)
 {
 	unsigned int status = serial_in(up, UART_MSR);
@@ -1283,8 +1382,23 @@
 			up->port.icount.rng++;
 		if (status & UART_MSR_DDSR)
 			up->port.icount.dsr++;
-		if (status & UART_MSR_DDCD)
+		if (status & UART_MSR_DDCD) {
+#ifdef CONFIG_PPSAPI_SERIAL
+			struct pps *pps =
+			    (struct pps *) up->port.info->tty->disc_data;
+
+			if (pps != NULL && pps->magic == PPSCLOCK_MAGIC) {
+#ifdef CONFIG_PPSAPI_SERIAL_DEBUG
+			    printk(KERN_DEBUG
+				   "check_modem_status: status=%#02x, pps=%p\n",
+				   status, pps);
+#endif /* CONFIG_PPSAPI_SERIAL_DEBUG */
+			    pps_update_event(up, status);
+			}
+#endif /* CONFIG_PPSAPI_SERIAL */
 			uart_handle_dcd_change(&up->port, status & UART_MSR_DCD);
+		}
+
 		if (status & UART_MSR_DCTS)
 			uart_handle_cts_change(&up->port, status & UART_MSR_CTS);
 
@@ -1308,6 +1422,23 @@
 
 	DEBUG_INTR("status = %x...", status);
 
+#ifdef CONFIG_PPSAPI_SERIAL
+	{	/* store timestamp in case it is wanted later */
+		struct pps *pps = (struct pps *) up->port.info->tty->disc_data;
+
+		if (pps != NULL && pps->magic == PPSCLOCK_MAGIC) {
+			pps->state.ecount = do_clock_gettime(CLOCK_REALTIME,
+							    &pps->state.etime);
+#ifdef CONFIG_PPSAPI_SERIAL_DEBUG
+			printk(KERN_DEBUG
+			       "serial8250_handle_port: time %ld:%ld(%ld)\n",
+			       pps->state.etime.tv_sec, pps->state.etime.tv_nsec,
+			       pps->state.ecount);
+#endif	/* CONFIG_PPSAPI_SERIAL_DEBUG */
+		}
+	}
+#endif /* CONFIG_PPSAPI_SERIAL */
+
 	if (status & UART_LSR_DR)
 		receive_chars(up, &status, regs);
 	check_modem_status(up);
Index: linux/drivers/serial/Kconfig
diff -u linux/drivers/serial/Kconfig:1.1.1.2 linux/drivers/serial/Kconfig:1.1.1.2.2.1
--- linux/drivers/serial/Kconfig:1.1.1.2	Wed Aug  9 21:08:48 2006
+++ linux/drivers/serial/Kconfig	Sat Aug 12 16:51:44 2006
@@ -39,6 +39,25 @@
 	  Most people will say Y or M here, so that they can use serial mice,
 	  modems and similar devices connecting to the standard serial ports.
 
+config PPSAPI_SERIAL
+	bool "PPS API (RFC 2783) support on serial port"
+	depends on SERIAL_8250
+	select PPSAPI
+	---help---
+	  The PPS (Pulse-Per-Second) API provides a user-level interface
+	  for getting the exact time of some one-bit-event ("assert" or
+	  "clear").  Here the serial port's DCD (Data Carrier Detect) line
+	  is used.  Currently only 8250/16550 compatible UARTs are supported.
+	  Typically you do not need this.
+
+config PPSAPI_SERIAL_DEBUG
+	bool "Enable debugging PPS API support on serial port"
+	depends on PPSAPI_SERIAL
+	---help---
+	  Activating this option enables generation of additional debugging
+	  messages.  Those messages are typically only interesting to
+	  kernel hackers, or for trouble-shooting.  You should say no here.
+
 config SERIAL_8250_CONSOLE
 	bool "Console on 8250/16550 and compatible serial port"
 	depends on SERIAL_8250=y
Index: linux/drivers/serial/serial_core.c
diff -u linux/drivers/serial/serial_core.c:1.1.1.2 linux/drivers/serial/serial_core.c:1.1.1.2.2.1
--- linux/drivers/serial/serial_core.c:1.1.1.2	Wed Aug  9 21:08:48 2006
+++ linux/drivers/serial/serial_core.c	Sat Aug 12 16:51:44 2006
@@ -35,6 +35,13 @@
 #include <linux/delay.h>
 #include <linux/mutex.h>
 
+#ifdef	CONFIG_PPSAPI_SERIAL
+#include <linux/time.h> 	/* struct timeval, do_gettimeofday(),
+				   hardpps() */
+#include <linux/ppsapi.h>	/* PPS API */
+#include <linux/serial_reg.h>	/* UART_ definitions */
+#endif
+
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 
@@ -1052,6 +1059,9 @@
 {
 	struct uart_state *state = tty->driver_data;
 	void __user *uarg = (void __user *)arg;
+#ifdef	CONFIG_PPSAPI_SERIAL
+	unsigned long flags;
+#endif
 	int ret = -ENOIOCTLCMD;
 
 	BUG_ON(!kernel_locked());
@@ -1114,6 +1124,208 @@
 	 * protected against the tty being hung up.
 	 */
 	switch (cmd) {
+/*FIXME: CLEAN UP THIS MESS!*/
+#ifdef CONFIG_PPSAPI_SERIAL
+#define AQUIRE_LOCK	spin_lock_irqsave(&tty->read_lock, flags)
+#define RELEASE_LOCK	spin_unlock_irqrestore(&tty->read_lock, flags)
+#ifdef CONFIG_PPSAPI_SERIAL_DEBUG
+#define PPSAPI_IOCTL_RETURN(unlock, fn, tag)	\
+	do { \
+		printk(KERN_DEBUG "uart_ioctl(PPS_IOC_%s) returns %d (%s)\n",\
+		       fn, ret, tag);\
+		if (unlock) RELEASE_LOCK;\
+		goto out_up;\
+	} while (0);
+#else
+#define PPSAPI_IOCTL_RETURN(unlock, fn, tag)	\
+	do { \
+		if (unlock) RELEASE_LOCK;\
+		goto out_up;\
+	} while (0);
+#endif
+/*FIXME: END OF MESS */
+	case PPS_IOC_CREATE:
+	{
+		AQUIRE_LOCK;
+		ret = pps_api_create(((struct pps **) &tty->disc_data),
+				     filp->f_mode & FMODE_WRITE,
+				     PPS_CAPTUREASSERT|PPS_OFFSETASSERT|
+				     PPS_CAPTURECLEAR|PPS_OFFSETCLEAR|
+				     PPS_ECHOASSERT|PPS_ECHOCLEAR|
+				     PPS_CANWAIT|PPS_TSFMT_TSPEC);
+		PPSAPI_IOCTL_RETURN(1, "CREATE", "final");
+	}
+
+	case PPS_IOC_DESTROY:
+	{
+		if ((filp->f_mode & FMODE_WRITE) == 0) {
+			ret = -EBADF;
+			PPSAPI_IOCTL_RETURN(0, "DESTROY", "!FMODE_WRITE");
+		}
+		AQUIRE_LOCK;
+		ret = pps_api_destroy(((struct pps **) &tty->disc_data));
+		PPSAPI_IOCTL_RETURN(1, "DESTROY", "final");
+	}
+
+	case PPS_IOC_FETCH:
+	{
+		struct pps *pps;
+		struct pps_fetch_args parms;
+		long timeout;
+
+		ret = copy_from_user(&parms, (struct pps_fetch_args *) arg,
+				     sizeof(struct pps_fetch_args)) ?
+		      -EFAULT : 0;
+		if (unlikely(ret))
+			PPSAPI_IOCTL_RETURN(0, "FETCH", "copy user args");
+		AQUIRE_LOCK;
+		pps = (struct pps *) tty->disc_data;
+#ifdef CONFIG_PPSAPI_SERIAL_DEBUG
+		printk(KERN_DEBUG
+		       "PPS_IOC_FETCH: tty/count/pps = %p/%d/%p\n",
+		       tty, tty->count, pps);
+#endif /* CONFIG_PPSAPI_SERIAL_DEBUG */
+		if (unlikely(pps == NULL || pps->magic != PPSCLOCK_MAGIC))
+		{
+			ret = -EOPNOTSUPP;
+			PPSAPI_IOCTL_RETURN(1, "FETCH", "no PPSCLOCK_MAGIC");
+		}
+		if (unlikely(parms.tsformat != PPS_TSFMT_TSPEC)) {
+			ret = -EINVAL;
+			PPSAPI_IOCTL_RETURN(1, "FETCH", "bad tsformat");
+		}
+		timeout = HZ * parms.timeout.tv_sec;
+		timeout += parms.timeout.tv_nsec / (1000000000 / HZ);
+		if (timeout != 0) {
+			RELEASE_LOCK;
+			if (parms.timeout.tv_sec == -1)
+				interruptible_sleep_on(&pps->state.ewait);
+			else {
+				timeout = interruptible_sleep_on_timeout(
+					&pps->state.ewait,
+					timeout);
+				if (timeout <= 0) {
+					ret = -ETIMEDOUT;
+					/* flags already restored */
+					PPSAPI_IOCTL_RETURN(0, "FETCH",
+							    "timeout");
+				}
+			}
+			AQUIRE_LOCK;
+			pps = (struct pps *) tty->disc_data;
+			if (pps == NULL || pps->magic != PPSCLOCK_MAGIC)
+			{
+#ifdef CONFIG_PPSAPI_SERIAL_DEBUG
+				printk(KERN_DEBUG "PPS_IOC_FETCH: "
+				       "tty %p lacks pps\n",
+				       tty);
+#endif /* CONFIG_PPSAPI_SERIAL_DEBUG */
+				ret = -EOPNOTSUPP;
+				PPSAPI_IOCTL_RETURN(1, "FETCH",
+						    "no PPSCLOCK_MAGIC");
+			}
+			if (signal_pending(current)) {
+				ret = -EINTR;
+				PPSAPI_IOCTL_RETURN(1, "FETCH",
+						    "signal pending");
+			}
+		}
+		parms.pps_info_buf = pps->state.info;
+		RELEASE_LOCK;
+		ret = copy_to_user((struct pps_fetch_args *) arg,
+				   &parms, sizeof(struct pps_fetch_args)) ?
+		      -EFAULT : 0;
+		PPSAPI_IOCTL_RETURN(0, "FETCH", "final");
+	}
+
+	case PPS_IOC_SETPARMS:
+	{
+		struct pps_params parms;
+
+		ret = copy_from_user(&parms, (struct pps_params *) arg,
+				     sizeof(struct pps_params)) ? -EFAULT : 0;
+		if (unlikely(ret))
+			PPSAPI_IOCTL_RETURN(0, "SETPARMS", "copy user args");
+		if ((filp->f_mode & FMODE_WRITE) == 0) {
+			ret = -EBADF;
+			PPSAPI_IOCTL_RETURN(0, "SETPARMS", "!FMODE_WRITE");
+		}
+		AQUIRE_LOCK;
+		ret = pps_api_setparams(((struct pps *) tty->disc_data),
+					&parms);
+		if (ret == 0 &&
+		    parms.mode & (PPS_CAPTUREASSERT|PPS_CAPTURECLEAR)) {
+			/* enable interrupts */
+			state->port->flags |= UPF_LOW_LATENCY;
+#ifdef CONFIG_PPSAPI_SERIAL_DEBUG
+			printk(KERN_DEBUG "PPS_IOC_SETPARAMS: enable_ms()\n");
+#endif /* CONFIG_PPSAPI_SERIAL_DEBUG */
+			state->port->ops->enable_ms(state->port);
+		}
+		PPSAPI_IOCTL_RETURN(1, "SETPARMS", "success");
+	}
+
+	case PPS_IOC_GETPARMS:
+	{
+		const struct pps *pps;
+
+		AQUIRE_LOCK;
+		pps = (struct pps *) tty->disc_data;
+#ifdef CONFIG_PPSAPI_SERIAL_DEBUG
+		printk(KERN_DEBUG "PPS_IOC_GETPARAMS: tty/pps = %p/%p\n",
+		       tty, pps);
+#endif /* CONFIG_PPSAPI_SERIAL_DEBUG */
+		if (pps == NULL || pps->magic != PPSCLOCK_MAGIC) {
+			ret = -EOPNOTSUPP;
+			PPSAPI_IOCTL_RETURN(1, "GETPARMS", "no PPSCLOCK_MAGIC");
+		}
+		RELEASE_LOCK;
+		ret = copy_to_user((pps_params_t *) arg, &(pps->state.parm),
+				   sizeof(struct pps_params)) ? -EFAULT : 0;
+		PPSAPI_IOCTL_RETURN(0, "GETPARMS", "final");
+	}
+
+	case PPS_IOC_GETCAP:
+	{
+		const struct pps *pps;
+		int may_bits, must_bits;
+
+		AQUIRE_LOCK;
+		pps = (struct pps *) tty->disc_data;
+#ifdef CONFIG_PPSAPI_SERIAL_DEBUG
+		printk(KERN_DEBUG "PPS_IOC_GETCAP: tty/pps = %p/%p\n",
+		       tty, pps);
+#endif /* CONFIG_PPSAPI_SERIAL_DEBUG */
+		if (pps == NULL || pps->magic != PPSCLOCK_MAGIC) {
+			ret = -EOPNOTSUPP;
+			PPSAPI_IOCTL_RETURN(1, "GETCAP", "no PPSCLOCK_MAGIC");
+		}
+		may_bits = pps_allowed_mode(tty->disc_data, filp->f_mode,
+					    &must_bits);
+		RELEASE_LOCK;
+		ret = copy_to_user((int *) arg, &may_bits, sizeof(int));
+		PPSAPI_IOCTL_RETURN(0, "GETCAP", "final");
+	}
+
+	case PPS_IOC_KC_BIND:
+	{
+		struct pps_bind_args parms;
+
+		ret = copy_from_user(&parms, (struct pps_bind_args *) arg,
+				     sizeof(struct pps_bind_args)) ?
+		      -EFAULT : 0;
+		if (ret)
+			PPSAPI_IOCTL_RETURN(0, "KC_BIND", "copy user args");
+		if ((filp->f_mode & FMODE_WRITE) == 0) {
+			ret = -EBADF;
+			PPSAPI_IOCTL_RETURN(0, "KC_BIND", "!FMODE_WRITE");
+		}
+		AQUIRE_LOCK;
+		ret = pps_api_kc_bind(((struct pps *) tty->disc_data),
+				       &parms);
+		PPSAPI_IOCTL_RETURN(1, "KC_BIND", "final");
+	}
+#endif /* CONFIG_PPSAPI_SERIAL */
 	case TIOCSERGETLSR: /* Get line status register */
 		ret = uart_get_lsr_info(state, uarg);
 		break;
@@ -1273,7 +1485,21 @@
 	
 	tty->closing = 0;
 	state->info->tty = NULL;
+#ifdef CONFIG_PPSAPI_SERIAL
+	{
+		struct pps *pps = (struct pps *) tty->disc_data;
 
+		if (pps != NULL && pps->magic == PPSCLOCK_MAGIC) {
+			if (pps_kc_is_bound_to(pps))
+				pps_kc_unbind();
+			kfree(pps);
+			tty->disc_data = NULL;
+#ifdef CONFIG_PPSAPI_SERIAL_DEBUG
+			printk(KERN_DEBUG "uart_close: pps at %p freed\n", pps);
+#endif /* CONFIG_PPSAPI_SERIAL_DEBUG */
+		}
+	}
+#endif
 	if (state->info->blocked_open) {
 		if (state->close_delay)
 			msleep_interruptible(state->close_delay);
Index: linux/include/linux/l_fp.h
diff -u /dev/null linux/include/linux/l_fp.h:1.1.4.2
--- /dev/null	Mon Aug 14 21:09:39 2006
+++ linux/include/linux/l_fp.h	Sat Aug 12 16:51:49 2006
@@ -0,0 +1,205 @@
+/***********************************************************************
+ *								       *
+ * Copyright (c) David L. Mills 1993-1998			       *
+ *								       *
+ * Permission to use, copy, modify, and distribute this software and   *
+ * its documentation for any purpose and without fee is hereby	       *
+ * granted, provided that the above copyright notice appears in all    *
+ * copies and that both the copyright notice and this permission       *
+ * notice appear in supporting documentation, and that the name	       *
+ * University of Delaware not be used in advertising or publicity      *
+ * pertaining to distribution of the software without specific,	       *
+ * written prior permission. The University of Delaware makes no       *
+ * representations about the suitability this software for any	       *
+ * purpose. It is provided "as is" without express or implied	       *
+ * warranty.							       *
+ *								       *
+ **********************************************************************/
+/*
+ * Modification history time_ops.h
+ *
+ * 23 Oct 98    David L. Mills
+ *      Created file
+ *
+ * This file contains macro sets for 64-bit arithmetic and logic
+ * operations in both 32-bit and 64-bit architectures. They are designed
+ * to use the same source code in either architecture, with all
+ * differences confined to this file. Macros adapted from the NTP
+ * distribution ntp_fp.h, original author Dennis Ferguson.
+ */
+#if !defined(NTP_L64)
+
+/*
+ * Double precision macros for 32-bit machines
+ *
+ * A 64-bit fixed-point value is represented in 32-bit architectures as
+ * two 32-bit words in the following format:
+ *
+ *    0		    1		   2		   3
+ *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   |s|			Integral Part			     |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *   |			       Fractional Part			     |
+ *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *
+ */
+typedef long int32;
+typedef unsigned long u_int32;
+typedef struct {			/* basic type in two formats */
+	union {
+		u_int32 Xl_ui;
+		int32 Xl_i;
+	} Ul_i;
+	union {
+		u_int32 Xl_uf;
+		int32 Xl_f;
+	} Ul_f;
+} l_fp;
+
+#define l_ui	Ul_i.Xl_ui		/* unsigned integral part */
+#define l_i	Ul_i.Xl_i		/* signed integral part */
+#define l_uf	Ul_f.Xl_uf		/* unsigned fractional part */
+#define l_f	Ul_f.Xl_f		/* signed fractional part */
+
+#define M_ADD(r_i, r_f, a_i, a_f)	/* r += a */ \
+	do { \
+		register u_int32 lo_tmp; \
+		register u_int32 hi_tmp; \
+		\
+		lo_tmp = ((r_f) & 0xffff) + ((a_f) & 0xffff); \
+		hi_tmp = (((r_f) >> 16) & 0xffff) + (((a_f) >> 16) & \
+		    0xffff); \
+		if (lo_tmp & 0x10000) \
+			 hi_tmp++; \
+		(r_f) = ((hi_tmp & 0xffff) << 16) | (lo_tmp & 0xffff); \
+		\
+		(r_i) += (a_i); \
+		if (hi_tmp & 0x10000) \
+			 (r_i)++; \
+	} while (0)
+
+#define M_SUB(r_i, r_f, a_i, a_f)	/* r -= a */ \
+	do { \
+		register u_int32 lo_tmp; \
+		register u_int32 hi_tmp; \
+		\
+		if ((a_f) == 0) { \
+			 (r_i) -= (a_i); \
+		} else { \
+			lo_tmp = ((r_f) & 0xffff) + ((-((int32)(a_f))) \
+			    & 0xffff); \
+			hi_tmp = (((r_f) >> 16) & 0xffff) \
+			    + (((-((int32)(a_f))) >> 16) & 0xffff); \
+			if (lo_tmp & 0x10000) \
+				 hi_tmp++; \
+			(r_f) = ((hi_tmp & 0xffff) << 16) | (lo_tmp & \
+			    0xffff); \
+			(r_i) += ~(a_i); \
+			if (hi_tmp & 0x10000) \
+				 (r_i)++; \
+		 } \
+	} while (0)
+
+#define M_NEG(v_i, v_f)  /* v = -v */ \
+	do { \
+		 if ((v_f) == 0) \
+			 (v_i) = -((int32)(v_i)); \
+		 else { \
+			 (v_f) = -((int32)(v_f)); \
+			 (v_i) = ~(v_i); \
+		 } \
+	} while (0)
+
+#define M_RSHIFT(v_i, v_f, n)		/* v >>= n */ \
+	do { \
+		if ((v_i) < 0) { \
+			M_NEG((v_i), (v_f)); \
+			if ((n) < 32) { \
+				(v_f) = ((v_f) >> (n)) | ((v_i) << \
+				    (32 - (n))); \
+				(v_i) = (v_i) >> (n); \
+			} else { \
+				(v_f) = (v_i) >> ((n) - 32); \
+				(v_i) = 0; \
+			} \
+			M_NEG((v_i), (v_f)); \
+		} else { \
+			if ((n) < 32) { \
+				(v_f) = ((v_f) >> (n)) | ((v_i) << \
+				    (32 - (n))); \
+				(v_i) = (v_i) >> (n); \
+			} else { \
+				(v_f) = (v_i) >> ((n) - 32); \
+				(v_i) = 0; \
+			} \
+		 } \
+	} while (0)
+
+#define M_MPY(v_i, v_f, m)		/* v *= m */ \
+	do { \
+		register u_int32 a, b, c, d; \
+		if ((v_i) < 0) { \
+			M_NEG((v_i), (v_f)); \
+			d = ((v_f) & 0xffff) * (m); \
+			c = ((v_f) >> 16) * (m) + (d >> 16); \
+			b = ((v_i) & 0xffff) * (m) + (c >> 16); \
+			a = ((v_i) >> 16) * (m) + (b >> 16); \
+			(v_i) = (a << 16) + (b & 0xffff); \
+			(v_f) = (c << 16) + (d & 0xffff); \
+			M_NEG((v_i), (v_f)); \
+		} else { \
+			d = ((v_f) & 0xffff) * (m); \
+			c = ((v_f) >> 16) * (m) + (d >> 16); \
+			b = ((v_i) & 0xffff) * (m) + (c >> 16); \
+			a = ((v_i) >> 16) * (m) + (b >> 16); \
+			(v_i) = (a << 16) + (b & 0xffff); \
+			(v_f) = (c << 16) + (d & 0xffff); \
+		} \
+	} while (0)
+/*
+ * Operations - u,v are 64 bits; a,n are 32 bits.
+ */
+#define L_ADD(v, u)	M_ADD((v).l_i, (v).l_uf, (u).l_i, (u).l_uf)
+#define L_SUB(v, u)	M_SUB((v).l_i, (v).l_uf, (u).l_i, (u).l_uf)
+#define L_ADDHI(v, a)	M_ADD((v).l_i, (v).l_uf, (a), 0)
+#define L_NEG(v)	M_NEG((v).l_i, (v).l_uf)
+#define L_RSHIFT(v, n)	M_RSHIFT((v).l_i, (v).l_uf, n)
+#define L_MPY(v, a)	M_MPY((v).l_i, (v).l_uf, a)
+#define L_CLR(v)	((v).l_i = (v).l_uf = 0)
+#define L_ISNEG(v)	((v).l_ui < 0)
+#define L_LINT(v, a)			/* load integral part */ \
+	do { \
+		 (v).l_i = (a); \
+		 (v).l_uf = 0; \
+	} while (0)
+#define L_GINT(v)	((v).l_i)	/* get integral part */
+
+#else /* NTP_L64 */
+
+/*
+ * Single-precision macros for 64-bit machines
+ *
+ * A 64-bit fixed-point value is represented in 62-bit architectures as
+ * a single 64-bit word, with the implied decimal point to the left of
+ * bit 32.
+ */
+typedef long long l_fp;
+#define L_ADD(v, u)	((v) += (u))
+#define L_SUB(v, u)	((v) -= (u))
+#define L_ADDHI(v, a)	((v) += (long long)(a) << 32)
+#define L_NEG(v)	((v) = -(v))
+#define L_RSHIFT(v, n) \
+	do { \
+		if ((v) < 0) \
+			(v) = -(-(v) >> (n)); \
+		else \
+			(v) = (v) >> (n); \
+	} while (0)
+#define L_MPY(v, a)	((v) *= (a))
+#define L_CLR(v)	((v) = 0)
+#define L_ISNEG(v)	((v) < 0)
+#define L_LINT(v, a)	((v) = (long long)(a) << 32)
+#define L_GINT(v)	((long) ((v) < 0 ? -(-(v) >> 32) : (v) >> 32))
+
+#endif /* NTP_L64 */
Index: linux/include/linux/parport_pc.h
diff -u linux/include/linux/parport_pc.h:1.1.1.5 linux/include/linux/parport_pc.h:1.1.1.5.2.1
--- linux/include/linux/parport_pc.h:1.1.1.5	Wed Aug  9 21:09:05 2006
+++ linux/include/linux/parport_pc.h	Sat Aug 12 16:51:49 2006
@@ -2,6 +2,9 @@
 #define __LINUX_PARPORT_PC_H
 
 #include <asm/io.h>
+#ifdef CONFIG_PPSAPI_PARALLEL
+#include <linux/timepps.h>
+#endif /* CONFIG_PPSAPI_PARALLEL */
 
 /* --- register definitions ------------------------------- */
 
@@ -41,6 +44,9 @@
 	struct pci_dev *dev;
 	struct list_head list;
 	struct parport *port;
+#ifdef CONFIG_PPSAPI_PARALLEL
+	struct pps *pps;	/* PPS API */
+#endif /* CONFIG_PPSAPI_PARALLEL */
 };
 
 struct parport_pc_via_data
Index: linux/include/linux/ppsapi.h
diff -u /dev/null linux/include/linux/ppsapi.h:1.1.4.2
--- /dev/null	Mon Aug 14 21:09:39 2006
+++ linux/include/linux/ppsapi.h	Sat Aug 12 16:51:49 2006
@@ -0,0 +1,64 @@
+/* Implementation to the PPS API described in RFC 2783 (March 2000)
+ *
+ * Copyright (c) 2006 by Ulrich Windl
+ */
+#ifndef _SYS_PPSAPI_H_
+#define _SYS_PPSAPI_H_
+
+#include <linux/timepps.h>
+#include <linux/ioctl.h>
+
+#define PPSCLOCK_MAGIC 0x5003	/* check Documentation/magic-number.txt! */
+
+struct pps_state {
+	pps_params_t	parm;		/* PPS parameters */
+	pps_info_t	info;		/* PPS information */
+	int		cap;		/* PPS capabilities */
+	long		ecount;		/* interpolation offset of event */
+	struct timespec	etime;		/* kernel time of event */
+	wait_queue_head_t ewait;	/* wait queue for event */
+};
+
+struct pps {
+	int     magic;			/* magic number */
+	struct  pps_state       state;	/* data */
+};
+
+/* state variables to bind kernel consumer */
+/* PPS API (RFC 2783): current source and mode for ``kernel consumer'' */
+extern	const struct pps	*pps_kc_hardpps_dev;	/* some unique pointer to device */
+
+extern	int	pps_kc_hardpps_mode;	/* mode bits for kernel consumer */
+
+/* Is any kernel consumer bound? */
+extern	int	pps_kc_is_bound(void);
+
+/* Is any kernel consumer bound to given pps? */
+extern	int	pps_kc_is_bound_to(const struct pps *pps);
+
+/* Bind kernel consumer to given pps with given mode */
+extern	void	pps_kc_bind_to(const struct pps *pps, int mode);
+
+/* Unbind kernel consumer */
+extern	void	pps_kc_unbind(void);
+
+/* Return allowed mode bits for given pps struct, file's writability, and
+ * current user.  Bits set in `*obligatory' must be set.  Returned bits may
+ * be set.
+ */
+extern int pps_allowed_mode(const struct pps *pps, int writable,
+			    int *obligatory);
+
+/* try to set up pps struct at *pps */
+extern int pps_api_create(struct pps **pps, int writable, int capabilities);
+
+/* try to destroy pps struct at *pps */
+extern int pps_api_destroy(struct pps **pps);
+
+/* set pps parameters from *parp */
+extern int pps_api_setparams(struct pps *pps, struct pps_params *parp);
+
+/* bind kernel consumer to pps device according to given bind ags */
+extern int pps_api_kc_bind(struct pps *pps, struct pps_bind_args *bap);
+
+#endif /* _SYS_PPSAPI_H_ */
Index: linux/include/linux/serial_core.h
diff -u linux/include/linux/serial_core.h:1.1.1.2 linux/include/linux/serial_core.h:1.1.1.2.2.1
--- linux/include/linux/serial_core.h:1.1.1.2	Wed Aug  9 21:09:04 2006
+++ linux/include/linux/serial_core.h	Sat Aug 12 16:51:49 2006
@@ -141,6 +141,11 @@
 #include <linux/tty.h>
 #include <linux/mutex.h>
 
+#ifdef CONFIG_PPSAPI_SERIAL
+#include <linux/time.h>
+#include <linux/timepps.h>
+#endif
+
 struct uart_port;
 struct uart_info;
 struct serial_struct;
@@ -456,11 +461,6 @@
 
 	port->icount.dcd++;
 
-#ifdef CONFIG_HARD_PPS
-	if ((port->flags & UPF_HARDPPS_CD) && status)
-		hardpps();
-#endif
-
 	if (info->flags & UIF_CHECK_CD) {
 		if (status)
 			wake_up_interruptible(&info->open_wait);
@@ -520,7 +520,17 @@
 /*
  *	UART_ENABLE_MS - determine if port should enable modem status irqs
  */
-#define UART_ENABLE_MS(port,cflag)	((port)->flags & UPF_HARDPPS_CD || \
+#ifdef CONFIG_PPSAPI_SERIAL
+# define PPSAPI_ON(info)	\
+	({ struct pps *pps = (info)->tty->disc_data; \
+	   pps != NULL && pps->magic == PPSCLOCK_MAGIC && \
+	   (pps->state.parm.mode & ~PPS_TSFMT_TSPEC) != 0; \
+	})
+#else
+# define PPSAPI_ON(info)	0
+#endif
+
+#define UART_ENABLE_MS(port,cflag)	(PPSAPI_ON((port)->info) || \
 					 (cflag) & CRTSCTS || \
 					 !((cflag) & CLOCAL))
 
Index: linux/include/linux/time.h
diff -u linux/include/linux/time.h:1.1.1.4 linux/include/linux/time.h:1.1.1.4.2.1
--- linux/include/linux/time.h:1.1.1.4	Wed Aug  9 21:09:04 2006
+++ linux/include/linux/time.h	Sat Aug 12 16:51:49 2006
@@ -87,10 +87,21 @@
 #define CURRENT_TIME		(current_kernel_time())
 #define CURRENT_TIME_SEC	((struct timespec) { xtime.tv_sec, 0 })
 
+/*BEGIN INTERFACE time.c <-> timer.c */
+#ifdef CONFIG_TIME_INTERPOLATION
+extern void time_interpolator_update(long delta_nsec);
+#else
+#define time_interpolator_update(x)
+#endif
+extern void update_wall_time_one_tick(void);
+extern void second_overflow(void);
+/*END INTERFACE time.c <-> timer.c */
+
 extern void do_gettimeofday(struct timeval *tv);
 extern int do_settimeofday(struct timespec *tv);
 extern int do_sys_settimeofday(struct timespec *tv, struct timezone *tz);
 #define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)
+extern unsigned long do_clock_gettime(clockid_t sysclock, struct timespec *tsp);
 extern long do_utimes(int dfd, char __user *filename, struct timeval *times);
 struct itimerval;
 extern int do_setitimer(int which, struct itimerval *value,
@@ -98,6 +109,10 @@
 extern unsigned int alarm_setitimer(unsigned int seconds);
 extern int do_getitimer(int which, struct itimerval *value);
 extern void getnstimeofday(struct timespec *tv);
+#ifdef CONFIG_NTP_PPS	/* handle PPS pulse */
+extern void hardpps(const struct timespec *p_ts, long nsec);
+#endif
+extern void timevar_init(void);		/* initialize kernel time variables */
 
 extern struct timespec timespec_trunc(struct timespec t, unsigned gran);
 
Index: linux/include/linux/timepps.h
diff -u /dev/null linux/include/linux/timepps.h:1.2.14.2
--- /dev/null	Mon Aug 14 21:09:39 2006
+++ linux/include/linux/timepps.h	Sat Aug 12 16:51:49 2006
@@ -0,0 +1,205 @@
+/* Interface to the PPS API described in RFC 2783 (March 2000)
+ *
+ * Copyright (c) 1999, 2001, 2004, 2006 by Ulrich Windl,
+ * 	based on code by Reg Clemens <reg@dwf.com>
+ *		based on code by Poul-Henning Kamp <phk@FreeBSD.org>
+ * ----------------------------------------------------------------------------
+ * "THE BEER-WARE LICENSE" (Revision 42):
+ * <phk@FreeBSD.org> wrote this file.  As long as you retain this notice you
+ * can do whatever you want with this stuff. If we meet some day, and you think
+ * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp
+ * ---------------------------------------------------------------------------- */
+
+#ifndef _SYS_TIMEPPS_H_
+#define _SYS_TIMEPPS_H_
+
+/* Implementation note: the logical states ``assert'' and ``clear''
+ * are implemented in terms of the chip register, i.e. ``assert''
+ * means the bit is set.
+ */
+
+/*---- 3.2 New data structures ----*/
+#define PPS_API_VERS_1	1		/* draft-05, dated 1999-08 */
+
+typedef int pps_handle_t;	 	/* represents a PPS source */
+
+typedef unsigned long pps_seq_t;	/* sequence number */
+
+typedef struct ntp_fp {
+	unsigned int	integral;
+	unsigned int	fractional;
+} ntp_fp_t;				/* NTP-compatible time stamp */
+
+typedef union pps_timeu {
+	struct timespec	tspec;
+	ntp_fp_t	ntpfp;
+	unsigned long	longpad[3];
+} pps_timeu_t;		/* generic data type to represent time stamps */
+
+typedef struct pps_info {
+	pps_seq_t	assert_sequence;	/* seq. num. of assert event */
+	pps_seq_t	clear_sequence;		/* seq. num. of clear event */
+	pps_timeu_t	assert_tu;		/* time of assert event */
+	pps_timeu_t	clear_tu;		/* time of clear event */
+	int		current_mode;		/* current mode bits */
+} pps_info_t;
+
+#define assert_timestamp        assert_tu.tspec
+#define clear_timestamp         clear_tu.tspec
+
+#define assert_timestamp_ntpfp  assert_tu.ntpfp
+#define clear_timestamp_ntpfp   clear_tu.ntpfp
+
+typedef struct pps_params {
+	int		api_version;	/* API version # */
+	int		mode;		/* mode bits */
+	pps_timeu_t assert_off_tu;	/* offset compensation for assert */
+	pps_timeu_t clear_off_tu;	/* offset compensation for clear */
+} pps_params_t;
+
+#define assert_offset   assert_off_tu.tspec
+#define clear_offset    clear_off_tu.tspec
+
+#define assert_offset_ntpfp     assert_off_tu.ntpfp
+#define clear_offset_ntpfp      clear_off_tu.ntpfp
+
+/*---- 3.3 Mode bit definitions ----*/
+/*-- Device/implementation parameters --*/
+#define PPS_CAPTUREASSERT	0x01	/* capture assert events */
+#define PPS_CAPTURECLEAR	0x02	/* capture clear events */
+#define PPS_CAPTUREBOTH		0x03	/* capture assert and clear events */
+
+#define PPS_OFFSETASSERT	0x10	/* apply compensation for assert ev. */
+#define PPS_OFFSETCLEAR		0x20	/* apply compensation for clear ev. */
+
+#define PPS_CANWAIT		0x100	/* Can we wait for an event? */
+#define PPS_CANPOLL		0x200	/* "This bit is reserved for
+                                           future use." */
+
+/*-- Kernel actions --*/
+#define PPS_ECHOASSERT		0x40	/* feed back assert event to output */
+#define PPS_ECHOCLEAR		0x80	/* feed back clear event to output */
+
+/*-- Timestamp formats --*/
+#define PPS_TSFMT_TSPEC		0x1000	/* select timespec format */
+#define PPS_TSFMT_NTPFP		0x2000	/* select NTP format */
+
+/*---- 3.4.4 New functions: disciplining the kernel timebase ----*/
+/*-- Kernel consumers --*/
+#define PPS_KC_HARDPPS		0	/* hardpps() (or equivalent) */
+#define PPS_KC_HARDPPS_PLL	1	/* hardpps() constrained to
+					   use a phase-locked loop */
+#define PPS_KC_HARDPPS_FLL	2	/* hardpps() constrained to
+					   use a frequency-locked loop */
+
+/*------ Here begins the implementation-specific part! ------*/
+struct pps_fetch_args {
+	int		tsformat;
+	struct timespec	timeout;
+	pps_info_t	pps_info_buf;
+};
+
+struct pps_bind_args {
+	int		tsformat;	/* format of time stamps */
+	int		edge;		/* selected event type */
+	int		consumer;	/* selected kernel consumer */
+};
+
+/* check Documentation/ioctl-number.txt! */
+#define PPS_IOC_CREATE		_IO('1', 1)
+#define PPS_IOC_DESTROY		_IO('1', 2)
+#define PPS_IOC_SETPARMS	_IOW('1', 3, pps_params_t)
+#define PPS_IOC_GETPARMS	_IOR('1', 4, pps_params_t)
+#define PPS_IOC_GETCAP		_IOR('1', 5, int)
+#define PPS_IOC_FETCH		_IOWR('1', 6, struct pps_fetch_args)
+#define PPS_IOC_KC_BIND		_IOW('1', 7, struct pps_bind_args)
+
+#ifndef __KERNEL__
+
+#include	<sys/ioctl.h>
+
+/*---- 3.4 Functions ----*/
+
+/* create PPS handle from file descriptor */
+static __inline int time_pps_create(int filedes, pps_handle_t *handle)
+{
+	int error;
+
+	error = ioctl(filedes, PPS_IOC_CREATE, 0);
+	if (error < 0) {
+		*handle = -1;
+		return (-1);
+	}
+	*handle = filedes;
+	return (0);
+}
+
+/* release PPS handle */
+static __inline int time_pps_destroy(pps_handle_t handle)
+{
+	return (ioctl(handle, PPS_IOC_DESTROY, 0));
+}
+
+/* set parameters for handle */
+static __inline int time_pps_setparams(pps_handle_t handle,
+				       const pps_params_t *ppsparams)
+{
+	if (ppsparams->api_version != PPS_API_VERS_1) {
+		/* This is ugly, but there was no reasonable consensus
+                   in the API working group.  I require
+                   ``api_version'' to be set!
+		*/
+		((pps_params_t *) ppsparams)->api_version = PPS_API_VERS_1;
+	}
+
+	return (ioctl(handle, PPS_IOC_SETPARMS, ppsparams));
+}
+
+/* get parameters for handle */
+static __inline int time_pps_getparams(pps_handle_t handle,
+				       pps_params_t *ppsparams)
+{
+	return (ioctl(handle, PPS_IOC_GETPARMS, ppsparams));
+}
+
+/* get capabilities for handle */
+static __inline int time_pps_getcap(pps_handle_t handle, int *mode)
+{
+	return (ioctl(handle, PPS_IOC_GETCAP, mode));
+}
+
+/* current event for handle */
+static __inline int time_pps_fetch(pps_handle_t handle, const int tsformat,
+				   pps_info_t *ppsinfobuf,
+				   const struct timespec *timeout)
+{
+	int error;
+	struct pps_fetch_args arg;
+
+	arg.tsformat = tsformat;
+	if (timeout)
+		arg.timeout = *timeout;
+	else	/* wait forever */
+		arg.timeout.tv_sec = arg.timeout.tv_nsec = -1;
+	error = ioctl(handle, PPS_IOC_FETCH, &arg);
+	*ppsinfobuf = arg.pps_info_buf;
+	return (error);
+}
+
+/* specify kernel consumer */
+static __inline int time_pps_kcbind(pps_handle_t handle,
+				    const int kernel_consumer,
+				    const int edge, const int tsformat)
+{
+	int error;
+	struct pps_bind_args arg;
+
+	arg.tsformat = tsformat;
+	arg.edge = edge;
+	arg.consumer = kernel_consumer;
+	error = ioctl(handle, PPS_IOC_KC_BIND, &arg);
+	return(error);
+}
+
+#endif /* !__KERNEL__ */
+#endif /* _SYS_TIMEPPS_H_ */
Index: linux/include/linux/timex.h
diff -u linux/include/linux/timex.h:1.1.1.4 linux/include/linux/timex.h:1.1.1.4.2.1
--- linux/include/linux/timex.h:1.1.1.4	Wed Aug  9 21:09:03 2006
+++ linux/include/linux/timex.h	Sat Aug 12 16:51:49 2006
@@ -1,22 +1,26 @@
-/*****************************************************************************
- *                                                                           *
- * Copyright (c) David L. Mills 1993                                         *
- *                                                                           *
- * Permission to use, copy, modify, and distribute this software and its     *
- * documentation for any purpose and without fee is hereby granted, provided *
- * that the above copyright notice appears in all copies and that both the   *
- * copyright notice and this permission notice appear in supporting          *
- * documentation, and that the name University of Delaware not be used in    *
- * advertising or publicity pertaining to distribution of the software       *
- * without specific, written prior permission.  The University of Delaware   *
- * makes no representations about the suitability this software for any      *
- * purpose.  It is provided "as is" without express or implied warranty.     *
- *                                                                           *
- *****************************************************************************/
+/***********************************************************************
+ *								       *
+ * Copyright (c) David L. Mills 1993-2000			       *
+ *								       *
+ * Permission to use, copy, modify, and distribute this software and   *
+ * its documentation for any purpose and without fee is hereby	       *
+ * granted, provided that the above copyright notice appears in all    *
+ * copies and that both the copyright notice and this permission       *
+ * notice appear in supporting documentation, and that the name        *
+ * University of Delaware not be used in advertising or publicity      *
+ * pertaining to distribution of the software without specific,	       *
+ * written prior permission. The University of Delaware makes no       *
+ * representations about the suitability this software for any	       *
+ * purpose. It is provided "as is" without express or implied	       *
+ * warranty.							       *
+ *								       *
+ **********************************************************************/
 
 /*
  * Modification history timex.h
  *
+ * 17 Nov 98	David L. Mills
+ *	Revised for nanosecond kernel and user interface.
  * 29 Dec 97	Russell King
  *	Moved CLOCK_TICK_RATE, CLOCK_TICK_FACTOR and FINETUNE to asm/timex.h
  *	for ARM machines
@@ -49,6 +53,8 @@
  *      Added new constant NTP_PHASE_LIMIT
  * 2004-08-12    Christoph Lameter
  *      Reworked time interpolation logic
+ * 2006-02-7    Ulrich Windl
+ *      Merge Dave Mills code base with Linux code base
  */
 #ifndef _LINUX_TIMEX_H
 #define _LINUX_TIMEX_H
@@ -61,101 +67,156 @@
 #include <asm/timex.h>
 
 /*
- * SHIFT_KG and SHIFT_KF establish the damping of the PLL and are chosen
- * for a slightly underdamped convergence characteristic. SHIFT_KH
- * establishes the damping of the FLL and is chosen by wisdom and black
- * art.
- *
- * MAXTC establishes the maximum time constant of the PLL. With the
- * SHIFT_KG and SHIFT_KF values given and a time constant range from
- * zero to MAXTC, the PLL will converge in 15 minutes to 16 hours,
- * respectively.
- */
-#define SHIFT_KG 6		/* phase factor (shift) */
-#define SHIFT_KF 16		/* PLL frequency factor (shift) */
-#define SHIFT_KH 2		/* FLL frequency factor (shift) */
-#define MAXTC 6			/* maximum time constant (shift) */
-
-/*
- * The SHIFT_SCALE define establishes the decimal point of the time_phase
- * variable which serves as an extension to the low-order bits of the
- * system clock variable. The SHIFT_UPDATE define establishes the decimal
- * point of the time_offset variable which represents the current offset
- * with respect to standard time. The FINENSEC define represents 1 nsec in
- * scaled units.
- *
- * SHIFT_USEC defines the scaling (shift) of the time_freq and
- * time_tolerance variables, which represent the current frequency
- * offset and maximum frequency tolerance.
- *
- * FINENSEC is 1 ns in SHIFT_UPDATE units of the time_phase variable.
- */
-#define SHIFT_SCALE 22		/* phase scale (shift) */
-#define SHIFT_UPDATE (SHIFT_KG + MAXTC) /* time offset scale (shift) */
-#define SHIFT_USEC 16		/* frequency offset scale (shift) */
-#define FINENSEC (1L << (SHIFT_SCALE - 10)) /* ~1 ns in phase units */
-
-#define MAXPHASE 512000L        /* max phase error (us) */
-#define MAXFREQ (512L << SHIFT_USEC)  /* max frequency error (ppm) */
-#define MINSEC 16L              /* min interval between updates (s) */
-#define MAXSEC 1200L            /* max interval between updates (s) */
-#define	NTP_PHASE_LIMIT	(MAXPHASE << 5)	/* beyond max. dispersion */
-
+ * This header file defines the Network Time Protocol (NTP) interfaces
+ * for user and daemon application programs. These are implemented using
+ * defined syscalls and data structures and require specific kernel
+ * support.
+ *
+ * The original precision time kernels developed from 1993 have an
+ * ultimate resolution of one microsecond; however, the most recent
+ * kernels have an ultimate resolution of one nanosecond. In these
+ * kernels, a ntp_adjtime() syscalls can be used to determine which
+ * resolution is in use and to select either one at any time. The
+ * resolution selected affects the scaling of certain fields in the
+ * ntp_gettime() and ntp_adjtime() syscalls, as described below.
+ *
+ * NAME
+ *	ntp_gettime - NTP user application interface
+ *
+ * SYNOPSIS
+ *	#include <sys/timex.h>
+ *
+ *	int ntp_gettime(struct ntptimeval *tptr);
+ *
+ * DESCRIPTION
+ *	The time returned by ntp_gettime() is in a timeval structure,
+ *	but may be in either microsecond (seconds and microseconds) or
+ *	nanosecond (seconds and nanoseconds) format. The particular
+ *	format in use is determined by the STA_NANO bit of the status
+ *	word returned by the ntp_adjtime() syscall.
+ *
+ * NAME
+ *	ntp_adjtime - NTP daemon application interface
+ *
+ * SYNOPSIS
+ *	#include <sys/timex.h>
+ *
+ *	int ntp_adjtime(struct timex *tptr);
+ *
+ * DESCRIPTION
+ *	Certain fields of the timex structure are interpreted in either
+ *	microseconds or nanoseconds according to the state of the
+ *	STA_NANO bit in the status word. See the description below for
+ *	further information.
+ */
 /*
  * syscall interface - used (mainly by NTP daemon)
  * to discipline kernel clock oscillator
  */
 struct timex {
-	unsigned int modes;	/* mode selector */
-	long offset;		/* time offset (usec) */
-	long freq;		/* frequency offset (scaled ppm) */
-	long maxerror;		/* maximum error (usec) */
-	long esterror;		/* estimated error (usec) */
-	int status;		/* clock command/status */
-	long constant;		/* pll time constant */
-	long precision;		/* clock precision (usec) (read only) */
-	long tolerance;		/* clock frequency tolerance (ppm)
-				 * (read only)
+	unsigned int modes;	/* clock mode bits (wo) */
+	long	offset;		/* time offset (ns/us) (rw) */
+	long	freq;		/* frequency offset (scaled PPM) (rw) */
+	long	maxerror;	/* maximum error (us) (rw) */
+	long	esterror;	/* estimated error (us) (rw) */
+	int	status;		/* clock status bits (rw) */
+	long	constant;	/* poll interval (log2 s) (rw) */
+	long	precision;	/* clock precision (ns/us) (ro) */
+	long	tolerance;	/* clock frequency tolerance (scaled PPM) (ro)
 				 */
-	struct timeval time;	/* (read only) */
-	long tick;		/* (modified) usecs between clock ticks */
 
-	long ppsfreq;           /* pps frequency (scaled ppm) (ro) */
-	long jitter;            /* pps jitter (us) (ro) */
+	/*----BEGIN Linux extensions (part 1) */
+	/* Depending on whether ``NTP_NANO'' is defined when including
+	 * this file, the same memory location can be accessed under
+	 * two different names.  ``STA_NANO'' at runtime should
+	 * correspond with ``NTP_NANO'' at compilation time.
+	 */
+#ifdef NTP_NANO
+	struct timespec time;	/* current time (ns) (ro) */
+#else
+	struct timeval time;	/* current time (us) (ro) */
+#endif /* NTP_NANO */
+	long	tick;		/* (modified) usecs between clock ticks (rw) */
+	/*----END Linux extensions (part 1) */
+
+	long ppsfreq;           /* PPS frequency (scaled PPM) (ro) */
+	long jitter;            /* PPS jitter (ns/us) (ro) */
 	int shift;              /* interval duration (s) (shift) (ro) */
-	long stabil;            /* pps stability (scaled ppm) (ro) */
+	long stabil;            /* PPS stability (scaled PPM) (ro) */
 	long jitcnt;            /* jitter limit exceeded (ro) */
 	long calcnt;            /* calibration intervals (ro) */
 	long errcnt;            /* calibration errors (ro) */
 	long stbcnt;            /* stability limit exceeded (ro) */
 
+	/*----BEGIN Linux extensions (part 2) */
+	/* This is a fixed block with some reserved space (12 * sizeof(int))
+	 * initially. Now we add new stuff, replacing those placeholders
+	 * unused so far. Yes, it's ugly, but it's binary compatible
+	 * (where sizeof(int) == sizeof(long)).
+	 */
+	long	tai;		/* TAI offset */
+	int  :32; int  :32; int  :32;
+	int	tickadj;	/* tickadj (us) (rw) -- extension by UW */
+	int  :32; int  :32; int  :32;
 	int  :32; int  :32; int  :32; int  :32;
-	int  :32; int  :32; int  :32; int  :32;
-	int  :32; int  :32; int  :32; int  :32;
+	/*----END Linux extensions (part 2) */
 };
 
+#define	NTP_API		4	/* NTP API version */
 /*
- * Mode codes (timex.mode)
- */
-#define ADJ_OFFSET		0x0001	/* time offset */
-#define ADJ_FREQUENCY		0x0002	/* frequency offset */
-#define ADJ_MAXERROR		0x0004	/* maximum time error */
-#define ADJ_ESTERROR		0x0008	/* estimated time error */
-#define ADJ_STATUS		0x0010	/* clock status */
-#define ADJ_TIMECONST		0x0020	/* pll time constant */
-#define ADJ_TICK		0x4000	/* tick value */
-#define ADJ_OFFSET_SINGLESHOT	0x8001	/* old-fashioned adjtime */
-
-/* xntp 3.4 compatibility names */
-#define MOD_OFFSET	ADJ_OFFSET
-#define MOD_FREQUENCY	ADJ_FREQUENCY
-#define MOD_MAXERROR	ADJ_MAXERROR
-#define MOD_ESTERROR	ADJ_ESTERROR
-#define MOD_STATUS	ADJ_STATUS
-#define MOD_TIMECONST	ADJ_TIMECONST
-#define MOD_CLKB	ADJ_TICK
-#define MOD_CLKA	ADJ_OFFSET_SINGLESHOT /* 0x8000 in original */
+ * The following defines establish the performance envelope of the
+ * kernel discipline loop. Phase or frequency errors greater than
+ * NAXPHASE or MAXFREQ are clamped to these maxima. For update intervals
+ * less than MINSEC, the loop always operates in PLL mode; while, for
+ * update intervals greater than MAXSEC, the loop always operates in FLL
+ * mode. Between these two limits the operating mode is selected by the
+ * STA_FLL bit in the status word.
+ */
+#define MAXPHASE	500000000L /* max phase error (ns) */
+#define MAXFREQ		500000L	/* max freq error (ns/s) */
+#define MINSEC		256	/* min FLL update interval (s) */
+#define MAXSEC		2048	/* max PLL update interval (s) */
+#define NANOSECOND	1000000000L /* nanoseconds in one second */
+#define SCALE_PPM	(65536 / 1000) /* crude ns/s to scaled PPM */
+#define MAXTC		10	/* max time constant */
 
+/*
+ * The following defines and structures define the user interface for
+ * the ntp_gettime() and ntp_adjtime() syscalls.
+ *
+ * Control mode codes (timex.modes)
+ */
+#define MOD_OFFSET	0x0001	/* set time offset */
+#define MOD_FREQUENCY	0x0002	/* set frequency offset */
+#define MOD_MAXERROR	0x0004	/* set maximum time error */
+#define MOD_ESTERROR	0x0008	/* set estimated time error */
+#define MOD_STATUS	0x0010	/* set clock status bits */
+#define MOD_TIMECONST	0x0020	/* set PLL time constant */
+#define MOD_PPSMAX	0x0040	/* set PPS maximum averaging interval */
+#define MOD_TAI		0x0080	/* set TAI offset */
+#define	MOD_MICRO	0x1000	/* select microsecond resolution */
+#define	MOD_NANO	0x2000	/* select nanosecond resolution */
+#define MOD_CLKB	0x4000	/* select clock B */
+#define MOD_CLKA	0x8000	/* select clock A */
+  
+/*
+ * Linux extensions:
+ * Here are the additional bits used to add adjtime() and other related
+ * functionality.  They all start with ``ADJ_''.  Some of these bits were
+ * different in the older kernel's adjtimex(), thus not all old binaries
+ * will work!!! (However those binaries are all system-level)
+ * We've learned the lesson and allocate bits from the other end now!
+ * As the `ADJ_OFFSET_SINGLESHOT' is the candidate that will most likely
+ * cause trouble, take the chance and replace that ugly name with
+ * `ADJ_ADJTIME' (because it's doing adjtime() anyway).
+ */
+#define ADJ_ADJTIME	0x80000000	/* plain old adjtime() */
+#define ADJ_TIMETICK	0x40000000	/* set new value for  `time_tick' */
+#define ADJ_TICKADJ	0x20000000	/* set new value for `tickadj' */
+
+/*FIXME: these should vanish */
+#define ADJ_TICK	_use_ADJ_TIMETICK_instead_	/*FIXME:0x4000 == tick value */
+#define ADJ_OFFSET_SINGLESHOT	_use_ADJ_ADJTIME_instead_	/*FIXME:0x8001 == old-fashioned adjtime */
 
 /*
  * Status codes (timex.status)
@@ -163,7 +224,7 @@
 #define STA_PLL		0x0001	/* enable PLL updates (rw) */
 #define STA_PPSFREQ	0x0002	/* enable PPS freq discipline (rw) */
 #define STA_PPSTIME	0x0004	/* enable PPS time discipline (rw) */
-#define STA_FLL		0x0008	/* select frequency-lock mode (rw) */
+#define STA_FLL		0x0008	/* enable FLL mode (rw) */
 
 #define STA_INS		0x0010	/* insert leap (rw) */
 #define STA_DEL		0x0020	/* delete leap (rw) */
@@ -176,20 +237,43 @@
 #define STA_PPSERROR	0x0800	/* PPS signal calibration error (ro) */
 
 #define STA_CLOCKERR	0x1000	/* clock hardware fault (ro) */
+#define STA_NANO	0x2000	/* resolution (0 = us, 1 = ns) (ro) */
+#define STA_MODE	0x4000	/* mode (0 = PLL, 1 = FLL) (ro) */
+#define STA_CLK		0x8000	/* clock source (0 = A, 1 = B) (ro) */
 
+/* read-only bits */
 #define STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | \
-    STA_PPSERROR | STA_CLOCKERR) /* read-only bits */
+    STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
 
 /*
  * Clock states (time_state)
  */
-#define TIME_OK		0	/* clock synchronized, no leap second */
-#define TIME_INS	1	/* insert leap second */
-#define TIME_DEL	2	/* delete leap second */
+#define TIME_OK		0	/* no leap second warning */
+#define TIME_INS	1	/* insert leap second warning */
+#define TIME_DEL	2	/* delete leap second warning */
 #define TIME_OOP	3	/* leap second in progress */
 #define TIME_WAIT	4	/* leap second has occurred */
-#define TIME_ERROR	5	/* clock not synchronized */
-#define TIME_BAD	TIME_ERROR /* bw compat */
+#define TIME_ERROR	5	/* error (see status word) */
+
+/*
+ * NTP user interface (ntp_gettime()) - used to read kernel clock values
+ *
+ * Note: The time member is in microseconds if STA_NANO is zero and
+ * nanoseconds if not.  Depending on whether ``NANO'' is defined when
+ * including this file, the same memory location can be accessed under two
+ * different names.  ``STA_NANO'' at runtime should correspond with ``NANO''
+ * at compilation time.
+ */
+struct ntptimeval {
+#ifdef NTP_NANO
+	struct timespec time;	/* current time (ns) (ro) */
+#else
+	struct timeval time;	/* current time (us) (ro) */
+#endif /* NTP_NANO */
+	long maxerror;		/* maximum error (us) (ro) */
+	long esterror;		/* estimated error (us) (ro) */
+	long tai;		/* TAI offset */
+};
 
 #ifdef __KERNEL__
 /*
@@ -198,48 +282,14 @@
  * estimated error = NTP dispersion.
  */
 extern unsigned long tick_usec;		/* USER_HZ period (usec) */
-extern unsigned long tick_nsec;		/* ACTHZ          period (nsec) */
-extern int tickadj;			/* amount of adjustment per tick */
-
-/*
- * phase-lock loop variables
- */
-extern int time_state;		/* clock status */
-extern int time_status;		/* clock synchronization status bits */
-extern long time_offset;	/* time adjustment (us) */
-extern long time_constant;	/* pll time constant */
-extern long time_tolerance;	/* frequency tolerance (ppm) */
-extern long time_precision;	/* clock precision (us) */
-extern long time_maxerror;	/* maximum error */
-extern long time_esterror;	/* estimated error */
+extern unsigned long tick_nsec;		/* ACTHZ   period (nsec) */
 
-extern long time_freq;		/* frequency offset (scaled ppm) */
-extern long time_reftime;	/* time at last adjustment (s) */
-
-extern long time_adjust;	/* The amount of adjtime left */
-extern long time_next_adjust;	/* Value for time_adjust at next tick */
-
-/**
- * ntp_clear - Clears the NTP state variables
- *
- * Must be called while holding a write on the xtime_lock
- */
-static inline void ntp_clear(void)
-{
-	time_adjust = 0;		/* stop active adjtime() */
-	time_status |= STA_UNSYNC;
-	time_maxerror = NTP_PHASE_LIMIT;
-	time_esterror = NTP_PHASE_LIMIT;
-}
-
-/**
- * ntp_synced - Returns 1 if the NTP status is not UNSYNC
- *
- */
-static inline int ntp_synced(void)
-{
-	return !(time_status & STA_UNSYNC);
-}
+/* This limit (ns) will set the clock to `unsynchronized' */
+#define	NTP_PHASE_LIMIT	(MAXPHASE << 2)
+  
+extern void set_ntp_unsync(void);	/* tell NTP the clock was set */
+#define ntp_clear	set_ntp_unsync
+extern int ntp_synced(void);		/* is NTP clock in sync? */
 
 /* Required to safely shift negative values */
 #define shift_right(x, s) ({	\
Index: linux/init/Kconfig
diff -u linux/init/Kconfig:1.1.1.2 linux/init/Kconfig:1.1.1.2.2.1
--- linux/init/Kconfig:1.1.1.2	Wed Aug  9 21:07:48 2006
+++ linux/init/Kconfig	Sat Aug 12 16:51:58 2006
@@ -392,6 +392,40 @@
 config OBSOLETE_INTERMODULE
 	tristate
 
+menu "NTP Support"
+
+config NTP_DEBUG
+	bool "Enable debugging NTP kernel code"
+	---help---
+	  Activating this option enables generation of additional debugging
+	  messages, possibly quite a lot.  Those messages are typically only
+	  interesting to kernel hackers, or for trouble-shooting.
+	  You should say no here.
+
+config NTP_PPS
+	bool "Add PPS (Pulse-Per-Second) support for NTP"
+	default n
+	help
+	  Some drivers are able to react on external PPS events by calling a
+	  kernel routine named hardpps().  That routine updates some
+	  time-related kernel variables, which, in turn, may be used by the
+	  NTP algorithms to discipline the kernel clock (regarding frequency
+	  and offset).
+
+	  Typically such PPS pulses are generated by GPS clocks these days.
+	  Usually you don't need this.
+
+config NTP_PPS_DEBUG
+	bool "Enable debugging NTP PPS support"
+	depends on NTP_PPS
+	---help---
+	  Activating this option enables generation of additional debugging
+	  messages, possibly quite a lot.  Those messages are typically only
+	  interesting to kernel hackers, or for trouble-shooting.
+	  You should say no here.
+
+endmenu
+
 menu "Loadable module support"
 
 config MODULES
Index: linux/kernel/time.c
diff -u linux/kernel/time.c:1.1.1.7 linux/kernel/time.c:1.1.1.7.2.2
--- linux/kernel/time.c:1.1.1.7	Wed Aug  9 21:08:49 2006
+++ linux/kernel/time.c	Sat Aug 12 18:21:52 2006
@@ -25,10 +25,14 @@
  * 2004-07-14	 Christoph Lameter
  *	Added getnstimeofday to allow the posix timer functions to return
  *	with nanosecond accuracy
+ * 2006-08-12	Ulrich Windl
+ *	Merge nanokernel implementation for Linux 2.4 with current code.
+ *	Fix ``getnstimeofday()'' to not discard the nanoseconds. Reduce
+ *	code duplication.
  */
+#define	NTP_NANO
 
 #include <linux/module.h>
-#include <linux/timex.h>
 #include <linux/capability.h>
 #include <linux/errno.h>
 #include <linux/smp_lock.h>
@@ -48,6 +52,198 @@
 
 EXPORT_SYMBOL(sys_tz);
 
+unsigned long tick_usec = TICK_USEC; 		/* USER_HZ period (usec) */
+unsigned long tick_nsec = TICK_NSEC;		/* ACTHZ period (nsec) */
+
+/* 
+ * The current time 
+ * wall_to_monotonic is what we need to add to xtime (or xtime corrected 
+ * for sub jiffie times) to get to monotonic time.  Monotonic is pegged
+ * at zero at system boot time, so wall_to_monotonic will be negative,
+ * however, we will ALWAYS keep the tv_nsec part positive so we can use
+ * the usual normalization.
+ */
+struct timespec xtime __attribute__ ((aligned (16)));
+struct timespec wall_to_monotonic __attribute__ ((aligned (16)));
+
+EXPORT_SYMBOL(xtime);
+
+/* kernel time variables */
+static long time_adjust = 0;	/* remaining adjustment for adjtime() */
+
+static int tickadj;		/* number of microseconds to adjust tick_nsec */
+
+/* [extension by UW]: If ``rtc_update'' is positive then update the RTC as
+ * before, but using the value as interval between updates.
+ * ``rtc_update_slave'' will contain the value of ``rtc_update'' if the RTC
+ * clock should be updated.  Once updated, the value will be reset to zero.
+ */
+static	int rtc_update;
+int rtc_update_slave;
+
+/* [extension by UW]: If ``rtc_runs_localtime'' is non-zero, believe
+ * that the RTC uses local time.
+ */
+static	int rtc_runs_localtime = 0;
+
+#define hz HZ			/* (fixed) timer interrupt frequency */
+
+#define	ADJ_SERVED_MODE_BITS	(MOD_OFFSET|MOD_FREQUENCY|MOD_MAXERROR| \
+				 MOD_ESTERROR|MOD_STATUS|MOD_TIMECONST| \
+				 MOD_PPSMAX|MOD_TAI|MOD_MICRO|MOD_NANO| \
+				 MOD_CLKB|MOD_CLKA| \
+				 ADJ_TICKADJ|ADJ_TIMETICK|ADJ_ADJTIME)
+/*
+ * Generic NTP kernel interface
+ *
+ * These routines constitute the Network Time Protocol (NTP) interfaces
+ * for user and daemon application programs. The ntp_gettime() routine
+ * provides the time, maximum error (synch distance) and estimated error
+ * (dispersion) to client user application programs. The ntp_adjtime()
+ * routine is used by the NTP daemon to adjust the system clock to an
+ * externally derived time. The time offset and related variables set by
+ * this routine are used by other routines in this module to adjust the
+ * phase and frequency of the clock discipline loop which controls the
+ * system clock.
+ *
+ * When the kernel time is reckoned directly in nanoseconds (NTP_NANO
+ * defined), the time at each tick interrupt is derived directly from
+ * the kernel time variable. When the kernel time is reckoned in
+ * microseconds, (NTP_NANO undefined), the time is derived from the kernel
+ * time variable together with a variable representing the leftover
+ * nanoseconds at the last tick interrupt. In either case, the current
+ * nanosecond time is reckoned from these values plus an interpolated
+ * value derived by the clock routines in another architecture-specific
+ * module. The interpolation can use either a dedicated counter or a
+ * processor cycle counter (PCC) implemented in some architectures.
+ *
+ * Note that all routines must run with exclusive access to the time
+ * variables.
+ */
+#include <linux/timex.h>
+#include <linux/l_fp.h>
+/*
+ * Phase/frequency-lock loop (PLL/FLL) definitions
+ *
+ * The nanosecond clock discipline uses two variable types, time
+ * variables and frequency variables. Both types are represented as 64-
+ * bit fixed-point quantities with the decimal point between two 32-bit
+ * halves. On a 32-bit machine, each half is represented as a single
+ * word and mathematical operations are done using multiple-precision
+ * arithmetic. On a 64-bit machine, ordinary computer arithmetic is
+ * used.
+ *
+ * A time variable is a signed 64-bit fixed-point number in ns and
+ * fraction. It represents the remaining time offset to be amortized
+ * over succeeding tick interrupts. The maximum time offset is about
+ * 0.5 s and the resolution is about 2.3e-10 ns.
+ *
+ *			1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |s s s|			 ns				   |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |			    fraction				   |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ *
+ * A frequency variable is a signed 64-bit fixed-point number in ns/s
+ * and fraction. It represents the ns and fraction to be added to the
+ * kernel time variable at each second. The maximum frequency offset is
+ * about +-500000 ns/s and the resolution is about 2.3e-10 ns/s.
+ *
+ *			1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |s s s s s s s s s s s s s|	          ns/s			   |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |			    fraction				   |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+/*
+ * The following variables establish the state of the PLL/FLL and the
+ * residual time and frequency offset of the local clock.
+ */
+#define SHIFT_PLL	4	/* PLL loop gain (shift) */
+#define SHIFT_FLL	2	/* FLL loop gain (shift) */
+
+int time_state;			/* clock state */
+/* bit STA_UNSYNC prevents a periodic update of the CMOS clock */
+int time_status;		/* clock status bits */
+long time_constant;		/* poll interval (shift) (s) */
+long time_tai;			/* TAI offset (s) */
+long time_monitor;		/* last time offset scaled (ns) */
+long time_precision = 1;	/* clock precision (ns) */
+long time_maxerror;		/* maximum error (ns) -- [extension by UW] */
+long time_esterror;		/* estimated error (ns) -- [extension by UW] */
+long time_reftime;		/* time at last adjustment (s) */
+l_fp time_offset;		/* time offset (ns) */
+l_fp time_freq;			/* frequency offset (ns/s) */
+l_fp time_adj;			/* tick adjust (ns/s) */
+l_fp time_phase;		/* time phase (ns) */
+
+#ifdef CONFIG_NTP_PPS
+/*
+ * The following variables are used when a pulse-per-second (PPS) signal
+ * is available and connected via a modem control lead. They establish
+ * the engineering parameters of the clock discipline loop when
+ * controlled by the PPS signal.
+ */
+#define PPS_FAVG	2	/* min freq avg interval (s) (shift) */
+#define PPS_FAVGDEF	8	/* default freq avg interval (s) (shift) */
+#define PPS_FAVGMAX	15	/* max freq avg interval (s) (shift) */
+#define PPS_PAVG	4	/* phase avg interval (s) (shift) */
+#define PPS_VALID	120	/* PPS signal watchdog max (s) */
+#define PPS_MAXWANDER	100000	/* max PPS wander (ns/s) */
+#define PPS_POPCORN	2	/* popcorn spike threshold (shift) */
+
+struct pps_var {
+	struct timespec tf[3];	/* phase median filter */
+	l_fp freq;		/* scaled frequency offset (ns/s) */
+	long lastfreq;		/* last scaled freq offset (ns/s) */
+	long fcount;		/* frequency accumulator */
+	long jitter;		/* nominal jitter (ns) */
+	long stabil;		/* nominal stability (scaled ns/s) */
+	long lastsec;		/* time of last calibration (s) */
+	int valid;		/* signal watchdog counter */
+	int shift;		/* interval duration (s) (shift) */
+	int shiftmax;		/* max interval duration (s) (shift) */
+	int intcnt;		/* interval counter */
+
+/*
+ * PPS signal quality monitors
+ */
+	long calcnt;		/* calibration intervals */
+	long jitcnt;		/* jitter limit exceeded */
+	long stbcnt;		/* stability limit exceeded */
+	long errcnt;		/* calibration errors */
+
+/* dynamic tolerance adjustment */
+	long fmin, fmax;	/* PPS frequency minimum and maximum */
+	long frange;		/* frequency range */
+};
+
+static struct pps_var pps;
+#endif	/* CONFIG_NTP_PPS */
+
+/**
+ * set_ntp_unsync - set NTP clock to unsynchronized (e.g. after setting time)
+ *
+ * Must be called while holding a write on the xtime_lock
+ */
+void set_ntp_unsync(void)
+{
+	time_adjust = 0;		/* stop active adjtime() */
+	time_status |= STA_UNSYNC;
+	time_maxerror = NTP_PHASE_LIMIT;
+	time_esterror = NTP_PHASE_LIMIT;
+}
+
+/* is NTP clock in sync? */
+int ntp_synced(void)
+{
+	return (time_status & STA_UNSYNC) == 0;
+}
+
 #ifdef __ARCH_WANT_SYS_TIME
 
 /*
@@ -72,6 +268,183 @@
 }
 
 /*
+ * this routine handles the overflow of the microsecond field
+ *
+ * The tricky bits of code to handle the accurate clock support
+ * were provided by Dave Mills (Mills@UDEL.EDU) of NTP fame.
+ * They were originally developed for SUN and DEC kernels.
+ * All the kudos should go to Dave for this stuff.
+ *
+ */
+void second_overflow(void)
+{
+	l_fp ftemp;		/* 32/64-bit temporary */
+
+	/* Bump the maxerror field */
+#ifdef CONFIG_NTP_PPS
+	time_maxerror += pps.frange;
+#else
+	time_maxerror += MAXFREQ;
+#endif
+	if (time_maxerror > NTP_PHASE_LIMIT) {
+		time_maxerror = NTP_PHASE_LIMIT;
+		time_status |= STA_UNSYNC;
+	}
+
+	if (rtc_update > 0 && (time_status & STA_UNSYNC) == 0)
+		rtc_update_slave = rtc_update;
+	/*
+	 * Leap second processing. If in leap-insert state at the end of the
+	 * day, the system clock is set back one second; if in leap-delete
+	 * state, the system clock is set ahead one second. The microtime()
+	 * routine or external clock driver will insure that reported time is
+	 * always monotonic. The ugly divides should be replaced.
+	 */
+	switch (time_state) {
+	case TIME_OK:	/* no leap second */
+		if (time_status & STA_INS)
+			time_state = TIME_INS;
+		else if (time_status & STA_DEL)
+			time_state = TIME_DEL;
+		break;
+	case TIME_INS:	/* Insert second 23:59:60 following second 23:59:59. */
+		if (!(time_status & STA_INS))
+			time_state = TIME_OK;
+		else if (xtime.tv_sec % 86400 == 0) {
+			xtime.tv_sec--;
+			wall_to_monotonic.tv_sec++;
+			/*FIXME: what's that? (UW) */
+			/*
+			 * The timer interpolator will make time change
+			 * gradually instead of an immediate jump by one second
+			 */
+			time_interpolator_update(-NSEC_PER_SEC);
+			time_state = TIME_OOP;
+			clock_was_set();
+			printk(KERN_NOTICE
+			       "TIME_INS: inserting second 23:59:60 UTC\n");
+		}
+		break;
+	case TIME_DEL:	/* Skip second 23:59:59. */
+		if (!(time_status & STA_DEL))
+			time_state = TIME_OK;
+		else if ((xtime.tv_sec + 1) % 86400 == 0) {
+			xtime.tv_sec++;
+			wall_to_monotonic.tv_sec--;
+			time_tai--;
+			/*
+			 * Use of time interpolator for a gradual change of
+			 * time
+			 */
+			time_interpolator_update(NSEC_PER_SEC);
+			clock_was_set();
+			time_state = TIME_WAIT;
+			printk(KERN_NOTICE
+			       "TIME_DEL: skipping second 23:59:59 UTC\n");
+		}
+		if ((xtime.tv_sec + 1) % 86400 == 0) {
+			xtime.tv_sec++;
+			wall_to_monotonic.tv_sec--;
+			/*
+			 * Use of time interpolator for a gradual change of
+			 * time
+			 */
+			time_interpolator_update(NSEC_PER_SEC);
+			time_state = TIME_WAIT;
+			clock_was_set();
+			printk(KERN_NOTICE "Clock: deleting leap second "
+					"23:59:59 UTC\n");
+		}
+		break;
+	case TIME_OOP:	/* leap second insert in progress */
+		time_tai++;
+		time_state = TIME_WAIT;
+		break;
+	case TIME_WAIT:	/* Wait for status bits to clear. */
+		if (!(time_status & (STA_INS | STA_DEL)))
+			time_state = TIME_OK;
+	}
+
+	/*
+	 * Compute the total time adjustment for the next second in ns. The
+	 * offset is reduced by a factor depending on whether the PPS signal
+	 * is operating. Note that the value is in effect scaled by the clock
+	 * frequency, since the adjustment is added at each tick interrupt.
+	 */
+	ftemp = time_offset;
+#ifdef CONFIG_NTP_PPS
+	if (time_status & STA_PPSTIME && time_status & STA_PPSSIGNAL)
+		L_RSHIFT(ftemp, pps.shift);
+	else
+#endif
+		L_RSHIFT(ftemp, SHIFT_PLL + time_constant);
+	time_adj = ftemp;
+	L_SUB(time_offset, ftemp);
+	L_ADD(time_adj, time_freq);
+	L_ADDHI(time_adj, NSEC_PER_SEC);
+#ifdef	CONFIG_NTP_PPS
+	if (pps.valid > 0)
+		pps.valid--;
+	else
+		time_status &= ~(STA_PPSSIGNAL | STA_PPSJITTER |
+				 STA_PPSWANDER | STA_PPSERROR);
+#endif
+#if 0 /*FIXME: What about this? (UW)*/
+#if HZ == 100
+	/*
+	 * Compensate for (HZ==100) != (1 << SHIFT_HZ).  Add 25% and 3.125% to
+	 * get 128.125; => only 0.125% error (p. 14)
+	 */
+	time_adj += shift_right(time_adj, 2) + shift_right(time_adj, 5);
+#endif
+#if HZ == 250
+	/*
+	 * Compensate for (HZ==250) != (1 << SHIFT_HZ).  Add 1.5625% and
+	 * 0.78125% to get 255.85938; => only 0.05% error (p. 14)
+	 */
+	time_adj += shift_right(time_adj, 6) + shift_right(time_adj, 7);
+#endif
+#if HZ == 1000
+	/*
+	 * Compensate for (HZ==1000) != (1 << SHIFT_HZ).  Add 1.5625% and
+	 * 0.78125% to get 1023.4375; => only 0.05% error (p. 14)
+	 */
+	time_adj += shift_right(time_adj, 6) + shift_right(time_adj, 7);
+#endif
+#endif
+}
+
+/* in the NTP reference this is called "hardclock()" */
+void update_wall_time_one_tick(void)
+{
+	long ltemp, time_update = time_adjust;
+
+	if (unlikely(time_update != 0)) {	/* doing adjtime() */
+		/* We are doing an adjtime() thing.
+		 * Clamp time_update within bounds (-tickadj .. tickadj).
+		 */
+		if (time_update > tickadj)
+			time_update = tickadj;
+		else if (time_update < -tickadj)
+			time_update = -tickadj;
+	     
+		/* Update remaining adjustment */
+		time_adjust -= time_update;
+		time_update *= 1000;	/* convert microseconds to nanoseconds */
+	}
+	/*
+	 * Update the nanosecond and microsecond clocks. If the phase
+	 * increment exceeds the tick period, update the clock phase.
+	 */
+	L_ADD(time_phase, time_adj);
+	ltemp = L_GINT(time_phase) / hz;
+	time_update += ltemp;
+	L_ADDHI(time_phase, -ltemp * hz);
+	xtime.tv_nsec += time_update;
+	time_interpolator_update(time_update);
+}
+
+/*
  * sys_stime() can be implemented in user-level using
  * sys_settimeofday().  Is this for backwards compatibility?  If so,
  * why not move it into the appropriate arch directory (for those
@@ -202,6 +575,35 @@
 	return do_sys_settimeofday(tv ? &new_ts : NULL, tz ? &new_tz : NULL);
 }
 
+/*
+ * The following variables are used when a pulse-per-second (PPS) signal
+ * is available and connected via a modem control lead. They establish
+ * the engineering parameters of the clock discipline loop when
+ * controlled by the PPS signal.
+ */
+#define PPS_FAVG	2	/* min freq avg interval (s) (shift) */
+#define PPS_FAVGDEF	8	/* default freq avg interval (s) (shift) */
+#define PPS_FAVGMAX	15	/* max freq avg interval (s) (shift) */
+#define PPS_PAVG	4	/* phase avg interval (s) (shift) */
+#define PPS_VALID	120	/* PPS signal watchdog max (s) */
+#define PPS_MAXWANDER	100000	/* max PPS wander (ns/s) */
+#define PPS_POPCORN	2	/* popcorn spike threshold (shift) */
+
+long pps_offset;		/* pps time offset (us) */
+long pps_jitter;		/* time dispersion (jitter) (us) */
+
+long pps_freq;			/* frequency offset (scaled ppm) */
+long pps_stabil;		/* frequency dispersion (scaled ppm) */
+
+long pps_valid;			/* pps signal watchdog counter */
+
+int pps_shift = PPS_FAVG;	/* interval duration (s) (shift) */
+
+long pps_jitcnt;		/* jitter limit exceeded */
+long pps_calcnt;		/* calibration intervals */
+long pps_errcnt;		/* calibration errors */
+long pps_stbcnt;		/* stability limit exceeded */
+
 /* we call this to notify the arch when the clock is being
  * controlled.  If no such arch routine, do nothing.
  */
@@ -210,168 +612,737 @@
 	return;
 }
 
-/* adjtimex mainly allows reading (and writing, if superuser) of
- * kernel time-keeping variables. used by xntpd.
+#ifdef	CONFIG_NTP_PPS
+/* this is an ugly work-around implementation for the overly
+ * complicated existing POSIX routines
+ */
+unsigned long do_clock_gettime(int unused_dummy, struct timespec *ts)
+{
+	getnstimeofday(ts);
+	return ts->tv_nsec % tick_nsec;
+}
+EXPORT_SYMBOL(do_clock_gettime);
+
+/*
+ * hardpps() - discipline CPU clock oscillator to external PPS signal
+ *
+ * This routine is called at each PPS interrupt in order to discipline
+ * the CPU clock oscillator to the PPS signal. There are two independent
+ * first-order feedback loops, one for the phase, the other for the
+ * frequency. The phase loop measures and grooms the PPS phase offset
+ * and leaves it in a handy spot for the seconds overflow routine. The
+ * frequency loop averages successive PPS phase differences and
+ * calculates the PPS frequency offset, which is also processed by the
+ * seconds overflow routine. The code requires the caller to capture the
+ * time and architecture-dependent hardware counter values in
+ * nanoseconds at the on-time PPS signal transition.
+ *
+ * Note that, on some Unix systems this routine runs at an interrupt
+ * priority level higher than the timer interrupt routine second_overflow().
+ * Therefore, the variables used are distinct from the second_overflow()
+ * variables, except for the actual time and frequency variables, which
+ * are determined by this routine and updated atomically.
+ */
+void hardpps(const struct timespec *p_ts, long nsec)
+{
+	static	long pps_lastcount;	/* last counter offset */
+	unsigned long flags;
+	long u_sec, u_nsec, v_nsec;	/* multi-purpose temps */
+	l_fp ftemp;
+	int fr_upd;			/* update frequency range? */
+
+	write_seqlock_irqsave(&xtime_lock, flags);
+	/*
+	 * The signal is first processed by a range gate and frequency
+	 * discriminator. The range gate rejects noise spikes outside
+	 * the range +-500 us. The frequency discriminator rejects input
+	 * signals with apparent frequency outside the range 1 +-500
+	 * PPM. If two hits occur in the same second, we ignore the
+	 * later hit; if not and a hit occurs outside the range gate,
+	 * keep the later hit for later comparison, but do not process
+	 * it.
+	 */
+	time_status |= STA_PPSJITTER;
+	time_status &= ~(STA_PPSWANDER | STA_PPSERROR);
+	u_sec = p_ts->tv_sec;
+	u_nsec = p_ts->tv_nsec;		/* relative position around second */
+	if (u_nsec >= (NSEC_PER_SEC >> 1)) {
+		u_nsec -= NSEC_PER_SEC;
+		u_sec++;
+	}
+	/* compute relative offset to last position */
+	v_nsec = u_nsec - pps.tf[0].tv_nsec;
+	if (unlikely(u_sec == pps.tf[0].tv_sec &&
+		     v_nsec < NSEC_PER_SEC - MAXFREQ)) {
+#ifdef CONFIG_NTP_PPS_DEBUG
+		printk(KERN_INFO
+		       "hardpps(%ld.%08ld): early pulse, delta = %ld ns\n",
+		       p_ts->tv_sec % 10, p_ts->tv_nsec, v_nsec);
+#endif
+		goto done;			/* ignore early pulse */
+	}
+	pps.tf[2] = pps.tf[1];
+	pps.tf[1] = pps.tf[0];
+	pps.tf[0].tv_sec = u_sec;
+	pps.tf[0].tv_nsec = u_nsec;
+
+	/*
+	 * Compute the difference between the current and previous
+	 * counter values. If the difference exceeds 0.5 s, assume it
+	 * has wrapped around, so correct 1.0 s. If the result exceeds
+	 * the tick interval, the sample point has crossed a tick
+	 * boundary during the last second, so correct the tick. Very
+	 * intricate.
+	 */
+	u_nsec = nsec - pps_lastcount;
+	pps_lastcount = nsec;
+	if (u_nsec > (tick_nsec >> 1))
+		u_nsec -= tick_nsec;
+	else if (u_nsec < -(tick_nsec >> 1))
+		u_nsec += tick_nsec;
+	pps.fcount += u_nsec;
+	if (unlikely(v_nsec > MAXFREQ || v_nsec < -MAXFREQ)) {
+#ifdef CONFIG_NTP_PPS_DEBUG
+		printk(KERN_INFO "hardpps: bad pulse, delta = %ld ns\n",
+		       v_nsec);
+		printk(KERN_DEBUG
+		       "hardpps: last=%ld:%09ld, this=%ld:%09ld (%ld nsec)\n",
+		       pps.tf[1].tv_sec % 10, pps.tf[1].tv_nsec,
+		       pps.tf[0].tv_sec % 10, pps.tf[0].tv_nsec, u_nsec);
+#endif
+		/* Not in reference implementation: The pulse is already in
+		 * the filter stages, therefore we can't simply ignore it.
+		 * Instead we discard the current data and restart the
+		 * calibration interval.  Don't increment jitcnt.
+		 */
+		pps.lastsec = pps.tf[0].tv_sec;
+		pps.fcount = 0;
+		if (--pps.intcnt <= -4) {
+			pps.intcnt = -4;
+			if (pps.shift > PPS_FAVG) {
+				pps.shift--;
+				pps.intcnt = 0;
+			}
+		}
+		goto done;
+	}
+	pps.valid = PPS_VALID;
+	time_status |= STA_PPSSIGNAL;
+	time_status &= ~STA_PPSJITTER;
+
+	/*
+	 * A three-stage median filter is used to help denoise the PPS
+	 * time. The median sample becomes the time offset estimate; the
+	 * difference between the other two samples becomes the time
+	 * dispersion (jitter) estimate.
+	 */
+	if (pps.tf[0].tv_nsec > pps.tf[1].tv_nsec) {
+		if (pps.tf[1].tv_nsec > pps.tf[2].tv_nsec) {
+			v_nsec = pps.tf[1].tv_nsec;	/* 0 1 2 */
+			u_nsec = pps.tf[0].tv_nsec - pps.tf[2].tv_nsec;
+		} else if (pps.tf[2].tv_nsec > pps.tf[0].tv_nsec) {
+			v_nsec = pps.tf[0].tv_nsec;	/* 2 0 1 */
+			u_nsec = pps.tf[2].tv_nsec - pps.tf[1].tv_nsec;
+		} else {
+			v_nsec = pps.tf[2].tv_nsec;	/* 0 2 1 */
+			u_nsec = pps.tf[0].tv_nsec - pps.tf[1].tv_nsec;
+		}
+	} else {
+		if (pps.tf[1].tv_nsec < pps.tf[2].tv_nsec) {
+			v_nsec = pps.tf[1].tv_nsec;	/* 2 1 0 */
+			u_nsec = pps.tf[2].tv_nsec - pps.tf[0].tv_nsec;
+		} else  if (pps.tf[2].tv_nsec < pps.tf[0].tv_nsec) {
+			v_nsec = pps.tf[0].tv_nsec;	/* 1 0 2 */
+			u_nsec = pps.tf[1].tv_nsec - pps.tf[2].tv_nsec;
+		} else {
+			v_nsec = pps.tf[2].tv_nsec;	/* 1 2 0 */
+			u_nsec = pps.tf[1].tv_nsec - pps.tf[0].tv_nsec;
+		}
+	}
+
+	/*
+	 * Nominal jitter is due to PPS signal noise and interrupt
+	 * latency. If it exceeds the popcorn threshold, the sample is
+	 * discarded. otherwise, if so enabled, the time offset is
+	 * updated. We can tolerate a modest loss of data here without
+	 * much degrading time accuracy.
+	 */
+	if (unlikely(u_nsec > (pps.jitter << PPS_POPCORN))) {
+#ifdef CONFIG_NTP_PPS_DEBUG
+		printk(KERN_INFO
+		       "hardpps: PPSJITTER: jitter=%ld, limit=%ld\n",
+		       u_nsec, (pps.jitter << PPS_POPCORN));
+#endif
+		time_status |= STA_PPSJITTER;
+		pps.jitcnt++;
+	} else if (time_status & STA_PPSTIME) {
+		time_monitor = -v_nsec;
+		L_LINT(time_offset, time_monitor);
+		time_adjust = 0;	/* cancel running adjtime() */
+#ifdef CONFIG_NTP_PPS_DEBUG
+		printk(KERN_DEBUG
+		       "hardpps: PPSTIME monitor=%ld, jitter=%ld\n",
+		       time_monitor, pps.jitter);
+#endif
+	}
+	pps.jitter += (u_nsec - pps.jitter) >> PPS_FAVG;
+	u_sec = pps.tf[0].tv_sec - pps.lastsec;
+	/* (The first pulse after a pause will always end a calibration
+	 * interval.  The workaround is probably not worth the extra cycles.)
+	 */
+	if (likely(u_sec < (1 << pps.shift)))
+		goto done;
+	/*
+	 * At the end of the calibration interval the difference between
+	 * the first and last counter values becomes the scaled
+	 * frequency. It will later be divided by the length of the
+	 * interval to determine the frequency update. If the frequency
+	 * exceeds a sanity threshold, or if the actual calibration
+	 * interval is not equal to the expected length, the data are
+	 * discarded. We can tolerate a modest loss of data here without
+	 * degrading frequency accuracy.
+	 */
+	pps.calcnt++;
+	v_nsec = -pps.fcount;
+	pps.lastsec = pps.tf[0].tv_sec;
+	pps.fcount = 0;
+	u_nsec = MAXFREQ << pps.shift;
+	if (unlikely(v_nsec > u_nsec || v_nsec < -u_nsec ||
+		     u_sec != (1 << pps.shift))) {
+#ifdef CONFIG_NTP_PPS_DEBUG
+		printk(KERN_NOTICE
+		       "hardpps: PPSERROR limit=%ld, fcount=%ld, len=%ld\n",
+		       u_nsec, v_nsec, u_sec);
+#endif
+		time_status |= STA_PPSERROR;
+		pps.errcnt++;
+		/* not in reference implementation */
+		if (--pps.intcnt <= -4) {
+			pps.intcnt = -4;
+			if (pps.shift > PPS_FAVG) {
+				pps.shift--;
+				pps.intcnt = 0;
+			}
+		}
+		goto done;
+	}
+
+	/*
+	 * Here the raw frequency offset and wander (stability) is
+	 * calculated. If the wander is less than the wander threshold
+	 * for four consecutive averaging intervals, the interval is
+	 * doubled; if it is greater than the threshold for four
+	 * consecutive intervals, the interval is halved. The scaled
+	 * frequency offset is converted to frequency offset. The
+	 * stability metric is calculated as the average of recent
+	 * frequency changes, but is used only for performance
+	 * monitoring.
+	 */
+	L_LINT(ftemp, v_nsec);
+	L_RSHIFT(ftemp, pps.shift);
+	L_SUB(ftemp, pps.freq);
+	u_nsec = L_GINT(ftemp);
+	fr_upd = 0;
+#ifdef CONFIG_NTP_PPS_DEBUG
+	printk(KERN_INFO "hardpps: new frequency %ld >> %d == %ld\n",
+	       v_nsec, pps.shift, v_nsec >> pps.shift);
+#endif
+	/* Not in reference implementation: Use dynamic limit (i.e. stability)
+	 * for maximum wander. Approximate SCALE_PPM (65536 / 1000) by 64.
+	 */
+	v_nsec = (pps.stabil >> 6) << PPS_POPCORN;
+	if (unlikely(v_nsec == 0 || v_nsec > PPS_MAXWANDER))
+		v_nsec = PPS_MAXWANDER;
+#ifdef CONFIG_NTP_PPS_DEBUG
+	printk(KERN_DEBUG "hardpps: frequency change=%ld (limit %ld)\n",
+	       u_nsec, v_nsec);
+#endif
+	if (unlikely(u_nsec > v_nsec || u_nsec < -v_nsec)) {
+#ifdef CONFIG_NTP_PPS_DEBUG
+		printk(KERN_NOTICE
+		       "hardpps: PPSWANDER: change=%ld, limit=%ld, shift=%d\n",
+		       u_nsec, v_nsec, pps.shift);
+#endif
+		L_LINT(ftemp, u_nsec > 0 ? v_nsec : -v_nsec);
+		time_status |= STA_PPSWANDER;
+		pps.stbcnt++;
+		if (--pps.intcnt <= -4) {
+			pps.intcnt = -4;
+			if (pps.shift > PPS_FAVG) {
+				pps.shift--;
+				pps.intcnt = 0;
+			}
+		}
+	} else {	/* good sample */
+		/* Update frequency error estimate in rather stable
+                   situations.
+		*/
+		if (pps.shift > PPS_FAVG + 1)
+			fr_upd = 1;
+		if (++pps.intcnt >= 4) {
+			pps.intcnt = 4;
+			if (pps.shift < pps.shiftmax) {
+				pps.shift++;
+				pps.intcnt = 0;
+			}
+		}
+	}
+	if (u_nsec < 0)
+		u_nsec = -u_nsec;
+	pps.stabil += (u_nsec * SCALE_PPM - pps.stabil) >> PPS_FAVG;
+
+	/*
+	 * The PPS frequency is recalculated and clamped to the maximum
+	 * MAXFREQ. If enabled, the system clock frequency is updated as
+	 * well.
+	 */
+	L_ADD(pps.freq, ftemp);
+	u_nsec = L_GINT(pps.freq);
+	if (unlikely(u_nsec > MAXFREQ))
+		L_LINT(pps.freq, MAXFREQ);
+	else if (unlikely(u_nsec < -MAXFREQ))
+		L_LINT(pps.freq, -MAXFREQ);
+	else if (fr_upd) {
+		/* pps.frange is the maximum difference of the
+		   observed frequency values including (in-)stability.
+		   Otherwise it's a pessimistic worst-case estimate.
+		*/
+		if (unlikely(u_nsec - (pps.stabil >> 7) < pps.fmin))
+			pps.fmin = u_nsec - (pps.stabil >> 7);
+		if (unlikely(u_nsec + (pps.stabil >> 7) > pps.fmax))
+			pps.fmax = u_nsec + (pps.stabil >> 7);
+		pps.frange = pps.fmax - pps.fmin;
+		if (unlikely(pps.frange > MAXFREQ)) {
+			printk(KERN_WARNING
+			       "hardpps: pps.frange %ld exceeded MAXFREQ\n",
+			       pps.frange);
+#ifdef CONFIG_NTP_PPS_DEBUG
+			printk(KERN_INFO "hardpps: frange=%ld (%ld:%ld)\n",
+			       pps.frange, pps.fmin, pps.fmax);
+#endif
+			/* force recalculation on next update */
+			pps.fmin = MAXFREQ;
+			pps.fmax = -MAXFREQ;
+			pps.frange = MAXFREQ;
+		}
+	}
+#ifdef CONFIG_NTP_PPS_DEBUG
+	printk(KERN_INFO "hardpps: new pps.freq=%ld (add %ld)\n",
+	       L_GINT(pps.freq), L_GINT(ftemp));
+#endif
+	if ((time_status & STA_PPSFREQ) != 0 &&
+	    (time_status & STA_FREQHOLD) == 0)
+	{
+		time_freq = pps.freq;
+#if 0 /*XXX: MISSING */
+		update_nanoscale(tick_nsec * hz - NSEC_PER_SEC +
+				 L_GINT(time_freq));
+#endif
+	}
+done:
+	write_sequnlock_irqrestore(&xtime_lock, flags);
+}
+
+EXPORT_SYMBOL(hardpps);
+#endif	/* CONFIG_NTP_PPS */
+
+/*
+ * hardupdate() - local clock update
+ *
+ * This routine is called by adjtimex() to update the local clock
+ * phase and frequency. The implementation is of an adaptive-parameter,
+ * hybrid phase/frequency-lock loop (PLL/FLL). The routine computes new
+ * time and frequency offset estimates for each call. If the kernel PPS
+ * discipline code is configured (CONFIG_NTP_PPS), the PPS signal itself
+ * determines the new time offset, instead of the calling argument.
+ * Presumably, calls to ntp_adjtime() occur only when the caller
+ * believes the local clock is valid within some bound (+-128 ms with
+ * NTP). If the caller's time is far different than the PPS time, an
+ * argument will ensue, and it's not clear who will lose.
+ *
+ * For uncompensated quartz crystal oscillators and nominal update
+ * intervals less than 256 s, operation should be in phase-lock mode,
+ * where the loop is disciplined to phase. For update intervals greater
+ * than 1024 s, operation should be in frequency-lock mode, where the
+ * loop is disciplined to frequency. Between 256 s and 1024 s, the mode
+ * is selected by the STA_MODE status bit.
+ */
+static inline void hardupdate(long offset)
+{
+	long mtemp;
+	l_fp ftemp;
+
+	/*
+	 * Select how the phase is to be controlled and from which
+	 * source. If the PPS signal is present and enabled to
+	 * discipline the time, the PPS offset is used; otherwise, the
+	 * argument offset is used.
+	 */
+	if (!(time_status & STA_PLL))
+		return;
+	if (!(time_status & STA_PPSTIME && time_status & STA_PPSSIGNAL)) {
+		if (offset > MAXPHASE)
+			time_monitor = MAXPHASE;
+		else if (offset < -MAXPHASE)
+			time_monitor = -MAXPHASE;
+		else
+			time_monitor = offset;
+		L_LINT(time_offset, time_monitor);
+	}
+ 
+	/*
+	 * Select how the frequency is to be controlled and in which
+	 * mode (PLL or FLL). If the PPS signal is present and enabled
+	 * to discipline the frequency, the PPS frequency is used;
+	 * otherwise, the argument offset is used to compute it.
+	 */
+	if (time_status & STA_PPSFREQ && time_status & STA_PPSSIGNAL) {
+		time_reftime = xtime.tv_sec;
+		return;
+	}
+	if (time_status & STA_FREQHOLD || time_reftime == 0)
+		time_reftime = xtime.tv_sec;
+	mtemp = xtime.tv_sec - time_reftime;
+	L_LINT(ftemp, time_monitor);
+	L_RSHIFT(ftemp, (SHIFT_PLL + 2 + time_constant) << 1);
+	L_MPY(ftemp, mtemp);
+	L_ADD(time_freq, ftemp);
+	time_status &= ~STA_MODE;
+	if (mtemp >= MINSEC && (time_status & STA_FLL || mtemp > MAXSEC)) {
+		L_LINT(ftemp, (time_monitor << 4) / mtemp);
+		L_RSHIFT(ftemp, SHIFT_FLL + 4);
+		L_ADD(time_freq, ftemp);
+		time_status |= STA_MODE;
+	}
+	time_reftime = xtime.tv_sec;
+	if (L_GINT(time_freq) > MAXFREQ)
+		L_LINT(time_freq, MAXFREQ);
+	else if (L_GINT(time_freq) < -MAXFREQ)
+		L_LINT(time_freq, -MAXFREQ);
+#if 0 /*XXX: MISSING */
+	update_nanoscale(tick_nsec * hz - NSEC_PER_SEC + L_GINT(time_freq));
+#endif
+}
+
+/* adjtimex() mainly allows reading (and writing, if superuser) of
+ * kernel time-keeping variables. Used by NTP.
  */
 int do_adjtimex(struct timex *txc)
 {
-        long ltemp, mtemp, save_adjust;
+        long save_adjust;
 	int result;
 
 	/* In order to modify anything, you gotta be super-user! */
 	if (txc->modes && !capable(CAP_SYS_TIME))
 		return -EPERM;
 		
+#if 1	/* complain about mode bits that aren't implemented */
+	if (unlikely(txc->modes & ~ADJ_SERVED_MODE_BITS)) {
+		static int complain = 7;
+		if (complain > 0) {
+			--complain;
+			printk(KERN_NOTICE
+			       "adjtimex: %s used unsupported ADJ bits 0x%x\n",
+			       current->comm,
+			       txc->modes & ~ADJ_SERVED_MODE_BITS);
+		}
+	}
+#endif
 	/* Now we validate the data before disabling interrupts */
 
-	if ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT)
-	  /* singleshot must not be used with any other mode bits */
-		if (txc->modes != ADJ_OFFSET_SINGLESHOT)
+	if ((txc->modes & ADJ_ADJTIME) == ADJ_ADJTIME)
+		/* adjtime() must not be used with any other mode bits */
+		if (txc->modes != ADJ_ADJTIME)
 			return -EINVAL;
 
-	if (txc->modes != ADJ_OFFSET_SINGLESHOT && (txc->modes & ADJ_OFFSET))
-	  /* adjustment Offset limited to +- .512 seconds */
-		if (txc->offset <= - MAXPHASE || txc->offset >= MAXPHASE )
+	if (txc->modes != ADJ_ADJTIME && (txc->modes & MOD_OFFSET))
+		/* adjustment Offset limited to +- .512 seconds */
+		if (txc->offset <= -MAXPHASE || txc->offset >= MAXPHASE)
 			return -EINVAL;	
 
-	/* if the quartz is off by more than 10% something is VERY wrong ! */
-	if (txc->modes & ADJ_TICK)
-		if (txc->tick <  900000/USER_HZ ||
-		    txc->tick > 1100000/USER_HZ)
+	/* if the clock's frequency is off by more than 10% something is VERY
+	 * wrong!
+	 */
+	if (txc->modes & ADJ_TIMETICK)
+		if (unlikely(txc->tick <  900000/USER_HZ ||
+			     txc->tick > 1100000/USER_HZ))
 			return -EINVAL;
 
+#if 1	/* Map old method to new one; this will vanish soon */
+#define	OLD_ADJTIME	(MOD_OFFSET|MOD_CLKA)
+	if (unlikely((txc->modes & OLD_ADJTIME) == OLD_ADJTIME)) {
+		static int complain = 7;
+		txc->modes ^= OLD_ADJTIME;
+		txc->modes |= ADJ_ADJTIME;
+		if (complain > 0) {
+			--complain;
+			printk(KERN_WARNING
+			       "adjtime: %s used obsolete "
+			       "ADJ_OFFSET_SINGLESHOT instead of ADJ_ADJTIME\n",
+			       current->comm);
+		}
+	}
+#undef	OLD_ADJTIME
+#if 1	/* Establish extra warnings for older applications */
+#define	OLD_ADJTICK	(MOD_CLKB)
+	if (unlikely((txc->modes & OLD_ADJTICK) == OLD_ADJTICK)) {
+		static int complain = 5;
+		if (complain > 0) {
+			--complain;
+			printk(KERN_NOTICE
+			       "adjtimex: %s may be using obsolete ADJ_TICK\n",
+			       current->comm);
+		}
+	}
+#undef	OLD_ADJTICK
+#define	OLD_ADJTICKADJ	(MOD_NANO)
+	if (unlikely((txc->modes & OLD_ADJTICKADJ) == OLD_ADJTICKADJ)) {
+		static int complain = 5;
+		if (complain > 0) {
+			--complain;
+			printk(KERN_NOTICE
+			       "adjtimex: %s could be using obsolete ADJ_TICKADJ\n",
+			       current->comm);
+		}
+	}
+#undef	OLD_ADJTICKADJ
+#endif	/* print extra warnings */
+#endif	/* map old bits to new ones with warning */
+	if (unlikely((txc->modes & MOD_OFFSET) != 0 &&
+		     (txc->modes & ADJ_ADJTIME) != 0)) {
+		/* ntp_adjtime() and adjtime() are mutually exclusive! */
+		return -EINVAL;
+	}
 	write_seqlock_irq(&xtime_lock);
 	result = time_state;	/* mostly `TIME_OK' */
 
-	/* Save for later - semantics of adjtime is to return old value */
-	save_adjust = time_next_adjust ? time_next_adjust : time_adjust;
-
 #if 0	/* STA_CLOCKERR is never set yet */
 	time_status &= ~STA_CLOCKERR;		/* reset STA_CLOCKERR */
 #endif
 	/* If there are input parameters, then process them */
 	if (txc->modes)
 	{
-	    if (txc->modes & ADJ_STATUS)	/* only set allowed bits */
-		time_status =  (txc->status & ~STA_RONLY) |
-			      (time_status & STA_RONLY);
-
-	    if (txc->modes & ADJ_FREQUENCY) {	/* p. 22 */
-		if (txc->freq > MAXFREQ || txc->freq < -MAXFREQ) {
-		    result = -EINVAL;
-		    goto leave;
-		}
-		time_freq = txc->freq;
-	    }
-
-	    if (txc->modes & ADJ_MAXERROR) {
-		if (txc->maxerror < 0 || txc->maxerror >= NTP_PHASE_LIMIT) {
-		    result = -EINVAL;
-		    goto leave;
-		}
-		time_maxerror = txc->maxerror;
-	    }
-
-	    if (txc->modes & ADJ_ESTERROR) {
-		if (txc->esterror < 0 || txc->esterror >= NTP_PHASE_LIMIT) {
-		    result = -EINVAL;
-		    goto leave;
-		}
-		time_esterror = txc->esterror;
-	    }
-
-	    if (txc->modes & ADJ_TIMECONST) {	/* p. 24 */
-		if (txc->constant < 0) {	/* NTP v4 uses values > 6 */
-		    result = -EINVAL;
-		    goto leave;
-		}
-		time_constant = txc->constant;
-	    }
-
-	    if (txc->modes & ADJ_OFFSET) {	/* values checked earlier */
-		if (txc->modes == ADJ_OFFSET_SINGLESHOT) {
-		    /* adjtime() is independent from ntp_adjtime() */
-		    if ((time_next_adjust = txc->offset) == 0)
-			 time_adjust = 0;
-		}
-		else if (time_status & STA_PLL) {
-		    ltemp = txc->offset;
-
-		    /*
-		     * Scale the phase adjustment and
-		     * clamp to the operating range.
-		     */
-		    if (ltemp > MAXPHASE)
-		        time_offset = MAXPHASE << SHIFT_UPDATE;
-		    else if (ltemp < -MAXPHASE)
-			time_offset = -(MAXPHASE << SHIFT_UPDATE);
-		    else
-		        time_offset = ltemp << SHIFT_UPDATE;
-
-		    /*
-		     * Select whether the frequency is to be controlled
-		     * and in which mode (PLL or FLL). Clamp to the operating
-		     * range. Ugly multiply/divide should be replaced someday.
-		     */
-
-		    if (time_status & STA_FREQHOLD || time_reftime == 0)
-		        time_reftime = xtime.tv_sec;
-		    mtemp = xtime.tv_sec - time_reftime;
-		    time_reftime = xtime.tv_sec;
-		    if (time_status & STA_FLL) {
-		        if (mtemp >= MINSEC) {
-			    ltemp = (time_offset / mtemp) << (SHIFT_USEC -
-							      SHIFT_UPDATE);
-			    time_freq += shift_right(ltemp, SHIFT_KH);
-			} else /* calibration interval too short (p. 12) */
-				result = TIME_ERROR;
-		    } else {	/* PLL mode */
-		        if (mtemp < MAXSEC) {
-			    ltemp *= mtemp;
-			    time_freq += shift_right(ltemp,(time_constant +
-						       time_constant +
-						       SHIFT_KF - SHIFT_USEC));
-			} else /* calibration interval too long (p. 12) */
-				result = TIME_ERROR;
-		    }
-		    time_freq = min(time_freq, time_tolerance);
-		    time_freq = max(time_freq, -time_tolerance);
-		} /* STA_PLL */
-	    } /* txc->modes & ADJ_OFFSET */
-	    if (txc->modes & ADJ_TICK) {
-		tick_usec = txc->tick;
-		tick_nsec = TICK_USEC_TO_NSEC(tick_usec);
-	    }
+		if (txc->modes & MOD_STATUS) {  /* only modify allowed bits */
+			if ((time_status & STA_PLL) != 0 &&
+			    (txc->status & STA_PLL) == 0) {
+				/* If the STA_PLL bit in the status word is
+				 * cleared, the state and status words are
+				 * reset to the initial values.
+				 */
+				time_state = TIME_OK;
+				time_status = STA_UNSYNC;
+#ifdef CONFIG_NTP_PPS
+				/* cause an early termination of the PPS
+				 * calibration interval (i.e. reset status)
+				 */
+				pps.shift = PPS_FAVG;
+				pps.intcnt = 0;
+#endif
+			}
+			time_status = (txc->status & ~STA_RONLY) |
+				      (time_status & STA_RONLY);
+		}
+
+		if (txc->modes & MOD_FREQUENCY) {	/* p. 22 */
+			long freq;		/* frequency ns/s) */
+			freq = txc->freq / SCALE_PPM;
+			if (unlikely(freq > MAXFREQ)) {
+				result = -EINVAL;
+				freq = MAXFREQ;
+			} else if (unlikely(freq < -MAXFREQ)) {
+				result = -EINVAL;
+				freq = -MAXFREQ;
+			}
+			L_LINT(time_freq, freq);
+#if 0 /*XXX: MISSING */
+			update_nanoscale(tick_nsec * hz - NSEC_PER_SEC +
+					 L_GINT(time_freq));
+#endif /*XXX: MISSING */
+#ifdef CONFIG_NTP_PPS
+			pps.freq = time_freq;
+#endif
+		}
+
+		if (txc->modes & MOD_MAXERROR) {
+			txc->maxerror *= 1000;	/* convert to ns */
+			if (unlikely(txc->maxerror < 0 ||
+				     txc->maxerror >= NTP_PHASE_LIMIT)) {
+				result = -EINVAL;
+				txc->maxerror = NTP_PHASE_LIMIT;
+			}
+			time_maxerror = txc->maxerror;
+		}
+
+		if (txc->modes & MOD_ESTERROR) {
+			txc->esterror *= 1000;
+			if (unlikely(txc->esterror < 0 ||
+				     txc->esterror >= NTP_PHASE_LIMIT)) {
+				result = -EINVAL;
+				txc->esterror = NTP_PHASE_LIMIT;
+			}
+			time_esterror = txc->esterror;
+		}
+
+		/* Note that the timex.constant structure member has a
+		 * dual purpose to set the time constant and to set
+		 * the TAI offset.
+		 */
+		if (txc->modes & MOD_TIMECONST) {	/* p. 24 */
+			if (unlikely(txc->constant < 0)) {
+				result = -EINVAL;
+				txc->constant = 0;
+			} else if (unlikely(txc->constant > MAXTC)) {
+				result = -EINVAL;
+				txc->constant = MAXTC;
+			}
+			time_constant = txc->constant;
+		}
+		if (txc->modes & MOD_TAI) {
+			if (likely(txc->constant > 0))
+				time_tai = txc->constant;
+			else
+				result = -EINVAL;
+		}
+#ifdef CONFIG_NTP_PPS
+		if (txc->modes & MOD_PPSMAX) {
+			if (unlikely(txc->shift < PPS_FAVG)) {
+				pps.shiftmax = PPS_FAVG;
+				result = -EINVAL;
+			} else if (unlikely(txc->shift > PPS_FAVGMAX)) {
+				pps.shiftmax = PPS_FAVGMAX;
+				result = -EINVAL;
+			} else
+				pps.shiftmax = txc->shift;
+			if (pps.shift > pps.shiftmax) {	/* enforce limit */
+				pps.shift = pps.shiftmax;
+			}
+		}
+#endif
+		if (txc->modes & MOD_NANO)
+			time_status |= STA_NANO;
+		if (txc->modes & MOD_MICRO)
+			time_status &= ~STA_NANO;
+		if (txc->modes & MOD_CLKB)
+			time_status |= STA_CLK;
+		if (txc->modes & MOD_CLKA)
+			time_status &= ~STA_CLK;
+		if (txc->modes & MOD_OFFSET) {
+			if ((time_status & STA_NANO) == 0) {
+				/* need nanoseconds, but avoid sign overflow */
+				if (txc->offset > MAXPHASE / 1000)
+					txc->offset = MAXPHASE;
+				else if (txc->offset < -MAXPHASE / 1000)
+					txc->offset = -MAXPHASE;
+				else
+					txc->offset *= 1000;
+			}
+			/* offset will be clamped silently in hardupdate() */
+			hardupdate(txc->offset);
+		}
+		if (txc->modes == ADJ_ADJTIME) {
+			/*
+			 * The emulation of adjtime() is actually broken,
+			 * because only one ``long'' is available to represent
+			 * a ``struct timeval''.
+			 */
+			/* Save current adjustment to be retuned */
+			save_adjust = time_adjust;
+			time_adjust = txc->offset;
+			if (txc->offset < -30000000 || txc->offset > 30000000)
+				printk(KERN_WARNING
+				       "adjtime() fails with large offsets\n");
+		}
+		if (txc->modes & ADJ_TIMETICK) {
+			if ((time_status & STA_NANO) == 0)
+				txc->tick *= 1000;
+			tick_usec = txc->tick;
+			tick_nsec = TICK_USEC_TO_NSEC(tick_usec);
+#if 0 /*XXX: MISSING */
+			update_nanoscale(tick * hz - NSEC_PER_SEC +
+					 L_GINT(time_freq));
+#endif
+		}
+		if (txc->modes & ADJ_TICKADJ) {
+			/* Traditional UN*Xes seem to allow about ``tick/10'',
+			 * but we will allow up to ``tick_usec/4'' (scaled).
+			 * Larger values might cause trouble!
+			 */
+			if (unlikely(txc->tickadj <= 0 ||
+				     txc->tickadj > tick_usec / 4)) {
+				result = -EINVAL;
+				goto leave;
+			}
+			tickadj = txc->tickadj;
+		}
 	} /* txc->modes */
-leave:	if ((time_status & (STA_UNSYNC|STA_CLOCKERR)) != 0)
-		result = TIME_ERROR;
-	
-	if ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT)
-	    txc->offset	   = save_adjust;
+leave:
+	if (txc->modes & ADJ_ADJTIME)
+		txc->offset = save_adjust;
 	else {
-	    txc->offset = shift_right(time_offset, SHIFT_UPDATE);
+		if (time_status & STA_NANO)
+			txc->offset = time_monitor;
+		else
+			txc->offset = time_monitor / 1000;
 	}
-	txc->freq	   = time_freq;
-	txc->maxerror	   = time_maxerror;
-	txc->esterror	   = time_esterror;
+	txc->freq	   = L_GINT(time_freq) * SCALE_PPM;
+	txc->maxerror	   = time_maxerror / 1000;
+	txc->esterror	   = time_esterror / 1000;
+	txc->tai	   = time_tai;
 	txc->status	   = time_status;
 	txc->constant	   = time_constant;
-	txc->precision	   = time_precision;
-	txc->tolerance	   = time_tolerance;
-	txc->tick	   = tick_usec;
-
-	/* PPS is not implemented, so these are zero */
-	txc->ppsfreq	   = 0;
-	txc->jitter	   = 0;
-	txc->shift	   = 0;
-	txc->stabil	   = 0;
-	txc->jitcnt	   = 0;
-	txc->calcnt	   = 0;
-	txc->errcnt	   = 0;
-	txc->stbcnt	   = 0;
+	if (time_status & STA_NANO) {
+		txc->precision = time_precision ? : 1;
+		txc->tick = tick_usec;
+	} else {
+		txc->time.tv_nsec += 500;	/* make microseconds */
+		txc->time.tv_nsec /= 1000;
+		txc->precision = ((time_precision + 500) / 1000) ? : 1;
+		txc->tick = tick_nsec;
+	}
+	txc->tolerance = MAXFREQ * SCALE_PPM;
+#ifdef CONFIG_NTP_PPS
+	txc->ppsfreq	   = L_GINT(pps.freq) * SCALE_PPM;
+	if (time_status & STA_NANO)
+		txc->jitter = pps.jitter;
+	else
+		txc->jitter = pps.jitter / 1000;
+	txc->shift	   = pps.shift;
+	txc->stabil	   = pps.stabil;
+	txc->jitcnt	   = pps.jitcnt;
+	txc->calcnt	   = pps.calcnt;
+	txc->errcnt	   = pps.errcnt;
+	txc->stbcnt	   = pps.stbcnt;
+#endif
+	txc->tickadj	   = tickadj;	/* extension by UW */
+
+	if ((time_status & (STA_UNSYNC|STA_CLOCKERR)) != 0
+	    /* clock not synchronized (hardware or software error) */
+#ifdef CONFIG_NTP_PPS
+	    || ((time_status & (STA_PPSFREQ|STA_PPSTIME)) != 0
+		&& (time_status & STA_PPSSIGNAL) == 0)
+	    /* PPS signal lost when either PPS time or PPS frequency
+	     * synchronization requested
+	     */
+	    || ((time_status & (STA_PPSTIME|STA_PPSJITTER))
+		== (STA_PPSTIME|STA_PPSJITTER))
+	    /* PPS jitter exceeded when PPS time synchronization requested */
+	    || ((time_status & STA_PPSFREQ) != 0
+		&& (time_status & (STA_PPSWANDER|STA_PPSERROR)) != 0)
+	    /* PPS wander exceeded or calibration error when PPS frequency
+	     * synchronization requested
+	     */
+#endif
+	   )
+		result = TIME_ERROR;
+	
 	write_sequnlock_irq(&xtime_lock);
-	do_gettimeofday(&txc->time);
+	getnstimeofday(&txc->time);
+	if ((time_status & STA_NANO) == 0)
+		txc->time.tv_nsec /= 1000;
 	notify_arch_cmos_timer();
+#ifdef	CONFIG_NTP_DEBUG
+	printk(KERN_DEBUG "adjtimex(0x%x) returns %d\n", txc->modes, result);
+#endif
 	return(result);
 }
 
@@ -450,26 +1421,39 @@
 }
 EXPORT_SYMBOL(timespec_trunc);
 
-#ifdef CONFIG_TIME_INTERPOLATION
+/* get system time with nanosecond accuracy */
 void getnstimeofday (struct timespec *tv)
 {
-	unsigned long seq,sec,nsec;
-
+	unsigned long seq, nsec, sec;
+#ifdef CONFIG_TIME_INTERPOLATION
 	do {
 		seq = read_seqbegin(&xtime_lock);
 		sec = xtime.tv_sec;
-		nsec = xtime.tv_nsec+time_interpolator_get_offset();
+		nsec = xtime.tv_nsec + time_interpolator_get_offset();
 	} while (unlikely(read_seqretry(&xtime_lock, seq)));
 
 	while (unlikely(nsec >= NSEC_PER_SEC)) {
 		nsec -= NSEC_PER_SEC;
 		++sec;
 	}
+#else
+	{	/*FIXME: Try not to loose nanoseconds */
+		struct timeval tv;
+
+		do_gettimeofday(&tv);
+		sec = tv.tv_sec;
+		nsec = tv.tv_usec * 1000 + xtime.tv_nsec % 1000;
+	}
+#endif
 	tv->tv_sec = sec;
 	tv->tv_nsec = nsec;
 }
 EXPORT_SYMBOL_GPL(getnstimeofday);
 
+#ifdef CONFIG_TIME_INTERPOLATION
+/* this is a mess: there are also architecture-dependent ``do_gettimeofday()''
+ * and ``do_settimeofday()''
+ */
 int do_settimeofday (struct timespec *tv)
 {
 	time_t wtm_sec, sec = tv->tv_sec;
@@ -485,11 +1469,7 @@
 
 		set_normalized_timespec(&xtime, sec, nsec);
 		set_normalized_timespec(&wall_to_monotonic, wtm_sec, wtm_nsec);
-
-		time_adjust = 0;		/* stop active adjtime() */
-		time_status |= STA_UNSYNC;
-		time_maxerror = NTP_PHASE_LIMIT;
-		time_esterror = NTP_PHASE_LIMIT;
+		set_ntp_unsync();		/* reset NTP state */
 		time_interpolator_reset();
 	}
 	write_sequnlock_irq(&xtime_lock);
@@ -500,42 +1480,14 @@
 
 void do_gettimeofday (struct timeval *tv)
 {
-	unsigned long seq, nsec, usec, sec, offset;
-	do {
-		seq = read_seqbegin(&xtime_lock);
-		offset = time_interpolator_get_offset();
-		sec = xtime.tv_sec;
-		nsec = xtime.tv_nsec;
-	} while (unlikely(read_seqretry(&xtime_lock, seq)));
-
-	usec = (nsec + offset) / 1000;
-
-	while (unlikely(usec >= USEC_PER_SEC)) {
-		usec -= USEC_PER_SEC;
-		++sec;
-	}
+	struct timespec	ts;
 
-	tv->tv_sec = sec;
-	tv->tv_usec = usec;
+	getnstimeofday(&ts);
+	tv->tv_sec = ts.tv_sec;
+	tv->tv_usec = (ts.tv_nsec + 500) / 1000;
 }
 
 EXPORT_SYMBOL(do_gettimeofday);
-
-
-#else
-/*
- * Simulate gettimeofday using do_gettimeofday which only allows a timeval
- * and therefore only yields usec accuracy
- */
-void getnstimeofday(struct timespec *tv)
-{
-	struct timeval x;
-
-	do_gettimeofday(&x);
-	tv->tv_sec = x.tv_sec;
-	tv->tv_nsec = x.tv_usec * NSEC_PER_USEC;
-}
-EXPORT_SYMBOL_GPL(getnstimeofday);
 #endif
 
 /* Converts Gregorian date to seconds since 1970-01-01 00:00:00.
@@ -658,3 +1610,66 @@
 #endif
 
 EXPORT_SYMBOL(jiffies);
+
+/*
+ * timevar_init() - initialize variables and structures
+ * (needed before first time interrupt is processed)
+ *
+ * This routine must be called after the kernel variables hz and tick
+ * are set or changed and before the next tick interrupt. In this
+ * particular implementation, these values are assumed set elsewhere in
+ * the kernel. The design allows the clock frequency and tick interval
+ * to be changed while the system is running. So, this routine should
+ * probably be integrated with the code that does that.
+ */
+void timevar_init(void)
+{
+	struct timespec ts;
+
+#ifdef	CONFIG_NTP_DEBUG
+	printk(KERN_DEBUG "PPSkit DEBUG: timevar_init() executed\n");
+#endif
+	/*
+	 * The following variable must be initialized any time the
+	 * kernel variable hz is changed.
+	 */
+	tick_nsec = (NSEC_PER_SEC + hz/2) / hz;
+	tick_usec = (tick_nsec + 500) / 1000;
+	/* Speed of adjtime() is 50ms/s; may not be <= 0 */
+	tickadj = 50000/hz ? : 1;
+	time_adjust = 0;
+	rtc_update = 660;			/* update every 11 minutes */
+
+	/*
+	 * The following variables are initialized only at startup. Only
+	 * those structures not cleared by the compiler need to be
+	 * initialized, and these only in the simulator. In the actual
+	 * kernel, any nonzero values here will quickly evaporate.
+	 */
+	time_state = TIME_OK;
+	time_status = STA_UNSYNC;
+	time_tai = 0;
+	time_maxerror = time_esterror = NTP_PHASE_LIMIT;
+	L_CLR(time_offset);
+	L_CLR(time_freq);
+	L_LINT(time_adj, NSEC_PER_SEC);		/* preset for first second */
+	L_CLR(time_phase);
+#if 0 /*FIXME: we don't have it yet (UW)*/
+	sys_clock_getres(CLOCK_REALTIME, &ts);
+	time_precision = ts.tv_nsec;
+#else
+	time_precision = 1;
+#endif
+#ifdef CONFIG_NTP_PPS
+	pps.shift = PPS_FAVG;
+	pps.shiftmax = PPS_FAVGDEF;
+	pps.tf[0].tv_sec = pps.tf[0].tv_nsec = 0;
+	pps.tf[1].tv_sec = pps.tf[1].tv_nsec = 0;
+	pps.tf[2].tv_sec = pps.tf[2].tv_nsec = 0;
+	pps.fcount = 0;
+	L_CLR(pps.freq);
+	pps.fmin = MAXFREQ;
+	pps.fmax = -MAXFREQ;
+	pps.frange = MAXFREQ;
+#endif
+}
Index: linux/kernel/timer.c
diff -u linux/kernel/timer.c:1.1.1.8 linux/kernel/timer.c:1.1.1.8.2.2
--- linux/kernel/timer.c:1.1.1.8	Wed Aug  9 21:08:49 2006
+++ linux/kernel/timer.c	Sat Aug 12 18:21:52 2006
@@ -41,12 +41,6 @@
 #include <asm/timex.h>
 #include <asm/io.h>
 
-#ifdef CONFIG_TIME_INTERPOLATION
-static void time_interpolator_update(long delta_nsec);
-#else
-#define time_interpolator_update(x)
-#endif
-
 u64 jiffies_64 __cacheline_aligned_in_smp = INITIAL_JIFFIES;
 
 EXPORT_SYMBOL(jiffies_64);
@@ -567,236 +561,6 @@
 /******************************************************************/
 
 /*
- * Timekeeping variables
- */
-unsigned long tick_usec = TICK_USEC; 		/* USER_HZ period (usec) */
-unsigned long tick_nsec = TICK_NSEC;		/* ACTHZ period (nsec) */
-
-/* 
- * The current time 
- * wall_to_monotonic is what we need to add to xtime (or xtime corrected 
- * for sub jiffie times) to get to monotonic time.  Monotonic is pegged
- * at zero at system boot time, so wall_to_monotonic will be negative,
- * however, we will ALWAYS keep the tv_nsec part positive so we can use
- * the usual normalization.
- */
-struct timespec xtime __attribute__ ((aligned (16)));
-struct timespec wall_to_monotonic __attribute__ ((aligned (16)));
-
-EXPORT_SYMBOL(xtime);
-
-/* Don't completely fail for HZ > 500.  */
-int tickadj = 500/HZ ? : 1;		/* microsecs */
-
-
-/*
- * phase-lock loop variables
- */
-/* TIME_ERROR prevents overwriting the CMOS clock */
-int time_state = TIME_OK;		/* clock synchronization status	*/
-int time_status = STA_UNSYNC;		/* clock status bits		*/
-long time_offset;			/* time adjustment (us)		*/
-long time_constant = 2;			/* pll time constant		*/
-long time_tolerance = MAXFREQ;		/* frequency tolerance (ppm)	*/
-long time_precision = 1;		/* clock precision (us)		*/
-long time_maxerror = NTP_PHASE_LIMIT;	/* maximum error (us)		*/
-long time_esterror = NTP_PHASE_LIMIT;	/* estimated error (us)		*/
-static long time_phase;			/* phase offset (scaled us)	*/
-long time_freq = (((NSEC_PER_SEC + HZ/2) % HZ - HZ/2) << SHIFT_USEC) / NSEC_PER_USEC;
-					/* frequency offset (scaled ppm)*/
-static long time_adj;			/* tick adjust (scaled 1 / HZ)	*/
-long time_reftime;			/* time at last adjustment (s)	*/
-long time_adjust;
-long time_next_adjust;
-
-/*
- * this routine handles the overflow of the microsecond field
- *
- * The tricky bits of code to handle the accurate clock support
- * were provided by Dave Mills (Mills@UDEL.EDU) of NTP fame.
- * They were originally developed for SUN and DEC kernels.
- * All the kudos should go to Dave for this stuff.
- *
- */
-static void second_overflow(void)
-{
-	long ltemp;
-
-	/* Bump the maxerror field */
-	time_maxerror += time_tolerance >> SHIFT_USEC;
-	if (time_maxerror > NTP_PHASE_LIMIT) {
-		time_maxerror = NTP_PHASE_LIMIT;
-		time_status |= STA_UNSYNC;
-	}
-
-	/*
-	 * Leap second processing. If in leap-insert state at the end of the
-	 * day, the system clock is set back one second; if in leap-delete
-	 * state, the system clock is set ahead one second. The microtime()
-	 * routine or external clock driver will insure that reported time is
-	 * always monotonic. The ugly divides should be replaced.
-	 */
-	switch (time_state) {
-	case TIME_OK:
-		if (time_status & STA_INS)
-			time_state = TIME_INS;
-		else if (time_status & STA_DEL)
-			time_state = TIME_DEL;
-		break;
-	case TIME_INS:
-		if (xtime.tv_sec % 86400 == 0) {
-			xtime.tv_sec--;
-			wall_to_monotonic.tv_sec++;
-			/*
-			 * The timer interpolator will make time change
-			 * gradually instead of an immediate jump by one second
-			 */
-			time_interpolator_update(-NSEC_PER_SEC);
-			time_state = TIME_OOP;
-			clock_was_set();
-			printk(KERN_NOTICE "Clock: inserting leap second "
-					"23:59:60 UTC\n");
-		}
-		break;
-	case TIME_DEL:
-		if ((xtime.tv_sec + 1) % 86400 == 0) {
-			xtime.tv_sec++;
-			wall_to_monotonic.tv_sec--;
-			/*
-			 * Use of time interpolator for a gradual change of
-			 * time
-			 */
-			time_interpolator_update(NSEC_PER_SEC);
-			time_state = TIME_WAIT;
-			clock_was_set();
-			printk(KERN_NOTICE "Clock: deleting leap second "
-					"23:59:59 UTC\n");
-		}
-		break;
-	case TIME_OOP:
-		time_state = TIME_WAIT;
-		break;
-	case TIME_WAIT:
-		if (!(time_status & (STA_INS | STA_DEL)))
-		time_state = TIME_OK;
-	}
-
-	/*
-	 * Compute the phase adjustment for the next second. In PLL mode, the
-	 * offset is reduced by a fixed factor times the time constant. In FLL
-	 * mode the offset is used directly. In either mode, the maximum phase
-	 * adjustment for each second is clamped so as to spread the adjustment
-	 * over not more than the number of seconds between updates.
-	 */
-	ltemp = time_offset;
-	if (!(time_status & STA_FLL))
-		ltemp = shift_right(ltemp, SHIFT_KG + time_constant);
-	ltemp = min(ltemp, (MAXPHASE / MINSEC) << SHIFT_UPDATE);
-	ltemp = max(ltemp, -(MAXPHASE / MINSEC) << SHIFT_UPDATE);
-	time_offset -= ltemp;
-	time_adj = ltemp << (SHIFT_SCALE - SHIFT_HZ - SHIFT_UPDATE);
-
-	/*
-	 * Compute the frequency estimate and additional phase adjustment due
-	 * to frequency error for the next second.
-	 */
-	ltemp = time_freq;
-	time_adj += shift_right(ltemp,(SHIFT_USEC + SHIFT_HZ - SHIFT_SCALE));
-
-#if HZ == 100
-	/*
-	 * Compensate for (HZ==100) != (1 << SHIFT_HZ).  Add 25% and 3.125% to
-	 * get 128.125; => only 0.125% error (p. 14)
-	 */
-	time_adj += shift_right(time_adj, 2) + shift_right(time_adj, 5);
-#endif
-#if HZ == 250
-	/*
-	 * Compensate for (HZ==250) != (1 << SHIFT_HZ).  Add 1.5625% and
-	 * 0.78125% to get 255.85938; => only 0.05% error (p. 14)
-	 */
-	time_adj += shift_right(time_adj, 6) + shift_right(time_adj, 7);
-#endif
-#if HZ == 1000
-	/*
-	 * Compensate for (HZ==1000) != (1 << SHIFT_HZ).  Add 1.5625% and
-	 * 0.78125% to get 1023.4375; => only 0.05% error (p. 14)
-	 */
-	time_adj += shift_right(time_adj, 6) + shift_right(time_adj, 7);
-#endif
-}
-
-/*
- * Returns how many microseconds we need to add to xtime this tick
- * in doing an adjustment requested with adjtime.
- */
-static long adjtime_adjustment(void)
-{
-	long time_adjust_step;
-
-	time_adjust_step = time_adjust;
-	if (time_adjust_step) {
-		/*
-		 * We are doing an adjtime thing.  Prepare time_adjust_step to
-		 * be within bounds.  Note that a positive time_adjust means we
-		 * want the clock to run faster.
-		 *
-		 * Limit the amount of the step to be in the range
-		 * -tickadj .. +tickadj
-		 */
-		time_adjust_step = min(time_adjust_step, (long)tickadj);
-		time_adjust_step = max(time_adjust_step, (long)-tickadj);
-	}
-	return time_adjust_step;
-}
-
-/* in the NTP reference this is called "hardclock()" */
-static void update_wall_time_one_tick(void)
-{
-	long time_adjust_step, delta_nsec;
-
-	time_adjust_step = adjtime_adjustment();
-	if (time_adjust_step)
-		/* Reduce by this step the amount of time left  */
-		time_adjust -= time_adjust_step;
-	delta_nsec = tick_nsec + time_adjust_step * 1000;
-	/*
-	 * Advance the phase, once it gets to one microsecond, then
-	 * advance the tick more.
-	 */
-	time_phase += time_adj;
-	if ((time_phase >= FINENSEC) || (time_phase <= -FINENSEC)) {
-		long ltemp = shift_right(time_phase, (SHIFT_SCALE - 10));
-		time_phase -= ltemp << (SHIFT_SCALE - 10);
-		delta_nsec += ltemp;
-	}
-	xtime.tv_nsec += delta_nsec;
-	time_interpolator_update(delta_nsec);
-
-	/* Changes by adjtime() do not take effect till next tick. */
-	if (time_next_adjust != 0) {
-		time_adjust = time_next_adjust;
-		time_next_adjust = 0;
-	}
-}
-
-/*
- * Return how long ticks are at the moment, that is, how much time
- * update_wall_time_one_tick will add to xtime next time we call it
- * (assuming no calls to do_adjtimex in the meantime).
- * The return value is in fixed-point nanoseconds with SHIFT_SCALE-10
- * bits to the right of the binary point.
- * This function has no side-effects.
- */
-u64 current_tick_length(void)
-{
-	long delta_nsec;
-
-	delta_nsec = tick_nsec + adjtime_adjustment() * 1000;
-	return ((u64) delta_nsec << (SHIFT_SCALE - 10)) + time_adj;
-}
-
-/*
  * Using a loop looks inefficient, but "ticks" is
  * usually just one (we shouldn't be losing ticks,
  * we're doing this this way mainly for interrupt
@@ -805,11 +569,16 @@
  */
 static void update_wall_time(unsigned long ticks)
 {
+#ifdef CONFIG_NTP_DEBUG
+	if (ticks > 1)
+		printk(KERN_INFO "update_wall_time(): INFO: ticks is %lu\n",
+		       ticks);
+#endif
 	do {
 		ticks--;
 		update_wall_time_one_tick();
-		if (xtime.tv_nsec >= 1000000000) {
-			xtime.tv_nsec -= 1000000000;
+		if (xtime.tv_nsec >= NANOSECOND) {
+			xtime.tv_nsec -= NANOSECOND;
 			xtime.tv_sec++;
 			second_overflow();
 		}
@@ -1443,7 +1212,7 @@
 #define INTERPOLATOR_ADJUST 65536
 #define INTERPOLATOR_MAX_SKIP 10*INTERPOLATOR_ADJUST
 
-static void time_interpolator_update(long delta_nsec)
+void time_interpolator_update(long delta_nsec)
 {
 	u64 counter;
 	unsigned long offset;
