// -*- mode: c++ -*-//
// Protocol definition for the EPA Demonstrator Board
//
autogen definitions protocol;

description = "Protocol for the EPA Demonstrator Board";
prefix = "EPA"; // for the signal names
id = "(LOFAR::GCF::TM::F_APL_PROTOCOL+11)";

// specify extra include files
// e.g.
include = '<sys/time.h>';
include = '<linux/types.h>';
include = '<net/ethernet.h>';
include = '<Common/LofarTypes.h>';
include = '"MEPHeader.h"';
include = '"MEPData.h"';

prelude = << PRELUDE_END

/**
 * Protocol constants.
 */

  /*@{*/
  /**
   * Constants used in the EPA protocol.
   * These constants are all derived from the leading
   * constants in MEPHeader.h.
   */
  static const int N_AP            = 4;    // number of AP's per board
  static const int N_COEF          = MEPHeader::FRAGMENT_SIZE / sizeof(int16);
  static const int BF_N_FRAGMENTS  = MEPHeader::BF_XROUT_SIZE / MEPHeader::FRAGMENT_SIZE;
  static const int N_WAVE_SAMPLES  = MEPHeader::WG_XWAVE_SIZE / sizeof(int16);
  static const int BST_N_FRAGMENTS = MEPHeader::BST_POWER_SIZE / MEPHeader::FRAGMENT_SIZE;
  static const int SST_N_FRAGMENTS = MEPHeader::SST_POWER_SIZE / MEPHeader::FRAGMENT_SIZE;
  static const int N_STATS         = MEPHeader::FRAGMENT_SIZE / sizeof(uint32);
  static const int XST_N_FRAGMENTS = MEPHeader::XST_STATS_SIZE / MEPHeader::XST_FRAGMENT_SIZE;
  static const int N_XST_STATS     = MEPHeader::XST_FRAGMENT_SIZE / sizeof(uint32);

  /*@}*/

  typedef struct RSPStatus
  {
      uint8  voltage_1_5; // measured voltage on 1.5V circuit
      uint8  voltage_2_5; // measured voltage on 2.5V circuit
      uint8  voltage_3_3; // measure voltage on 3.3V circuit
      uint8  voltage_12;  // measured voltage on 12V circuit
  };

  typedef struct FPGAStatus
  {
      uint8  bp_temp;    // board processor temperature
      uint8  ap0_temp;   // antenna processor 0 temperature
      uint8  ap1_temp;   // antenna processor 1 temperature
      uint8  ap2_temp;   // antenna processor 2 temperature
      uint8  ap3_temp;   // antenna processor 3 temperature

      uint8  ffi0; // unused bytes
      uint8  ffi1;
      uint8  ffi2;
      uint8  ffi3;
      uint8  ffi4;
      uint8  ffi5;
      uint8  ffi6;
  };

  typedef struct ETHStatus
  {
      uint32 nof_frames; // number of ETH frame received
      uint32 nof_errors; // number of incorrect ETH frames
      uint8  last_error; // error status of last received ETH frame
      uint8  ffi0;
      uint8  ffi1;
      uint8  ffi2;
  };
  
  typedef struct MEPStatus
  {
      uint16 seqnr;  // sequence number of previously received message
      uint8  error;  // error status of previously received message
      uint8  ffi0;
  };
  
  typedef struct SYNCStatus
  {
      uint32 sample_offset; // offset from expected sample count
      uint32 sync_count;    // number of sync events (seconds)
      uint32 slice_count;   // number of samples per slice
  };

  typedef struct BoardRCUStatus
  {
      uint8  statusx;
      uint8  statusy;
      uint8  ffi0;
      uint8  ffi1;
      uint32 nof_overflowx;
      uint32 nof_overflowy;
  };

  typedef struct RCUStatus
  {
      uint8 status;
      uint8 ffi0;
      uint8 ffi1;
      uint8 ffi2;
      uint32 nof_overflow;
  };
  
  typedef struct BoardStatus
  {
      RSPStatus       rsp;
      FPGAStatus      fpga;
      ETHStatus       eth;
      MEPStatus       mep;
      SYNCStatus      ap0_sync;
      SYNCStatus      ap1_sync;
      SYNCStatus      ap2_sync;
      SYNCStatus      ap3_sync;
      BoardRCUStatus  ap0_rcu;
      BoardRCUStatus  ap1_rcu;
      BoardRCUStatus  ap2_rcu;
      BoardRCUStatus  ap3_rcu;
  };

  /*@{*/
  /**
   * Output operators for the system status types.
   */ 
  inline std::ostream& operator<<(std::ostream& s, const BoardStatus&  stat)
  {
    return s << "[" << std::endl
	     << "voltage_1_5   =" << int(stat.rsp.voltage_1_5)    << ", " << std::endl
	     << "voltage_2_5   =" << int(stat.rsp.voltage_2_5)    << ", " << std::endl
	     << "voltage_3_3   =" << int(stat.rsp.voltage_3_3)    << ", " << std::endl
	     << "voltage_12   =" << int(stat.rsp.voltage_12)    << ", " << std::endl
	     << "bp_temp      =" << int(stat.fpga.bp_temp)      << ", " << std::endl
	     << "ap0_temp     =" << int(stat.fpga.ap0_temp)     << ", " << std::endl
	     << "ap1_temp     =" << int(stat.fpga.ap1_temp)     << ", " << std::endl
	     << "ap2_temp     =" << int(stat.fpga.ap2_temp)     << ", " << std::endl
	     << "ap3_temp     =" << int(stat.fpga.ap3_temp)     << ", " << std::endl
	     << "nof_frames   =" << stat.eth.nof_frames         << ", " << std::endl
	     << "nof_error    =" << stat.eth.nof_errors         << ", " << std::endl
	     << "last_error   =" << int(stat.eth.last_error)    << ", " << std::endl
	     << "seqnr        =" << stat.mep.seqnr              << ", " << std::endl
	     << "error        =" << int(stat.mep.error)         << ", " << std::endl
	     << "ap0_sync.sample_offset =" << stat.ap0_sync.sample_offset << ", " << std::endl
	     << "ap0_sync.sync_count   =" << stat.ap0_sync.sync_count   << ", " << std::endl
	     << "ap0_sync.slice_count  =" << stat.ap0_sync.slice_count  << ", " << std::endl
	     << "ap1_sync.sample_offset =" << stat.ap1_sync.sample_offset << ", " << std::endl
	     << "ap1_sync.sync_count   =" << stat.ap1_sync.sync_count   << ", " << std::endl
	     << "ap1_sync.slice_count  =" << stat.ap1_sync.slice_count  << ", " << std::endl
	     << "ap2_sync.sample_offset =" << stat.ap2_sync.sample_offset << ", " << std::endl
	     << "ap2_sync.sync_count   =" << stat.ap2_sync.sync_count   << ", " << std::endl
	     << "ap2_sync.slice_count  =" << stat.ap2_sync.slice_count  << ", " << std::endl
	     << "ap3_sync.sample_offset =" << stat.ap3_sync.sample_offset << ", " << std::endl
	     << "ap3_sync.sync_count   =" << stat.ap3_sync.sync_count   << ", " << std::endl
	     << "ap3_sync.slice_count  =" << stat.ap3_sync.slice_count  << ", " << std::endl
	     << "ap0_rcu.statusx       =" << (int)stat.ap0_rcu.statusx       << ", " << std::endl
	     << "ap0_rcu.statusy       =" << (int)stat.ap0_rcu.statusy       << ", " << std::endl
	     << "ap0_rcu.nof_overflowx =" << stat.ap0_rcu.nof_overflowx << ", " << std::endl
	     << "ap0_rcu.nof_overflowy =" << stat.ap0_rcu.nof_overflowy << ", " << std::endl
	     << "ap1_rcu.statusx       =" << (int)stat.ap1_rcu.statusx       << ", " << std::endl
	     << "ap1_rcu.statusy       =" << (int)stat.ap1_rcu.statusy       << ", " << std::endl
	     << "ap1_rcu.nof_overflowx =" << (int)stat.ap1_rcu.nof_overflowx << ", " << std::endl
	     << "ap1_rcu.nof_overflowy =" << stat.ap1_rcu.nof_overflowy << ", " << std::endl
	     << "ap2_rcu.statusx       =" << (int)stat.ap2_rcu.statusx       << ", " << std::endl
	     << "ap2_rcu.statusy       =" << (int)stat.ap2_rcu.statusy       << ", " << std::endl
	     << "ap2_rcu.nof_overflowx =" << stat.ap2_rcu.nof_overflowx << ", " << std::endl
	     << "ap2_rcu.nof_overflowy =" << stat.ap2_rcu.nof_overflowy << ", " << std::endl
	     << "ap3_rcu.statusx       =" << (int)stat.ap3_rcu.statusx       << ", " << std::endl
	     << "ap3_rcu.statusy       =" << (int)stat.ap3_rcu.statusy       << ", " << std::endl
	     << "ap3_rcu.nof_overflowx =" << stat.ap3_rcu.nof_overflowx << ", " << std::endl
	     << "ap3_rcu.nof_overflowy =" << stat.ap3_rcu.nof_overflowy << ", " << std::endl
	     << "]" << std::endl;
  }
  
  /*@}*/

PRELUDE_END;

//
// The EPA events are specified from the point of view
// of the EPA firmware. An event with direction IN is 
// an input to the EPA firmware, OUT is an output of
// the EPA firmware and INOUT is both.
//

//
// Generic events:
// * READ  , READACK  , READACK_ERROR
// * WRITE , WRITEACK , WRITEACK_ERROR
//
// For the specific EPA registers the following generic
// events are used because there is no point in using
// specific events when only a MEPHeader is sent:
// * READ, READACK_ERROR, WRITEACK, WRITEACK_ERROR
//
// For each read-only EPA register a specific OUT
// event is defined.
//
// For each read-write EPA register a specific INOUT
// event is defined.
//
// This results in the following scenarios (REGISTER_X)
// is a placeholder for register READACK, WRITE events.
//
// Read register (success):
//
//  User                      EPA
//  ----                      ---
//   |                         |
//   +-------READ------------->|
//   |                         |
//   |<-----REGISTER_X---------+
//   |                         |
//
//  Read register (error)
//
//  User                          EPA
//  ----                          ---
//   |                             |
//   +-------READ----------------->|
//   |                             |
//   |<---READACK_ERROR------------+
//   |                             |
//
// Write register (success)
//
//  User                      EPA
//  ----                      ---
//   |                         |
//   +-------REGISTER_X------->|
//   |                         |
//   |<------WRITEACK----------+
//   |                         |
//
// Write register (error)
//
//  User                      EPA
//  ----                      ---
//   |                         |
//   +-------REGISTER_X------->|
//   |                         |
//   |<------WRITEACK_ERROR----+
//   |                         |
//
// There are also generic WRITE and READACK events
// which have a generic "MEPData payload" parameter
// to send/recv variable sized payload data.
//
event = {
  noheader;
  signal = WRITE;
  dir = IN;
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "payload";
    type = "MEPData";
    userdefined;
  };
};

event = {
  noheader;
  signal = WRITEACK;
  dir = IN;
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
};

event = {
  noheader;
  signal = WRITEACK_ERROR;
  dir = OUT;
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
};

event = {
  noheader;
  signal = READ;
  dir = IN;
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
};

event = {
  noheader;
  signal = READACK;
  dir = IN;
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "payload";
    type = "MEPData";
    userdefined;
  };
};

event = {
  noheader;
  signal = READACK_ERROR;
  dir = OUT;
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
};

//
// Specific READACK and WRITE events start here
//

event = {
  noheader;
  signal = RSR_STATUS;
  dir = OUT; // read-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };

  /**
   * RSP status fields.
   */
  param = {
    name = "board";
    type = "BoardStatus";
  };
};

event = {
  noheader;
  signal = RSR_VERSION;
  dir = OUT; // read-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "rsp_version";
    type = "uint8";
  };
  param = {
    name = "bp_version";
    type = "uint8";
  };
  param = {
    name = "ap_version";
    type = "uint8";
  };
};

event = {
  noheader;
  signal = TST_SELFTEST;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "test";
    type = "uint8";
  };
};

event = {
  noheader;
  signal = CFG_RESET;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
};

event = {
  noheader;
  signal = CFG_REPROGRAM;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  // params to be determined
};

event = {
  noheader;
  signal = WG_SETTINGS; // hdr should specify XPOL/YPOL
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "freq";
    type = "uint16";
  };
  param = {
    name = "phase";
    type = "uint8";
  };
  param = {
    name = "ampl";
    type = "uint8";
  };
  param = {
    name = "nof_samples";
    type = "uint16";
  };
  param = {
    name = "mode";
    type = "uint8";
  };
};

event = {
  noheader;
  signal = WG_WAVE; // hdr should specify XPOL/YPOL
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "samples";
    type = "int16[N_WAVE_SAMPLES]";
  };
};

event = {
  noheader;
  signal = SS_SELECT;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "ch";
    type = "uint16[MEPHeader::N_BEAMLETS * MEPHeader::N_POL]";
  };
};

event = {
  noheader;
  signal = BF_COEFS; // hdr should specify XROUT, XIOUT, XROUT or YIOUT
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "coef";
    type = "int16[N_COEF]";
  };
};

event = {
  noheader;
  signal = STATS; // hdr should specify SST_POWER or BST_POWER
  dir = OUT;
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "stat";
    type = "uint32[N_STATS]";
  };
};

event = {
  noheader;
  signal = XST_STATS;
  dir = OUT;
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "xst_stat";
    type = "uint32[N_XST_STATS]";
  };
};

event = {
  noheader;
  signal = RCU_SETTINGS;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "x";
    type = "uint8";
  };
  param = {
    name = "y";
    type = "uint8";
  };
};

event = {
  noheader;
  signal = CRR_SOFTRESET;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "trigger"; // should always have value 0x1
    type = "uint8";
  };
};

event = {
  noheader;
  signal = CRR_SOFTPPS;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "trigger"; // should always have value 0x1
    type = "uint8";
  };
};

event = {
  noheader;
  signal = CRB_SOFTRESET;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "trigger"; // should always have value 0x1
    type = "uint8";
  };
};

event = {
  noheader;
  signal = CRB_SOFTPPS;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "trigger"; // should always have value 0x1
    type = "uint8";
  };
};

event = {
  noheader;
  signal = CDO_SETTINGS;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "station_id";
    type = "uint32";
  };
  param = {
    name = "configuration_id";
    type = "uint16";
  };
  param = {
    name = "format";
    type = "uint16";
  };
  param = {
    name = "antenna_id";
    type = "uint16";
  };
};

event = {
  noheader;
  signal = TRIGGER_CLOCK;
  dir = OUT;
  param = {
    name = "value";
    type = "uint8";
  };
};
