<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title></title>
</head>

<body>



<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>IOHandler&lt;DataObj, ParamObj&gt;</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p>
<h1>IOHandler&lt;DataObj, ParamObj&gt;</h1>


















<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td><img src="functors.gif" width="194" height="38"></td>
        <td align="right"><img src="concept.gif" width="194"
        height="39"></td>
    </tr>
    <tr>
        <td valign="top"><b>Category</b>: functors</td>
        <td align="right" valign="top"><b>Component type</b>:
        concept</td>
    </tr>
</table>
<h3>Description</h3>

<p>An <font size="2" face="Courier New">IOHandler</font> is a function object 
  (or a wrapped function pointer if you use <a href="cb_ptr_fun.htm"> <font size="2" face="Courier New">cb_ptr_fun_w_ret()</font></a>) 
  that is called when exceptions are thrown in <font
size="2" face="Courier New">DB_iterator</font> operations. The handler uses the 
  state of the iterator passed in to decide how to process the exception. After 
  performing its work, the handler tells the iterator whether to suppress the 
  error (<font size="2"
face="Courier New">dtl_ios_base::SUPPRESS_ERROR</font>) or to re-throw the exception 
  (<font size="2"
face="Courier New">dtl_ios_base::THROW_EXCEPTION</font>). To use the <font size="2" face="Courier New">IOHandler 
  </font>facility, declare your own handler class as shown in the examples below. 
  To install a handler, pass your handler to the iterator's set_io_handler() function. 
  For example, suppose your handler is of type <font size="2"
face="Courier New">MyHandler&lt;DataObj, ParamObj&gt; </font> and you wish to 
  pass it to an iterator called <font size="2" face="Courier New">DB_iterator&lt;DataObj, 
  ParamObj&gt;&nbsp;it</font>. You would use <font size="2" face="Courier New">set_io_handler()</font><font
size="3"> by saying:</font><font size="2" face="Courier New"> it.set_io_handler(MyHandler&lt;DataObj, 
  ParamObj&gt;()). </font><font size="3">Later on, you may need to extract things 
  such as an error log from your handler or other state information. To query 
  your handler, extract it by invoking</font><font size="2" face="Courier New"> 
  it.get_io_handler((MyHandler *) NULL).</font><font
size="3"> The dummy pointer is passed in to tell the compiler the type of the 
  result of </font><font size="2" face="Courier New">get_io_handler(). </font><font size="3">You 
  can also set a default handler for a </font><font
size="2" face="Courier New">DBView</font><font size="3"> so that all newly created 
  iterators over that view will use this default handler if they don't explicitly 
  install their own handler. To set the default handlder for a </font><font size="2"
face="Courier New">DBView</font><font size="3"> call the <font face="Courier New, Courier, mono" size="2">get_io_handler()</font> 
  and <font face="Courier New, Courier, mono" size="2">set_io_handler()</font> 
  methods for the </font><font size="2"
face="Courier New">DBView</font><font size="3">. The handler for a </font><font
size="2" face="Courier New">DBView </font><font size="3">defaults to whatever 
  handler is #defined as the macro <code>DEFAULT_IO_HANDLER</code>. If the user 
  doesn't specify a default, then DTL sets the macro to be </font><a href="AlwaysThrowsHandler.htm"><font
size="2" face="Courier New">AlwaysThrowsHandler</font></a> <font
size="3">, which rethrows the exception. Finally, if you are working with an </font><font
size="2" face="Courier New">IndexedDBView </font><font
size="3">you can call </font><font
size="2" face="Courier New">IndexedDBView::get_io_handler()</font><font
size="3"> to get the handler of the underlying</font><font
size="2" face="Courier New"> DBView</font><font
size="3"> that it uses.</font></p>

<h3>Definition</h3>

<p>Defined in the <font size="2" face="Courier New">DBView.h</font><font
size="1" face="Courier New"> </font>header file. </p>

<h3>Associated types</h3>

<p><a href="AlwaysThrowsHandler.htm"><font size="2"
face="Courier New">AlwaysThrowsHandler</font></a><font size="2"
face="Courier New">, </font><a href="LoggingHandler.htm"><font
size="2" face="Courier New">LoggingHandler</font></a><font
size="2" face="Courier New">, <a href="BulkFetchHandler.htm"><font face="Courier New, Courier, mono">BulkFetchHandler</font></a>.</font></p>

<h3>Example 1:</h3>

<p><h3> A good example of an IOHandler: LoggingHandler</h3>

<pre><code>
<span class="codeComment">// *** Note: this is the actual LoggingHandler template from the DTL code ***

// this handler logs exceptions to a vector
// then tells caller to reperform the action</span>
template&lt;class DataObj, class ParamObj = DefaultParamObj&lt;DataObj&gt;&nbsp;&gt; class LoggingHandler
{
public:
	struct LoggedTriple
	{
		string errmsg;
		DataObj dataObj;
		ParamObj paramObj;

		LoggedTriple() : errmsg(""), dataObj(), paramObj() { }

		LoggedTriple(const string &amp;msg, const DataObj &amp;data, const ParamObj &amp;param) :
		  errmsg(msg), dataObj(data), paramObj(param) { }
	};

private:
	CountedPtr&lt;vector&lt;LoggedTriple&gt;&nbsp;&gt; errorLog;<span class="codeComment">// all copies of the handler will share this error log</span>
	
public:

	LoggingHandler() :
		  errorLog() { }
	
	dtl_ios_base::MeansOfRecovery
		operator()(RootException &amp;ex, dtl_ios_base &amp;base,
			DataObj &amp;data, ParamObj &amp;params)
	{
		<span class="codeComment">// log the error</span>
		errorLog.push_back(LoggedTriple(ex.what(), data, params));
		
		<span class="codeComment">// tell the program to continue</span>
		return dtl_ios_base::SUPPRESS_ERROR;
	}

	vector&lt;LoggedTriple&gt; GetLog() const
	{
		return errorLog;
	}

};
</code></pre>

<pre><code><span class="codeComment">// Example Code Using LoggingHandler on a DBView

// test of failed SelValidate() when reading data</span>
void TestBadSelValidate()
{
 	vector&lt;Example&gt; results;

	<span class="codeComment">// construct view
	// DBView&lt;Example&gt; is actually DBView&lt;Example, 
	// DefaultParamObj&lt;Example&gt; &gt; thanks to the default 
	// argument to the DBView template

	// use our bad BCA which references a nonexistent column name in DB_EXAMPLE</span>
	DBView&lt;Example&gt;
		view(&quot;DB_EXAMPLE&quot;, BCAExampleObj(),
		&quot;WHERE INT_VALUE BETWEEN (?) AND (?) AND &quot;
		&quot;STRING_VALUE = (?) OR EXAMPLE_DATE &lt; (?) ORDER BY EXAMPLE_LONG&quot;,
		BPAExampleObj(), BadSelValidate());

	view.set_io_handler(LoggingHandler&lt;Example&gt;());

	<span class="codeComment">// loop through query results and add them to our vector
	// in this loop, read_it.GetLastCount() records read from DB</span>

	DBView&lt;Example&gt;::select_iterator read_it = view.begin();

	<span class="codeComment">// set parameter values for the WHERE clause in our SQL query</span>
	read_it.Params().lowIntValue = 2;
	read_it.Params().highIntValue = 8;
	read_it.Params().strValue = &quot;Example&quot;;
	
	TIMESTAMP_STRUCT paramDate = {2000, 1, 1, 0, 0, 0, 0};
	read_it.Params().dateValue = paramDate;

	for ( ; read_it != view.end(); read_it++)
	{
		try
		{
		  <span class="codeComment">// note that the read_iterator::GetLastCount()  is incremented in operator++()
		  // remember that the record is fetched and thus the count incremented
		  // before operator*() is applied to the read_iterator</span>

		  cout &lt;&lt; &quot;Reading element #&quot; &lt;&lt; read_it.GetLastCount() &lt;&lt; endl;
		  
		  cout &lt;&lt; &quot;read_it-&gt;exampleInt = &quot; &lt;&lt; read_it-&gt;exampleInt &lt;&lt; endl;
		  cout &lt;&lt; &quot;read_it-&gt;exampleStr = &quot; &lt;&lt; read_it-&gt;exampleStr &lt;&lt; endl;
		  
		  results.push_back(*read_it);
		}
		catch (RootException &amp;ex)
		{
		  cout &lt;&lt; &quot;Caught Exception!!!!&quot; &lt;&lt; endl;
		  cout &lt;&lt; ex.what() &lt;&lt; endl;
		}
	}

	LoggingHandler&lt;Example&gt; handler = 
		read_it.get_io_handler((LoggingHandler&lt;Example&gt; *) NULL);

	typedef LoggingHandler&lt;Example&gt;::LoggedTriple LoggedTriple;

	vector&lt;LoggedTriple&gt; errors = handler.GetLog();

	for (vector&lt;LoggedTriple&gt;::iterator log_it = errors.begin(); log_it != errors.end();
			log_it++)
	{
		LoggedTriple error = *log_it;

		cout &lt;&lt; &quot;Error msg = &quot; &lt;&lt; error.errmsg &lt;&lt; endl;
		cout &lt;&lt; &quot;Example = &quot; &lt;&lt; error.dataObj &lt;&lt; endl;
	}

}
</code></pre>


 </p>

<h3>Example 2: A Heroic Error Handler</h3>

<p><pre><code><span class="codeComment">// Let's Use our X-Ray Vision to Look at the Innards of our Hero</span>


template&lt;class DataObj, class ParamObj = DefaultParamObj&lt;DataObj&gt; &gt; class OurHeroicHandler
{
private:
	<span class="codeComment">// ... some state data, but assume handler is default constructible</span>
public:

	dtl_ios_base::MeansOfRecovery
		operator()(RootException &amp;ex, dtl_ios_base &amp;base,
		   DataObj &amp;data, ParamObj &amp;params)
	{
		<span class="codeComment">// example of what you might do in a handler</span>
		if (bad())
		{
			LogErrorToFile(ex);
			return dtl_ios_base::THROW_EXCEPTION;
		}
		else if (fail())
		{
			<span class="codeComment">// tries to make the DataObj valid and then reapplies previous operation
			// to base on the good object ... may still fail</span>
			bool failed = WorkMagicOnDataObjAndTryAgain(...);

			if (failed)
			{
				LogErrorToFile(ex);
				return dtl_ios_base::THROW_EXCEPTION;
			}
			else
				return dtl_ios_base::SUPPRESS_ERROR; <span class="codeComment">// success ... our superhero
								     // has saved the day!</span>
		}
	}
};
</code></pre>

 </p>

<h3>Public Base Classes</h3>

<p>None.</p>

<h3>Template parameters</h3>

<table border="1">
<TBODY>    <tr>
        <th>Parameter </th>
        <th>Description </th>
        <th>Default </th>
    </tr>
    <tr>
        <td valign="top"><tt>DataObj</tt> </td>
        <td valign="top">The value type of objects in a <font
        size="2" face="Courier New">DBView</font>. </td>
        <td valign="top">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top"><tt>ParamObj</tt> </td>
        <td valign="top">The type of object used to specify the
        postfix parameters to the <font size="2"
        face="Courier New">DBView</font>.</td>
        <td valign="top"><font size="2" face="Courier New">DefaultParamObj&lt;DataObj&gt;</font>&nbsp;
        </td>
    </tr>
</TBODY></table>

<p>&nbsp;</p>

<h3>Notation</h3>

<table border="0">
    <tr>
        <td valign="top"><tt>X</tt> </td>
        <td valign="top">A type that is a model of <font size="2"
        face="Courier New">IOHandler</font></td>
    </tr>
    <tr>
        <td valign="top"><tt>a</tt> </td>
        <td valign="top">Object of type <tt>X</tt> </td>
    </tr>
</table>

<h3>Expression semantics</h3>

<table border="1">
    <tr>
        <th>Name </th>
        <th>Expression </th>
        <th>Precondition </th>
        <th>Semantics </th>
        <th>Postcondition </th>
    </tr>
    <tr>
        <td valign="top">Default constructor </td>
        <td valign="top"><pre>X a()</pre>
        </td>
        <td valign="top">&nbsp; </td>
        <td valign="top">Construct the function object.</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">Copy constructor </td>
        <td valign="top"><pre>X a(constX &amp;b)</pre>
        </td>
        <td valign="top">&nbsp; </td>
        <td valign="top">Copy construct the <font size="2"
        face="Courier New">IOHandler</font>.</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top"><font size="2" face="Courier New">UserHandler</font>
        constructor</td>
        <td valign="top"><pre>template&lt;class UserHandler&gt; a(const UserHandler hb)</pre>
        </td>
        <td valign="top">&nbsp; </td>
        <td valign="top">Construct the <font size="2"
        face="Courier New">IOHandler</font> using the user-defined
        handler ( it's type is bound to the <font size="2"
        face="Courier New">UserHandler </font>template parameter)
        passed in (the example classes above declare such
        handlers)..</td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td>Assignment Operator</td>
        <td><font size="2" face="Courier New">X operator=(const X
        &amp;b)</font></td>
        <td>&nbsp;</td>
        <td>Assign the <font size="2" face="Courier New">IOHandler</font>.</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">Handle exception operator</td>
        <td valign="top"><pre>dtl_ios_base::MeansOfRecovery operator()(RootException &amp;ex, dtl_ios_base &amp;base, DataObj &amp;data, ParamObj &amp;params)</pre>
        </td>
        <td valign="top">&nbsp; </td>
        <td valign="top">This operator takes references to the
        thrown <font size="2" face="Courier New">RootException</font>
        object, the <font size="2" face="Courier New">dtl_ios_base</font>
        (iterator) which threw, and the <font size="2"
        face="Courier New">DataObj </font>and <font size="2"
        face="Courier New">ParamObj </font>relevant to the
        exception. Handles the exception and then returns whether
        the iterator should suppress the error (<font size="2"
        face="Courier New">dtl_ios_base::SUPPRESS_ERROR</font>)
        or whether to still throw the exception (<font size="2"
        face="Courier New">dtl_ios_base::THROW_EXCEPTION</font>).
        </td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">Get <font size="2" face="Courier New">UserHandler</font></td>
        <td valign="top"><pre>template&lt;class UserHandler&gt; const UserHandler &amp;
   get(const UserHandler *dummy) const</pre>
        </td>
        <td valign="top">&nbsp; </td>
        <td valign="top">Returns the user-defined handler ( it's
        type is bound to the <font size="2" face="Courier New">UserHandler
        </font>template parameter). You must pass in a pointer to
        your user-defined handler's type so the compiler knows
        what type <font size="2" face="Courier New">UserHandler </font><font
        size="3">should be as in:</font><p><font size="2"
        face="Courier New">MyHandler my_handler = io_handler.get((MyHandler
        *) NULL);</font></p>
        </td>
        <td valign="top">&nbsp;</td>
    </tr>
</table>

<p>&nbsp;</p>

<h3>Notes</h3>


<h3>See also</h3>

<p><a href="AlwaysThrowsHandler.htm"><font size="2"
face="Courier New">AlwaysThrowsHandler</font></a><font size="2"
face="Courier New">, </font><a href="LoggingHandler.htm"><font
size="2" face="Courier New">LoggingHandler</font></a><font
size="2" face="Courier New">, <a href="BulkFetchHandler.htm">BulkFetchHandler</a>, 
  </font><a href="DBView.htm"><font
size="2" face="Courier New">DBView</font></a><font size="2"
face="Courier New">, </font><a href="IndexedDBView.htm"><font
size="2" face="Courier New">IndexedDBView</font><font size="2"><!--start footer--></font></a></p>

<p>
<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright © 2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body> </p>
</body>
</html>
