<html>

 
<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>DTL Performance</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p> 
<h1>DTL Performance Tips</h1>
<p>
Here is a short list of tips to get the best performance out of DTL.<br>
<b>1. </b> In your classes use a fixed length string such as char[x] or tcstring&lt;x&gt; to read or write character data for large data sets.
This allows dtl to bind the data directly to your class.  If you use std::string in your
class then DTL assumes that the string might be arbitrarily long and calls SQLGetData / SQLPutData to read or write
the information which is slower than directly binding a fixed length string. <br>
<b>2. </b> If you are reading a large number of records or writing a large number of records at once then use the 
bulk_copy or bulk_copy_helper methods as these can use ODBC bulk operations to read/write the data which is
much faster than working with one record at a time.  This tip will give you the biggest improvement for insert operations.
Bulk fetch is about 10% faster than a fetch done one row at a time, but bulk insert is often more than twice as fast as 
inserts that are done one row at a time.<br>
<b>3. </b> If you are going to be executing a SQL statement multiple times, then try to re-use that iterator (and associated DBView).
Re-using an existing iterator to re-execute an existing statement is much faster than re-creating the statement
every single time.
</p>

<h1>DTL Performance Benchmarks</h1>

<p><font size="4" face="Times Roman">In order to get an understanding of how much overhead is
incurred in working with a DBView we ran some tests which compare
a DBView::select_iterator to a select statement using the raw
ODBC API :</font></p>

<pre><code>
<span class="codeComment">// Read the contents of the DB_EXAMPLE table and return a vector of the
// resulting rows
// Use DTL</span>
vector&lt;Example&gt; ReadData()
{
 vector&lt;Example&gt; results;
 DBView&lt;Example&gt; view(&quot;DB_EXAMPLE&quot;);

 DBView&lt;Example&gt;::select_iterator read_it = view.begin();
 DBView&lt;Example&gt;::select_iterator end_it = view.end();

 for ( ; read_it != end_it; ++read_it)
 {
  results.push_back(*read_it);
 }

 return results;
}

<span class="codeComment">// Read the contents of the DB_EXAMPLE table and return a vector of the
// resulting rows
// Use raw ODBC API</span>
vector&lt;Example&gt; RawReadData()
{
	vector&lt;Example&gt; results;
	Example row;

	SQLHENV	     	V_OD_Env;			<span class="codeComment">// Handle ODBC environment</span>
	RETCODE		V_OD_erg;			<span class="codeComment">// result of functions</span>
	SQLHDBC		V_OD_hdbc;		<span class="codeComment">// Handle connection</span>
	SQLHSTMT	V_OD_hstmt;

	SQLINTEGER		V_OD_status[10];	<span class="codeComment">// Status SQL, NULL or not</span>
	char                	string_buffer[200];
	TIMESTAMP_STRUCT    	timestamp_buffer;
	 
	V_OD_Env = DBConnection::GetDefaultConnection().GetHENV();
	V_OD_hdbc = DBConnection::GetDefaultConnection().GetHDBC();

	V_OD_erg=SQLAllocHandle(SQL_HANDLE_STMT, V_OD_hdbc, &amp;V_OD_hstmt);
	if ((V_OD_erg != SQL_SUCCESS) &amp;&amp; (V_OD_erg != SQL_SUCCESS_WITH_INFO))
	{
		cout &lt;&lt; &quot;Error. Unable to alloc handle&quot; &lt;&lt; endl;
		exit(0);
	}
	SQLBindCol(V_OD_hstmt,1,SQL_C_SSHORT, &amp;row.exampleInt, 0, &amp;V_OD_status[0]);
	SQLBindCol(V_OD_hstmt,2,SQL_C_CHAR, string_buffer, sizeof(string_buffer), &amp;V_OD_status[1]);
	SQLBindCol(V_OD_hstmt,3,SQL_C_DOUBLE, &amp;row.exampleDouble, 0, &amp;V_OD_status[2]);
	SQLBindCol(V_OD_hstmt,4,SQL_C_SLONG, &amp;row.exampleLong, 0, &amp;V_OD_status[3]);
	SQLBindCol(V_OD_hstmt,5,SQL_C_TIMESTAMP, &amp;timestamp_buffer, 0, &amp;V_OD_status[4]);

	V_OD_erg=SQLExecDirect(V_OD_hstmt,(unsigned char *)&quot;SELECT INT_VALUE, STRING_VALUE, DOUBLE_VALUE, EXAMPLE_LONG, &quot;
	 &quot;EXAMPLE_DATE FROM DB_EXAMPLE&quot;,SQL_NTS);   
	if ((V_OD_erg != SQL_SUCCESS) &amp;&amp; (V_OD_erg != SQL_SUCCESS_WITH_INFO))
	{
	   cout &lt;&lt; &quot;Error. Unable to execute statement&quot; &lt;&lt; endl;
	   exit(0);
	}

	while(SQLFetch(V_OD_hstmt) != SQL_NO_DATA)
        {
	   row.exampleStr = string_buffer;
	   row.exampleDate = timestamp_buffer;
           results.push_back(row);
    
        }  
    	SQLFreeHandle(SQL_HANDLE_STMT,V_OD_hstmt);

   	return results;
}
</code></pre>

<pre><code>void test_read() {
   <span class="codeComment">// read initial data from table</span>
   _ftime( &amp;start );
   examples = RawReadDataDummy();  <span class="codeComment">// RawReadDataDummy() is the same as RawReadData() -- see below for an explanation</span>
  _ftime( &amp;finish );
   cout &lt;&lt; &quot;Dummy: &quot; &lt;&lt; finish.time*1000+finish.millitm 
	   - start.time*1000 - start.millitm &lt;&lt; endl;



   <span class="codeComment">// read data from table using ODBC API</span>
   cout &lt;&lt; &quot;Examples read from database using raw ODBC API:&quot; &lt;&lt; endl;
   _ftime( &amp;start );
   for (i = 0; i &lt; 10; i++)
     examples = RawReadData();
   _ftime( &amp;finish );
   cout &lt;&lt; &quot;Raw: &quot; &lt;&lt; finish.time*1000+finish.millitm 
	   - start.time*1000 - start.millitm &lt;&lt; endl;

 
   <span class="codeComment">// read data from table using DBView</span>
   cout &lt;&lt; &quot;Examples read from database using DBView:&quot; &lt;&lt; endl;
   _ftime( &amp;start );
   for (i = 0; i &lt; 10; i++)
     examples = ReadData();
   _ftime( &amp;finish );
   cout &lt;&lt; &quot;Read Data: &quot; &lt;&lt; finish.time*1000+finish.millitm 
	   - start.time*1000 - start.millitm &lt;&lt; endl;
}</code></pre>

<p><font size="4" face="Times Roman">In running these tests you will notice that there is a call to
a function called DummyRawReadData. The reason for this is that
when we first ran our tests versus MS SQL Server 7.0, we noticed
that whichever routine was called first would always run more slowly. It
turns out that the way the SQL Server 7 ODBC driver works, when the first
statement is executed the SQL is parsed and all 32 records from
the DB_EXAMPLE table are stored into a buffer. On our test
machine, the population of this buffer takes about 150ms, wheras transferring the contents of the
buffer to a local vector requires about 2ms. Furthermore
any subsequent ODBC call which executes the same SQL select
statement is able to simply reuse the driver's data buffer. So, to in order to
not distort perfomance metrics we measure the cost of this first
fetch separately by a routine called RawReadDataDummy.</p>

<p>Test results from running the program four times using a 333MHZ Pentium computer with SQLServer 7.0 and
the above code. All times shown in milliseconds as output:</font></p>

<table border="1" font size="4" face="Times Roman">
    <tr>
        <td><font size="4">RawReadDataDummy (called once)</font></td>
        <td><font size="4">160</font></td>
        <td><font size="4">150</font></td>
        <td><font size="4">160</font></td>
        <td><font size="4">190</font></td>
    </tr>
    <tr>
        <td><font size="4">RawReadData (called x10)</font></td>
        <td><font size="4">18.1</font></td>
        <td><font size="4">19.1</font></td>
        <td><font size="4">18.0</font></td>
        <td><font size="4">19.0</font></td>
    </tr>
    <tr>
        <td><font size="4">ReadData (called x10)</font></td>
        <td><font size="4">68.1</font></td>
        <td><font size="4">67.1</font></td>
        <td><font size="4">68.1</font></td>
        <td><font size="4">68.1</font></td>
    </tr>
</table>


<p><font size="4" face="Times Roman">This gave us a feel for the overall performance difference
between the two methods. The next question we asked was how much
of this performance difference was a constant factor
(initialization of the DBView + iterator) and how much of this difference
was a variable overhead (i.e. a cost per row of data read). To
answer this question we ran the code through Numega TrueTime (TM)
which was able to measure the amount of time spent on a line by line basis in the
functions above.  Doing the math with this profiling
tool led to the result that 72.4% of the function time for RawReadData was spent in
the fetch loop whereas 56.3% of the function time for ReadData was in the fetch loop. This gives us:
</font></p>
<table border="1">
    <tr>
        <td><font size="4">Function</font></td>
        <td><font size="4">Fetch loop time in ms</font></td>
        <td><font size="4">Time outside fetch loop / fixed
        overhead</font></td>
    </tr>
    <tr>
        <td><font size="4">RawReadData</font></td>
        <td><font size="4">18.5 * .724 = 13.40</font></td>
        <td><font size="4">18.5 * .276 = 5.11</font></td>
    </tr>
    <tr>
        <td><font size="4">ReadData</font></td>
        <td><font size="4">68.1 * .563 = 38.34</font></td>
        <td><font size="4">68.1 * .437 = 29.76</font></td>
    </tr>
</table>
<p><font size="4" face="Times Roman">Therefore if we look at the fetch loop the overhead incurred by the ReadData routine 
is a total 24.94ms.  Since ReadData was called 10 times, and the total number of rows fetched
was 32, this gives a per row overhead of 0.08ms / row when using DBView versus
a the raw ODBC API calls shown above.  Similarly, we can compute the fixed / construction time
overhead of using a DBView as 2.46ms.</font></p>

<h2>Conclusions:</h2>
<p><font size="4" face="Times Roman">There is a performance price to be paid for using the DBView code.  However, the
per row overhead is relatively small, on the order of 0.08ms / row on our 333MHZ test machine.
Most of the overhead in using a DBView comes from the constructor calls associated with
creating a DBView and a select iterator.  The DBView construction overhead is on the order of 2.46ms.
This construction overhead is relatively small compared to the time taken to parse 
a query and read rows from the database which is on the order of 150ms in RawReadDataDummy above.  So, the
most significant overhead is the construction cost for a DBView, but for the majority
of applications this will not be noticeable as it is dwarfed by the time taken to process
the underlying query against the database.
</font></p>



<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright © 2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body> 
</html>
