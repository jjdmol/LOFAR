// -*- mode: c++ -*-//
// Protocol definition for the EPA Demonstrator Board
//
autogen definitions protocol;

description = "Protocol for the EPA Demonstrator Board";
prefix = "EPA"; // for the signal names
id = "(LOFAR::GCF::TM::F_APL_PROTOCOL+11)";

// specify extra include files
// e.g.
include = '<sys/time.h>';
include = '<linux/types.h>';
include = '<net/ethernet.h>';
include = '<Common/LofarTypes.h>';
include = '<APL/RSP_Protocol/MEPHeader.h>';
include = '<APL/RSP_Protocol/MEPData.h>';

prelude = << PRELUDE_END

/**
 * Protocol constants.
 */

#undef MIN
#define MIN(a,b) ((a)<(b)?(a):(b))

  /*@{*/
  /**
   * Constants used in the EPA protocol.
   * These constants are all derived from the leading
   * constants in MEPHeader.h.
   */
  static const int N_AP            = 4; // number of AP's per board
  static const int N_COEF          = MIN(MEPHeader::FRAGMENT_SIZE, MEPHeader::BF_XROUT_SIZE) / sizeof(int16);
  static const int BF_N_FRAGMENTS  = 1; // MEPHeader::BF_XROUT_SIZE / MEPHeader::FRAGMENT_SIZE
  static const int N_WAVE_SAMPLES  = MEPHeader::DIAG_WGXWAVE_SIZE / sizeof(int16);
  static const int BST_N_FRAGMENTS = 1; // MEPHeader::BST_POWER_SIZE / MEPHeader::FRAGMENT_SIZE;
  static const int SST_N_FRAGMENTS = MEPHeader::SST_POWER_SIZE / MEPHeader::FRAGMENT_SIZE;
  static const int N_SST_STATS     = MEPHeader::FRAGMENT_SIZE / sizeof(uint32);
  static const int N_BST_STATS     = MIN(MEPHeader::FRAGMENT_SIZE, MEPHeader::BST_POWER_SIZE) / sizeof(uint32);
  static const int XST_N_FRAGMENTS = (MEPHeader::N_GLOBAL_XLETS > MEPHeader::MAX_XLETS_PER_FRAGMENT ? 2 : 1);
  static const int N_XST_STATS     = MEPHeader::XST_FRAGMENT_SIZE / sizeof(uint32);

  /*@}*/

  typedef struct RSPStatus // total size 8 bytes
  {
    uint8 voltage_1_5; // measured voltage on 1.5V circuit
    uint8 voltage_3_3; // measured voltage on 3.3V circuit
    uint8 bp_temp;     // board processor temperature
    uint8 ap0_temp;    // antenna processor 0 temperature
    uint8 ap1_temp;    // antenna processor 1 temperature
    uint8 ap2_temp;    // antenna processor 2 temperature
    uint8 ap3_temp;    // antenna processor 3 temperature
    uint8 bp_clock;    // board processor system clock speed
  };

  typedef struct ETHStatus // total size 12 bytes
  {
    uint32 nof_frames; // number of ETH frame received
    uint32 nof_errors; // number of incorrect ETH frames
    uint8  last_error; // error status of last received ETH frame
    uint8  ffi0;
    uint8  ffi1;
    uint8  ffi2;
  };
  
  typedef struct MEPStatus // total size 4 bytes
  {
    uint16 seqnr;  // sequence number of previously received message
    uint8  error;  // error status of previously received message
    uint8  ffi0;
  };

  typedef struct DIAGStatus // total size 24 bytes
  {
    uint8  interface;     // Interface under test
    uint8  mode;          // Test mode
    uint16 ri_errors;     // Number of detected errors
    uint16 rcux_errors;   // Number of detected errors
    uint16 rcuy_errors;   // Number of detected errors
    uint16 lcu_errors;    // Number of detected errors
    uint16 cep_errors;    // Number of detected errors
    uint16 serdes_errors; // Number of detected errors
    uint16 ap0_ri_errors; // Number of detected errors
    uint16 ap1_ri_errors; // Number of detected errors
    uint16 ap2_ri_errors; // Number of detected errors
    uint16 ap3_ri_errors; // Number of detected errors
    uint16 ffi;
  };
  
  typedef struct BSStatus // total size 64 bytes
  {
    uint32 ext_count;     // number of cycles between external and internal sync, reset 
    uint32 sync_count;    // number of internal sync events
    uint32 sample_offset; // number of samples processed since last reset (wraps)
    uint32 slice_count;   // number of slices in the previous internal sync interval
  };

  typedef struct APStatus // total size 48 bytes
  {
    struct {
      uint8 pllx:1;
      uint8 plly:1;
      uint8 ffi :6;
    };
    uint8  ffi0;
    uint8  ffi1;
    uint8  ffi2;
    uint32 nof_overflowx;
    uint32 nof_overflowy;
  };

  typedef struct RSUStatus // total size 4 bytes
  {
    uint8 rdy:1;  // 0 = Configuration ongoing, 1 = Configuration done
    uint8 err:1;  // 0 = Configuration was succesful, 1 = Error during configuration
    uint8 fpga:1; // 0 = BP was reconfigured, 1 = AP was reconfigured
    uint8 im:1;   // 0 = Factory image, 1 = Application image
    uint8 trig:3; // 000 = Board reset
                  // 001 = User reconfiguration request
                  // 010 = User reset request
                  // 100 = Watchdog timer timeout
    uint8 ffi:1;  // not used
  };

  typedef struct BoardStatus // total size 164 bytes
  {
    RSPStatus  rsp;
    ETHStatus  eth;
    MEPStatus  mep;
    DIAGStatus diag;
    BSStatus   ap0_sync;
    BSStatus   ap1_sync;
    BSStatus   ap2_sync;
    BSStatus   ap3_sync;
    APStatus   ap0_rcu;
    APStatus   ap1_rcu;
    APStatus   ap2_rcu;
    APStatus   ap3_rcu;
    RSUStatus  cp_status;
  };

  typedef struct RSRVersion
  {
    uint8 rsp;         // RSP hardware version, undefined for AP's
    uint8 fpga_min :4; // FPGA firmware version (minor)
    uint8 fpga_maj :4; // FPGA firmware version (major)
    uint8 fpga_id  :4; // 4 bits for FPGA identifier number (0..3)
    uint8 board_pos:4; // 4 remaining bits for board_pos (0..1)
  };

  typedef struct RSUReconfig
  {
    uint8 page      :3;       // page selection
    uint8 ffi       :4;
    uint8 fpgaselect:1; // fpga selection (0 == reconfigure AP, 1 == reconfigure BP)
  };

  typedef struct RSUReset
  {
    uint8 sync :1; // send sync pulse to all FPGA's
    uint8 clear:1; // clear all FPGA's
    uint8 reset:1; // reset all FPGA's and reconfigure BP with factory image
    uint8 ffi  :5;
  };

  typedef struct DIAGBypass
  {
    uint8 ffi0:1;
    uint8 pfs :1;  // bypass PFS
    uint8 pft :1;  // bypass PFT
    uint8 bf  :1;  // bypass BF
    uint8 ffi1:4;
  };

  typedef struct RCUHandler
  {
    uint8 spec_inv_x   :1; // spectral inversion bit for X-receiver
    uint8 spec_inv_y   :1; // spectral inversion bit for Y-receiver
    uint8 ffi0         :6;
    uint8 input_delay_x:7; // input delay for X-receiver
    uint8 ffi1         :1;
    uint8 input_delay_y:7; // input delay for Y-receiver
    uint8 ffi2         :1;
  };

  typedef struct CRControl
  {
    uint8 sync        :1; // generate soft sync pulse for a specific FPGA
    uint8 clear       :1; // soft clear a specific FPGA
    uint8 sync_disable:1; // disable the external sync pulse
    uint8 ffi         :5;
  };

  /*@{*/
  /**
   * Output operators for the system status types.
   */ 
  inline std::ostream& operator<<(std::ostream& s, const BoardStatus&  stat)
  {
#if 0
    return s;
#else
    return s << "[" << std::endl
	     << "voltage_1_5 =" << int(stat.rsp.voltage_1_5) << std::endl
	     << "voltage_3_3 =" << int(stat.rsp.voltage_3_3) << std::endl
	     << "bp_temp     = " << int(stat.rsp.bp_temp)    << std::endl
	     << "ap0_temp    = " << int(stat.rsp.ap0_temp)   << std::endl
	     << "ap1_temp    = " << int(stat.rsp.ap1_temp)   << std::endl
	     << "ap2_temp    = " << int(stat.rsp.ap2_temp)   << std::endl
	     << "ap3_temp    = " << int(stat.rsp.ap3_temp)   << std::endl
             << "bp_clock    = " << int(stat.rsp.bp_clock)   << std::endl
	     << "nof_frames  = " << stat.eth.nof_frames      << std::endl
	     << "nof_error   = " << stat.eth.nof_errors      << std::endl
	     << "last_error  = " << int(stat.eth.last_error) << std::endl
	     << "seqnr       = " << stat.mep.seqnr           << std::endl
	     << "error       = " << int(stat.mep.error)      << std::endl
	     << std::endl
	     << "ap0_sync.ext_count     = " << stat.ap0_sync.ext_count     << std::endl
	     << "ap0_sync.sync_count    = " << stat.ap0_sync.sync_count    << std::endl
	     << "ap0_sync.sample_offset = " << stat.ap0_sync.sample_offset << std::endl
	     << "ap0_sync.slice_count   = " << stat.ap0_sync.slice_count   << std::endl
	     << "ap1_sync.ext_count     = " << stat.ap1_sync.ext_count     << std::endl
	     << "ap1_sync.sync_count    = " << stat.ap1_sync.sync_count    << std::endl
	     << "ap1_sync.sample_offset = " << stat.ap1_sync.sample_offset << std::endl
	     << "ap1_sync.slice_count   = " << stat.ap1_sync.slice_count   << std::endl
	     << "ap2_sync.ext_count     = " << stat.ap2_sync.ext_count     << std::endl
	     << "ap2_sync.sync_count    = " << stat.ap2_sync.sync_count    << std::endl
	     << "ap2_sync.sample_offset = " << stat.ap2_sync.sample_offset << std::endl
	     << "ap2_sync.slice_count   = " << stat.ap2_sync.slice_count   << std::endl
	     << "ap3_sync.ext_count     = " << stat.ap3_sync.ext_count     << std::endl
	     << "ap3_sync.sync_count    = " << stat.ap3_sync.sync_count    << std::endl
	     << "ap3_sync.sample_offset = " << stat.ap3_sync.sample_offset << std::endl
	     << "ap3_sync.slice_count   = " << stat.ap3_sync.slice_count   << std::endl
	     << std::endl
	     << "diag.interface     = " << int(stat.diag.interface) << std::endl
	     << "diag.mode          = " << int(stat.diag.mode)      << std::endl
	     << "diag.ri_errors     = " << stat.diag.ri_errors      << std::endl
	     << "diag.rcux_errors   = " << stat.diag.rcux_errors    << std::endl
	     << "diag.rcuy_errors   = " << stat.diag.rcuy_errors    << std::endl
	     << "diag.lcu_errors    = " << stat.diag.lcu_errors     << std::endl
	     << "diag.cep_errors    = " << stat.diag.cep_errors     << std::endl
	     << "diag.serdes_errors = " << stat.diag.serdes_errors  << std::endl
	     << "diag.ap0_ri_errors = " << stat.diag.ap0_ri_errors  << std::endl
	     << "diag.ap1_ri_errors = " << stat.diag.ap1_ri_errors  << std::endl
	     << "diag.ap2_ri_errors = " << stat.diag.ap2_ri_errors  << std::endl
	     << "diag.ap3_ri_errors = " << stat.diag.ap3_ri_errors  << std::endl
	     << std::endl
	     << "ap0_rcu.pllx          = " << (int)stat.ap0_rcu.pllx          << std::endl
	     << "ap0_rcu.plly          = " << (int)stat.ap0_rcu.plly          << std::endl
	     << "ap0_rcu.nof_overflowx = " << stat.ap0_rcu.nof_overflowx      << std::endl
	     << "ap0_rcu.nof_overflowy = " << stat.ap0_rcu.nof_overflowy      << std::endl
	     << "ap1_rcu.pllx          = " << (int)stat.ap1_rcu.pllx          << std::endl
	     << "ap1_rcu.plly          = " << (int)stat.ap1_rcu.plly          << std::endl
	     << "ap1_rcu.nof_overflowx = " << (int)stat.ap1_rcu.nof_overflowx << std::endl
	     << "ap1_rcu.nof_overflowy = " << stat.ap1_rcu.nof_overflowy      << std::endl
	     << "ap2_rcu.pllx          = " << (int)stat.ap2_rcu.pllx          << std::endl
	     << "ap2_rcu.plly          = " << (int)stat.ap2_rcu.plly          << std::endl
	     << "ap2_rcu.nof_overflowx = " << stat.ap2_rcu.nof_overflowx      << std::endl
	     << "ap2_rcu.nof_overflowy = " << stat.ap2_rcu.nof_overflowy      << std::endl
	     << "ap3_rcu.pllx          = " << (int)stat.ap3_rcu.pllx          << std::endl
	     << "ap3_rcu.plly          = " << (int)stat.ap3_rcu.plly          << std::endl
	     << "ap3_rcu.nof_overflowx = " << stat.ap3_rcu.nof_overflowx      << std::endl
	     << "ap3_rcu.nof_overflowy = " << stat.ap3_rcu.nof_overflowy      << std::endl
             << std::endl
	     << "cp_status.rdy  = " << int(stat.cp_status.rdy)  << std::endl
	     << "cp_status.err  = " << int(stat.cp_status.err)  << std::endl
	     << "cp_status.fpga = " << int(stat.cp_status.fpga) << std::endl
	     << "cp_status.im   = " << int(stat.cp_status.im)   << std::endl
	     << "cp_status.trig = " << int(stat.cp_status.trig) << ", " << std::endl
      
	     << "]" << std::endl;
#endif
  }
  
  /*@}*/

PRELUDE_END;

//
// The EPA events are specified from the point of view
// of the EPA firmware. An event with direction IN is 
// an input to the EPA firmware, OUT is an output of
// the EPA firmware and INOUT is both.
//

//
// Generic events:
// * READ  , READACK  , READACK_ERROR
// * WRITE , WRITEACK , WRITEACK_ERROR
//
// For the specific EPA registers the following generic
// events are used because there is no point in using
// specific events when only a MEPHeader is sent:
// * READ, READACK_ERROR, WRITEACK, WRITEACK_ERROR
//
// For each read-only EPA register a specific OUT
// event is defined.
//
// For each read-write EPA register a specific INOUT
// event is defined.
//
// This results in the following scenarios (REGISTER_X)
// is a placeholder for register READACK, WRITE events.
//
// Read register (success):
//
//  User                      EPA
//  ----                      ---
//   |                         |
//   +-------READ------------->|
//   |                         |
//   |<-----REGISTER_X---------+
//   |                         |
//
//  Read register (error)
//
//  User                          EPA
//  ----                          ---
//   |                             |
//   +-------READ----------------->|
//   |                             |
//   |<---READACK_ERROR------------+
//   |                             |
//
// Write register (success)
//
//  User                      EPA
//  ----                      ---
//   |                         |
//   +-------REGISTER_X------->|
//   |                         |
//   |<------WRITEACK----------+
//   |                         |
//
// Write register (error)
//
//  User                      EPA
//  ----                      ---
//   |                         |
//   +-------REGISTER_X------->|
//   |                         |
//   |<------WRITEACK_ERROR----+
//   |                         |
//
// There are also generic WRITE and READACK events
// which have a generic "MEPData payload" parameter
// to send/recv variable sized payload data.
//
event = {
  noheader;
  signal = WRITE;
  dir = OUT; // output to hardware
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "payload";
    type = "MEPData";
    userdefined;
  };
};

event = {
  noheader;
  signal = WRITEACK;
  dir = IN; // input from hardware
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
};

event = {
  noheader;
  signal = WRITEACK_ERROR;
  dir = IN; // input from hardware
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
};

event = {
  noheader;
  signal = READ;
  dir = OUT; // output to hardware
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
};

event = {
  noheader;
  signal = READACK;
  dir = IN; // input from hardware
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "payload";
    type = "MEPData";
    userdefined;
  };
};

event = {
  noheader;
  signal = READACK_ERROR;
  dir = IN; // input from hardware
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
};

//
// Specific READACK and WRITE events start here
//

event = {
  noheader;
  signal = RSR_STATUS;
  dir = IN; // read-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "board";
    type = "BoardStatus";
  };
};

event = {
  noheader;
  signal = RSR_VERSION;
  dir = IN; // read-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "version";
    type = "RSRVersion";
  };
};

event = {
  noheader;
  signal = RSU_FLASHRW;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "data";
    type = "MEPData";
    userdefined;
  };
};

event = {
  noheader;
  signal = RSU_FLASHERASE;
  dir = OUT; // write-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  parm = {
    name = "erase"; // value must always be 1
    type = "uint8";
  };
};

event = {
  noheader;
  signal = RSU_RECONFIGURE;
  dir = OUT; // write-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "config";
    type = "RSUReconfig";
  };
};

event = {
  noheader;
  signal = RSU_RESET;
  dir = OUT; // write-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "reset";
    type = "RSUReset";
  };
};

event = {
  noheader;
  signal = DIAG_WG; // hdr should specify XPOL/YPOL
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "mode";
    type = "uint8";
  };
  param = {
    name = "phase";
    type = "uint8";
  };
  param = {
    name = "nof_samples";
    type = "uint16";
  };
  param = {
    name = "freq";
    type = "uint16";
  };
  param = {
    name = "ampl";
    type = "uint16";
  };
};

event = {
  noheader;
  signal = DIAG_WGWAVE; // hdr should specify XPOL/YPOL
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "samples";
    type = "int16[N_WAVE_SAMPLES]";
  };
};

event = {
  noheader;
  signal = DIAG_BYPASS;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "bypass";
    type = "DIAGBypass";
  };
};

event = {
  noheader;
  signal = DIAG_RESULTS;
  dir = IN; // read-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "data";
    type = "MEPData";
    userdefined;
  };
};

event = {
  noheader;
  signal = DIAG_SELFTEST;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    //
    // interface
    // 0: ring
    // 1: rcu x
    // 2: rcu y
    // 3: lcu (control)
    // 4: cep (output)
    // 5: serdes (b2b = board2board)
    //
    name = "interface";
    type = "uint8";
  };
  param = {
    //
    // testmode
    // 1: local loopback
    // 2: remote loopback
    // 3: transmit
    // 4: receive
    // 5: lane
    // 6: lane single
    //
    name = "mode";
    type = "uint8";
  };
  param = {
    //
    // selftest duration
    // 0:debug
    // 1:short
    // 2:normal
    // 3:long
    //
    name = "duration";
    type = "uint8";
  };
  param = {
    name = "lane"; // LVDS ring bit lane index
    type = "uint8";
  };
};

event = {
  noheader;
  signal = SS_SELECT;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "subbands";
    type = "uint16[MEPHeader::SS_SELECT_SIZE / sizeof(uint16)]";
  };
};

event = {
  noheader;
  signal = BF_COEFS; // hdr should specify XROUT, XIOUT, XROUT or YIOUT
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "coef";
    type = "int16[N_COEF]";
  };
};

event = {
  noheader;
  signal = BST_STATS; // hdr should specify SST_POWER or BST_POWER
  dir = IN; // read-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "stat";
    type = "uint32[N_BST_STATS]";
  };
};

event = {
  noheader;
  signal = SST_STATS; // hdr should specify SST_POWER or BST_POWER
  dir = IN; // read-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "stat";
    type = "uint32[N_SST_STATS]";
  };
};

event = {
  noheader;
  signal = RCU_SETTINGS;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "ap";
    type = "RCUHandler";
  };
};

event = {
  noheader;
  signal = RCU_PROTOCOL; // hdr should specify XPOL or YPOL
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "data";
    type = "MEPData";
    userdefined;
  };
};  

event = {
  noheader;
  signal = RCU_RESULTS; // hdr should specify XPOL or YPOL
  dir = IN; // read-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "data";
    type = "MEPData";
    userdefined;
  };
};

event = {
  noheader;
  signal = CR_CONTROL;
  dir = OUT; // write-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "control"; // should always have value 0x1
    type = "CRControl";
  };
};

event = {
  noheader;
  signal = XST_STATS;
  dir = IN; // read-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "xst_stat";
    type = "uint32[N_XST_STATS]";
  };
};

event = {
  noheader;
  signal = CDO_SETTINGS;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "station_id";
    type = "uint32";
  };
  param = {
    name = "configuration_id";
    type = "uint16";
  };
  param = {
    name = "format";
    type = "uint16";
  };
  param = {
    name = "antenna_id";
    type = "uint16";
  };
  param = {
    name = "destination_mac";
    type = "uint8[ETH_ALEN]";
  };
};

event = {
  noheader;
  signal = CDO_HEADER;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "header";
    type = "uint8[MEPHeader::CDO_HEADER_SIZE]";
  };
};

event = {
  noheader;
  signal = BS_NOFSAMPLESPERSYNC;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "nof_samples_per_sync_interval";
    type = "uint32";
  };
};

event = {
  noheader;
  signal = TDS_PROTOCOL;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "data";
    type = "MEPData";
    userdefined;
  };
};  

event = {
  noheader;
  signal = TDS_RESULTS;
  dir = IN; // read-only register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "data";
    type = "MEPData";
    userdefined;
  };
};

event = {
  noheader;
  signal = TBB_CONTROL;
  dir = INOUT; // read-write register
  param = {
    name = "hdr";
    type = "MEPHeader";
    userdefined;
  };
  param = {
    name = "dummy";
    type = "uint8";
  };
};  
