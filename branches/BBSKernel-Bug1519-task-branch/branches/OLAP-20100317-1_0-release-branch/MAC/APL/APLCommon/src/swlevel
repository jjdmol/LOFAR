#!/bin/bash
#
# swlevel : bring software on node in certain runlevel
#
# Copyright (C) 2006
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Syntax: swlevel [ 0 | 1 | 2 | 3 | 4 | 5 | 6 ]
#
# $Id$
#
VERSION="v1.7 20090130"		# loading image 1 before starting RSPdriver
BINDIR=/opt/lofar/bin
LOGDIR=${BINDIR}/../log
ETCDIR=${BINDIR}/../etc
LEVELTABLE=${ETCDIR}/swlevel.conf

#
# SyntaxError msg
#
SyntaxError()
{
	Msg=$1

	[ -z "${Msg}" ] || echo "ERROR: ${Msg}"
	echo ""
	echo "Syntax: $(basename $0) [-s/v] [ 0 | 1 | 2 | 3 | 4 | 5 | 6 ]"
	echo "-s: Show current level, exit"
	echo "-v: Show running LOFAR version, exit"
        echo
	echo "0:  stop all lofar software"
	echo "1:  Lofar daemons and PVSS"
	echo "2:  Lowlevel hardware drivers"
	echo "3:  Calculation services"
	echo "4:  Hardware and software monitors"
	echo "5:  System Health Management"
	echo "6:  MAC is controlling the software"
	echo ""
	exit 0
}

#
# selectImage1()
#
selectImage1()
{
	let nrRSPs=`grep RSPBOARDS ${ETCDIR}/RemoteStation.conf | cut -d'=' -f2 | sed 's/ //g'`
	let board=0
	while [ $board -lt $nrRSPs ]
	do
		# get version of RSPboard
		boardHex=`echo $board | awk '{ printf "%02x", $1 }'`
		rsu=`sudo ${BINDIR}/../sbin/rsuctl3 -m 10:fa:00:00:$boardHex:00 -qV 2>&1 | grep BP | cut -d':' -f2 | sed 's/ //g' | cut -d'.' -f1`
		if [ ${#rsu} -eq 1 ]; then
  		  let version=$rsu
 		  # if board has reset itself to image 0, load image 1 again
		  if [ $version -le 4 ]; then
		     echo "Loading image 1 on RSPboard $board ..."
		     sudo ${BINDIR}/../sbin/rsuctl3_reset -m 10:fa:00:00:$boardHex:00 -q -x -p 1 1>/dev/null 2>&1
		  fi
                else
                  echo "No RSP board $board found"
		fi
		let board+=1
	done
}

#
# Start the program when it exists
#
start_prog()
{
	# make arguments readable
	prog=$1
	asroot=${2:1}
	withmpi=${3:1}

	# special check for logging-daemons
	[ $prog == $logProgToSkip ] && return
	
	# check existance
	[ -x $BINDIR/$prog ] || [ -x $BINDIR/${prog}.sh ] || return

	# if it is a shell script call the script
	if [ -f $BINDIR/${prog}.sh ]; then
		$BINDIR/${prog}.sh start
		return
	fi

#	ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog} 1>/dev/null 2>&1
	/sbin/pidof ${prog} 1>/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo Starting $prog
		# PVSS needs special treatment
		if [ "$prog" = "PVSS00pmon" ]; then
			start_pvss2 1>/dev/null 2>&1 &
			sleep 5
		else
			if [ -n "$asroot" ]; then
				sudo rm -f $LOGDIR/$prog.log.? 1>/dev/null 2>&1
				if [ "$prog" = "RSPDriver" ]; then
					selectImage1
					sudo -b $BINDIR/$prog 1>/dev/null 2>&1
				else
					sudo -b $BINDIR/$prog 1>/dev/null 2>&1
				fi
			else
				rm -f $LOGDIR/$prog.log*.? 1>/dev/null 2>&1
				$BINDIR/$prog 1>/dev/null 2>&1 &
			fi
			sleep 1
		fi
		ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog}
	fi
}

#
# Stop the program when it is running
#
stop_prog()
{
	# make arguments readable
	prog=$1
	asroot=${2:1}
	withmpi=${3:1}
	[ ! -z "$asroot" ] && asroot=sudo	

	# special check for logging-daemons
	[ $prog == $logProgToSkip ] && return
	
	# check existance
	[ -x $BINDIR/$prog ] || [ -x $BINDIR/${prog}.sh ] || return
	
	# if it is a shell script call the script
	if [ -f $BINDIR/${prog}.sh ]; then
		$BINDIR/${prog}.sh stop
		return
	fi

	# get processlist
#	ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog} 2>&1 >/dev/null
	/sbin/pidof ${prog} 1>/dev/null 2>&1
	if [ $? -ne 0 ]; then
		return
	fi

	# PVSS needs special treatment
	if [ "$prog" = "PVSS00pmon" ]; then
		echo "Stopping PVSS database"
		start_pvss2 -stopWait
		return
	fi

	# first handle mpi programs
	if [ ! -z "$withmpi" ]; then
		$asroot cexec :0-11 killall -9 ${prog}
		return
	fi

	# first try normal kill
#	ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog} | awk '{ print $2 }' | while read pid
	for pid in `/sbin/pidof ${prog}`
	do 
		echo "Softly killing ${prog}(${pid})"
		$asroot kill $pid
		sleep 1
	done

	# when normal kill did not work, kill is with -9
#	ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog} | awk '{ print $2 }' | while read pid
	for pid in `/sbin/pidof ${prog}`
	do 
		sleep 2
		echo "Hard killing ${prog}(${pid})"
		$asroot kill -9 $pid 1>/dev/null 2>&1
	done
}

#
# show status of program
#
status_prog()
{
	echo
	echo Status of all software level:
	prevlevel=1
	list=( `cat $LEVELTABLE | cut -d"#" -f1 | awk '{ if (NF>0) print $0 }' ` )
	for line in ${list[@]}
	do
		levelnr=`echo $line | cut -d":" -f1`
		prog=`echo $line | cut -d":" -f6`
                pid=("")

		# special check for logging-daemons
		[ $prog == $logProgToSkip ] && continue
		
		# check existance
		[ -x $BINDIR/$prog ] || [ -x $BINDIR/${prog}.sh ] || continue
	
		if [ $prevlevel -ne $levelnr ]; then
			echo "---"
			prevlevel=$levelnr
		fi

		# if it is a shell script call the script
		if [ -f $BINDIR/${prog}.sh ]; then
			$BINDIR/${prog}.sh status $levelnr
			continue
		fi

#		ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog} 2>&1 >/dev/null
		/sbin/pidof ${prog} 1>/dev/null 2>&1
		if [ $? -eq 0 ]; then
			pid=( `/sbin/pidof ${prog}` )
		else
			pid="DOWN"
		fi
		echo ${levelnr}:${prog}:${pid[*]} | awk -F: '{ printf "%s : %-25s %s\n", $1, $2, $3 }'
		# Some Checks
		# AMCServer needs two instances
		if [ "$prog" == "AMCServer" -a $level -ge 3 ]; then
		    if [ ${#pid[@]} -lt 2 ]; then 
		       missing="$missing ${prog}[$levelnr]"
		    fi
		    if [ ${#pid[@]} -gt 2 ]; then 
                       toomany="$toomany ${prog}[$levelnr]"
		    fi
		else
		    # Other controllers must have one instance, only
		    if [ ${#pid[@]} -ge 2 ]; then 
                       toomany="$toomany ${prog}[$levelnr]"
		    fi
		fi
		
		# Check for missing controllers 
		if [ "$pid" = "DOWN" -o "$pid" = "0" ]; then 
  		  if [ $levelnr -le $level ]; then 
		    if [ $levelnr -le 5 ]; then
			missing="$missing ${prog}[$levelnr]"
		    else
			# LCU level 6 has two permanent controllers running
			if [ "$prog" == "StationControl" \
			    -o "$prog" == "ClockControl" ]; then 
			    missing="$missing ${prog}[$levelnr]"
			fi
			# MCU level 6 must have MACScheduler running
			if [ "$prog" == "MACScheduler" ]; then 
			    missing="$missing ${prog}[$levelnr]"
			fi
		    fi
		  fi
		fi
	done
	echo "---"
	if [ "$missing" ]; then 
		echo "Missing :"$missing
	fi
	if [ "$toomany" ]; then 
		echo "Too many:"$toomany
	fi
}

#
# goto_level levelnr
#
goto_level()
{
	#first power down to new level
	newlevel=$1

	# set rcumode to 0 (power save) when entering level 1
	if [ ${newlevel} -le 1 ]; then
          if [ -e /tmp/level.admin ]; then
            curlevel=`cat /tmp/level.admin`
          else
            curlevel=-1
          fi
          if [ ${curlevel} -ge 2 ]; then 
	    /sbin/pidof RSPDriver 1>/dev/null 2>&1
	    if [ $? -eq 0 ]; then
     	      echo "set rcumode to 0 (power save)"
	      rspctl --rcumode=0 1>/dev/null 2>&1
            fi
          fi
	fi

	for (( l=6 ; l>newlevel ; l-- ))
	do
		tac $LEVELTABLE | cut -d"#" -f1 | awk '{ if (NF>0) print $0 }' | \
		grep "^${l}:" | grep ":d:" |  while read line
		do
			asroot=`echo $line | cut -d":" -f4`
			withmpi=`echo $line | cut -d":" -f5`
			program=`echo $line | cut -d":" -f6`
			stop_prog $program x$asroot x$withmpi
		done
	done

	# then power up to new level
	for (( l=1 ; l<=newlevel ; l++ ))
	do
		cat $LEVELTABLE | cut -d"#" -f1 | awk '{ if (NF>0) print $0 }' | \
		grep "^${l}:" | grep ":u:" |  while read line
		do
			asroot=`echo $line | cut -d":" -f4`
			withmpi=`echo $line | cut -d":" -f5`
			program=`echo $line | cut -d":" -f6`
			start_prog $program x$asroot x$withmpi
		done
	done
}

#
# MAIN
#


# Find out if we are running on a PVSS system
# Note: on PVSS systems LoggingClient must be ignored, 
# On non-PVSS system LoggingProcessor.

logProgToSkip=LoggingProcessor
if [ -f ${BINDIR}/PVSS00pmon ]; then
	logProgToSkip=LoggingClient
fi

# when no argument, or -s/-S is given show current level and exit 
if [ -z "$1" -o "$1" = "-s" -o "$1" = "-S" ]; then
        if [ -e /tmp/level.admin ]; then
          level=`cat /tmp/level.admin`
	  if [ "$1" != "-S" ]; then
	     echo -n "Currently set level is "
	  fi
	  echo $level
        else
          level=-1
          if [ "$1" != "-S" ]; then
             echo "Currently set level unknown"
          fi
        fi
        # argument -s/-S only returns level, no list
        if [ -z "$1" ]; then
            status_prog
        fi
        if [ $level -ne -1 ]; then 
          exit 0
        else
          exit $level
        fi
fi

if [ "$1" = "-v" -o "$1" = "-V" ]; then
        if [ -e /opt/lofar/Version.txt ]; then
          version=`cat /opt/lofar/Version.txt`
	  if [ "$1" = "-v" ]; then  
            echo -n "Current LOFAR version is "
	  fi
          echo $version
        else
          version="-1"
          if [ "$1" = "-v" ]; then
            echo "Current LOFAR version unknown"
          fi
        fi
	if [ "$version" != "-1" ]; then 
  	  exit
        else
          exit $version
        fi

fi

# don't allow root to run swlevel because all logfile get root access.
user=`id | cut -d'(' -f2 | cut -d')' -f1`
group=`groups | awk '{print $1}'`
#echo $user
if [ $user != "lofarsys" ]; then
    if [ $group != "local" ]; then 
	echo "swlevel must be run by user lofarsys or group local members!"
	exit
    fi
fi

# first power down to this level
case $1 in
	0|1|2|3|4|5|6)	let level=$1
			;;
	*) SyntaxError
esac
echo Going to level $level
cwd=`pwd`
cd ${BINDIR}
goto_level $level
cd ${cwd}
status_prog

# save for later
echo $level > /tmp/level.admin
date=`date +%Y-%m-%d\ %H:%M:%S`
echo [${date}]:$0 $* >> /log/swlevel.log
exit $level
