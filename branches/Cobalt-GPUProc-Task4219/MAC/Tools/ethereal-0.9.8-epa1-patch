diff -Naur --exclude=CVS ethereal-0.9.8-orig/configure.in ethereal-0.9.8-epaplugin/configure.in
--- ethereal-0.9.8-orig/configure.in	2002-12-04 05:26:12.000000000 +0100
+++ ethereal-0.9.8-epaplugin/configure.in	2004-11-15 15:26:56.000000000 +0100
@@ -766,6 +766,7 @@
   plugins/gryphon/Makefile
   plugins/mgcp/Makefile
   plugins/pcli/Makefile
+  plugins/epa/Makefile
   tools/Makefile
   tools/lemon/Makefile
   ,)
diff -Naur --exclude=CVS ethereal-0.9.8-orig/Makefile.am ethereal-0.9.8-epaplugin/Makefile.am
--- ethereal-0.9.8-orig/Makefile.am	2002-12-08 04:38:19.000000000 +0100
+++ ethereal-0.9.8-epaplugin/Makefile.am	2004-07-13 17:15:05.000000000 +0200
@@ -417,7 +417,8 @@
 	plugins/giop/packet-coseventcomm.c \
 	plugins/gryphon/packet-gryphon.c \
 	plugins/mgcp/packet-mgcp.c \
-	plugins/pcli/packet-pcli.c
+	plugins/pcli/packet-pcli.c \
+	plugins/epa/packet-epa.c
 
 plugin_static_ldadd = \
 	plugins/docsis/packet-bpkmattr-static.o \
@@ -447,7 +448,8 @@
 	plugins/giop/packet-coseventcomm-static.o \
 	plugins/gryphon/packet-gryphon-static.o \
 	plugins/mgcp/packet-mgcp-static.o \
-	plugins/pcli/packet-pcli-static.o
+	plugins/pcli/packet-pcli-static.o \
+	plugins/epa/packet-epa-static.o
 
 plugin_libs = \
 	plugins/docsis/docsis.la \
@@ -455,7 +457,8 @@
 	plugins/giop/coseventcomm.la \
 	plugins/gryphon/gryphon.la \
 	plugins/mgcp/mgcp.la \
-	plugins/pcli/pcli.la
+	plugins/pcli/pcli.la \
+	plugins/epa/epa.la
 
 plugin_ldadd = \
 	"-dlopen" self	\
@@ -464,7 +467,8 @@
 	"-dlopen" plugins/giop/coseventcomm.la \
 	"-dlopen" plugins/gryphon/gryphon.la \
 	"-dlopen" plugins/mgcp/mgcp.la \
-	"-dlopen" plugins/pcli/pcli.la
+	"-dlopen" plugins/pcli/pcli.la \
+	"-dlopen" plugins/epa/epa.la
 else
 plugin_src =
 
diff -Naur --exclude=CVS ethereal-0.9.8-orig/plugins/epa/AUTHORS ethereal-0.9.8-epaplugin/plugins/epa/AUTHORS
--- ethereal-0.9.8-orig/plugins/epa/AUTHORS	1970-01-01 01:00:00.000000000 +0100
+++ ethereal-0.9.8-epaplugin/plugins/epa/AUTHORS	2004-07-13 17:15:05.000000000 +0200
@@ -0,0 +1,4 @@
+Author :
+Klaas Jan Wierenga <wierenga@astron.nl>
+
+
diff -Naur --exclude=CVS ethereal-0.9.8-orig/plugins/epa/COPYING ethereal-0.9.8-epaplugin/plugins/epa/COPYING
--- ethereal-0.9.8-orig/plugins/epa/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ ethereal-0.9.8-epaplugin/plugins/epa/COPYING	2004-07-13 17:15:05.000000000 +0200
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -Naur --exclude=CVS ethereal-0.9.8-orig/plugins/epa/Makefile.am ethereal-0.9.8-epaplugin/plugins/epa/Makefile.am
--- ethereal-0.9.8-orig/plugins/epa/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ ethereal-0.9.8-epaplugin/plugins/epa/Makefile.am	2004-07-13 17:15:05.000000000 +0200
@@ -0,0 +1,55 @@
+# Makefile.am
+# Automake file for Ethereal/EPA dissectors
+#
+# $Id$
+#
+# Copyright 2004, Astron
+# Klaas Jan Wierenga <wierenga@astron.nl>
+#
+# Ethereal - Network traffic analyzer
+# By Gerald Combs <gerald@ethereal.com>
+# Copyright 1998 Gerald Combs
+#
+# 
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#
+
+INCLUDES = -I$(top_srcdir)
+
+plugindir = @plugindir@
+
+plugin_LTLIBRARIES = epa.la
+epa_la_SOURCES = packet-epa.c moduleinfo.h
+epa_la_LDFLAGS = -module -avoid-version
+
+# Libs must be cleared, or else libtool won't create a shared module.
+# If your module needs to be linked against any particular libraries,
+# add them here.
+LIBS =
+
+
+# The following allows a non-plugin version of the module to be built to 
+# be linked with a static ethereal binary.
+#
+epa_la_DEPENDENCIES = packet-epa-static.o
+
+packet-epa-static.o:   packet-epa.c moduleinfo.h
+	$(LTCOMPILE) -c -o packet-epa-static.o -D__ETHEREAL_STATIC__ $(srcdir)/packet-epa.c 
+
+CLEANFILES = \
+        epa
+
+EXTRA_DIST = \
+        Makefile.nmake
diff -Naur --exclude=CVS ethereal-0.9.8-orig/plugins/epa/Makefile.nmake ethereal-0.9.8-epaplugin/plugins/epa/Makefile.nmake
--- ethereal-0.9.8-orig/plugins/epa/Makefile.nmake	1970-01-01 01:00:00.000000000 +0100
+++ ethereal-0.9.8-epaplugin/plugins/epa/Makefile.nmake	2004-07-13 17:15:05.000000000 +0200
@@ -0,0 +1,20 @@
+#
+# $Id$
+#
+include ..\..\config.nmake
+
+############### no need to modify below this line #########
+
+CFLAGS=/DHAVE_CONFIG_H /I../.. /I../../wiretap \
+	/I$(GLIB_DIR) /I$(GTK_DIR) /I$(GLIB_DIR)/gmodule \
+	/I$(GTK_DIR)\gdk /I$(GTK_DIR)\gdk\win32 \
+	/I$(PCAP_DIR)\include $(LOCAL_CFLAGS)
+
+OBJECTS=packet-epa.obj 
+
+epa.dll epa.exp epa.lib : packet-epa.obj ..\plugin_api.obj
+	link -dll /out:epa.dll packet-epa.obj ..\plugin_api.obj \
+	$(GLIB_DIR)\glib-$(GLIB_VERSION).lib
+
+clean:
+	rm -f $(OBJECTS) epa.dll epa.exp epa.lib
diff -Naur --exclude=CVS ethereal-0.9.8-orig/plugins/epa/moduleinfo.h ethereal-0.9.8-epaplugin/plugins/epa/moduleinfo.h
--- ethereal-0.9.8-orig/plugins/epa/moduleinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ ethereal-0.9.8-epaplugin/plugins/epa/moduleinfo.h	2004-07-13 17:15:05.000000000 +0200
@@ -0,0 +1,17 @@
+/* Included *after* config.h, in order to re-define these macros */
+
+#ifdef PACKAGE
+#undef PACKAGE
+#endif
+
+/* Name of package */
+#define PACKAGE "epa"
+
+
+#ifdef VERSION
+#undef VERSION
+#endif
+
+/* Version number of package */
+#define VERSION "0.0.1"
+
diff -Naur --exclude=CVS ethereal-0.9.8-orig/plugins/epa/packet-epa.c ethereal-0.9.8-epaplugin/plugins/epa/packet-epa.c
--- ethereal-0.9.8-orig/plugins/epa/packet-epa.c	1970-01-01 01:00:00.000000000 +0100
+++ ethereal-0.9.8-epaplugin/plugins/epa/packet-epa.c	2005-06-07 15:17:07.000000000 +0200
@@ -0,0 +1,1556 @@
+/* packet-epa.c
+ * Routines for LOFAR Embedded Processing Application protocol dissection
+ * Copyright 2004, Klaas Jan Wierenga <wierenga@astron.nl>
+ *
+ * $Id$
+ *
+ * Ethereal - Network traffic analyzer
+ * By Gerald Combs <gerald@ethereal.com>
+ * Copyright 1998 Gerald Combs
+ *
+ * Copied from WHATEVER_FILE_YOU_USED (where "WHATEVER_FILE_YOU_USED"
+ * is a dissector file; if you just copied this from README.developer,
+ * don't bother with the "Copied from" - you don't even need to put
+ * in a "Copied from" if you copied an existing dissector, especially
+ * if the bulk of the code in the new dissector is your code)
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <glib.h>
+
+#ifdef NEED_SNPRINTF_H
+# include "snprintf.h"
+#endif
+
+#include <epan/packet.h>
+#include "packet-epa.h"
+
+#define FRAGMENT_SIZE_BYTES     1024
+#define SS_SELECT_SIZE_BYTES     512
+#define XST_FRAGMENT_SIZE_BYTES  960
+
+/*@{*/
+/**
+ * Message types.
+ */
+#define TYPE_UNSET 0x00
+#define READ       0x01
+#define WRITE      0x02
+#define READACK    0x03
+#define WRITEACK   0x04
+
+#define MAX_TYPE 0x04 /* counting from 0 */
+/*@}*/
+
+/*@{*/
+/**
+ * Address constants
+ *
+ * Destination ID
+ * RSP Board: bit7 set, all other bits 0 (= 0x80)
+ * BLP:       bit7 unset, other bits indicate which BLP is addressed.
+ * Two broadcasts are supported:
+ * To all BLP's: 0x7F
+ * To all BLP's and the RSP board: 0xFF
+ */
+#define DST_BLP            0x00 /* BLP's are addressed starting from 0x00 */
+#define DST_RSP            0x80 /* Destination id of the RSP board */
+#define DST_BROADCAST_BLPS 0x7F /* Broadcast to all BLP's but not the RSP */
+#define DST_BROADCAST      0xFF /* Broadcast to RSP and all BLP's */
+/*@}*/
+
+/*@{*/
+/**
+ * Process IDs
+ */
+#define RSR     0x00 /* Status overview */
+#define TST     0x01 /* Selftest functionality */
+#define CFG     0x02 /* FPGA configuration and reset */
+#define WG      0x03 /* Waveform generator */
+#define SS      0x04 /* Subband select */
+#define BF      0x05 /* Beamformer */
+#define BST     0x06 /* Beamformer statistics */
+#define SST     0x07 /* Subband statistics */
+#define RCU     0x08 /* RCU control */
+#define CRR     0x09 /* RSP clock and reset */
+#define CRB     0x0A /* BLP clock and reset */
+#define CDO     0x0B /* CEP Data Output */
+#define XST     0x0C /* Crosslet Statistics */
+
+#define MAX_PID XST /* counting from 0 */
+/*@}*/
+
+/*@{*/
+/**
+ * Register IDs
+ */
+#define RSR_STATUS    0x00
+#define RSR_VERSION   0x01
+
+#define TST_SELFTEST  0x00
+
+#define CFG_RESET     0x00
+#define CFG_REPROGRAM 0x01
+
+#define WG_XSETTINGS  0x00
+#define WG_YSETTINGS  0x01
+#define WG_XWAVE      0x02
+#define WG_YWAVE      0x03
+
+#define SS_SELECT     0x00
+
+#define BF_XROUT      0x00
+#define BF_XIOUT      0x01
+#define BF_YROUT      0x02
+#define BF_YIOUT      0x03
+
+#define BST_POWER     0x00
+
+#define SST_POWER     0x00
+
+#define RCU_SETTINGS  0x00
+
+#define CRR_SOFTRESET 0x00
+#define CRR_SOFTPPS   0x01
+
+#define CRB_SOFTRESET 0x00
+#define CRB_SOFTPPS   0x01
+
+#define CDO_SETTINGS  0x00
+
+#define XST_0_X       0X00
+#define XST_0_Y       0X01
+#define XST_1_X       0X02
+#define XST_1_Y       0X03
+#define XST_2_X       0X04
+#define XST_2_Y       0X05
+#define XST_3_X       0X06
+#define XST_3_Y       0X07
+
+#define MAX_REGID 0x03
+
+/*@}*/
+
+/*@{*/
+/**
+ * Define the number of beamlets N_BEAMLETS
+ * supported by the EPA firmware. For FTS-1
+ * the number of beamlets supported is 128.
+ * For the final LOFAR remote station
+ * 256 beamlets will be supported.
+ *
+ * Many register sizes are derived from
+ * the number of beamlets.
+ *
+ * The N_SUBBANDS(512) defines the number of
+ * subbands produced by the EPA digital filter.
+ * The N_BEAMLETS are a selection from this
+ * number of beamlets.
+ */
+#define N_SUBBANDS 512
+#define N_BEAMLETS 128;               /* FTS-1 spec, final remote station will be 256 */
+#define N_POL      2                  /* number of polarizations */
+#define N_PHASE    2                  /* number of phases in a complex number */
+#define N_PHASEPOL (N_PHASE * N_POL)  /* number of phase polarizations */
+
+
+/**
+ * Registers too large to send in a single ethernet frame
+ * (> 1500 bytes) will be sent in a number of fragments of this size.
+ */
+#define FRAGMENT_SIZE 1024
+
+/**
+ * Read/write sizes in octets (= bytes)
+ */
+#define RSR_STATUS_SIZE    96
+#define RSR_VERSION_SIZE   3
+
+#define TST_SELFTEST_SIZE  1
+
+#define CFG_RESET_SIZE     1
+#define CFG_REPROGRAM_SIZE 1
+
+#define WG_XSETTINGS_SIZE  7
+#define WG_YSETTINGS_SIZE  7
+#define WG_XWAVE_SIZE      1024
+#define WG_YWAVE_SIZE      1024
+
+#define SS_SELECT_SIZE     (N_BEAMLETS * N_POL * sizeof(uint16))
+
+#define BF_XROUT_SIZE      (N_BEAMLETS * N_PHASEPOL * sizeof(int16))
+#define BF_XIOUT_SIZE      (N_BEAMLETS * N_PHASEPOL * sizeof(int16))
+#define BF_YROUT_SIZE      (N_BEAMLETS * N_PHASEPOL * sizeof(int16))
+#define BF_YIOUT_SIZE      (N_BEAMLETS * N_PHASEPOL * sizeof(int16))
+
+#define BST_POWER_SIZE     (N_BEAMLETS * N_POL * sizeof(uint32))
+
+#define SST_POWER_SIZE     (N_SUBBANDS * N_POL * sizeof(uint32))
+
+#define RCU_SETTINGS_SIZE  2
+
+#define CRR_SOFTRESET_SIZE 1
+#define CRR_SOFTPPS_SIZE   1
+
+#define CRB_SOFTRESET_SIZE 1
+#define CRB_SOFTPPS_SIZE   1
+
+#define CDO_SETTINGS_SIZE  10
+
+#define XST_SETTINGS_SIZE  960
+/*@}*/
+
+/**
+ * EPA protocol constants and value to string mappings.
+ */
+static const value_string type_info_vals[] =
+{
+  { TYPE_UNSET, "Invalid " },
+  { READ,       "READ    " },
+  { WRITE,      "WRITE   " },
+  { READACK,    "READACK " },
+  { WRITEACK,   "WRITEACK" },
+  { 0,     NULL                   },
+};
+
+static const value_string type_vals[] =
+{
+  { TYPE_UNSET, "Invalid message type"         },
+  { READ,       "Read  request     (READ)"     },
+  { WRITE,      "Write command     (WRITE)"    },
+  { READACK,    "Read  acknowledge (READACK)"  },
+  { WRITEACK,   "Write acknowledge (WRITEACK)" },
+  { 0,     NULL                   },
+};
+
+static const value_string dst_vals[] =
+{
+  { DST_BLP,     "Beamlet processor 0" },
+  { DST_BLP + 1, "Beamlet processor 1" },
+  { DST_BLP + 2, "Beamlet processor 2" },
+  { DST_BLP + 3, "Beamlet processor 3" },
+  { DST_RSP,     "RSP main FPGA"     },
+  { 0,     NULL               },  
+};
+
+static const value_string pid_info_vals[] =
+{
+  { RSR, "RSR" },
+  { TST, "TST" },
+  { CFG, "CFG" },
+  { WG,  "WG " },
+  { SS,  "SS " },
+  { BF,  "BF " },
+  { BST, "BST" },
+  { SST, "SST" },
+  { RCU, "RCU" },
+  { CRR, "CRR" },
+  { CRB, "CRB" },
+  { CDO, "CDO" },
+  { XST, "XST" },
+  { 0,   NULL  },
+};
+
+static const value_string pid_vals[] =
+{
+  { RSR, "Status overview (RSR)"              },
+  { TST, "Selftest functionality (TST)"       },
+  { CFG, "FPGA configuration and reset (CFG)" },
+  { WG,  "Waveform generator (WG)"            },
+  { SS,  "Subband select (SS)"                },
+  { BF,  "Beamformer (BF)"                    },
+  { BST, "Beamlet statistics (BST)"           },
+  { SST, "Subband statistics (SST)"           },
+  { RCU, "RCU Control (RCU)"                  },
+  { CRR, "RSP Clock and Reset (CRR)"          },
+  { CRB, "BLP Clock and Reset (CRB)"          },
+  { CDO, "CEP Data Output (CDO)"              },
+  { XST, "Crosslet statistics (XST)"          },
+  { 0,   NULL                                 },
+};
+
+static const value_string status_vals[] =
+{
+  { RSR_STATUS,  "RSP Status" },
+  { RSR_VERSION, "Version"    },
+  { 0,     NULL        },
+};
+
+static const value_string tst_vals[] =
+{
+  { TST_SELFTEST, "Selftest" },
+  { 0,     NULL        },
+};
+
+static const value_string cfg_vals[] =
+{
+  { CFG_RESET,     "Reset"     },
+  { CFG_REPROGRAM, "Reprogram" },
+  { 0,     NULL       },
+};
+
+static const value_string wg_vals[] =
+{
+  { WG_XSETTINGS, "Waveform generator settings X polarization" },
+  { WG_YSETTINGS, "Waveform generator settings Y polarization" },
+  { WG_XWAVE,     "User waveform X polarization"               },
+  { WG_YWAVE,     "User waveform Y polarization"               },
+  { 0,     NULL                         },
+};
+
+static const value_string ss_vals[] =
+{
+  { SS_SELECT, "Subband Select parameters"   },
+  { 0,     NULL                         },
+};
+
+static const value_string bf_vals[] =
+{
+  { BF_XROUT, "XR,XI,YR,YI coefficients for XR output" },
+  { BF_XIOUT, "XR,XI,YR,YI coefficients for XI output" },
+  { BF_YROUT, "XR,XI,YR,YI coefficients for YR output" },
+  { BF_YIOUT, "XR,XI,YR,YI coefficients for YI output" },
+  { 0,     NULL       },
+};
+
+static const value_string bst_vals[] =
+{
+  { BST_POWER, "Beamlet Statistics - X,Y Power"  },
+  { 0,     NULL   },
+};
+
+static const value_string sst_vals[] =
+{
+  { SST_POWER, "Subband Statistics - X,Y Power"  },
+  { 0,     NULL   },
+};
+
+static const value_string rcu_vals[] =
+{
+  { RCU_SETTINGS, "RCU Settings"  },
+  { 0,     NULL   },
+};
+
+static const value_string crr_vals[] =
+{
+  { CRR_SOFTRESET, "Soft Reset"  },
+  { CRR_SOFTPPS,   "Soft PPS"  },
+  { 0,     NULL   },
+};
+
+static const value_string crb_vals[] =
+{
+  { CRB_SOFTRESET, "Soft Reset"  },
+  { CRB_SOFTPPS,   "Soft PPS"  },
+  { 0,     NULL   },
+};
+
+static const value_string cdo_vals[] =
+{
+  { CDO_SETTINGS, "CEP Data Output Settings"  },
+  { 0,     NULL   },
+};
+
+static const value_string xst_vals[] =
+{
+  { XST_0_X, "Xlets AP_0_X" },
+  { XST_0_Y, "Xlets AP_0_Y" },
+  { XST_1_X, "Xlets AP_1_X" },
+  { XST_1_Y, "Xlets AP_1_Y" },
+  { XST_2_X, "Xlets AP_2_X" },
+  { XST_2_Y, "Xlets AP_2_Y" },
+  { XST_3_X, "Xlets AP_3_X" },
+  { XST_3_Y, "Xlets AP_3_Y" },
+  { 0,       NULL },
+};
+
+static const value_string eth_error_vals[] =
+{
+  { 0, "The ethernet frame was received correctly"           },
+  { 1, "Preamble had other value than 0xAA"                  },
+  { 2, "Frame delimiter had other value than 0xAB"           },
+  { 3, "Not enough preamble nibbles"                         },
+  { 4, "Frame ended during frame header."                    },
+  { 5, "Calculated CRC does not match received CRC"          },
+  { 6, "An odd number of nibbles was received from ethernet" },
+  { 7, "Length specified in the frame size field does not match the real number of received bytes" },
+  { 0,     NULL   },
+};
+
+static const value_string mep_error_vals[] =
+{
+  { 0, "The MEP message was processed successfully"          },
+  { 1, "Unknown message type"                                },
+  { 2, "DSTID is too large"                                  },
+  { 3, "Invalid PID"                                         },
+  { 4, "Register does not exist"                             },
+  { 5, "Message is too large"                                },
+  { 6, "Error occurred during inter-FPGA transmission."      },
+  { 0, NULL },
+};
+
+static const value_string wg_mode_vals[] =
+{
+  { 0, "off" },
+  { 1, "calc" },
+  { 3, "single" },
+  { 5, "repeat" },
+  { 0, NULL },
+};
+
+
+/**
+ * Pluginize BEGIN
+ *
+ * Pluginize the EPA dissector
+ */
+#include "plugins/plugin_api.h"
+#include "moduleinfo.h"
+#include <gmodule.h>
+#include "plugins/plugin_api_defs.h"
+
+#ifndef __ETHEREAL_STATIC__
+G_MODULE_EXPORT const gchar version[] = "3.0";
+G_MODULE_EXPORT void plugin_init(plugin_address_table_t *pat);
+G_MODULE_EXPORT void plugin_reg_handoff(void);
+#endif 
+
+/**
+ * Pluginize END
+ */
+
+/**
+ * Constants
+ */
+#define ETHERTYPE_EPA 0x10FA
+
+/* Initialize the protocol and registered fields */
+static int proto_epa          = -1;
+static int hf_epa_type        = -1;
+static int hf_epa_error       = -1;
+static int hf_epa_seqnr       = -1;
+static int hf_epa_addr        = -1;
+static int hf_epa_addr_dstid  = -1;
+static int hf_epa_addr_pid    = -1;
+static int hf_epa_addr_regid  = -1;
+static int hf_epa_addr_ffi    = -1;
+static int hf_epa_offset      = -1;
+static int hf_epa_size        = -1;
+static int hf_epa_data        = -1;
+static int hf_epa_int16       = -1;
+static int hf_epa_uint16      = -1;
+static int hf_epa_int32       = -1;
+static int hf_epa_uint32      = -1;
+static int hf_epa_double      = -1;
+
+/**
+ * RSP Status register fields.
+ */
+/*static int df_rspstatus           = -1;*/
+static int df_rspstatus_voltage_1_5 = -1;
+static int df_rspstatus_voltage_2_5 = -1;
+static int df_rspstatus_voltage_3_3 = -1;
+static int df_rspstatus_voltage_12  = -1;
+/*static int df_fpgastatus          = -1;*/
+static int df_fpgastatus_bp_temp    = -1;
+static int df_fpgastatus_ap0_temp   = -1;
+static int df_fpgastatus_ap1_temp   = -1;
+static int df_fpgastatus_ap2_temp   = -1;
+static int df_fpgastatus_ap3_temp   = -1;
+/*static int df_ethstatus           = -1;*/
+static int df_ethstatus_nof_frames  = -1;
+static int df_ethstatus_nof_errors  = -1;
+static int df_ethstatus_last_error  = -1;
+/*static int df_mepstatus      = -1;*/
+static int df_mepstatus_seqnr  = -1;
+static int df_mepstatus_error  = -1;
+/*static int df_syncstatus = -1; */
+static int df_ap0_sync_sample_offset = -1;
+static int df_ap0_sync_sync_count    = -1;
+static int df_ap0_sync_slice_count   = -1;
+static int df_ap1_sync_sample_offset = -1;
+static int df_ap1_sync_sync_count    = -1;
+static int df_ap1_sync_slice_count   = -1;
+static int df_ap2_sync_sample_offset = -1;
+static int df_ap2_sync_sync_count    = -1;
+static int df_ap2_sync_slice_count   = -1;
+static int df_ap3_sync_sample_offset = -1;
+static int df_ap3_sync_sync_count    = -1;
+static int df_ap3_sync_slice_count   = -1;
+
+/**
+ * RSP Version register fields.
+ */
+static int df_rsp_version = -1;
+static int df_bp_version  = -1;
+static int df_ap_version  = -1;
+
+/**
+ * RCU Settings register fields
+ */
+static int df_vddvcc_en    = -1;
+static int df_vh_enable    = -1;
+static int df_vl_enable    = -1;
+static int df_filsel_b     = -1;
+static int df_filsel_a     = -1;
+static int df_bandsel      = -1;
+static int df_hba_enable   = -1;
+static int df_lba_enable   = -1;
+static int df_nof_overflow = -1;
+
+/**
+ * WG settings
+ */
+static int df_wg_freq  = -1;
+static int df_wg_phase = -1;
+static int df_wg_ampl  = -1;
+static int df_wg_nof_samples = -1;
+static int df_wg_mode = -1;
+
+/* Initialize the subtree pointers */
+static gint ett_epa         = -1;
+static gint ett_epa_addr    = -1;
+static gint ett_rspstatus   = -1;
+static gint ett_rspstatus_detail = -1;
+static gint ett_fpgastatus  = -1;
+static gint ett_ethstatus   = -1;
+static gint ett_mepstatus   = -1;
+static gint ett_syncstatus  = -1;
+static gint ett_syncvalues  = -1;
+static gint ett_rcustatus   = -1;
+static gint ett_rcusettings = -1;
+static gint ett_rspversion  = -1;
+static gint ett_wgsettings  = -1;
+static gint ett_payload     = -1;
+
+/* Code to actually dissect the packets */
+static void
+dissect_epa(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+
+  /* Set up structures needed to add the protocol subtree and manage it */
+  proto_item *ti;
+  proto_tree *epa_tree;
+  char*  typestr = NULL;
+  char*  pidstr  = NULL;
+  char*  regstr  = NULL;
+  guint8 type = tvb_get_guint8(tvb, 0);
+  guint8 reg  = tvb_get_guint8(tvb, 6);
+  guint8 pid  = tvb_get_guint8(tvb, 5);
+
+#if 0
+  /* don't know enough about how this conversation stuff works, implement it later */
+  conversation_t* conversation = NULL;
+
+  conversation = find_conversation(&pinfo->net_src, &pinfo->net_dst, pinfo->ptype,
+				   0, 0, NO_PORT2);
+  if (conversation == NULL)
+  {
+    /* No conversation, create one */
+    conversation = conversation_new(&pinfo->net_src, &pinfo->net_dst, pinfo->ptype,
+				    0, 0, NO_PORT_B);
+  }
+#endif
+  
+  /* Make entries in Protocol column and Info column on summary display */
+  if (check_col(pinfo->cinfo, COL_PROTOCOL)) 
+    col_set_str(pinfo->cinfo, COL_PROTOCOL, "EPA");
+    
+  /* This field shows up as the "Info" column in the display; you should make
+     it, if possible, summarize what's in the packet, so that a user looking
+     at the list of packets can tell what type of packet it is. See section 1.5
+     for more information.
+
+     If you are setting it to a constant string, use "col_set_str()", as
+     it's more efficient than the other "col_set_XXX()" calls.
+
+     If you're setting it to a string you've constructed, or will be
+     appending to the column later, use "col_add_str()".
+
+     "col_add_fstr()" can be used instead of "col_add_str()"; it takes
+     "printf()"-like arguments.  Don't use "col_add_fstr()" with a format
+     string of "%s" - just use "col_add_str()" or "col_set_str()", as it's
+     more efficient than "col_add_fstr()".
+
+     If you will be fetching any data from the packet before filling in
+     the Info column, clear that column first, in case the calls to fetch
+     data from the packet throw an exception because they're fetching data
+     past the end of the packet, so that the Info column doesn't have data
+     left over from the previous dissector; do
+
+     if (check_col(pinfo->cinfo, COL_INFO)) 
+     col_clear(pinfo->cinfo, COL_INFO);
+
+  */
+
+  if (check_col(pinfo->cinfo, COL_INFO)) 
+    col_clear(pinfo->cinfo, COL_INFO);
+
+  /* decode the typestr */
+  typestr = type_info_vals[type].strptr;
+  pidstr  = pid_info_vals[pid].strptr;
+  switch (pid)
+  {
+    case RSR:
+      regstr = status_vals[reg].strptr;
+      break;
+
+    case TST:
+      regstr = tst_vals[reg].strptr;
+      break;
+
+    case CFG:
+      regstr = cfg_vals[reg].strptr;
+      break;
+
+    case WG:
+      regstr = wg_vals[reg].strptr;
+      break;
+
+    case SS:
+      regstr = ss_vals[reg].strptr;
+      break;
+
+    case BF:
+      regstr = bf_vals[reg].strptr;
+      break;
+
+    case BST:
+      regstr = bst_vals[reg].strptr;
+      break;
+
+    case SST:
+      regstr = sst_vals[reg].strptr;
+      break;
+
+    case RCU:
+      regstr = rcu_vals[reg].strptr;
+      break;
+
+    case CRR:
+      regstr = crr_vals[reg].strptr;
+      break;
+
+    case CRB:
+      regstr = crb_vals[reg].strptr;
+      break;
+
+    case CDO:
+      regstr = cdo_vals[reg].strptr;
+      break;
+
+    case XST:
+      regstr = xst_vals[reg].strptr;
+      break;
+  }
+
+  if (!typestr) typestr = "Unknown type?";
+  if (!pidstr)  pidstr  = "Unknown process?";
+  if (!regstr)  regstr  = "Unknown register?";
+      
+  /* fill the INFO column */
+  if (check_col(pinfo->cinfo, COL_INFO))
+    col_add_fstr(pinfo->cinfo, COL_INFO, "%s %s %s", typestr, pidstr, regstr);
+  
+  /* In the interest of speed, if "tree" is NULL, don't do any work not
+     necessary to generate protocol tree items. */
+  if (tree)
+  {
+    proto_item* newitem = 0;
+    proto_tree* newtree = 0;
+    proto_tree* subtree = 0;
+    proto_tree* synctree = 0;
+    proto_tree* rcustatus_tree = 0;
+
+    /* NOTE: The offset and length values in the call to
+       "proto_tree_add_item()" define what data bytes to highlight in the hex
+       display window when the line in the protocol tree display
+       corresponding to that item is selected.
+
+       Supplying a length of -1 is the way to highlight all data from the
+       offset to the end of the packet. */
+
+    /* create display subtree for the protocol */
+    ti = proto_tree_add_item(tree, proto_epa, tvb, 0, -1, FALSE);
+    
+    epa_tree = proto_item_add_subtree(ti, ett_epa);
+
+    /* add an item to the subtree, see section 1.6 for more information */
+    
+    /* Continue adding tree items to process the packet here */
+    proto_tree_add_item(epa_tree, hf_epa_type,        tvb,  0,  1, FALSE);
+    proto_tree_add_item(epa_tree, hf_epa_error,       tvb,  1,  1, FALSE);
+    proto_tree_add_item(epa_tree, hf_epa_seqnr,       tvb,  2,  2, TRUE);
+
+    newitem = proto_tree_add_item(epa_tree, hf_epa_addr, tvb,  4,  4, FALSE);
+    newtree = proto_item_add_subtree(newitem, ett_epa_addr);
+
+    proto_tree_add_item(newtree, hf_epa_addr_dstid,  tvb,  4,  1, FALSE);
+    proto_tree_add_item(newtree, hf_epa_addr_pid,    tvb,  5,  1, FALSE);
+
+    if (regstr)
+      proto_tree_add_string(newtree, hf_epa_addr_regid, tvb, 6, 1, regstr);
+    else
+      proto_tree_add_item(newtree, hf_epa_addr_regid,  tvb,  6,  1, FALSE);
+
+    proto_tree_add_item(newtree, hf_epa_addr_ffi, tvb,  7,  1, FALSE);
+
+    proto_tree_add_item(epa_tree, hf_epa_offset,      tvb,  8,  2, TRUE);
+    proto_tree_add_item(epa_tree, hf_epa_size,        tvb, 10,  2, TRUE);
+
+    if (READACK == type && RSR == pid && RSR_STATUS == reg)
+    {
+      /* READACK RSR_STATUS */
+      newitem = proto_tree_add_text(epa_tree, tvb, 12, RSR_STATUS_SIZE, "RSP Status register");
+      newtree = proto_item_add_subtree(newitem, ett_rspstatus);
+
+      newitem = proto_tree_add_text(newtree, tvb, 12, 4,  "RSP Status");
+      subtree = proto_item_add_subtree(newitem, ett_rspstatus_detail);
+      proto_tree_add_item(subtree, df_rspstatus_voltage_1_5  ,tvb, 12, 1,  FALSE);
+      proto_tree_add_item(subtree, df_rspstatus_voltage_2_5  ,tvb, 13, 1,  FALSE);
+      proto_tree_add_item(subtree, df_rspstatus_voltage_3_3  ,tvb, 14, 1,  FALSE);
+      proto_tree_add_item(subtree, df_rspstatus_voltage_12   ,tvb, 15, 1,  FALSE);
+
+      newitem = proto_tree_add_text(newtree, tvb,  16, 12, "FPGA Status");
+      subtree = proto_item_add_subtree(newitem, ett_fpgastatus);
+      proto_tree_add_item(subtree, df_fpgastatus_bp_temp    ,tvb, 16, 1,  FALSE);
+      proto_tree_add_item(subtree, df_fpgastatus_ap0_temp   ,tvb, 17, 1,  FALSE);
+      proto_tree_add_item(subtree, df_fpgastatus_ap1_temp   ,tvb, 18, 1,  FALSE);   
+      proto_tree_add_item(subtree, df_fpgastatus_ap2_temp   ,tvb, 19, 1,  FALSE);
+      proto_tree_add_item(subtree, df_fpgastatus_ap3_temp   ,tvb, 20, 1,  FALSE);   
+
+      newitem = proto_tree_add_text(newtree, tvb, 28, 12, "ETH Status");
+      subtree = proto_item_add_subtree(newitem, ett_ethstatus);
+      proto_tree_add_item(subtree, df_ethstatus_nof_frames  ,tvb, 28, 4,  TRUE);
+      proto_tree_add_item(subtree, df_ethstatus_nof_errors  ,tvb, 32, 4,  TRUE);
+      proto_tree_add_item(subtree, df_ethstatus_last_error  ,tvb, 36, 1,  FALSE);
+
+      newitem = proto_tree_add_text(newtree, tvb, 40, 4, "MEP Status");
+      subtree = proto_item_add_subtree(newitem, ett_mepstatus);
+      proto_tree_add_item(subtree, df_mepstatus_seqnr  ,tvb, 40, 2,  TRUE);
+      proto_tree_add_item(subtree, df_mepstatus_error  ,tvb, 42, 1,  FALSE);
+      
+      newitem = proto_tree_add_text(newtree, tvb, 44, 12, "SYNC Status");
+      synctree = proto_item_add_subtree(newitem, ett_syncstatus);
+      {
+	/* AP0 sync status */
+	newitem = proto_tree_add_text(synctree, tvb, 44, 12, "AP0 sync status");
+	subtree = proto_item_add_subtree(newitem, ett_syncvalues);
+	proto_tree_add_item(subtree, df_ap0_sync_sample_offset ,tvb, 44, 4, TRUE);
+	proto_tree_add_item(subtree, df_ap0_sync_sync_count   ,tvb, 48, 4, TRUE);
+	proto_tree_add_item(subtree, df_ap0_sync_slice_count  ,tvb, 52, 4, TRUE);
+      }
+      {
+	/* AP1 sync status */
+	newitem = proto_tree_add_text(synctree, tvb, 56, 12, "AP1 sync status");
+	subtree = proto_item_add_subtree(newitem, ett_syncvalues);
+	proto_tree_add_item(subtree, df_ap1_sync_sample_offset ,tvb, 56, 4, TRUE);
+	proto_tree_add_item(subtree, df_ap1_sync_sync_count   ,tvb, 60, 4, TRUE);
+	proto_tree_add_item(subtree, df_ap1_sync_slice_count  ,tvb, 64, 4, TRUE);
+      }
+      {
+	/* AP2 sync status */
+	newitem = proto_tree_add_text(synctree, tvb, 68, 12, "AP2 sync status");
+	subtree = proto_item_add_subtree(newitem, ett_syncvalues);
+	proto_tree_add_item(subtree, df_ap2_sync_sample_offset ,tvb, 68, 4, TRUE);
+	proto_tree_add_item(subtree, df_ap2_sync_sync_count   ,tvb, 72, 4, TRUE);
+	proto_tree_add_item(subtree, df_ap2_sync_slice_count  ,tvb, 76, 4, TRUE);
+      }
+      {
+	/* AP3 sync status */
+	newitem = proto_tree_add_text(synctree, tvb, 80, 12, "AP3 sync status");
+	subtree = proto_item_add_subtree(newitem, ett_syncvalues);
+	proto_tree_add_item(subtree, df_ap3_sync_sample_offset ,tvb, 80, 4, TRUE);
+	proto_tree_add_item(subtree, df_ap3_sync_sync_count   ,tvb, 84, 4, TRUE);
+	proto_tree_add_item(subtree, df_ap3_sync_slice_count  ,tvb, 88, 4, TRUE);
+      }
+
+      newitem = proto_tree_add_text(newtree, tvb, 92, 48, "RCU Status");
+      rcustatus_tree = subtree = proto_item_add_subtree(newitem, ett_rcustatus);
+
+      newitem = proto_tree_add_text(rcustatus_tree, tvb, 92, 12, "AP0 RCU status");
+      newtree = proto_item_add_subtree(newitem, ett_rcusettings);
+      {
+	/* AP0 X-polarization */
+	newitem = proto_tree_add_text(newtree, tvb, 92, 12, "X polarization");
+	subtree = proto_item_add_subtree(newitem, ett_rcusettings);
+	proto_tree_add_item(subtree, df_vddvcc_en,  tvb, 92, 1, FALSE);
+	proto_tree_add_item(subtree, df_vh_enable,  tvb, 92, 1, FALSE);
+	proto_tree_add_item(subtree, df_vl_enable,  tvb, 92, 1, FALSE);
+	proto_tree_add_item(subtree, df_filsel_b,   tvb, 92, 1, FALSE);
+	proto_tree_add_item(subtree, df_filsel_a,   tvb, 92, 1, FALSE);
+	proto_tree_add_item(subtree, df_bandsel,    tvb, 92, 1, FALSE);
+	proto_tree_add_item(subtree, df_hba_enable, tvb, 92, 1, FALSE);
+	proto_tree_add_item(subtree, df_lba_enable, tvb, 92, 1, FALSE);
+	proto_tree_add_item(subtree, df_nof_overflow, tvb, 98, 4, TRUE);
+      }
+      {
+	/* AP0 Y-polarization */
+	newitem = proto_tree_add_text(newtree, tvb, 92, 12, "Y polarization");
+	subtree = proto_item_add_subtree(newitem, ett_rcusettings);
+	proto_tree_add_item(subtree, df_vddvcc_en,  tvb, 93, 1, FALSE);
+	proto_tree_add_item(subtree, df_vh_enable,  tvb, 93, 1, FALSE);
+	proto_tree_add_item(subtree, df_vl_enable,  tvb, 93, 1, FALSE);
+	proto_tree_add_item(subtree, df_filsel_b,   tvb, 93, 1, FALSE);
+	proto_tree_add_item(subtree, df_filsel_a,   tvb, 93, 1, FALSE);
+	proto_tree_add_item(subtree, df_bandsel,    tvb, 93, 1, FALSE);
+	proto_tree_add_item(subtree, df_hba_enable, tvb, 93, 1, FALSE);
+	proto_tree_add_item(subtree, df_lba_enable, tvb, 93, 1, FALSE);
+	proto_tree_add_item(subtree, df_nof_overflow, tvb, 100, 4, TRUE);
+      }
+      
+      newitem = proto_tree_add_text(rcustatus_tree, tvb, 104, 12, "AP1 RCU status");
+      newtree = proto_item_add_subtree(newitem, ett_rcusettings);
+      {
+	/* AP1 X-polarization */
+	newitem = proto_tree_add_text(newtree, tvb, 104, 12, "X polarization");
+	subtree = proto_item_add_subtree(newitem, ett_rcusettings);
+	proto_tree_add_item(subtree,df_vddvcc_en,  tvb, 104, 1, FALSE);
+	proto_tree_add_item(subtree,df_vh_enable,  tvb, 104, 1, FALSE);
+	proto_tree_add_item(subtree,df_vl_enable,  tvb, 104, 1, FALSE);
+	proto_tree_add_item(subtree,df_filsel_b,   tvb, 104, 1, FALSE);
+	proto_tree_add_item(subtree,df_filsel_a,   tvb, 104, 1, FALSE);
+	proto_tree_add_item(subtree,df_bandsel,    tvb, 104, 1, FALSE);
+	proto_tree_add_item(subtree,df_hba_enable, tvb, 104, 1, FALSE);
+	proto_tree_add_item(subtree,df_lba_enable, tvb, 104, 1, FALSE);
+	proto_tree_add_item(subtree, df_nof_overflow, tvb, 108, 4, TRUE);
+      }
+      {
+	/* AP1 Y-polarization */
+	newitem = proto_tree_add_text(newtree, tvb, 104, 12, "Y polarization");
+	subtree = proto_item_add_subtree(newitem, ett_rcusettings);
+	proto_tree_add_item(subtree,df_vddvcc_en,  tvb, 105, 1, FALSE);
+	proto_tree_add_item(subtree,df_vh_enable,  tvb, 105, 1, FALSE);
+	proto_tree_add_item(subtree,df_vl_enable,  tvb, 105, 1, FALSE);
+	proto_tree_add_item(subtree,df_filsel_b,   tvb, 105, 1, FALSE);
+	proto_tree_add_item(subtree,df_filsel_a,   tvb, 105, 1, FALSE);
+	proto_tree_add_item(subtree,df_bandsel,    tvb, 105, 1, FALSE);
+	proto_tree_add_item(subtree,df_hba_enable, tvb, 105, 1, FALSE);
+	proto_tree_add_item(subtree,df_lba_enable, tvb, 105, 1, FALSE);
+	proto_tree_add_item(subtree, df_nof_overflow, tvb, 112, 4, TRUE);
+      }
+      
+      newitem = proto_tree_add_text(rcustatus_tree, tvb, 116, 12, "AP2 RCU status");
+      newtree = proto_item_add_subtree(newitem, ett_rcusettings);
+      {
+	/* AP2 X-polarization */
+	newitem = proto_tree_add_text(newtree, tvb, 116, 12, "X polarization");
+	subtree = proto_item_add_subtree(newitem, ett_rcusettings);
+	proto_tree_add_item(subtree,df_vddvcc_en,  tvb, 116, 1, FALSE);
+	proto_tree_add_item(subtree,df_vh_enable,  tvb, 116, 1, FALSE);
+	proto_tree_add_item(subtree,df_vl_enable,  tvb, 116, 1, FALSE);
+	proto_tree_add_item(subtree,df_filsel_b,   tvb, 116, 1, FALSE);
+	proto_tree_add_item(subtree,df_filsel_a,   tvb, 116, 1, FALSE);
+	proto_tree_add_item(subtree,df_bandsel,    tvb, 116, 1, FALSE);
+	proto_tree_add_item(subtree,df_hba_enable, tvb, 116, 1, FALSE);
+	proto_tree_add_item(subtree,df_lba_enable, tvb, 116, 1, FALSE);
+	proto_tree_add_item(subtree, df_nof_overflow, tvb, 120, 4, TRUE);
+      }
+      {
+	/* AP2 Y-polarization */
+	newitem = proto_tree_add_text(newtree, tvb, 116, 12, "Y polarization");
+	subtree = proto_item_add_subtree(newitem, ett_rcusettings);
+	proto_tree_add_item(subtree,df_vddvcc_en,  tvb, 117, 1, FALSE);
+	proto_tree_add_item(subtree,df_vh_enable,  tvb, 117, 1, FALSE);
+	proto_tree_add_item(subtree,df_vl_enable,  tvb, 117, 1, FALSE);
+	proto_tree_add_item(subtree,df_filsel_b,   tvb, 117, 1, FALSE);
+	proto_tree_add_item(subtree,df_filsel_a,   tvb, 117, 1, FALSE);
+	proto_tree_add_item(subtree,df_bandsel,    tvb, 117, 1, FALSE);
+	proto_tree_add_item(subtree,df_hba_enable, tvb, 117, 1, FALSE);
+	proto_tree_add_item(subtree,df_lba_enable, tvb, 117, 1, FALSE);
+	proto_tree_add_item(subtree, df_nof_overflow, tvb, 124, 4, TRUE);
+      }
+      
+      newitem = proto_tree_add_text(rcustatus_tree, tvb, 128, 12, "AP3 RCU status");
+      newtree = proto_item_add_subtree(newitem, ett_rcusettings);
+      {
+	/* AP3 X-polarization */
+	newitem = proto_tree_add_text(newtree, tvb, 128, 12, "Y polarization");
+	subtree = proto_item_add_subtree(newitem, ett_rcusettings);
+	proto_tree_add_item(subtree,df_vddvcc_en,  tvb, 128, 1, FALSE);
+	proto_tree_add_item(subtree,df_vh_enable,  tvb, 128, 1, FALSE);
+	proto_tree_add_item(subtree,df_vl_enable,  tvb, 128, 1, FALSE);
+	proto_tree_add_item(subtree,df_filsel_b,   tvb, 128, 1, FALSE);
+	proto_tree_add_item(subtree,df_filsel_a,   tvb, 128, 1, FALSE);
+	proto_tree_add_item(subtree,df_bandsel,    tvb, 128, 1, FALSE);
+	proto_tree_add_item(subtree,df_hba_enable, tvb, 128, 1, FALSE);
+	proto_tree_add_item(subtree,df_lba_enable, tvb, 128, 1, FALSE);
+	proto_tree_add_item(subtree, df_nof_overflow, tvb, 132, 4, TRUE);
+      }
+      {
+	/* AP3 Y-polarization */
+	newitem = proto_tree_add_text(newtree, tvb, 128, 12, "Y polarization");
+	subtree = proto_item_add_subtree(newitem, ett_rcusettings);
+	proto_tree_add_item(subtree,df_vddvcc_en,  tvb, 129, 1, FALSE);
+	proto_tree_add_item(subtree,df_vh_enable,  tvb, 129, 1, FALSE);
+	proto_tree_add_item(subtree,df_vl_enable,  tvb, 129, 1, FALSE);
+	proto_tree_add_item(subtree,df_filsel_b,   tvb, 129, 1, FALSE);
+	proto_tree_add_item(subtree,df_filsel_a,   tvb, 129, 1, FALSE);
+	proto_tree_add_item(subtree,df_bandsel,    tvb, 129, 1, FALSE);
+	proto_tree_add_item(subtree,df_hba_enable, tvb, 129, 1, FALSE);
+	proto_tree_add_item(subtree,df_lba_enable, tvb, 129, 1, FALSE);
+	proto_tree_add_item(subtree, df_nof_overflow, tvb, 136, 4, TRUE);
+      }
+    }
+    else if (READACK == type && RSR == pid && RSR_VERSION == reg)
+    {
+      /* READACK RSR_VERSION */
+      newitem = proto_tree_add_text(epa_tree, tvb, 12, RSR_VERSION_SIZE, "RSP Version register");
+      newtree = proto_item_add_subtree(newitem, ett_rspversion);
+
+      proto_tree_add_item(newtree, df_rsp_version, tvb, 12, 1, FALSE);
+      proto_tree_add_item(newtree, df_bp_version,  tvb, 13, 1, FALSE);
+      proto_tree_add_item(newtree, df_ap_version,  tvb, 14, 1, FALSE);
+    }
+    else if ( (WRITE == type || READACK == type) && WG == pid && (WG_XSETTINGS == reg || WG_YSETTINGS == reg))
+    {
+      /* WRITE or READACK WG_[X|Y]SETTINGS */
+      if (WG_XSETTINGS == reg)
+	newitem = proto_tree_add_text(epa_tree, tvb, 12, WG_XSETTINGS_SIZE, "Waveform generator settings X-polarization");
+      else
+	newitem = proto_tree_add_text(epa_tree, tvb, 12, WG_YSETTINGS_SIZE, "Waveform generator settings Y-polarization");
+      newtree = proto_item_add_subtree(newitem, ett_wgsettings);
+
+      proto_tree_add_item(newtree, df_wg_freq,        tvb, 12, 2, TRUE);
+      proto_tree_add_item(newtree, df_wg_phase,       tvb, 14, 1, FALSE);
+      proto_tree_add_item(newtree, df_wg_ampl,        tvb, 15, 1, FALSE);
+      proto_tree_add_item(newtree, df_wg_nof_samples, tvb, 16, 2, TRUE);
+      proto_tree_add_item(newtree, df_wg_mode,        tvb, 18, 1, FALSE);
+    }
+    else if ( (WRITE == type || READACK == type) && WG == pid && (WG_XWAVE == reg || WG_YWAVE == reg))
+    {
+      /* WRITE or READACK WG_[X|Y]WAVE */
+      if (WG_XWAVE == reg)
+	newitem = proto_tree_add_text(epa_tree, tvb, 12, WG_XWAVE_SIZE, "User waveform X-polarization");
+      else
+	newitem = proto_tree_add_text(epa_tree, tvb, 12, WG_YWAVE_SIZE, "User Waveform Y-polarization");
+      newtree = proto_item_add_subtree(newitem, ett_wgsettings);
+
+      int i;
+      for (i = 0; i < 16; i++)
+      {
+	proto_tree_add_item(newtree, hf_epa_int16, tvb,
+			    12 + (i*sizeof(gint16)),
+			    sizeof(gint16), TRUE);
+      }
+      proto_tree_add_text(newtree, tvb, 0, 0, "...");
+      for (i = 0; i < 8; i++)
+      {
+	proto_tree_add_item(newtree, hf_epa_int16, tvb,
+			    12 + WG_XWAVE_SIZE - (8*sizeof(gint16)) + (i*sizeof(gint16)),
+			    sizeof(gint16), TRUE);
+      }
+    }
+    else if ( (WRITE == type || READACK == type) && BF == pid)
+    {
+      /* WRITE BF_* */
+
+      newitem = proto_tree_add_text(epa_tree, tvb, 12, -1, "Beamformer Payload");
+      newtree = proto_item_add_subtree(newitem, ett_payload);
+
+      int i;
+      for (i = 0; i < 16; i++)
+      {
+	proto_tree_add_item(newtree, hf_epa_int16, tvb,
+			    12 + (i*sizeof(gint16)),
+			    sizeof(gint16), TRUE);
+      }
+      proto_tree_add_text(newtree, tvb, 0, 0, "...");
+      for (i = 0; i < 8; i++)
+      {
+	proto_tree_add_item(newtree, hf_epa_int16, tvb,
+			    12 + FRAGMENT_SIZE_BYTES - (8*sizeof(gint16)) + (i*sizeof(gint16)),
+			    sizeof(gint16), TRUE);
+      }
+    }
+    else if ( (WRITE == type || READACK == type) && SS == pid && SS_SELECT == reg)
+    {
+      /* WRITE SS_SELECT */
+
+      newitem = proto_tree_add_text(epa_tree, tvb, 12, -1, "Subband Select Payload");
+      newtree = proto_item_add_subtree(newitem, ett_payload);
+
+      int i;
+      for (i = 0; i < 16; i++)
+      {
+	proto_tree_add_item(newtree, hf_epa_uint16, tvb,
+			    12 + (i*sizeof(guint16)),
+			    sizeof(guint16), TRUE);
+      }
+      proto_tree_add_text(newtree, tvb, 0, 0, "...");
+      for (i = 0; i < 8; i++)
+      {
+	proto_tree_add_item(newtree, hf_epa_uint16, tvb,
+			    12 + SS_SELECT_SIZE_BYTES - (8*sizeof(guint16)) + (i*sizeof(guint16)),
+			    sizeof(guint16), TRUE);
+      }
+    }
+    else if ( READACK == type && (BST == pid || SST == pid) && (BST_POWER == reg || SST_POWER == reg) )
+    {
+      /* READACK [BST|SST]_MEAN POWER */
+
+      newitem = proto_tree_add_text(epa_tree, tvb, 12, -1, "Statistics Payload (POWER)");
+      newtree = proto_item_add_subtree(newitem, ett_payload);
+
+      int i;
+      /* print first 16 values */
+      for (i = 0; i < 16; i++)
+      {
+	guint64 val64 = tvb_get_ntohl(tvb, 12 + (i*sizeof(guint32)));
+	if (((guint64)1<<31) && val64) val64 = (val64 & (((guint64)1<<31)-1)) << 25;
+	double dval = (double)val64;
+	
+	proto_tree_add_double(newtree, hf_epa_double, tvb,
+			      12 + (i*sizeof(guint32)),
+			      sizeof(guint32), dval);
+      }
+      proto_tree_add_text(newtree, tvb, 0, 0, "...");
+
+      /* print last 8 values */
+      for (i = 0; i < 8; i++)
+      {
+	guint64 val64 = tvb_get_ntohl(tvb, 12 + FRAGMENT_SIZE_BYTES - (8*sizeof(guint32)) + (i*sizeof(guint32)));
+	if (((guint64)1<<31) && val64) val64 = (val64 & (((guint64)1<<31)-1)) << 25;
+	double dval = (double)val64;
+
+	proto_tree_add_double(newtree, hf_epa_double, tvb,
+			      12 + FRAGMENT_SIZE_BYTES - (8*sizeof(guint32)) + (i*sizeof(guint32)),
+			      sizeof(guint32), dval);
+      }
+    }
+    else if (READACK == type && XST == pid)
+    {
+      /* READACK XST_* */
+
+      newitem = proto_tree_add_text(epa_tree, tvb, 12, -1, "Crosslets Payload");
+      newtree = proto_item_add_subtree(newitem, ett_payload);
+
+      int i;
+      for (i = 0; i < 16; i++)
+      {
+	guint64 val64 = tvb_get_ntohl(tvb, 12 + (i*sizeof(guint32)));
+	if (((guint64)1<<31) && val64) val64 = (val64 & (((guint64)1<<31)-1)) << 25;
+	double dval = (double)val64;
+
+	proto_tree_add_item(newtree, hf_epa_uint32, tvb,
+			    12 + (i*sizeof(guint32)),
+			    sizeof(guint32), dval);
+      }
+      proto_tree_add_text(newtree, tvb, 0, 0, "...");
+      for (i = 0; i < 8; i++)
+      {
+	guint64 val64 = tvb_get_ntohl(tvb, 12 + XST_FRAGMENT_SIZE_BYTES - (8*sizeof(guint32)) + (i*sizeof(guint32)));
+	if (((guint64)1<<31) && val64) val64 = (val64 & (((guint64)1<<31)-1)) << 25;
+	double dval = (double)val64;
+
+	proto_tree_add_item(newtree, hf_epa_uint32, tvb,
+			    12 + XST_FRAGMENT_SIZE_BYTES - (8*sizeof(guint32)) + (i*sizeof(guint32)),
+			    sizeof(guint32), dval);
+      }
+    }
+    else if ( (WRITE == type || READACK == type) && RCU == pid && RCU_SETTINGS == reg)
+    {
+      /* WRITE or READACK RCU_SETTINGS */
+      newitem = proto_tree_add_text(epa_tree, tvb, 12, 2, "RCU status");
+      newtree = proto_item_add_subtree(newitem, ett_rcusettings);
+      {
+	/* X-polarization */
+	newitem = proto_tree_add_text(newtree, tvb, 12, 2, "X polarization");
+	subtree = proto_item_add_subtree(newitem, ett_rcusettings);
+	proto_tree_add_item(subtree, df_vddvcc_en,  tvb, 12, 1, FALSE);
+	proto_tree_add_item(subtree, df_vh_enable,  tvb, 12, 1, FALSE);
+	proto_tree_add_item(subtree, df_vl_enable,  tvb, 12, 1, FALSE);
+	proto_tree_add_item(subtree, df_filsel_b,   tvb, 12, 1, FALSE);
+	proto_tree_add_item(subtree, df_filsel_a,   tvb, 12, 1, FALSE);
+	proto_tree_add_item(subtree, df_bandsel,    tvb, 12, 1, FALSE);
+	proto_tree_add_item(subtree, df_hba_enable, tvb, 12, 1, FALSE);
+	proto_tree_add_item(subtree, df_lba_enable, tvb, 12, 1, FALSE);
+      }
+      {
+	/* Y-polarization */
+	newitem = proto_tree_add_text(newtree, tvb, 12, 2, "Y polarization");
+	subtree = proto_item_add_subtree(newitem, ett_rcusettings);
+	proto_tree_add_item(subtree, df_vddvcc_en,  tvb, 13, 1, FALSE);
+	proto_tree_add_item(subtree, df_vh_enable,  tvb, 13, 1, FALSE);
+	proto_tree_add_item(subtree, df_vl_enable,  tvb, 13, 1, FALSE);
+	proto_tree_add_item(subtree, df_filsel_b,   tvb, 13, 1, FALSE);
+	proto_tree_add_item(subtree, df_filsel_a,   tvb, 13, 1, FALSE);
+	proto_tree_add_item(subtree, df_bandsel,    tvb, 13, 1, FALSE);
+	proto_tree_add_item(subtree, df_hba_enable, tvb, 13, 1, FALSE);
+	proto_tree_add_item(subtree, df_lba_enable, tvb, 13, 1, FALSE);
+      }
+    }
+    else
+    {
+      proto_tree_add_item(epa_tree, hf_epa_data,        tvb, 12, -1, FALSE);
+    }
+  }
+
+  /* If this protocol has a sub-dissector call it here, see section 1.8 */
+}
+
+
+/* Register the protocol with Ethereal */
+
+/* this format is require because a script is used to build the C function
+   that calls all the protocol registration.
+*/
+
+void
+proto_register_epa(void)
+{                 
+
+  /* Setup list of header fields  See Section 1.6.1 for details*/
+  static hf_register_info hf[] = {
+    { &hf_epa_type,
+      { "type",           "epa.type",
+	FT_UINT8, BASE_HEX, VALS(type_vals), 0x0,          
+	"Message type", HFILL }
+    },
+    {
+      &hf_epa_error,
+      { "error", "epa.error",
+	FT_UINT8, BASE_DEC, VALS(mep_error_vals), 0x0,
+	"Error indicator", HFILL }
+    },
+    { &hf_epa_seqnr,
+      { "seqnr",           "epa.seqnr",
+	FT_UINT16, BASE_DEC, NULL, 0x0,          
+	"Sequence number", HFILL }
+    },
+    { &hf_epa_addr,
+      { "addr",           "epa.addr",
+	FT_BYTES, BASE_HEX, NULL, 0x0,          
+	"Message addressing", HFILL }
+    },
+    { &hf_epa_offset,
+      { "offset",           "epa.offset",
+	FT_UINT16, BASE_DEC, NULL, 0x0,          
+	"Register offset", HFILL }
+    },
+    { &hf_epa_size,
+      { "size",           "epa.size",
+	FT_UINT16, BASE_DEC, NULL, 0x0,          
+	"Read/write size", HFILL }
+    },
+    { &hf_epa_data,
+      { "data",           "epa.data",
+	FT_BYTES, BASE_HEX, NULL, 0x0,          
+	"Userdata", HFILL }
+    },
+    {
+      &hf_epa_int16,
+      { "payload_int16", "epa.payload_int16",
+	FT_INT16, BASE_DEC, NULL, 0x0,
+	"int16 payload", HFILL }
+    },
+    {
+      &hf_epa_uint16,
+      { "payload_uint16", "epa.payload_uint16",
+	FT_UINT16, BASE_DEC, NULL, 0x0,
+	"uint16 payload", HFILL }
+    },
+    {
+      &hf_epa_int32,
+      { "payload_int32", "epa.payload_int32",
+	FT_INT32, BASE_DEC, NULL, 0x0,
+	"int32 payload", HFILL }
+    },
+    {
+      &hf_epa_uint32,
+      { "payload_uint32", "epa.payload_uint32",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"uint32 payload", HFILL }
+    },
+    {
+      &hf_epa_double,
+      { "payload_double", "epa.payload_double",
+	FT_DOUBLE, BASE_DEC, NULL, 0x0,
+	"double precision values payload", HFILL }
+    },
+  };
+
+  static hf_register_info addr_fields[] = {
+    { &hf_epa_addr_dstid,
+      { "dstid",           "epa.addr.dstid",
+	FT_UINT8, BASE_HEX, VALS(dst_vals), 0x0,          
+	"Destination ID", HFILL }
+    },
+    { &hf_epa_addr_pid,
+      { "pid",           "epa.addr.pid",
+	FT_UINT8, BASE_HEX, VALS(pid_vals), 0x0,          
+	"Process ID", HFILL }
+    },
+    { &hf_epa_addr_regid,
+      { "regid",           "epa.addr.regid",
+	FT_STRING, BASE_HEX, NULL, 0x0,          
+	"Register ID", HFILL }
+    },
+    { &hf_epa_addr_ffi,
+      { "ffi",           "epa.addr.ffi",
+	FT_UINT8, BASE_HEX, NULL, 0x0,          
+	"FFI", HFILL }
+    },
+  };
+
+  static hf_register_info rspstatus_fields[] = {
+    { &df_rspstatus_voltage_1_5,
+      { "voltage_1_5",           "epa.data.rspstatus.voltage_1_5",
+	FT_UINT8, BASE_HEX, NULL, 0x0,          
+	"Measured voltage on 1.5V circuit", HFILL }
+    },
+    { &df_rspstatus_voltage_2_5,
+      { "voltage_2_5",           "epa.data.rspstatus.voltage_2_5",
+	FT_UINT8, BASE_HEX, NULL, 0x0,          
+	"Measured voltage on 2.5 circuit", HFILL }
+    },
+    { &df_rspstatus_voltage_3_3,
+      { "voltage_3_3",           "epa.data.rspstatus.voltage_3_3",
+	FT_UINT8, BASE_HEX, NULL, 0x0,          
+	"Measured voltage on 3.3 circuit", HFILL }
+    },
+    { &df_rspstatus_voltage_12,
+      { "voltage_12",           "epa.data.rspstatus.voltage_12",
+	FT_UINT8, BASE_HEX, NULL, 0x0,          
+	"Measured voltage on 12V circuit", HFILL }
+    },
+    { &df_fpgastatus_bp_temp,
+      { "bp_temp",           "epa.data.fpgastatus.bp_temp",
+	FT_UINT8, BASE_HEX, NULL, 0x0,          
+	"Current Board Processor temperature", HFILL }
+    },
+    { &df_fpgastatus_ap0_temp,
+      { "ap0_temp",           "epa.data.fpgastatus.ap0_temp",
+	FT_UINT8, BASE_HEX, NULL, 0x0,          
+	"Current Antenna Processor 0 temperature", HFILL }
+    },
+    { &df_fpgastatus_ap1_temp,
+      { "ap1_temp",           "epa.data.fpgastatus.ap1_temp",
+	FT_UINT8, BASE_HEX, NULL, 0x0,          
+	"Current Antenna Processor 1 temperature", HFILL }
+    },
+    { &df_fpgastatus_ap2_temp,
+      { "ap2_temp",           "epa.data.fpgastatus.ap2_temp",
+	FT_UINT8, BASE_HEX, NULL, 0x0,          
+	"Current Antenna Processor 2 temperature", HFILL }
+    },
+    { &df_fpgastatus_ap3_temp,
+      { "ap3_temp",           "epa.data.fpgastatus.ap3_temp",
+	FT_UINT8, BASE_HEX, NULL, 0x0,          
+	"Current Antenna Processor 3 temperature", HFILL }
+    },
+    {
+      &df_ethstatus_nof_frames,
+      {
+	"nof_frames", "epa.data.ethstatus.nof_frames",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Number of eth frames received", HFILL 
+      }
+    },
+    {
+      &df_ethstatus_nof_errors,
+      {
+	"nof_errors", "epa.data.ethstatus.nof_errors",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Number of incorrect ethernet frames", HFILL 
+      }
+    },
+    {
+      &df_ethstatus_last_error,
+      {
+	"last_error", "epa.data.ethstatus.last_error",
+	FT_UINT8, BASE_DEC, VALS(eth_error_vals), 0x0,
+	"Error status of last received ethernet frame", HFILL 
+      }
+    },
+    {
+      &df_mepstatus_seqnr,
+      {
+	"seqnr", "epa.data.mepstatus.seqnr",
+	FT_UINT16, BASE_DEC, NULL, 0x0,
+	"Sequence number of previously received message", HFILL 
+      }
+    },
+    {
+      &df_mepstatus_error,
+      {
+	"error", "epa.data.mepstatus.error",
+	FT_UINT8, BASE_DEC, VALS(mep_error_vals), 0x0,
+	"Error status of previously received message", HFILL 
+      }
+    },
+    {
+      &df_ap0_sync_sample_offset,
+      {
+	"sample_offset", "epa.data.ap0_sync.sample_offset",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Sample count at last sync event", HFILL
+      }
+    },
+    {
+      &df_ap0_sync_sync_count,
+      {
+	"sync_count", "epa.data.ap0_sync.sync_count",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Counter for the number of sync events", HFILL
+      }
+    },
+    {
+      &df_ap0_sync_slice_count,
+      {
+	"slice_count", "epa.data.ap0_sync.slice_count",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Counter for the number of sync errors", HFILL
+      }
+    },
+    {
+      &df_ap1_sync_sample_offset,
+      {
+	"sample_offset", "epa.data.ap1_sync.sample_offset",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Sample count at last sync event", HFILL
+      }
+    },
+    {
+      &df_ap1_sync_sync_count,
+      {
+	"sync_count", "epa.data.ap1_sync.sync_count",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Counter for the number of sync events", HFILL
+      }
+    },
+    {
+      &df_ap1_sync_slice_count,
+      {
+	"slice_count", "epa.data.ap1_sync.slice_count",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Counter for the number of sync errors", HFILL
+      }
+    },
+    {
+      &df_ap2_sync_sample_offset,
+      {
+	"sample_offset", "epa.data.ap2_sync.sample_offset",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Sample count at last sync event", HFILL
+      }
+    },
+    {
+      &df_ap2_sync_sync_count,
+      {
+	"sync_count", "epa.data.ap2_sync.sync_count",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Counter for the number of sync events", HFILL
+      }
+    },
+    {
+      &df_ap2_sync_slice_count,
+      {
+	"slice_count", "epa.data.ap2_sync.slice_count",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Counter for the number of sync errors", HFILL
+      }
+    },
+    {
+      &df_ap3_sync_sample_offset,
+      {
+	"sample_offset", "epa.data.ap3_sync.sample_offset",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Sample count at last sync event", HFILL
+      }
+    },
+    {
+      &df_ap3_sync_sync_count,
+      {
+	"sync_count", "epa.data.ap3_sync.sync_count",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Counter for the number of sync events", HFILL
+      }
+    },
+    {
+      &df_ap3_sync_slice_count,
+      {
+	"slice_count", "epa.data.ap3_sync.slice_count",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"Counter for the number of sync errors", HFILL
+      }
+    },
+  };
+
+  static hf_register_info rspversion_fields[] = {
+    { &df_rsp_version,
+      { "rsp_version",           "epa.data.rsp_version",
+	FT_UINT8, BASE_DEC, NULL, 0x0,          
+	"Version of the RSP board hardware", HFILL }
+    },
+    { &df_bp_version,
+      { "bp_version",           "epa.data.bp_version",
+	FT_UINT8, BASE_DEC, NULL, 0x0,          
+	"Version of the BP fpga firmware", HFILL }
+    },
+    { &df_ap_version,
+      { "ap_version",           "epa.data.ap_version",
+	FT_UINT8, BASE_DEC, NULL, 0x0,          
+	"Version of the AP fpga firmware", HFILL }
+    }
+  };
+
+  static hf_register_info rcusettings_fields[] = {
+    { &df_vddvcc_en,
+      { "vddvcc_en",           "epa.data.vddvcc_en",
+	FT_UINT8, BASE_HEX, NULL, 0x80, /* bit 7 */
+	"VDDVCC_EN", HFILL }
+    },
+    { &df_vh_enable,
+      { "vh_enable",           "epa.data.vh_enable",
+	FT_UINT8, BASE_HEX, NULL, 0x40, /* bit 6 */
+	"VH_ENABLE", HFILL }
+    },
+    { &df_vl_enable,
+      { "vl_enable",           "epa.data.vl_enable",
+	FT_UINT8, BASE_HEX, NULL, 0x20, /* bit 5 */
+	"VL_ENABLE", HFILL }
+    },
+    { &df_filsel_b,
+      { "filsel_b",           "epa.data.filsel_b",
+	FT_UINT8, BASE_HEX, NULL, 0x10, /* bit 4 */
+	"FILSEL_B", HFILL }
+    },
+    { &df_filsel_a,
+      { "filsel_a",           "epa.data.filsel_a",
+	FT_UINT8, BASE_HEX, NULL, 0x08, /* bit 3 */
+	"FILSEL_A", HFILL }
+    },
+    { &df_bandsel,
+      { "bandsel",           "epa.data.bandsel",
+	FT_UINT8, BASE_HEX, NULL, 0x04, /* bit 2 */
+	"BANDSEL", HFILL }
+    },
+    { &df_hba_enable,
+      { "hba_enable",           "epa.data.hba_enable",
+	FT_UINT8, BASE_HEX, NULL, 0x02, /* bit 1 */
+	"HBA_ENABLE", HFILL }
+    },
+    { &df_lba_enable,
+      { "lba_enable",           "epa.data.lba_enable",
+	FT_UINT8, BASE_HEX, NULL, 0x01, /* bit 0 */
+	"LBA_ENABLE", HFILL }
+    },
+    { &df_nof_overflow,
+      { "nof_overflow", "epa.data.nof_overflow",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"NOF_OVERFLOW", HFILL }
+    },
+  };
+
+  static hf_register_info wgsettings_fields[] = {
+    { &df_wg_freq,
+      { "freq", "epa.data.wg.freq",
+	FT_UINT16, BASE_DEC, NULL, 0x0,
+	"Frequency", HFILL }
+    },
+    { &df_wg_phase,
+      { "phase", "epa.data.wg.phase",
+	FT_UINT8, BASE_DEC, NULL, 0x0,
+	"Phase", HFILL }
+    },
+    { &df_wg_ampl,
+      { "ampl", "epa.data.wg.ampl",
+	FT_UINT8, BASE_DEC, NULL, 0x0,
+	"Amplitude", HFILL }
+    },
+    { &df_wg_nof_samples,
+      { "nof_samples", "epa.data.wg.nof_samples",
+	FT_UINT16, BASE_DEC, NULL, 0x0,
+	"Number of user waveform samples", HFILL }
+    },
+    { &df_wg_mode,
+      { "mode", "epa.data.wg.mode",
+	FT_UINT8, BASE_DEC, NULL, 0x0,
+	"Mode", HFILL }
+    },
+  };
+
+  /* Setup protocol subtree array */
+  static gint* ett[] = {
+    &ett_epa,
+    &ett_epa_addr,
+    &ett_rspstatus,
+    &ett_rspstatus_detail,
+    &ett_fpgastatus,
+    &ett_ethstatus,
+    &ett_mepstatus,
+    &ett_syncstatus,
+    &ett_syncvalues,
+    &ett_rcustatus,
+    &ett_rcusettings,
+    &ett_rspversion,
+    &ett_wgsettings,
+    &ett_payload,
+  };
+
+  /* Register the protocol name and description */
+  proto_epa = proto_register_protocol("LOFAR EPA Protocol",
+				      "EPA", "epa");
+
+  /* Required function calls to register the header fields and subtrees used */
+  proto_register_field_array(proto_epa, hf, array_length(hf));
+  proto_register_field_array(proto_epa, addr_fields, array_length(addr_fields));
+  proto_register_field_array(proto_epa, rspstatus_fields, array_length(rspstatus_fields));
+  proto_register_field_array(proto_epa, rspversion_fields, array_length(rspversion_fields));
+  proto_register_field_array(proto_epa, rcusettings_fields, array_length(rcusettings_fields));
+  proto_register_field_array(proto_epa, wgsettings_fields, array_length(wgsettings_fields));
+  proto_register_subtree_array(ett, array_length(ett));
+}
+
+
+/* If this dissector uses sub-dissector registration add a registration routine.
+   This format is required because a script is used to find these routines and
+   create the code that calls these routines.
+*/
+void
+proto_reg_handoff_epa(void)
+{
+  dissector_handle_t epa_handle;
+
+  epa_handle = create_dissector_handle(dissect_epa, proto_epa);
+  dissector_add("ethertype", ETHERTYPE_EPA, epa_handle);
+}
+
+void plugin_init(plugin_address_table_t* pat)
+{
+  /* initialise the table of pointers needed in Win32 DLLs */
+  pat = pat; /* shut-up compiler warning on non Win32 hosts */
+  plugin_address_table_init(pat);
+
+  /* register the new protocol, protocol fields, and subtrees */
+  if (proto_epa == -1) { /* execute protocol initialization only once */
+    proto_register_epa();
+  }
+}
+
+void plugin_reg_handoff(void)
+{
+  proto_reg_handoff_epa();
+}
diff -Naur --exclude=CVS ethereal-0.9.8-orig/plugins/epa/packet-epa.h ethereal-0.9.8-epaplugin/plugins/epa/packet-epa.h
--- ethereal-0.9.8-orig/plugins/epa/packet-epa.h	1970-01-01 01:00:00.000000000 +0100
+++ ethereal-0.9.8-epaplugin/plugins/epa/packet-epa.h	2004-07-13 17:15:05.000000000 +0200
@@ -0,0 +1,29 @@
+/* packet-epa.h
+ *
+ * $Id$
+ *
+ * Ethereal - Network traffic analyzer
+ * By Gerald Combs <gerald@ethereal.com>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __PACKET_EPA_H__
+#define __PACKET_EPA_H__
+
+void capture_epa(const guchar *, int, int, packet_counts *);
+
+#endif
diff -Naur --exclude=CVS ethereal-0.9.8-orig/plugins/Makefile.am ethereal-0.9.8-epaplugin/plugins/Makefile.am
--- ethereal-0.9.8-orig/plugins/Makefile.am	2002-10-05 05:47:38.000000000 +0200
+++ ethereal-0.9.8-epaplugin/plugins/Makefile.am	2004-07-13 17:15:05.000000000 +0200
@@ -21,7 +21,7 @@
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-SUBDIRS = docsis giop gryphon mgcp pcli
+SUBDIRS = docsis giop gryphon mgcp pcli epa
 
 plugindir = @plugindir@
