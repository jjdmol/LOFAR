#!/bin/sh

# socketrun: Start a distributed process using socket connections
#
# Copyright (C) 2008
# ASTRON (Netherlands Institute for Radio Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands
#
# This file is part of the LOFAR software suite.
# The LOFAR software suite is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# The LOFAR software suite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with the LOFAR software suite. If not, see <http://www.gnu.org/licenses/>.
#
# @author Ger van Diepen <diepen AT astron nl>
#
# $Id$


# This script starts a distributed process to process a dataset.
# The processes will use sockets for communication.
# The processed are started in the MPI-style; a machinefile tells on which
# hosts to start a process; they also get a rank (0..n).
#
# This script is a helper script for startdistproc, but it could be used
# stand-alone as well.
#
# run as: socketrun dry hfn masterhost port wait killfail logfile program envfile
#                   [arg1 arg2 ...]
#
#   dry!=0      means that the command is only printed, not executed.
#   hfn         is the name of an MPI-style machinefile. Each line in it
#               looks like:  host#part,filesys,partvds
#                host     name of the host to start a process on
#                part     name of the dataset part to process on the host
#                filesys  the file system the dataset part is on
#                partvds  name of the VDS-file of the dataset part
#   masterhost  the host the master process is running on; if empty, the first
#               host in the machine file is the master host.
#   port        the port the master host process is using and where the workers
#               can connect to.
#               Note that it is up to implementation to use a masterhost/port.
#               E.g. mwimager only starts distributed processes, but they do
#               not communicate, so there is no master.
#   wait=1      means that socketrun waits for all processes to end.
#   killfail=1  means that all other remote processes are killed if one fails.
#               It is only used if wait=1.
#   logfile     name of the log file to use; It will be suffixed with '-rank'
#               where rank is the process rank.
#   program     name of the program to start.
#   envfile     name of the envfile generated by startdistproc.
#   arg-i       extra arguments directly passed to the program started.
#
# The processes are started with the following fixed arguments:
#   socket      a string with the value 'socket'.
#   masterhost  name of the master host
#   port        port on master host
#   np          number of processes started
#   rank        process rank (0..np-1)
#   part        name of dataset part to process
#   filesys     file system dataset part is on
#   partvds     name of VDS-file describing dataset part
# Thereafter the variable arguments (passed to socketrun) are given.


dry=$1
shift
hfn=$1
shift
masterhost=$1
shift
port=$1
shift
wait=$1
shift
killfail=$1
shift
logfile=$1
shift
program=$1
shift
envfile=$1
shift

np=`wc -l $hfn | awk '{print $1}'`

# The first host is the master one.
pidlist=
rank=0
for inline in `cat $hfn`
do
  host=`echo $inline | awk -F'#' '{print $1'}`
  rest=`echo $inline | awk -F'#' '{print $2'}`
  part=`echo $rest | awk -F',' '{print $1'}`
  fsys=`echo $rest | awk -F',' '{print $2'}`
  partvds=`echo $rest | awk -F',' '{print $3'}`
  if test "$part" = ""; then
    part=.
  fi
  if test "$fsys" = ""; then
    fsys=.
  fi
  if test "$partvds" = ""; then
    partvds=.
  fi
  if test "$masterhost" = ""; then
    masterhost=$host
  fi
  # Quote all arguments ("$@" does not work over ssh).
  arg=
  for a in "$@"
  do
    arg="$arg '$a'"
  done
  echo "ssh -x -n $host $program socket $masterhost $port $np $rank '$part' '$fsys' '$partvds' '$envfile' $arg" " &"
  if test "$dry" = 0; then
    if test "$logfile" = ""; then
      ssh -x -n $host $program socket $masterhost $port $np $rank "$part" "$fsys" "$partvds" $envfile $arg &
    else
      ssh -x -n $host $program socket $masterhost $port $np $rank "$part" "$fsys" "$partvds" $envfile $arg > $logfile-$rank 2>&1 &
    fi
    pidlist="$pidlist $!"
  fi
  rank=`expr $rank + 1`
done

# If needed, wait for the processes to end.
# If a process ended unsuccessfully, kill the others if needed.
if test "$wait" = 1; then
  if test $killfail = 1; then
    # If killonfail, wait for the first process to end.
    # Poll every second.
    cont=1
    while test $cont = 1
    do
      sleep 1
      seqnr=0
      for pid in $pidlist
      do
        if ! kill -0 $pid > /dev/null 2>&1; then
          cont=0
          break
        fi
        seqnr=`expr $seqnr + 1`
      done
    done
    status=0
    if test -f $envfile.pid-$seqnr; then
      status=`grep '^status=' $envfile.pid-$seqnr | sed -e 's/status=//'`
    fi
    if test $status != 0; then
      echo "Remote process (pid=$pid) with rank $seqnr ended with error status $status"
      echo "Killing the other remote processes ..."
      rank=0
      for inline in `cat $hfn`
      do
        if test $rank != $seqnr  -a  -f $envfile.pid-$rank; then
          host=`echo $inline | awk -F'#' '{print $1'}`
          rempid=`grep '^pid=' $envfile.pid-$rank | sed -e 's/pid=//'`
          echo "ssh -x $host kill -9 $rempid"
          if test "$logfile" = ""; then
            ssh -x $host kill -9 $rempid
          else
            ssh -x $host kill -9 $rempid >> $logfile-$rank
          fi
        fi
        rank=`expr $rank + 1`
      done
    fi
  fi
  # Wait for all processes.
  # Ignore status in case the pid does not exist anymore (error 127).
  for pid in $pidlist
  do
    wait $pid > /dev/null 2>&1
    stat=$?
    if test $stat != 0  -a  $stat != 127; then
      status=1
    fi
  done
fi

exit $status
