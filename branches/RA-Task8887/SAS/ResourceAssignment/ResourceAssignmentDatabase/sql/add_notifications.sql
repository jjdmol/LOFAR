--this file was generated by create_add_notifications.sql.py
--it creates triggers and functions which fire postgres notify events upon the given table actions
--these notify events can be listened to implenting a subclass of the PostgresListener in the lofar.common.postgres python module
--for the radb such a subclass has been made, which listens specifically to the notifications defined below
--RADBPGListener in module lofar.sas.resourceassignment.database.radbpglistener
--this RADBPGListener then broadcasts the event on the lofar bus.


DROP TRIGGER IF EXISTS TRIGGER_NOTIFY_NOTIFY_task_INSERT_with_task_view ON resource_allocation.task CASCADE;
DROP FUNCTION IF EXISTS resource_allocation.NOTIFY_task_INSERT_with_task_view();


CREATE OR REPLACE FUNCTION resource_allocation.NOTIFY_task_INSERT_with_task_view()
RETURNS TRIGGER AS $$
DECLARE
new_row_from_view resource_allocation.task_view%ROWTYPE;
BEGIN
select * into new_row_from_view from resource_allocation.task_view where id = NEW.id LIMIT 1;
PERFORM pg_notify(CAST('task_insert_with_task_view' AS text),
'{"old":' || 'null' || ',"new":' || row_to_json(new_row_from_view)::text || '}');
RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER TRIGGER_NOTIFY_NOTIFY_task_INSERT_with_task_view
AFTER INSERT ON resource_allocation.task
FOR EACH ROW
EXECUTE PROCEDURE resource_allocation.NOTIFY_task_INSERT_with_task_view();


DROP TRIGGER IF EXISTS TRIGGER_NOTIFY_NOTIFY_task_UPDATE_with_task_view ON resource_allocation.task CASCADE;
DROP FUNCTION IF EXISTS resource_allocation.NOTIFY_task_UPDATE_with_task_view();


CREATE OR REPLACE FUNCTION resource_allocation.NOTIFY_task_UPDATE_with_task_view()
RETURNS TRIGGER AS $$
DECLARE
new_row_from_view resource_allocation.task_view%ROWTYPE;
BEGIN
select * into new_row_from_view from resource_allocation.task_view where id = NEW.id LIMIT 1;
PERFORM pg_notify(CAST('task_update_with_task_view' AS text),
'{"old":' || row_to_json(OLD)::text || ',"new":' || row_to_json(new_row_from_view)::text || '}');
RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER TRIGGER_NOTIFY_NOTIFY_task_UPDATE_with_task_view
AFTER UPDATE ON resource_allocation.task
FOR EACH ROW
EXECUTE PROCEDURE resource_allocation.NOTIFY_task_UPDATE_with_task_view();


DROP TRIGGER IF EXISTS TRIGGER_NOTIFY_NOTIFY_task_DELETE ON resource_allocation.task CASCADE;
DROP FUNCTION IF EXISTS resource_allocation.NOTIFY_task_DELETE();


CREATE OR REPLACE FUNCTION resource_allocation.NOTIFY_task_DELETE()
RETURNS TRIGGER AS $$
BEGIN
PERFORM pg_notify(CAST('task_delete' AS text),
'{"old":' || row_to_json(OLD)::text || ',"new":' || 'null' || '}');
RETURN OLD;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER TRIGGER_NOTIFY_NOTIFY_task_DELETE
AFTER DELETE ON resource_allocation.task
FOR EACH ROW
EXECUTE PROCEDURE resource_allocation.NOTIFY_task_DELETE();


DROP TRIGGER IF EXISTS TRIGGER_NOTIFY_NOTIFY_specification_UPDATE_with_task_view ON resource_allocation.specification CASCADE;
DROP FUNCTION IF EXISTS resource_allocation.NOTIFY_specification_UPDATE_with_task_view();


CREATE OR REPLACE FUNCTION resource_allocation.NOTIFY_specification_UPDATE_with_task_view()
RETURNS TRIGGER AS $$
DECLARE
new_row_from_view resource_allocation.task_view%ROWTYPE;
BEGIN
select * into new_row_from_view from resource_allocation.task_view where specification_id = NEW.id LIMIT 1;
PERFORM pg_notify(CAST('specification_update_with_task_view' AS text),
'{"old":' || row_to_json(OLD)::text || ',"new":' || row_to_json(new_row_from_view)::text || '}');
RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER TRIGGER_NOTIFY_NOTIFY_specification_UPDATE_with_task_view
AFTER UPDATE ON resource_allocation.specification
FOR EACH ROW
EXECUTE PROCEDURE resource_allocation.NOTIFY_specification_UPDATE_with_task_view();


DROP TRIGGER IF EXISTS TRIGGER_NOTIFY_NOTIFY_resource_claim_INSERT_with_resource_claim_view ON resource_allocation.resource_claim CASCADE;
DROP FUNCTION IF EXISTS resource_allocation.NOTIFY_resource_claim_INSERT_with_resource_claim_view();


CREATE OR REPLACE FUNCTION resource_allocation.NOTIFY_resource_claim_INSERT_with_resource_claim_view()
RETURNS TRIGGER AS $$
DECLARE
new_row_from_view resource_allocation.resource_claim_view%ROWTYPE;
BEGIN
select * into new_row_from_view from resource_allocation.resource_claim_view where id = NEW.id LIMIT 1;
PERFORM pg_notify(CAST('resource_claim_insert_with_resource_claim_view' AS text),
'{"old":' || 'null' || ',"new":' || row_to_json(new_row_from_view)::text || '}');
RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER TRIGGER_NOTIFY_NOTIFY_resource_claim_INSERT_with_resource_claim_view
AFTER INSERT ON resource_allocation.resource_claim
FOR EACH ROW
EXECUTE PROCEDURE resource_allocation.NOTIFY_resource_claim_INSERT_with_resource_claim_view();


DROP TRIGGER IF EXISTS TRIGGER_NOTIFY_NOTIFY_resource_claim_UPDATE_with_resource_claim_view ON resource_allocation.resource_claim CASCADE;
DROP FUNCTION IF EXISTS resource_allocation.NOTIFY_resource_claim_UPDATE_with_resource_claim_view();


CREATE OR REPLACE FUNCTION resource_allocation.NOTIFY_resource_claim_UPDATE_with_resource_claim_view()
RETURNS TRIGGER AS $$
DECLARE
new_row_from_view resource_allocation.resource_claim_view%ROWTYPE;
BEGIN
select * into new_row_from_view from resource_allocation.resource_claim_view where id = NEW.id LIMIT 1;
PERFORM pg_notify(CAST('resource_claim_update_with_resource_claim_view' AS text),
'{"old":' || row_to_json(OLD)::text || ',"new":' || row_to_json(new_row_from_view)::text || '}');
RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER TRIGGER_NOTIFY_NOTIFY_resource_claim_UPDATE_with_resource_claim_view
AFTER UPDATE ON resource_allocation.resource_claim
FOR EACH ROW
EXECUTE PROCEDURE resource_allocation.NOTIFY_resource_claim_UPDATE_with_resource_claim_view();


DROP TRIGGER IF EXISTS TRIGGER_NOTIFY_NOTIFY_resource_claim_DELETE ON resource_allocation.resource_claim CASCADE;
DROP FUNCTION IF EXISTS resource_allocation.NOTIFY_resource_claim_DELETE();


CREATE OR REPLACE FUNCTION resource_allocation.NOTIFY_resource_claim_DELETE()
RETURNS TRIGGER AS $$
BEGIN
PERFORM pg_notify(CAST('resource_claim_delete' AS text),
'{"old":' || row_to_json(OLD)::text || ',"new":' || 'null' || '}');
RETURN OLD;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER TRIGGER_NOTIFY_NOTIFY_resource_claim_DELETE
AFTER DELETE ON resource_allocation.resource_claim
FOR EACH ROW
EXECUTE PROCEDURE resource_allocation.NOTIFY_resource_claim_DELETE();


DROP TRIGGER IF EXISTS TRIGGER_NOTIFY_NOTIFY_resource_availability_UPDATE ON resource_monitoring.resource_availability CASCADE;
DROP FUNCTION IF EXISTS resource_monitoring.NOTIFY_resource_availability_UPDATE();


CREATE OR REPLACE FUNCTION resource_monitoring.NOTIFY_resource_availability_UPDATE()
RETURNS TRIGGER AS $$
BEGIN
PERFORM pg_notify(CAST('resource_availability_update' AS text),
'{"old":' || row_to_json(OLD)::text || ',"new":' || row_to_json(NEW)::text || '}');
RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER TRIGGER_NOTIFY_NOTIFY_resource_availability_UPDATE
AFTER UPDATE ON resource_monitoring.resource_availability
FOR EACH ROW
EXECUTE PROCEDURE resource_monitoring.NOTIFY_resource_availability_UPDATE();


DROP TRIGGER IF EXISTS TRIGGER_NOTIFY_NOTIFY_resource_capacity_UPDATE ON resource_monitoring.resource_capacity CASCADE;
DROP FUNCTION IF EXISTS resource_monitoring.NOTIFY_resource_capacity_UPDATE();


CREATE OR REPLACE FUNCTION resource_monitoring.NOTIFY_resource_capacity_UPDATE()
RETURNS TRIGGER AS $$
BEGIN
PERFORM pg_notify(CAST('resource_capacity_update' AS text),
'{"old":' || row_to_json(OLD)::text || ',"new":' || row_to_json(NEW)::text || '}');
RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER TRIGGER_NOTIFY_NOTIFY_resource_capacity_UPDATE
AFTER UPDATE ON resource_monitoring.resource_capacity
FOR EACH ROW
EXECUTE PROCEDURE resource_monitoring.NOTIFY_resource_capacity_UPDATE();

