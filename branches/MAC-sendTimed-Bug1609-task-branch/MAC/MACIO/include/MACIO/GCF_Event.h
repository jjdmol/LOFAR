//#  GCF_Event.h: finite state machine events
//#
//#  Copyright (C) 2002-2003
//#  ASTRON (Netherlands Foundation for Research in Astronomy)
//#  P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
//#
//#  This program is free software; you can redistribute it and/or modify
//#  it under the terms of the GNU General Public License as published by
//#  the Free Software Foundation; either version 2 of the License, or
//#  (at your option) any later version.
//#
//#  This program is distributed in the hope that it will be useful,
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//#  GNU General Public License for more details.
//#
//#  You should have received a copy of the GNU General Public License
//#  along with this program; if not, write to the Free Software
//#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//#
//#  $Id$

#ifndef MACIO_GCF_EVENT_H
#define MACIO_GCF_EVENT_H

#include <Common/LofarTypes.h>
#include <Common/lofar_string.h>

namespace LOFAR {
 namespace MACIO {

/**
 * This class is the base event data container to exchange messages between two 
 * tasks. 
 * Application tasks will have to define their own protocol by specifying the 
 * contents of events that are exchanged between tasks. Creating sub class from 
 * GCFEvent creates application (tasks) specific events. All GCFEvent sub 
 * classes are generally the same except for the parameters that make the event 
 * unique. A protocol is a collection of events where each event has a specific 
 * direction (IN/OUT). To create a new protocol a protocol specification file 
 * must be created (with extension '.prot'). The autogen utility is then used to 
 * convert this specification file into a header file containing GCFEvent sub 
 * class definitions. 
 * The protocol specification consists of a list of the possible events in the 
 * protocol each with its own parameters (or no parameters) and with the 
 * direction in which the event can be sent. The autogen utility is used to 
 * generate a header file from this definition using a template for the header 
 * file and the nested key-value pairs from the specification file. This header 
 * file contains definitions of GCFEvent sub classes, one for each event. 
 */

#define SIZEOF_EVENT(e) ((ssize_t) (sizeof((e).signal) + sizeof((e).seqnr) + sizeof((e).length) + (e).length))

class GCFEvent
{
public:
	// constructors, destructors, operators
	GCFEvent() :
		signal(0), seqnr(0), length(0), _buffer(0)
	{}

	GCFEvent(unsigned short sig) :
		signal(sig), seqnr(0), length(0), _buffer(0)
	{}

	/// destructor
	virtual ~GCFEvent();

	/// result of a dispatch action
	enum TResult { 
		HANDLED = 0, 
		NOT_HANDLED,
		NEXT_STATE
	};

	// packs all fields of the event into the event buffer and returns its 
	// pointer and the number of packed bytes (output argument)
	virtual void pack();

	// Make a copy of the event
	virtual GCFEvent* clone();

	// print function for operator<< 
	ostream& print (ostream& os) const;

	// some constant values
	static const uint	sizeSignal		   = sizeof(uint16);
	static const uint	sizeSeqnr		   = sizeof(uint16);
	static const uint	sizeLength		   = sizeof(uint32);
	static const uint	sizePackedGCFEvent = sizeSignal + sizeSeqnr + sizeLength;

	uint 	bufferSize()    { return (_buffer ? length + sizePackedGCFEvent : 0); }
	char*	packedBuffer()	{ return (_buffer); }

protected:
	// special constructor it will be call by the specialised "unpack"- 
	// constructor generated by autogen
	GCFEvent(GCFEvent& e) :
		signal(e.signal), seqnr(e.seqnr), length(e.length), _buffer(e._buffer)
	{}
	GCFEvent(const GCFEvent& e) :
		signal(e.signal), seqnr(e.seqnr), length(e.length), _buffer(e._buffer)
	{}

	// helper methods
	uint32 unpackString(string& value, char* buffer);   
	uint32 packString  (char* buffer, const string& value);  
	void   resizeBuf   (uint32 requiredSize);
	void*  unpackMember(char* data, uint32& offset, uint32& memberNOE, uint32 sizeofMemberType);
	uint32 packMember  (uint32 offset, const void* member, uint32 memberNOE, uint32 sizeofMemberType);

private:
	// prevent copying
	GCFEvent& operator= (GCFEvent& e);

	// ----- Data Members -----
public:
	// @code
	// Signal format 
	//
	// 2 most significant bits indicate direction of signal:
	//   F_IN    = 0b01
	//   F_OUT   = 0b10
	//   F_INOUT = 0b11 (F_IN_SIGNAL | F_OUT_SIGNAL)
	//
	// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	// | O | I | P | P | P | P | P | P | S | S | S | S | S | S | S | S |
	// +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
	// <- I/O-><--- protocol ---------><--------- signal -------------->
	// @endcode
	uint16  signal; // lsb contains signal id (0-255)
	// msb contains protocol id (0-255)
	uint16	seqnr;	// port generated sequencenumber for support of timed messages.
	uint32  length; // payload length of the event (thus excl. signal and length) should be <= SSIZE_MAX)

//protected:
	// The packbuffer where a packed version of an event can reside. As soon as the buffer
	// buffer is unpacked it is released. The first few bytes in the buffer are always the
	// (packed) signal and length values.
	char* _buffer;
};

//#
//# operator<<
//#
inline ostream& operator<< (ostream& os, const GCFEvent& anEvent)
{	
	return (anEvent.print(os));
}

//
// GCFTransportable
//
class GCFTransportable
{
public:
	virtual ~GCFTransportable() {}
	virtual unsigned int pack(char* buffer) = 0;
	virtual unsigned int unpack(char* buffer) = 0;
	virtual unsigned int getSize() = 0;
};

// Macros to aid in decoding the signal field.
#define F_EVT_INOUT_MASK    (0xc000)
#define F_EVT_PROTOCOL_MASK (0x3f00)
#define F_EVT_SIGNAL_MASK   (0x00ff)

#define F_EVT_INOUT(e)       (((e).signal & F_EVT_INOUT_MASK) >> 14)
#define F_EVT_PROTOCOL(e)    (((e).signal & F_EVT_PROTOCOL_MASK) >> 8)
#define F_EVT_SIGNAL(e)      ((e).signal & F_EVT_SIGNAL_MASK)
#define F_SIGNAL_INOUT(s)    (((s) & F_EVT_INOUT_MASK) >> 14)
#define F_SIGNAL_PROTOCOL(s) (((s) & F_EVT_PROTOCOL_MASK) >> 8)
#define F_SIGNAL_SIGNAL(s)   ((s) & F_EVT_SIGNAL_MASK)

 } // namespace MACIO
} // namespace LOFAR

#endif
