#!/bin/sh

# todo
#   maybe allow -i ID1=... -i ID2=...
# so different ids can be used in the glob pattern.

showhelp() 
{
  echo ''
  echo ' cexecms runs a command on cluster nodes for files matching'
  echo ' the given file name glob pattern.'
  echo ''
  echo ' usage:'
  echo '    cexecms [-c cluster] command nameglob [arg1 arg2 ...]'
  echo ''
  echo '      -c cluster    cluster name as defined for cexec'
  echo '                    default is lce: if run on an lfe node, otherwise locus:'
  echo '      -d            do a dryrun (i.e., do not execute, but only print the command)'
  echo '      -i ids        List of ids to replace <ID> in the nameglob argument'
  echo '                    A comma and/or blank can be used as separator'
  echo '                    Ids can be given with parset range style (e.g. 33678..33683)'
  echo '                    In this way the command can be executed for multiple observations'
  echo '      -p parset     parset to be used by the command'
  echo '                    It must b accessible on all nodes in the cluster'
  echo '                    placeholders in the parset like <FN> are replaced'
  echo '                    The parset will be used as the first argument for the command'
  echo '      -w workdir    Working directory in remote process. Default is login directory'
  echo '      command       command to be executed remotely'
  echo '                    Quotes are needed if it contains spaces, etc.'
  echo '      nameglob      file name glob pattern (# is a shorthand for [0-9])'
  echo '                    E.g., one can use SB### for any subband'
  echo '      arg1 arg2 ..  Optional extra arguments given to the command'
  echo ''
  echo ' Using cexec, the script cexecms-part is executed on the given cluster'
  echo ' nodes. It looks for files matching the given file name glob pattern.'
  echo ' The glob pattern can be bash-style, thus *, ?, [], and {} are possible.'
  echo ' The given command will be executed for each matching file name.'
  echo ' The actual file name can be made part of the command using:'
  echo '     <FILENAME> or <FN>  for the full file name'
  echo '     <BASENAME> or <BN>  for the basename part'
  echo '     <DIRNAME>  or <DN>  for the directory part'
  echo ' The first two can be followed by a . (e.g. <FN.>) meaning that the'
  echo ' basename is used till the first dot (thus the extension is removed.)'
  echo ' If no substitutions have been done, the command is executed like'
  echo '     command filename arg1 arg2 ...'
  echo ' otherwise like'
  echo '     command arg1 arg2...'
  echo ''
  echo ' For example:'
  echo '   cexecms "ls -d" "/data/scratch/pipeline/L2011_22663/*"'
  echo ' is a trivial example and could also be done with cexec. Note that'
  echo '   cexecms "ls -d <FN>" "/data/scratch/pipeline/L2011_22663/*"'
  echo ' is doing the same.'
  echo ' The following example is more elaborate and creates a _sel.MS table'
  echo ' in another directory for each MS of subband 000 till 099.'
  echo '   cexecms "taql '"'"'select from <FN> where ANTENNA1 in [0,1,2]'
  echo '                 giving /data/scratch/diepen/<BN.>_sel.MS'"'"'"'
  echo '           "/data/scratch/pipeline/L2011_22663/*SB0##*"'
  echo ''
  echo ' Sometimes a command can be dangerous or take a long time to run.'
  echo ' In such a case it makes sense to execute it first on a single subband'
  echo ' using a glob pattern with a specific subband or by using cexecms-part'
  echo ' on a remote node'.
  echo ''
  echo ' Note that the current environment (paths, etc.) is copied. You should'
  echo ' have done "use LofIm" if you need LofIm in the (remote) command.'
  echo ''
}

# Find the path used to start the script.
pgmpath=`dirname $0`
pgmpath=`cd $pgmpath > /dev/null 2>&1  &&  pwd`

if test $# -lt 2; then
    showhelp
    exit 1
fi
cluster=
parset=
ids=
dryrun=
workdir=
# Handle possible options.
while [ $# != 0 ]
do
  if test "$1" = "-c"; then
    shift
    cluster="$1"
    shift
  elif test "$1" = "-p"; then
    shift
    parset="$1"
    shift
  elif test "$1" = "-i"; then
    shift
    ids="$1"
    shift
  elif test "$1" = "-w"; then
    shift
    workdir="$1"
    shift
  elif test "$1" = "-d"; then
    shift
    dryrun="-d"
  else
    case "$1" in
    -*)
      echo "$1 is an unknown cexecms option"
      exit 1
      ;;
    *)
      # A command has been found, so stop parsing options.
      break
      ;;
    esac
  fi
done
if test "$1" = "-p"; then
    shift
    parset="$1"
    shift
fi
if test "$1" = "-c"; then
    shift
    cluster="$1"
    shift
fi
if test $# -lt 2; then
    showhelp
    exit 1
fi

# Replace possible commas in ids by blanks.
ids=`echo "$ids" | sed 's/,/ /g'`
# Get coomand and glob pattern.
command="$1"
shift
nameglob="$1"
shift

# If no cluster given, use default.
if test "$cluster" = ""; then
  cluster="locus:"
  case "$HOSTNAME" in
    lfe*) cluster="lce:";;
  esac
fi

# The ids can be given in parset format (e.g. 001..4), so expand them.
ids=`expandparameter "$ids"`

# Find all PATH and ROOT variables and store in a file with the pid in its name.
envfile=$HOME/${USER}-$$.env
grex='[^=]*(PATH|ROOT|APS_LOCAL)'
printenv | egrep "^$grex=" | sed -e "s/^\([^=]*\)=\(.*\)/\1='\2'; export \1/;" > $envfile

# Execute on all compute nodes.
# cexec does not keep quotes around the command, so substitute all shell
# characters like space and brackets.
commandnew=`echo "$command" | sed \
    -e 's% %:SPACE:%g' \
    -e 's%<%:LT:%g' \
    -e 's%>%:GT:%g' \
    -e 's%(%:LPAR:%g' \
    -e 's%)%:RPAR:%g' \
    -e 's%{%:LBRACE:%g' \
    -e 's%}%:RBRACE:%g' \
    -e 's%\\[%:LBRACKET:%g' \
    -e 's%]%:RBRACKET:%g' \
    -e 's%|%:VBAR:%g' \
    -e 's%&%:AMPERSAND:%g' \
    -e 's%\\*%:ASTERIX:%g' \
    -e 's%!%:NOT:%g' \
    -e 's%#%:HASH:%g' \
    -e 's%~%:TILDE:%g' \
    -e 's%,%:COMMA:%g' \
    -e 's%\\?%:QMARK:%g' \
    -e 's%;%:SEMICOLON:%g' \
    -e 's%"%:DQUOTE:%g' \
    -e "s%'%:SQUOTE:%g" \
    -e 's%\\$%:DOLLAR:%g'`
# Furthermore it expands the nameglob, so change that as well.
nameglobnew=`echo "$nameglob" | sed \
    -e 's%\*%:ASTERISK:%g' \
    -e 's%\?%:QUESTIONMARK:%g' \
    -e 's%\[%:LBRACKET:%g' \
    -e 's%\]%:RBRACKET:%g' \
    -e 's%{%:LBRACE:%g' \
    -e 's%}%:RBRACE:%g'`

# Add -p is parset is used.
# Same for -w.
test "$parset"  = ""  ||   parset="-p $parset"
test "$workdir" = ""  ||  workdir="-w $workdir"
# Do a single run if no ids given, otherwise iterate over all ids.
if test "$ids" = ""; then
  cexec $cluster $pgmpath/cexecms-part $dryrun -e "$envfile" "$parset" "$workdir" "'$commandnew'" "$nameglobnew" "$@"
else
  for id in $ids
  do
    nm=`echo "$nameglobnew" | sed -e "s%<ID>%$id%g"`
    cexec $cluster $pgmpath/cexecms-part $dryrun -e "$envfile" "$parset" "$workdir" "'$commandnew'" "$nm" "$@"
  done
fi
rm -f "$envfile"
