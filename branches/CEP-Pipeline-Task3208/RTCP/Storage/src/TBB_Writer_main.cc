/* TBB_Writer_main.cc
 * 
 * LOFAR Transient Buffer Boards (TBB) Data Writer  Copyright (C) 2011, 2012
 * ASTRON (Netherlands Institute for Radio Astronomy)
 * P.O. Box 2, 7990 AA Dwingeloo, The Netherlands.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with the LOFAR software suite.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * $Id: TBB_Writer_main.cc 29470 2012-03-14 18:58:53Z amesfoort $
 */
/* 
 * Parts derived from the BF writer written by Jan David Mol, and from
 * TBB writers written by Lars Baehren, Andreas Horneffer, and Joseph Masters.
 */

/*
 * NOTE: Only transient data mode has been implemented and tested.
 * Some code for spectral mode is implemented, but it could never be tested and the TBB HDF5 format considers transient data only.
 * Currently, users I talked to don't care about spectral data, although the hardware should be able to supply it. (Mar 2012)
 */

#include <lofar_config.h>			// before any other include

#define _XOPEN_SOURCE	500			// enable sigaction(2), gethostname(2), and thread-safe _r functions, like gmtime_r()

#include <cstddef>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cmath>
#include <csignal>
#include <ctime>					// strftime()
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/time.h>

#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <map>

#include <boost/lexical_cast.hpp>

#include <Common/LofarTypes.h>
#include <Common/LofarLogger.h>
#include <Common/SystemUtil.h>
#include <Common/StringUtil.h>
#include <Common/StreamUtil.h>
#include <Common/Thread/Thread.h>
#include <Common/Exceptions.h>
#include <Common/NewHandler.h>

#include <Storage/TBB_StaticMapping.h>
#include <Storage/TBB_Writer.h>
#include <Storage/IOPriority.h>

#if defined HAVE_PKVERSION
#include "Package__Version.h"		// generated by cmake
#endif

#define TBB_DEFAULT_BASE_PORT		0x7bb0	// i.e. tbb0
#define TBB_DEFAULT_LAST_PORT		0x7bbb	// 0x7b5 for NL stations

using namespace std;

struct progArgs {
	string inFilename;
	string outFilename;
	string parsetFilename;
	string connMapFilename;
	int proto;
	uint16_t port;
};

// Install a new handler to produce backtraces for std::bad_alloc.
LOFAR::NewHandler badAllocExcHandler(LOFAR::BadAllocException::newHandler);

static volatile bool sigint_seen; // read only for anyone, written only by the signal handler below

static void sigint_handler(int signal_number) {
	sigint_seen = true;
}

static unsigned stationNameToId(const string& stName) {
	if (stName.size() < 5) {
		throw LOFAR::Exception("Station name must be at least 5 characters");
	}
	unsigned id = LOFAR::strToUint(stName.substr(2, 3));
	if (id > 200) {
		unsigned sub = (id - 101) / 100;
		id = id - sub * 80;
	}
	return id;
}

// Returns last mod date/time of filename or current time of day if stat()ing
// filename fails, in YYYY-MM-DDThh:mm:ss.s UTC format.
static string getFileModDate(const string& filename) {
	struct stat st;
	int err;

	err = stat(filename.c_str(), &st);
	if (err != 0) {
		struct timeval tv;
		err = gettimeofday(&tv, NULL); // If stat() fails, this is close enough to file mod date.
		if (err == 0) {
			st.st_mtime = tv.tv_sec;
			st.st_mtim.tv_nsec = tv.tv_usec * 1000;
		} else { // very unlikely, gettimeofday() should not return non-null when passed a proper buffer
			st.st_mtime = 0;
			st.st_mtim.tv_nsec = 0;
		}
	}

	struct tm tm = {0}; // init in case gmtime_r() returns NULL (if year does not fit into an int, unlikely)
	gmtime_r(&st.st_mtime, &tm);
	double secs = tm.tm_sec + st.st_mtim.tv_nsec / 1000000000.0;

	const char output_fmt[] = "YYYY-MM-DDThh:mm:ss.s";
	char* date_str = new char[sizeof(output_fmt)];
	size_t nwritten = strftime(date_str, sizeof(output_fmt), "%Y-%m-%dT%H:%M:", &tm); // Add the "ss.s" secs separately.
	/*int nprinted = */snprintf(date_str + nwritten, sizeof(output_fmt) - nwritten, "%04.1f", secs); // _total_ width of 4 of "ss.s"

	string date(date_str);
	delete[] date_str;
	return date;
}

static string timeStr(double time) {
	time_t timeSec = static_cast<time_t>(floor(time));
	unsigned long timeNSec = static_cast<unsigned long>(round( (time-floor(time))*1e9 ));

	char utcstr[50];
	if (strftime( utcstr, sizeof(utcstr), "%Y-%m-%dT%H:%M:%S", gmtime(&timeSec) ) == 0) {
		return "";
	}

	return LOFAR::formatString("%s.%09lu", utcstr, timeNSec);
}

static double toMJD(double time) {
	// 40587 modify Julian day number = 00:00:00 January 1, 1970, GMT
	return 40587.0 + time / (24*60*60);
}

// Populates the Station group. Note: Does _not_ set the dipole datasets.
static void setStationGroup(DAL::TBB_Station& st, const LOFAR::RTCP::Parset& parset, const string& stName, const vector<double>& stPosition) {
	st.groupType().set("StationGroup");
	st.stationName().set(stName);

	st.stationPositionValue().set(stPosition);
	//st.stationPositionUnit().set(); // TODO: ??? array of strings? (also at beamDirection, but not at antennaPosition)
	st.stationPositionFrame().set(parset.positionType()); // returns "ITRF"

	// TODO: Also see bf writer MS makeBeamTable() kind of function. In the future, also indicates broken tiles/dipoles w/ timestamp.
	// TODO: ITRF -> ITRF2008...?
	if (parset.haveAnaBeam()) { // HBA // TODO: AnaBeam vs Beam?
		st.beamDirectionValue().set(parset.getAnaBeamDirection()); // always for beam 0
		st.beamDirectionFrame().set(parset.getAnaBeamDirectionType()); // idem
	} else {
		unsigned nBeams = parset.nrBeams(); // TODO: What if >1 station beams? Now, only write beam0. Probably irrel for now, because of AnaBeam (HBA).
		if (parset.nrBeams() > 0) {
			st.beamDirectionValue().set(parset.getBeamDirection(0));
			st.beamDirectionFrame().set(parset.getBeamDirectionType(0)); // TODO: fix getBeamDirectionType() sprintf -> snprintf (check all parset funcs)
		} else { // No beam (known or at all), so set null vector
			vector<double> noBeamDirVal(2, 0.0);
			st.beamDirectionValue().set(noBeamDirVal);
			st.beamDirectionFrame().set("ITRF");
		}
	}
	//st.beamDirectionUnit().set(); // TODO: ??? beam dir = 2 angles. array of string??? "radians"

	st.clockOffsetValue().set(parset.clockCorrectionTime(stName)); // TODO: check if stName is as expected; returns 0.0 if not avail
	st.clockOffsetUnit().set("s");

	//st.triggerOffset().set(); // TODO: remove from DAL

	// Also need the following, but we create/set that while the data is incoming to match better.
	//st.nofDipoles().set(); // TODO: make it unsigned (instead of int in the ICD); later: remove it alltogether and make it and #stations retrievable
	//DAL::TBB_DipoleDataset tdds(tbbf.dipole(stationId, rspId, rcuId)); // we could get all station/rsp pairs from getStationNamesAndRSPboardNumbers(), but not rcus
}

static void setTriggerGroup(DAL::TBB_Trigger& tg, const LOFAR::RTCP::Parset& parset) {
	tg.groupType().set("TriggerGroup");
//	tg.triggerType().set("Unknown"); // We don't get this or any other trigger data yet, so do the minimum.
//	tg.triggerVersion().set(0); // There is no trigger alg impl yet.

	// TODO: put these into DAL, because we can set them
	// Trigger parameters (how to decide if there is a trigger) (per obs)
//	tg.paramCoincidenceChannels().set(parset.tbbNumberOfCoincidenceChannels());	// int(->unsigned); from Observation.ObservationControl.StationControl.TBBControl.NoCoincChann
//	tg.paramCoincidenceTime()    .set(parset.tbbCoincidenceTime());				// double; from Observation.ObservationControl.StationControl.TBBControl.CoincidenceTime
//	tg.paramDirectionFit()       .set(parset.tbbDoDirectionFit());				// string; from Observation.ObservationControl.StationControl.TBBControl.DoDirectionFit
//	tg.paramElevationMin()       .set(parset.tbbMinElevation());				// double; from Observation.ObservationControl.StationControl.TBBControl.MinElevation
//	tg.paramFitVarianceMax()     .set(parset.tbbMaxFitVariance());				// double; Observation.ObservationControl.StationControl.TBBControl.MaxFitVariance
	// unused: Observation.ObservationControl.StationControl.TBBControl.ParamExtension = []

	// Trigger data (per trigger)
	// N/A atm

	// TODO: (this is already done for any attribute in any group?)
	/* From an e-mail by Pim Schellart:
	 * To actually implement this, given the likely need for many
	 * changes, it is probably easiest to provide only one method for the
	 * TriggerGroup that allows setting (keyword, value) pairs and one to
	 * retrieve an attribute. That way we can just get/set whatever we need
	 * in that group without having to bother you with it.
	 */
}

static void setTBB_RootAttributes(DAL::TBB_File& file, const LOFAR::RTCP::Parset& parset, const string& stName) {
	//file.mode().set("transient"); // TODO: add string mode field: "transient" or "spectral". Maybe it's Observation.TBB.TBBsetting.operatingMode = 1
	// TODO: also setting for?: Each TBB can store [...] either before or after the conversion to subbands (the polyphase filter and FFT).
	// from: http://www.astron.nl/radio-observatory/astronomers/users/technical-information/transient-buffer-boards/transient-buffer-b

	// The writer creates one HDF5 file per station, so create only one Station Group here.
	DAL::TBB_Station station(file.station(0/*stName*/)); // TODO: 0 -> stName

	// Find the station name we're looking for ("CS001" == "CS001HBA0") and retrieve it's pos using the found idx.
	vector<double> stPos;

	vector<string> obsStationNames(parset.allStationNames()); // can also contain "CS001HBA0"
	vector<string>::const_iterator nameIt(obsStationNames.begin());

	vector<double> stationPositions(parset.positions()); // len must be (is generated as) 3x #stations
	vector<double>::const_iterator posIt(stationPositions.begin());

	const size_t stNameLen = 5;
	for ( ; nameIt != obsStationNames.end(); ++nameIt, posIt += 3) {
		if (nameIt->substr(0, stNameLen) == stName) {
			break;
		}
	}
	if (nameIt != obsStationNames.end() && // found?
				posIt < stationPositions.end()) { // only fails if Parset provided broken vectors
		stPos.assign(posIt, posIt + 3);
	} else { // not found or something wrong; create anyway or we lose data
		stPos.assign(3, 0.0);
	}
	station.create();
	setStationGroup(station, parset, stName, stPos);

	// Trigger Group
	DAL::TBB_Trigger tg(file.triggerData()); // TODO: triggerData() -> trigger()
	tg.create();
	setTriggerGroup(tg, parset);

	// TODO: dump all Observation.TBB.* parset attribs? what are those?
}

static void setCommonLofarAttributes(DAL::TBB_File& file, const LOFAR::RTCP::Parset& parset, const string& filename) {
	file.groupType().set("Root");
	const string baseFilename(LOFAR::basename(filename));
	file.fileName() .set(baseFilename);
	file.fileDate() .set(getFileModDate(baseFilename));
	file.fileType() .set("tbb"); // TODO: this is obviously tbb specific; the rest of this function is not.
	file.telescope().set("LOFAR");
	//file.observer() .set(parset.observer()); // TODO: name(s) of the observer(s); bf writes "unknown"; our default val is "UNKNOWN"

	file.projectID()     .set(parset.getString("Observation.Campaign.name"));
	file.projectTitle()  .set(parset.getString("Observation.Campaign.title"));
	file.projectPI()     .set(parset.getString("Observation.Campaign.PI"));
	// Don't use ", " as a separator, because it already occurs in names formatted backwards (e.g. Smith, J.).
	ostringstream oss;
	LOFAR::writeVector(oss, parset.getStringVector("Observation.Campaign.CO_I"), "; ", "", "");
	file.projectCOI()    .set(oss.str());
	file.projectContact().set(parset.getString("Observation.Campaign.contact"));

/*	// TODO: add getString() and getStringVector() routines to RTCP Parset (sub)class
	file.projectID()     .set(parset.observationName()); // TODO: check if Name -> ID
	file.projectTitle()  .set(parset.observationTitle());
	file.projectPI()     .set(parset.observationPI());
	file.projectCOI()    .set(parset.observationCOI()); // TODO: see above
	file.projectContact().set(parset.observationContact());
*/
	//file.observationID() .set(str(format("%s") % parset.observationID()));
	file.observationID() .set(LOFAR::formatString("%u", parset.observationID()));

	file.observationStartUTC().set(timeStr(parset.startTime())); // TODO: parset gives this as a double?!?! also below
	file.observationStartMJD().set(toMJD(parset.startTime())); // TODO: needed? also below
	//file.observationStartTAI().set(toTAI(parset.startTime()));

	// The stop time can be a bit further than the one actually specified, because we process in blocks.
	const size_t nBlocks = ceil((parset.stopTime() - parset.startTime()) / parset.CNintegrationTime());
	const double stopTime = parset.startTime() + nBlocks * parset.CNintegrationTime();
	file.observationEndUTC().set(timeStr(stopTime));
	file.observationEndMJD().set(toMJD(stopTime));
	//file.observationEndTAI().set(toTAI(stopTime));

	file.observationNofStations().set(parset.nrStations()); // TODO: SS beamformer?

	// For the observation attribs, dump all stations participating in the observation (i.e. allStationNames(), not mergedStatioNames()).
	// This may not correspond to which station HDF5 groups will be written, but that is true anyway, regardless of any merging (e.g. w/ piggy-backed TBB).
	file.observationStationsList().set(parset.allStationNames()); // TODO: SS beamformer?

	// TODO: DAL: this is for the original obs; DAL TBB users need to know which stations and dipoles are actually there. Use some way to enumerate to get it from HDF5. And some way to iterate over all or over a user-specified selection (see DAL1).

	const vector<double> subbandCenterFrequencies(parset.subbandToFrequencyMapping());
	double min_centerfrequency = *min_element(subbandCenterFrequencies.begin(), subbandCenterFrequencies.end());
	double max_centerfrequency = *max_element(subbandCenterFrequencies.begin(), subbandCenterFrequencies.end());
	double sum_centerfrequencies = accumulate(subbandCenterFrequencies.begin(), subbandCenterFrequencies.end(), 0.0);
	double subbandBandwidth = parset.sampleRate();
	double channelBandwidth = parset.channelWidth();

	file.observationFrequencyMin()   .set((min_centerfrequency - subbandBandwidth / 2) / 1e6);
	file.observationFrequencyCenter().set(sum_centerfrequencies / subbandCenterFrequencies.size());
	file.observationFrequencyMax()   .set((max_centerfrequency + subbandBandwidth / 2) / 1e6);
	file.observationFrequencyUnit()  .set("MHz");

	file.observationNofBitsPerSample().set(parset.nrBitsPerSample());

	file.clockFrequency()    .set(parset.clockSpeed() / 1e6);
	file.clockFrequencyUnit().set("MHz");

	file.antennaSet().set(parset.antennaSet()); // TODO: does this provide the strings from the ICD const tables?!?

	file.filterSelection().set(parset.getString("Observation.bandFilter"));

	//file.target().set(); // TODO: not in bf h5 writer; as array of strings?
	// Code from bf MS Writer:
	//vector<string> targets(parset.getStringVector("Observation.Beam[" + toString(subarray) + "].target"));

	/*
	 * Set release string, e.g. "LOFAR-Release-1.0".
	 * Only works if writer is rebuilt and reinstalled on every release, so force cmake deps. (Means on build failure, everyone will know soon!)
	 */
/*
#if defined HAVE_PKVERSION
	const string releaseStr(TBB_WriterVersion::getVersion());
#else // TODO: test both cases
	ostringstream vss;
	string type("brief");
	LOFAR::Version::show<TBB_WriterVersion>(vss, "TBB_Writer",  type);
	const string releaseStr(vss.str());
#endif
	file.systemVersion().set(versionStr);
*/
	//file.pipelineName().set(); // TODO: remove from DAL; for offline/LTA only
	//file.pipelineVersion().set(); // idem

	//file.ICDNumber().set("1"); //TODO: this is wrong if we provide a spec doc, and redundant if we already have 'tbb'; LOFAR-USG-ICD-001: TBB Time-Series Data"); // make it 1 or 001, or drop this, it's in file type (data product type)
	//file.ICDVersion().set("2.02.15"); // patch number is useless; and this is wrong if we provide a spec doc
	//file.notes().set(""); // TODO: needed?
	// TODO: No TBB_SysLog group anymore, add it back to CommonLofarAttributes instead of Notes?
	/*if (parset.fakeInputData()) { // ignore checkFakeInputData(), always annotate the data product if data is fake
		syslog.append("input data is fake!"); // -> "TBB Writer: input data is fake!"
	}*/
}

/*
 * The generated format is: <Prefix><Observation ID>_<Optional Descriptors>_<Filetype>.<Extension>
 * From LOFAR-USG-ICD005 spec named "LOFAR Data Format ICD File Naming Conventions", by A. Alexov et al.
 * Example for TBB: "L10000_CS001_D20120101T03:16:41.123Z_tbb.h5" or "L10000_CS001_D20120101T03:16:41.123Z_R%03u_R%03u_tbb.raw"
 */
static string genOutputFilename(const string& observationId,
		const string& stationName, const string& dateTime, const vector<string>& readOuts, // <-- all optional
		const string& fileType, const string& filenameExtension) {
	ostringstream oss;

	oss << 'L' << observationId;
	if (!stationName.empty()) {
		oss << "_" << stationName;
	}
	if (!dateTime.empty()) {
		oss << "_" << dateTime;
	}
	for (size_t i = 0; i < readOuts.size(); i++) {
		oss << "_R" << readOuts[i];
	}
	oss << "_" << fileType << "." << filenameExtension;

	return oss.str();
}

/*
 * Return station names that will send data to this host.
 * 
 * This function will be redundant once the mapping info is available through the parset.
 * Multiple stations may be sending to the same locus node (i.e. TBB writer).
 * This mapping is indicated in MAC/Deployment/data/StaticMetaData/TBBConnections.dat
 */
static vector<string> getTBB_StationNames(string& tbbMappingFilename) {
	vector<string> stationNames;

	LOFAR::TBB_StaticMapping tbbMapping(tbbMappingFilename);
	if (tbbMapping.empty()) {
		throw LOFAR::IOException("Failed to derive any node-to-station mappings from the static TBB mapping file");
	}

	string myHname(LOFAR::myHostname(true));
	stationNames = tbbMapping.getStationNames(myHname);
	if (stationNames.empty()) {
		// Likely, it only knows e.g. 'tbbsinknode123' instead of 'tbbsinknode123.example.com', so retry.
		myHname = LOFAR::myHostname(false);
		stationNames = tbbMapping.getStationNames(myHname);
		if (stationNames.empty()) {
			throw LOFAR::IOException("Failed to retrieve station names that will send TBB data to this node");
		}
	}

	return stationNames;
}

static vector<string> getTBB_InputStreamNames(struct progArgs& args) {
	/*
	 * Proto: TBB always arrives over UDP (but command-line override).
	 * 
	 * Ports: Each board sends data to port TBB_DEFAULT_BASE_PORT + itsBoardNr, so that's where put a r/w thread pair each to listen.
	 * The number of TBB boards can be retrieved using LCS/ApplCommon/src/StationConfig.cc: nrTBBs = StationInfo.getInt ("RS.N_TBBOARDS");
	 * but we know that stations have 6 (NL stations) or 12 (EU stations) TBB boards, so use defines for now.
	 */
	vector<string> allInputStreamNames;

	for (uint16_t port = TBB_DEFAULT_BASE_PORT; port <= TBB_DEFAULT_LAST_PORT; port++) {
		string streamName(LOFAR::formatString("udp:0.0.0.0:%hu", port));
		allInputStreamNames.push_back(streamName);
	}

	return allInputStreamNames;
}

static void doThreadedWrites(map<unsigned, LOFAR::RTCP::SmartPtr<LOFAR::RTCP::TBB_StationOut> >& h5Outputs,
							vector<string>& inputStreamNames, LOFAR::RTCP::Parset& parset) {
	// Create a TBB_Writer for each (possible) input stream.
	string obsIdStr(LOFAR::formatString("%u", parset.observationID()));
	vector<LOFAR::RTCP::SmartPtr<LOFAR::RTCP::TBB_Writer> > writers;
	for (vector<string>::const_iterator it(inputStreamNames.begin()); it != inputStreamNames.end(); ++it) {
		string inputStreamName(*it);
		const string logPrefix(LOFAR::formatString("[TBB obs %s stream %s]", obsIdStr.c_str(), it->c_str()));
		writers.push_back(new LOFAR::RTCP::TBB_Writer(h5Outputs, inputStreamName, parset, logPrefix));
	}
	// Join with writer threads here when destructing writers objects.
}

// TODO: what was planned (OTDB/MoM) vs what actually happened: try to store what actually happened
// TODO: remove _VALUE except wcscoords REFERENCE_VALUE (e.g. in ICD003 Table 14, 15).
// TODO: cross-check formats with casacore (see Ger's e-mail)

// TODO: most cerr/cout through logger, some into h5out Syslog
static int parseArgs(int argc, char *argv[], struct progArgs* args) {
	int rv = 0;

	// Default values
	args->inFilename = "";	// default is to read from a socket
	args->outFilename = "";	// default is generated according to ICD005
	args->parsetFilename = "";	// default means most meta data fields cannot be set
//	args->proto = LOFAR::SocketStream::UDP;
	args->port = 0;

	// Specified arguments and per-argument checks
	int i;
	for (i = 0; i < argc; i++) {
		if (strncmp(argv[i], "--infile=", strlen("--infile=")) == 0) {
			args->inFilename = argv[i + strlen("--infile=")];
		} else if (strncmp(argv[i], "--outfile=", strlen("--outfile=")) == 0) {
			args->outFilename = argv[i + strlen("--outfile=")];
			// force '.h5' file name extension  TODO: here?!?
			const string h5ext(".h5");
			if (args->outFilename.size() < h5ext.size() ||
					args->outFilename.substr(args->outFilename.size() - h5ext.size()) != h5ext) {
				args->outFilename.append(h5ext);
			}
		} else if (strncmp(argv[i], "--parsetfile=", strlen("--parsetfile=")) == 0) {
			args->parsetFilename = argv[i + strlen("--parsetfile=")];
		} else if (strncmp(argv[i], "--proto=", strlen("--proto=")) == 0) {
			if (strcmp(argv[i + strlen("--proto=")], "tcp") == 0) {
//				args->proto = LOFAR::SocketStream::TCP;
			} else if (strcmp(argv[i + strlen("--proto=")], "udp") == 0) {
//				args->proto = LOFAR::SocketStream::UDP;
			} else {
				cerr << "Invalid proto argument: " << argv[i] << endl;
				rv = 1;
			}
		} else if (strncmp(argv[i], "--port=", strlen("--port=")) == 0) {
			try {
				args->port = boost::lexical_cast<uint16_t>(argv[i + strlen("--port=")]);
			} catch (boost::bad_lexical_cast& /*exc*/) {
				cerr << "Invalid port argument: " << argv[i] << endl;
				rv = 1;
			}
		} else if (strcmp(argv[i], "--version") == 0 || strcmp(argv[i], "--help") == 0) {
			rv = 2; // Not an error, just print some info, then exit.
		} else if (strcmp(argv[i], "--") == 0) { // "end of options" option. Not so useful if we have only opts and no args.
			break;
		} else {
			cerr << "Invalid program argument: " << argv[i] << endl;
			rv = 1;
		}
	}

	// Checks across arguments
	if ( (args->inFilename != "" && (args->inFilename == args->outFilename || args->inFilename == args->parsetFilename))
			|| ((args->outFilename != "" && args->outFilename == args->parsetFilename)) ) {
		cerr << "Pair(s) of in-, out-, and/or parsetfile options cannot specify the same filename (outfile always ends in .h5)." << endl;
		rv = 1;
	}

	return rv;
}

// Register signal handlers to terminate early, so we can also break out of blocking system calls. TODO: deal with EINTR
static void setSigIntHandler() {
	struct sigaction sa;
	int err;

	sa.sa_handler = sigint_handler;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	err  = sigaction(SIGINT,  &sa, NULL);
	err |= sigaction(SIGHUP,  &sa, NULL);
	err |= sigaction(SIGTERM, &sa, NULL);
	if (err != 0) {
		LOG_WARN_STR("Failed to register int/hup/term signal handler; graceful abort may be difficult.");
	}
}

static void printUsage(const char* progname) {
	cout << "Usage: " << progname << " [--infile=input_file.raw] [--outfile=output_file.h5] [--parsetfile=file.parset]"
		" [--proto=tcp|udp] [--port=1234]" << endl;
}

int main(int argc, char* argv[]) {
	struct progArgs args;
	int err;

	// Allocate stdout and stderr buffer beforehand and set stderr also to line buffered. We don't use stdin.
	const size_t stdBufferSize = 1024;
	char* stdoutBuffer = new char[stdBufferSize];
	char* stderrBuffer = new char[stdBufferSize];
	setvbuf(stdout, stdoutBuffer, _IOLBF, stdBufferSize);
	setvbuf(stderr, stderrBuffer, _IOLBF, stdBufferSize);

#if defined HAVE_LOG4CPLUS
	INIT_LOGGER(string(getenv("LOFARROOT") ? : ".") + "/etc/Storage_main.log_prop");
#elif defined HAVE_LOG4CXX
#error LOG4CXX support is broken (nonsensical?) -- please fix this code if you want to use it
	Context::initialize();
	setLevel("Global", 8);
#else
	INIT_LOGGER_WITH_SYSINFO(str(boost::format("Storage@%02d") % (argc > 1 ? atoi(argv[1]) : -1)));
#endif

	// TODO: rework prog args
	err = parseArgs(argc, argv, &args);
	if (err != 0) {
		if (err == 2) err = 0;
		printUsage(argv[0]);
		return err;
	}
	if (argc > 1) {
		printUsage(argv[0]);
		return 1;
	}

	setSigIntHandler();

	// We don't run alone, so increase the QoS we get from the OS to decrease the chance of data loss.
	setIOpriority();
	setRTpriority();
	lockInMemory();

	try {
		LOFAR::RTCP::Parset parset(args.parsetFilename);

		/*
		 * Retrieve the station name that will send data to this host (input thread will check this at least once).
		 * Getting this from static meta data is inflexible. Should come from the parset.
		 */
		vector<string> stationNames;
		try {
			string tbbMappingFilename(args.connMapFilename);
			if (tbbMappingFilename.empty()) {
				const string defaultTbbMappingFilename("TBBConnections.dat");
				char* lrpath = getenv("LOFARROOT");
				if (lrpath != NULL) {
					tbbMappingFilename = string(lrpath) + "/etc/StaticMetaData/";
				}
				tbbMappingFilename.append(defaultTbbMappingFilename);
			}

			stationNames = getTBB_StationNames(tbbMappingFilename);
		} catch (LOFAR::IOException& exc) {
			LOG_FATAL_STR(exc.what());
		}

		// Generate the output filename ourselve (if not from command-line), because for TBB it's not in the parset.
		string obsIdStr(LOFAR::formatString("%u", parset.observationID()));
		const string triggerDateTime(getFileModDate("")); // Don't have the trigger timestamp. Use NOW as getFileModDate() cannot stat("").
		vector<string> filenameReadOuts;
		string h5FilenameFmt(genOutputFilename(obsIdStr, "%s", triggerDateTime, filenameReadOuts, "tbb", "h5"));
		filenameReadOuts.assign(2, "%03u"); // We set stationName, but leave these rsp and rcu ids to be filled in by the output threads.
		string rawFilenameFmt(genOutputFilename(obsIdStr, "%s", triggerDateTime, filenameReadOuts, "tbb", "raw"));

		/*
		* The converters receive a stationId in the incoming datagrams, so create an HDF5 output per station
		* and map from stationId to the TBB_StationOut struct.
		*/
		map<unsigned, LOFAR::RTCP::SmartPtr<LOFAR::RTCP::TBB_StationOut> > h5Outputs;
		for (unsigned i = 0; i < stationNames.size(); i++) {
			string h5Filename(LOFAR::formatString(h5FilenameFmt.c_str(), stationNames[i].c_str()));
			string rawFilenameStationFmt(LOFAR::formatString(rawFilenameFmt.c_str(), stationNames[i].c_str()));
			LOFAR::RTCP::SmartPtr<LOFAR::RTCP::TBB_StationOut> stOut = new LOFAR::RTCP::TBB_StationOut(h5Filename, rawFilenameStationFmt);

			// Don't need to grab the mutex, because we are the main thead initializing before we create output threads.
			setCommonLofarAttributes(stOut->h5Out, parset, h5Filename);
			setTBB_RootAttributes(stOut->h5Out, parset, stationNames[i]);
			stOut->h5Out.flush();

			unsigned stationId = stationNameToId(stationNames[i]);
			h5Outputs.insert(make_pair(stationId, stOut));
		}

		vector<string> inputStreamNames(getTBB_InputStreamNames(args));
		if (inputStreamNames.empty()) {
			LOG_FATAL_STR("Failed to find any input stream name(s)"); // TODO all LOG_FATAL_STR into exc to catch below
		}

		LOG_INFO_STR(LOFAR::formatString("Expecting from %zu through %zu input stream name(s)", stationNames.size(), inputStreamNames.size()).c_str());

		doThreadedWrites(h5Outputs, inputStreamNames, parset);

		err = 0;
	} catch (LOFAR::Exception& lexc) {
		LOG_FATAL_STR(lexc.text());
		err = 1;
	} catch (exception& ex) {
		LOG_FATAL_STR("[obs unknown] Caught std::exception: " << ex.what());
		err = 1;
	} catch (...) {
		LOG_FATAL_STR("[obs unknown] Caught non-std::exception");
		err = 1;
	}

	fclose(stderr);
	fclose(stdout);
	delete[] stderrBuffer;
	delete[] stdoutBuffer;

	return err;
}
