<html>


<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>BoundIO and BoundIOs</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p>
<h1>BoundIO and BoundIOs</h1>



















<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td><img src="utilities.gif" width="194" height="38"></td>
        <td align="right"><img src="type.gif" width="194"
        height="39"></td>
    </tr>
    <tr>
        <td valign="top"><b>Category</b>: utilities</td>
        <td align="right" valign="top"><b>Component type</b>:
        type</td>
    </tr>
</table>
<h3>Description</h3>

<p>A <font size="2" face="Courier New">BoundIO </font>is an
object used to hold an association between a field in a query and
a field in a user defined data object. The <font size="2"
face="Courier New">BoundIO</font> class is held in a private
member of the <a href="DBView.htm"><font size="2"
face="Courier New">DBView</font></a><font size="2"
face="Courier New"> </font>template called the <font size="2"
face="Courier New">BoundIOs </font>object which is an STL <a
href="http://www.sgi.com/tech/stl/Map.html"><font size="2"
face="Courier New">map</font></a><font size="2"
face="Courier New">&lt;string, BoundIO&gt;</font> that holds a
set of <font size="2" face="Courier New">BoundIO</font> objects that
are mapped by SQL field name. As an end user, the four places you
will encouter a <font size="2" face="Courier New">BoundIO </font>are
when writing <a href="BCA.htm"><font size="2" face="Courier New">BCA</font></a>
, <a href="BPA.htm"><font size="2" face="Courier New">BPA</font></a>,
<a href="InsVal.htm"><font size="2" face="Courier New">InsVal</font></a>
or <a href="SelVal.htm"><font size="2" face="Courier New">SelVal</font></a>
functions.</p>

<h3>Definition</h3>

<p>Defined in the <font size="2" face="Courier New">BoundIO.h </font><font
size="3">header file. </font></p>

<h3>Refinement of</h3>

<p>None.</p>

<h3>Associated types</h3>

<p><font face="Courier New, Courier, mono" size="2">NullField </font>- a tag struct 
  which indicates we want to set a field to null.</p>

<h3>Example 1:</h3>
<pre><code><span class="codeComment">// Functor to bind SQL columns to a data object</span>
class Example
{
  public:                                       <span class="codeComment">// tablename.columnname:</span>
	int exampleInt;                         <span class="codeComment">// DB_EXAMPLE.INT_VALUE</span>
	string exampleStr;                      <span class="codeComment">// DB_EXAMPLE.STRING_VALUE</span>
	double exampleDouble;                   <span class="codeComment">// DB_EXAMPLE.DOUBLE_VALUE</span>
	long exampleLong;                       <span class="codeComment">// DB_EXAMPLE.EXAMPLE_LONG</span>
	TIMESTAMP_STRUCT exampleDate;           <span class="codeComment">// DB_EXAMPLE.EXAMPLE_DATE</span>
};</pre>

<pre>class BCAExampleObj
{
public:
	void operator()(BoundIOs &amp;boundIOs, Example &amp;rowbuf)
    	{
	   boundIOs[&quot;INT_VALUE&quot;] 	&gt;&gt; rowbuf.exampleInt;
	   boundIOs[&quot;STRING_VALUE&quot;]	&gt;&gt; rowbuf.exampleStr;
	   boundIOs[&quot;DOUBLE_VALUE&quot;]	&gt;&gt; rowbuf.exampleDouble;
	   boundIOs[&quot;EXAMPLE_LONG&quot;]	&gt;&gt; rowbuf.exampleLong;
	   boundIOs[&quot;EXAMPLE_DATE&quot;]	&gt;&gt; rowbuf.exampleDate;
	}
};
</code></pre>
<p>&nbsp;</p>

<h3>Example 2:</h3>
<pre><code><span class="codeComment">//BPA Functor to bind SQL parameters to a data object</span>

<span class="codeComment">// &quot;Example&quot; class to hold rows from our database table</span>
class Example
{
  public:                                <span class="codeComment">// tablename.columnname:</span>
	int exampleInt;                 <span class="codeComment">// DB_EXAMPLE.INT_VALUE</span>
	string exampleStr;              <span class="codeComment">// DB_EXAMPLE.STRING_VALUE</span>
	double exampleDouble;           <span class="codeComment">// DB_EXAMPLE.DOUBLE_VALUE</span>
	long exampleLong;               <span class="codeComment">// DB_EXAMPLE.EXAMPLE_LONG</span>
	TIMESTAMP_STRUCT exampleDate;   <span class="codeComment">// DB_EXAMPLE.EXAMPLE_DATE</span>

	Example(int exInt, const string &amp;exStr, double exDouble, long exLong,
		const TIMESTAMP_STRUCT &amp;exDate) :
	   exampleInt(exInt), exampleStr(exStr), exampleDouble(exDouble), exampleLong(exLong),
	   exampleDate(exDate)
	{ }

};

<span class="codeComment">// Create an association between table columns and fields in our object</span>
class BCAExampleObj
{
public:
	void operator()(BoundIOs &amp;cols, Example &amp;rowbuf)
    	{
	   cols[&quot;INT_VALUE&quot;] &gt;&gt; rowbuf.exampleInt;
	   cols[&quot;STRING_VALUE&quot;] &gt;&gt; rowbuf.exampleStr;
	   cols[&quot;DOUBLE_VALUE&quot;] &gt;&gt; rowbuf.exampleDouble;
	   cols[&quot;EXAMPLE_LONG&quot;] &gt;&gt; rowbuf.exampleLong;
	   cols[&quot;EXAMPLE_DATE&quot;] &gt;&gt; rowbuf.exampleDate;
	}
}

class ExampleParamObj
{
    public:
       	int lowIntValue;
	int highIntValue;
	string strValue;
	TIMESTAMP_STRUCT dateValue;
};

class BPAParamObj
{
public:
	void operator()(BoundIOs &amp;boundIOs, ExampleParamObj &amp;paramObj)
	{
	  boundIOs[0] &lt;&lt; paramObj.lowIntValue;
	  boundIOs[1] &lt;&lt; paramObj.highIntValue;
	  boundIOs[2] &lt;&lt; paramObj.strValue;
	  boundIOs[3] &lt;&lt; paramObj.dateValue;
	}

};

<span class="codeComment">// read some Example objects from the database and return a vector of</span>
<span class="codeComment">// the results, use BPA to set join parameters</span>
vector&lt;Example&gt; ReadData()
{
	vector&lt;Example&gt; results;

	<span class="codeComment">// construct view</span>
	
	DBView&lt;Example, ExampleParamObj&gt;
		view(&quot;DB_EXAMPLE&quot;, BCAExampleObj(),
		&quot;WHERE INT_VALUE BETWEEN (?) AND (?) AND &quot;
		&quot;STRING_VALUE = (?) OR EXAMPLE_DATE &lt; (?) ORDER BY EXAMPLE_LONG&quot;,
		BPAParamObj());

	<span class="codeComment">// loop through query results and add them to our vector</span>
	<span class="codeComment">// in this loop, read_it.GetLastCount() records read from DB</span>

	DBView&lt;Example, ExampleParamObj&gt;::select_iterator read_it = view.begin();

	<span class="codeComment">// set parameter values for the WHERE clause in our SQL query</span>
	read_it.Params().lowIntValue = 2;
	read_it.Params().highIntValue = 8;
	read_it.Params().strValue = &quot;Example&quot;;
	
	TIMESTAMP_STRUCT paramDate = {2000, 1, 1, 0, 0, 0, 0};
	read_it.Params().dateValue = paramDate;

	for ( ; read_it != view.end();  read_it++)
	{
		cout &lt;&lt; &quot;Reading element #&quot; &lt;&lt; read_it.GetLastCount() &lt;&lt; endl;
		results.push_back(*read_it);

		cout &lt;&lt; &quot;read_it-&gt;exampleInt = &quot; &lt;&lt; read_it-&gt;exampleInt &lt;&lt; endl;
		cout &lt;&lt; &quot;read_it-&gt;exampleStr = &quot; &lt;&lt; read_it-&gt;exampleStr &lt;&lt; endl;
		
	}
	
	return results;
}
</code></pre>
<p>&nbsp;</p>

<h3>Example 3:</h3>

<pre><code><span class="codeComment">//Default SelVal function to make sure fields in a row selected from the database are valid

// Default select validation behavior ... data is valid if and only if
// there are no columns which are null.
// If there are other checks you wish to make, put them in
// your own SelVal functor.
// You can also specialize this template if you wish to have different default behavior
// for your data class.</span>
template&lt;class DataObj&gt; class DefaultSelValidate {
public:
bool operator()(BoundIOs &amp;boundIOs, DataObj &amp;rowbuf)
{
	for (BoundIOs::iterator b_it = boundIOs.begin();
				b_it != boundIOs.end(); b_it++)
	{
		BoundIO &amp;boundIO = (*b_it).second;
		if (boundIO.IsColumn() &amp;&amp; boundIO.IsNull())
			return false;  <span class="codeComment">// found null column ... data is invalid</span>
	}

	return true;	<span class="codeComment">// no nulls found ... data is OK</span>
}
};

</code></pre>

<h3>Public base classes: BoundIO</h3>

<p>None.</p>

<h3>Public base classes: BoundIOs</h3>

<p><font size="2" face="Courier New">map&lt;string, BoundIO&gt;</font></p>

<h3>Notation:</h3>

<table border="0">
    <tr>
        <td valign="top"><tt>X</tt> </td>
        <td valign="top">A type that is a model of <font size="2"
        face="Courier New">BoundIO</font></td>
    </tr>
    <tr>
        <td valign="top"><tt>a</tt> </td>
        <td valign="top">Object of type <tt>X</tt> </td>
    </tr>
</table>

<h3>Expression semantics: BoundIO</h3>

<table border="1">
  <tr> 
    <th>Name </th>
    <th>Expression </th>
    <th>Precondition </th>
    <th>Semantics </th>
    <th>Postcondition </th>
  </tr>
  <tr> 
    <td valign="top">Default constructor </td>
    <td valign="top"> 
      <pre>X a()</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Construct an empty <font size="2"
        face="Courier New">BoundIO</font></td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Copy constructor </td>
    <td valign="top"> 
      <pre>X a(constX &amp;b)</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Copy construct a <font size="2"
        face="Courier New">BoundIO</font>.</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Assignment operator</td>
    <td valign="top"> 
      <pre>X&amp; operator=(const X&amp;b)</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Assignment copy</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Binding operator for INPUT/OUTPUT</td>
    <td valign="top"><font size="2" face="Courier New">template&lt;class T&gt; 
      BoundIO operator==(T &amp;memberToBind)</font> </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">INPUT/OUTPUT parameter type. Create an association between SQL column names / parameter 
      numbers and object field names. This is done by inserting elements into 
      the <font size="2"
        face="Courier New">BoundIOs</font> map. The syntax for inserting elements 
      into the BoundIOs map is to call <font
        size="2" face="Courier New">BoundIOs[&quot;SQL FIELD NAME&quot; / SQL 
      Parameter Number] == RowObject.FieldName</font>. This invokes the<font size="2" face="Courier New"> 
      ==</font> operator for the<font size="2" face="Courier New"> BoundIO</font> 
      class. We use the<font size="2"
        face="Courier New"> == </font>syntax here as a mnemonic to remind end 
      users that this is a two way association. Once the association is created, 
      values can either be read from the database to the field, or written from 
      the field to the database. (For a list of supported C++ types see <a href="#foot1"><strong>[1]</strong></a>). Internally, this syntax does two things. First, 
      the <font size="2" face="Courier New">operator==() </font>analyzes the <font size="2" face="Courier New">RowObject.FieldName</font> 
      parameter to determine what type of field we are binding to and the memory 
      address of the given field name (<strong>there are some restrictions! see 
      </strong><a href="#foot2"><strong>[2]</strong></a>). Based on this information, 
      <font size="2"
        face="Courier New">operator==()</font>, determines the <font
        size="2" face="Courier New">SQL_TYPE</font>, the <font
        size="2" face="Courier New">SQL_C_TYPE</font>, the data size, and the 
      address to pass to <font size="2"
        face="Courier New">SQLBindCol()</font> or <font size="2"
        face="Courier New">SQLBindParam()</font>. All of this information gets 
      stored in what is known as a <font
        size="2" face="Courier New">BoundIO</font> object. Finally, the resulting 
      <font size="2" face="Courier New">BoundIO</font> object is inserted into 
      the<font size="2"
        face="Courier New"> BoundIOs</font> map using the <font
        size="2" face="Courier New">BoundIOs::operator[]() </font>described below.</td>
    <td valign="top">&nbsp;</td>
  </tr>
<tr> 
    <td valign="top">Binding operator to bind an input parameter</td>
    <td valign="top"><font size="2" face="Courier New">template&lt;class T&gt; 
      BoundIO operator &lt;&lt; (T &amp;memberToBind)</font> </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">INPUT parameter type. The class member supplies data strictly 
      as an input parameter to a SQL query. (See <a href="BPA.htm">BPA</a> for 
      details.).</td>
</tr>
<tr> 
    <td valign="top">Binding operator to bind an output parameter</td>
    <td valign="top"><font size="2" face="Courier New">template&lt;class T&gt; 
      BoundIO operator &gt;&gt; (T &amp;memberToBind)</font> </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">OUTPUT parameter type. The class member supplies data strictly 
      as an output parameter to a SQL query. (See <a href="BPA.htm">BPA</a> for 
      details.).</td>
</tr>
  <tr> 
    <td valign="top">Column Indicator</td>
    <td valign="top"> 
      <pre>bool IsColumn()</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Returns <font size="2"
        face="Courier New">true</font> if this <font size="2"
        face="Courier New">BoundIO </font>represents a SQL field.</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Parameter Indicator</td>
    <td valign="top"> 
      <pre>bool IsParam()</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Returns <font size="2"
        face="Courier New">true </font>if this <font size="2"
        face="Courier New">BoundIO</font> represents a SQL parameter.</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">NULL data Indicator</td>
    <td valign="top"> 
      <pre>bool IsNull()</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Returns <font size="2"
        face="Courier New">true </font>if value held in this field by the current 
      <font size="2" face="Courier New">rowbuf</font> object holds <font size="2" face="Courier New">NULL</font> 
      data. Typically this is used by the <a
        href="SelVal.htm"><font size="2" face="Courier New">SelVal</font></a> 
      function.</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Set to null</td>
    <td valign="top"><font face="Courier New, Courier, mono" size="2">void SetNull()</font></td>
    <td valign="top">&nbsp;</td>
    <td valign="top">Sets the field to represent a null value.</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr>
    <td valign="top">Make non-null</td>
    <td valign="top"><font face="Courier New, Courier, mono" size="2">void ClearNull()</font></td>
    <td valign="top">&nbsp;</td>
    <td valign="top">Sets the field to represent a non-null value.</td>
    <td valign="top">&nbsp;</td>
  </tr>
<tr>
    <td valign="top">Set the SQL type</td>
    <td valign="top"><font face="Courier New, Courier, mono" size="2">void SetSQLType(SDWORD newSqlType)</font></td>
    <td valign="top">&nbsp;</td>
    <td valign="top">Override the SQL type used by SQLBindParam when binding this column.  By default the SQL type that is used
when binding this column as a parameter is as per the ETIMap::build() settings in bind_basics.cpp.  This method can be used to override the
default SQL binding for the given data type. The available list of SQL types are as per the list of SQL data types
for ODBC.  This value will be used as the ParameterType argument when a call is made to SQLBindParam if this column is used as a parameter.</td>
    <td valign="top">&nbsp;</td>
  </tr>
<tr>
    <td valign="top">Set the SQL C type</td>
    <td valign="top"><font face="Courier New, Courier, mono" size="2">void SetCType(SDWORD newCType)</font></td>
    <td valign="top">&nbsp;</td>
    <td valign="top">Override the SQL C type used by ODBC when binding this column.  By default the SQL C type that is used
when binding this column is as per the ETIMap::build() settings in bind_basics.cpp.  This method can be used to override the
default SQL C binding for the given data type. The available list of SQL C types are as per the list of SQL C data types
for ODBC.  This value will be used as the ValueType argument when a call is made to either SQLBindParam or SQLBindCol.  As an example, 
the default SQL C type for a char data field
	 is SQL_C_CHAR, but you might want to use SQL_C_TINYINT to hold an integer in a char field instead.  Be careful!  We do not check the value you 
set here!  If you specify a C data type that contains more bytes then the size of the field ODBC will overflow that field in memory.  Similarly, if you specify
a C datatype that is too small for the field your field may be only partially initialized.</td>
    <td valign="top">&nbsp;</td>
  </tr>
</table>

<h3>Expression semantics: BoundIOs</h3>

<p>As per STL <a
href="http://www.sgi.com/tech/stl/Map.html"><font size="2"
face="Courier New">map</font></a><font size="2"
face="Courier New"> </font>but with the following modifications:</p>

<table border="1">
    <tr>
        <th>Name </th>
        <th>Expression </th>
        <th>Precondition </th>
        <th>Semantics </th>
        <th>Postcondition </th>
    </tr>
    <tr>
        <td valign="top">Parameter operator</td>
        <td valign="top"><pre>BoundIO &amp;operator[](unsigned int paramNum)</pre>
        </td>
        <td valign="top">&nbsp; </td>
        <td valign="top">This is used to insert/find a <font
        size="2" face="Courier New">BoundIO</font> in the <font
        size="2" face="Courier New">BoundIO</font>s map using a
        stringified version of the number as the key. If this
        operator does not find an existing <font size="2"
        face="Courier New">BoundIO</font> with the given key, it
        creates a new <font size="2" face="Courier New">BoundIO</font>
        object that is marked as a SQL <strong>parameter</strong>
        with the name given by the key string. This new <font
        size="2" face="Courier New">BoundIO</font> object is then
        inserted into the<font size="2" face="Courier New">
        BoundIOs</font> list. SQL parameters are represented in
        the SQL string passed to a <font size="2"
        face="Courier New">DBView</font> by a <font size="2"
        face="Courier New">'(?)'</font>. </td>
        <td valign="top">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top">Column operator</td>
        <td valign="top"><pre>BoundIO &amp;operator[](const string &amp;colName)</pre>
        </td>
        <td valign="top">&nbsp; </td>
        <td valign="top">This is used to insert/find a <font
        size="2" face="Courier New">BoundIO</font> in the <font
        size="2" face="Courier New">BoundIOs </font>map using a
        the given string as the key. If this operator does not
        find an existing<font size="2" face="Courier New">
        BoundIO </font>with the given key, it creates a new <font
        size="2" face="Courier New">BoundIO</font> object that is
        marked as a SQL <strong>field</strong> with the name
        given by the key string. This new <font size="2"
        face="Courier New">BoundIO</font> object is then inserted
        into the <font size="2" face="Courier New">BoundIOs</font>
        list.</td>
        <td valign="top">&nbsp;</td>
    </tr>
</table>

<h3>Notes</h3>

<p><a name="foot1">[1] </a>Supported C++ types for binding to fields in a database: 
<h4>Supported C++ data types and mappings (see ETI_Map::build() in
bind_basics.cpp for details)</h4>

<table border="1">
  <tr> 
    <td><strong>C++ type</strong></td>
    <td><strong>ODBC C Data Type</strong></td>
    <td><strong>ODBC SQL Data Type</strong></td>
  </tr>
  <tr> 
    <td>short</td>
    <td>SQL_C_SSHORT</td>
    <td>SQL_INTEGER</td>
  </tr>
  <tr> 
    <td>unsigned short</td>
    <td>SQL_C_USHORT</td>
    <td>SQL_INTEGER</td>
  </tr>
  <tr> 
    <td>int</td>
    <td>SQL_C_SLONG</td>
    <td>SQL_INTEGER</td>
  </tr>
  <tr> 
    <td>unsigned int</td>
    <td>SQL_C_ULONG</td>
    <td>SQL_INTEGER</td>
  </tr>
  <tr> 
    <td>long</td>
    <td>SQL_C_SLONG</td>
    <td>SQL_INTEGER</td>
  </tr>
  <tr> 
    <td>unsigned long</td>
    <td>SQL_C_ULONG</td>
    <td>SQL_INTEGER</td>
  </tr>
  <tr> 
    <td>ODBCINT64 (this is defined in sqltypes.h, under windows this tends to be defined as "_int64", under unix it tends to be defined as "long long")</td>
    <td>SQL_C_BIGINT</td>
    <td>SQL_BIGINT</td>
  </tr>
  <tr> 
    <td>double</td>
    <td>SQL_C_DOUBLE</td>
    <td>SQL_DOUBLE</td>
  </tr>
  <tr> 
    <td>float</td>
    <td>SQL_C_FLOAT</td>
    <td>SQL_FLOAT</td>
  </tr>
  <tr> 
    <td>bool</td>
    <td>SQL_C_BIT</td>
    <td>SQL_INTEGER</td>
  </tr>
  <tr> 
    <td>ODBC TIMESTAMP_STRUCT</td>
    <td>SQL_C_TIMESTAMP</td>
    <td>SQL_TIMESTAMP</td>
  </tr>
  <tr> 
    <td><a href="jtime_c.htm">jtime_c</a></td>
    <td>SQL_C_TIMESTAMP</td>
    <td>SQL_TIMESTAMP</td>
  </tr>
  <tr> 
    <td>TCHAR[xxx] (must be bound using DTL_CHAR_FIELD(cstr) in BCA or BPA)</td>
    <td>SQL_C_CHAR or SQL_C_WCHAR if UNICODE</td>
    <td>SQL_VARCHAR or SQL_WVARCHAR if UNICODE</td>
  </tr>
  <tr> 
    <td>tcstring&lt;xxx&gt;</td>
    <td>SQL_C_CHAR or SQL_C_WCHAR if UNICODE</td>
    <td>SQL_VARCHAR or SQL_WVARCHAR if UNICODE</td>
  </tr>
  <tr> 
    <td>string &lt;--&gt; basic_string&lt;char&gt;</td>
    <td>SQL_C_CHAR</td>
    <td>SQL_VARCHAR</td>
  </tr>
  <tr> 
    <td>wstring&lt;--&gt; basic_string&lt;wchar_t&gt;</td>
    <td>SQL_C_WCHAR</td>
    <td>SQL_WVARCHAR</td>
  </tr>
  <tr> 
    <td>binary data or blob &lt;--&gt; basic_string&lt;unsigned char&gt;</td>
    <td>SQL_C_BINARY</td>
    <td>SQL_VARBINARY</td>
  </tr>
</table>
<p></p>

<p><a name="foot2">[2] </a>We recommend that you only use
statically allocated fields in your BCA. The reason is that
some of the logic in DBView & IndexedDBView uses field offsets within the class to compare
fields for sorting and assignment.  If you really want to
use a dynamically allocated field, it can be done if the fields
are allocated as a contiguous block,
but it is a bit tricky. You can check out <font
size="2" face="Fixedsys">DynamicRowBCA</font> in <font size="2"
face="Courier New">DynaDBView.h</font> and the <font size="2"
face="Courier New">data_ptr()</font> function that we define for
the <font size="2" face="Courier New">variant_row</font> class in
<font size="2" face="Courier New">variant_row.h</font> for an
example of how we worked around this to accomodate dynamically
sized rows. The result is not for the faint of heart.
</p>



<h3>See also</h3>

<p><a href="BPA.htm"><font size="2" face="Courier New">BPA</font></a><font
size="2" face="Courier New">, </font><a href="BCA.htm"><font
size="2" face="Courier New">BCA</font></a><font size="2"
face="Courier New">, </font><a href="InsVal.htm"><font size="2"
face="Courier New">InsVal</font></a><font size="2"
face="Courier New">, </font><a href="SelVal.htm"><font size="2"
face="Courier New">SelVal</font></a><font size="2"
face="Courier New">, </font><a href="DBView.htm"><font
size="2" face="Courier New">DBView</font></a><font size="2"
face="Courier New">, </font><a
href="IndexedDBView.htm"><font size="2"
face="Courier New">IndexedDBView</font><font size="2"><!--start footer--></font></a></p>


<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright © 2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body>
</html>