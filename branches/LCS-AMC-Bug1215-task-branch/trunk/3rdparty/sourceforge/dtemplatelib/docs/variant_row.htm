<html>


<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>variant_row</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p>
<h1>variant_row</h1>



















<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td><img src="utilities.gif" width="194" height="38"></td>
        <td align="right"><img src="type.gif" width="194"
        height="39"></td>
    </tr>
    <tr>
        <td valign="top"><b>Category</b>: utilities</td>
        <td align="right" valign="top"><b>Component type</b>:
        type</td>
    </tr>
</table>
<h3>Description</h3>

<p>The <font size="2" face="Courier New">variant_row </font>class
provides a mechanism to hold an arbitrary number of fields with
values of arbitrary types. This class is used primarily by
dynamic queries where the number and the types of the fields
returned by a query are unknown.</p>

<h3>Definition</h3>

<p>Defined in the <font size="2" face="Courier New">variant_row.h
</font><font size="3">header file.</font></p>

<h3>Refinement of</h3>

<p>None.</p>

<h3>Associated types</h3>

<p><a href="variant_field.htm"><font size="2" face="Courier New">variant_field</font></a><font
size="2" face="Courier New">, TypeTranslation</font>.</p>

<h3>Example 1:</h3>
<p><pre><code><span class="codeComment">// Manipulating fields in a variant_row</span>

void variant_row_example(void) {

	TIMESTAMP_STRUCT test_date = {1999, 9, 29, 0, 0, 0, 0};

	vector&lt;TypeTranslation&gt; types;
	vector&lt;string&gt; names;
	int i;
	string s;
	TypeTranslation vt0=TypeTranslation(typeid(int).name(), C_INT, SQL_INTEGER, SQL_C_SLONG,
				TypeTranslation::TYPE_PRIMITIVE, sizeof(int)), 
			vt1=TypeTranslation(typeid(string).name(), C_STRING, SQL_VARCHAR, SQL_C_CHAR,
				TypeTranslation::TYPE_COMPLEX, sizeof(string));

	types.push_back(vt0);
	names.push_back(&quot;int&quot;);

	types.push_back(vt1);
	names.push_back(&quot;string&quot;);

	variant_row r(types, names);
	
	
	r[&quot;int&quot;] = (int)r[&quot;int&quot;] + 5;
	i = (int)r[&quot;int&quot;];
	
	s = (string) r[&quot;int&quot;];

	r[&quot;int&quot;] = test_date;
	s = (string) r[&quot;int&quot;];

	<span class="codeComment">// Print out the column names</span>
	vector&lt;string&gt; colNames = r.GetNames();
	for (vector&lt;string&gt;::iterator name_it = colNames.begin(); name_it != colNames.end(); name_it++)
	{
		cout &lt;&lt; (*name_it) &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	<span class="codeComment">// Print out all column values</span>
	for (i = 0; i &lt; r.size(); i++)
		cout &lt;&lt; r[i] &lt;&lt; &quot; &quot;;
	cout &lt;&lt; endl;


};
</code></pre></p>
<h3>Example 2:</h3>
<p> 
<h3><font face="Times New Roman, Times, serif">Example: Reading a set of records
 from an Oracle stored procedure.</font><br>
  </h3>
<pre><code>
<span class="codeComment">// Oracle stored procedure we wish to test</span>
<span class="codeComment">// for more information on this example, see the following <a href="OracleResultSets.htm">Oracle documentation</a></span>
#if 0
 Create or replace package ExampleInfo as

   Type ExampleRec is record

   (
   INT_VALUE     integer,

   STRING_VALUE   varchar2(50)

   );

   Type ExampleCursor is ref cursor return 

   ExampleRec;

   End ExampleInfo;

   

   Create or replace procedure ExampleInfoProc

   (LONG_CRITERIA IN integer, empcursor IN OUT 

   ExampleInfo.ExampleCursor)

   As

   Begin

   Open empcursor For

   select INT_VALUE, STRING_VALUE 

   from db_example

   where EXAMPLE_LONG = LONG_CRITERIA;

   End;
#endif

class ProcBCA {
public:
 void operator()(BoundIOs &amp;cols, variant_row &amp;row)
 {
  cols["INT_VALUE"] &gt;&gt; row._int();
  cols["STRING_VALUE"] &gt;&gt; row._string();
  
  cols.BindVariantRow(row);
 }
};

class ProcParams {
public:
	long long_criteria;
};

class ProcBPA {
public:
 void operator()(BoundIOs &amp;cols, ProcParams &amp;row)
 {
  cols[0] &lt;&lt; row.long_criteria;
 }
};

<span class="codeComment">// Read the contents of a table and print the resulting rows
// *** you must have Oracle ODBC driver version 8.1.5.3.0 for this to work ***
// The reason why is that the stored procedure shown above returns a "cursor"
// to pass back multiple rows which is only supported in Oracle ODBC driver
// version 8.1.5.3.0 or higher.  (Merant drivers for Oracle also support this syntax.)</span>
void StoredProcReadData() {

        <span class="codeComment">// Note: ExampleInfoProc takes an integer as an input parameter to determine
        // what records to return, and returns a cursor to a set of rows as an
        // output parameter. The output cursor is bound implicitly as a set of columns.</span>
	DBView&lt;variant_row, ProcParams&gt; view("{call ExampleInfoProc(?)}", 
		ProcBCA(), "", ProcBPA());

	variant_row s(view.GetDataObj());

	<span class="codeComment">// Print out the column names</span>
	vector&lt;string&gt; colNames = s.GetNames();
	for (vector&lt;string&gt;::iterator name_it = colNames.begin(); name_it != colNames.end(); ++name_it)
		cout &lt;&lt; (*name_it) &lt;&lt; " ";
	cout &lt;&lt; endl;

	<span class="codeComment">// Print out all rows and columns from our query</span>
	DBView&lt;variant_row, ProcParams&gt;::sql_iterator print_it = view.begin();
	print_it.Params().long_criteria = 22;

	for (; print_it != view.end(); ++print_it)
	{
		 variant_row r = *print_it;
		 for (size_t i = 0; i < r.size(); ++i)
		 	cout &lt;&lt; r[i] &lt;&lt; " ";
		 cout &lt;&lt; endl;
	}
}

</code></pre>
 </p>
<h3>Example 3:</h3>
<p><h3>Example: Using a DynamicDBView to insert records into the database. Illustrates
writing NULL values to the database.</h3> 
<pre><code><span class="codeComment">// Using a DynamicDBView to insert records into the database.

// this example also shows how to set NULL fields in a variant_row

// Insert two rows into a table with unknown fields</span>
void SimpleDynamicWrite() {
	TIMESTAMP_STRUCT paramDate = {2012, 12, 23, 0, 0, 0, 0}; 
	<span class="codeComment">// Mayan DOOMSDAY! End of the Mayan 5126 year long calendar cycle starting from May 1, 3094 B.C.
	// Date is 13.13.13.0.0.0.0  4 Ahaw, 3 K'ank'in</span>
	
	DynamicDBView&lt;&gt; view(&quot;DB_EXAMPLE&quot;, &quot;*&quot;);

	DynamicDBView&lt;&gt;::insert_iterator write_it = view;

	<span class="codeComment">// NOTE: We need to construct r from the view itself since we
	// don't know what fields the table will contain.
	// We therefore make a call to the DataObj() function to have the
	// table return us a template row with the correct number of fields
	// and field types.</span>
	variant_row r(view.GetDataObj());

	<span class="codeComment">// Prepare the number of the beast!
	// Set all fields to the value 6,
	// except for the last column which is a date and cannot
	// currently accept numeric values</span>
	for (size_t i = 0; i &lt; r.size()-1; i++)
	{
		 r[i] = 6;
	}
	r[i] = paramDate;  <span class="codeComment">// set the Doomsdate</span>

	<span class="codeComment">// insert the number</span>
	*write_it = r;
	write_it++;

	<span class="codeComment">// Prepare the number of angels who stand before
	// the throne of God!
	// Set all fields to the value 7,
	// except for the last column which is a date and cannot
	// currently accept numeric values</span>
	for (i = 0; i &lt; r.size()-1; i++)
	{
		 r[i] = 7;
	}
	r[i] = paramDate;

	<span class="codeComment">// insert the number</span>
	*write_it = r;
	write_it++;

	<span class="codeComment">// Insert Purgatory (the void) into the database.
	// Set all fields to NULL</span>
	for (i = 0; i &lt; r.size()-1; i++)
	{
		 r[i] = NullField();
	}
	r[i] = NullField();

	<span class="codeComment">// insert the number</span>
	*write_it = r;
	write_it++;

	// For more on this example - see the *REAL* <a href="http://www.dtl.org/">DTL</a> homepage!
}
</code></pre>
</p>
<h3>Public base classes</h3>

<p>None.</p>

<h3>Notation</h3>

<table border="0">
    <tr>
        <td valign="top"><tt>X</tt> </td>
        <td valign="top">A type that is a model of <font size="2"
        face="Courier New">variant_row</font> </td>
    </tr>
    <tr>
        <td valign="top"><tt>a</tt> </td>
        <td valign="top">Object of type <tt>X</tt> </td>
    </tr>
</table>

<h3>Expression semantics</h3>

<table border="1">
  <tr> 
    <th>Name </th>
    <th>Expression </th>
    <th>Precondition </th>
    <th>Semantics </th>
    <th>Postcondition </th>
  </tr>
  <tr> 
    <td valign="top">Default constructor </td>
    <td valign="top"> 
      <pre>X a()</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Creates an empty <font size="2"
        face="Courier New">variant_row</font><font size="3">. The type and number 
      of fields is not set so an empty </font><font
        size="2" face="Courier New">variant_row</font><font
        size="3"> ca</font>nnot be used until is has been copy or assignment constructed 
      from another row.</td>
    <td valign="top">The row is empty.</td>
  </tr>
  <tr> 
    <td valign="top">Alterante constructor </td>
    <td valign="top"> 
      <pre>X a(vector&lt;TypeTranslation&gt; 
  &amp;types, vector&lt;string&gt; &amp;names)</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Creates a <font size="2"
        face="Courier New">variant_row</font> to hold an array of types as specified 
      in <font size="2" face="Courier New">types</font> with field names given 
      by <font size="2"
        face="Courier New">names</font>. In practice, you should never need to 
      use this. Instead we recommend that you get any raw rowbuf object that you 
      need by calling the <font
        size="2" face="Courier New">DataObj()</font> method of <a
        href="DynamicDBView.htm"><font size="2"
        face="Courier New">DynamicDBView</font></a> or <a
        href="DynamicIndexedDBView.htm"><font
        size="2" face="Courier New">DynamicIndexedDBView</font></a> to get a variant_row 
      constructed for you that matches the columns in your query. See <a href="#1">[1]</a> 
      for details about <font size="2" face="Courier New">TypeTranslation</font>.</td>
    <td valign="top">The row is initialized to be able to hold the given types 
      and access these fields using the specified names.</td>
  </tr>
  <tr> 
    <td valign="top">Copy constructor </td>
    <td valign="top"> 
      <pre>X a(const X &amp;b)</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Creates a <font size="2"
        face="Courier New">variant_row</font> to hold an array of types as specified 
      in<font size="2" face="Courier New"> b</font>. The types, field names and 
      values stored in <font
        size="2" face="Courier New">b</font> are copied into <font
        size="2" face="Courier New">a</font>.</td>
    <td valign="top">The row is initialized to be able to hold the types and fields 
      given in <font size="2"
        face="Courier New">b</font>. The data held in b is copied to<font size="2" face="Courier New"> 
      a</font>.</td>
  </tr>
  <tr>
    <td valign="top">Assignment operator</td>
    <td valign="top"><font size="2" face="Courier New, Courier, mono">const X 
      &amp; operator=(const X &amp;b)</font></td>
    <td valign="top">&nbsp;</td>
    <td valign="top">Assigns to the <font size="2"
        face="Courier New">variant_row</font> to hold an array of types as specified 
      in<font size="2" face="Courier New"> b</font>. The types, field names and 
      values stored in <font
        size="2" face="Courier New">b</font> are copied into <font
        size="2" face="Courier New">a</font>.</td>
    <td valign="top">The row is initialized to be able to hold the types and fields 
      given in <font size="2"
        face="Courier New">b</font>. The data held in b is copied to<font size="2" face="Courier New"> 
      a</font>.</td>
  </tr>
  <tr> 
    <td valign="top">Get field types</td>
    <td valign="top"> 
      <pre>vector&lt;TypeTranslation&gt; GetTypes()</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Returns a vector listing the type of each field in <font size="2" face="Courier New">variant_row</font> 
      in the order that these fields occur. See <a href="#1">[1]</a> for details 
      about <font size="2" face="Courier New">TypeTranslation.</font></td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Get field names</td>
    <td valign="top"> 
      <pre>vector&lt;string&gt; GetFields()</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Returns a vector listing the name of each field in <font size="2" face="Courier New">variant_row 
      </font>in the order that these fields occur.</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Get number of fields</td>
    <td valign="top"> 
      <pre>size_t size()</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Returns the number of fields in the <font
        size="2" face="Courier New">variant_row</font>.</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Get field by number </td>
    <td valign="top"> 
      <pre>variant_field operator[](int i)

const variant_field operator[](int i) const</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Retrieves field number<font size="2"
        face="Courier New"> i</font> from the variant_row object. Fields are numbered 
      starting at 0. The field is returned as a <a href="variant_field.htm"><font size="2"
        face="Courier New">variant_field</font></a> object.</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Get field by name</td>
    <td valign="top"> 
      <pre>variant_field operator[](const string &amp;f)

const variant_field operator[](const string &amp;f) const</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top">Retrieves the field with the name given by the string f from 
      the <font size="2"
        face="Courier New">variant_row </font>object. Fields are numbered starting 
      at 0. The field is returned as a <a
        href="variant_field.htm"><font size="2"
        face="Courier New">variant_field</font></a> object.</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Variant field creators for the appropriate types</td>
    <td valign="top"> 
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _short()</font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _unsigned_short()</font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _int()</font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _unsigned_int()</font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _long()</font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _unsigned_long()</font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _double()</font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _float()</font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _string()</font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _wstring()</font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _tstring() <font face="Times New Roman, Times, serif">(see <a href="Unicode.htm">Unicode</a> 
        docs)</font></font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _tchar_star() <font face="Times New Roman, Times, serif">(binds to a fixed length string of
type TCHAR[BoundIO::MINSTRBUFLEN])</font></font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _jtime_c()</font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _timestamp()</font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _bool() </font></p>
      <p><font face="Courier New, Courier, mono" size="2">TypeTranslationField 
        _blob() </font></p>
    </td>
    <td valign="top">&nbsp;</td>
    <td valign="top"> 
      <p>Creates an &quot;empty&quot; <font face="Courier New, Courier, mono" size="2">variant_field 
        <font face="Times New Roman, Times, serif" size="3">for use in binding 
        columns or parameters. Using these functions, in a BCA or BPA, the user 
        can say something like:</font></font></p>
      <p><font face="Courier New, Courier, mono" size="2">boundIOs[paramNum] &gt;&gt; 
        var_row._typename()</font></p>
      <p>This provides the user a syntax to construct a <font face="Courier New, Courier, mono" size="2">variant_row</font> 
        on the fly in the BCA or BPA. When binding columns, the user must then 
        conclude the BCA by calling <font face="Courier New, Courier, mono" size="2">boundIOs.BindVariantRow(vr) 
        <font face="Times New Roman, Times, serif" size="3">to commit the structure 
        of the <font size="2" face="Courier New, Courier, mono">variant_row</font> 
        to the <font face="Courier New, Courier, mono" size="2">BoundIOs</font>.</font> 
        </font></p>
    </td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Set field to null</td>
    <td valign="top"> 
      <p><font face="Courier New, Courier, mono" size="2">void SetNull(int i)</font></p>
      <p><font face="Courier New, Courier, mono" size="2">void SetNull(const string 
        &amp;fieldName) </font></p>
    </td>
    <td valign="top">Sets the field with the given index to null.</td>
    <td valign="top">&nbsp;</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Make field non-null.</td>
    <td valign="top"> 
      <p><font face="Courier New, Courier, mono" size="2">void ClearNull(int i)</font></p>
      <p><font face="Courier New, Courier, mono" size="2">void ClearNull(const 
        string &amp;fieldName)</font></p>
    </td>
    <td valign="top">Makes the field with the given index non-null.</td>
    <td valign="top">&nbsp;</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Make all fields non-null</td>
    <td valign="top"><font face="Courier New, Courier, mono" size="2">void ClearNulls()</font></td>
    <td valign="top">Makes all fields non-null.</td>
    <td valign="top">&nbsp;</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Null field check</td>
    <td valign="top"> 
      <p><font face="Courier New, Courier, mono" size="2">void IsNull(int i)</font></p>
      <p><font face="Courier New, Courier, mono" size="2">void IsNull(const string 
        &amp;fieldName) </font></p>
    </td>
    <td valign="top">Returns whether the field with the given index is null.</td>
    <td valign="top">&nbsp;</td>
    <td valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="top">Comparison operators</td>
    <td valign="top"> 
      <p><font face="Courier New, Courier, mono" size="2">friend bool operator==(const 
        variant_row &amp;vr1, const variant_row &amp;vr2)</font></p>
      <p><font face="Courier New, Courier, mono" size="2">friend bool operator!=(const 
        variant_row &amp;vr1, const variant_row &amp;vr2)</font></p>
      <p><font face="Courier New, Courier, mono" size="2">friend bool operator&lt;(const 
        variant_row &amp;vr1, const variant_row &amp;vr2)</font></p>
      <p><font face="Courier New, Courier, mono" size="2">friend bool operator&gt;(const 
        variant_row &amp;vr1, const variant_row &amp;vr2)</font></p>
      <p><font face="Courier New, Courier, mono" size="2">friend bool operator&lt;=(const 
        variant_row &amp;vr1, const variant_row &amp;vr2)</font></p>
      <p><font face="Courier New, Courier, mono" size="2">friend bool operator&gt;=(const 
        variant_row &amp;vr1, const variant_row &amp;vr2)</font></p>
    </td>
    <td valign="top">These operators return whether the specified relationship 
      between the two <font face="Courier New, Courier, mono" size="2">variant_row's</font> 
      is satisifed. The fields of the row are compared in order from <font size="2" face="Courier New, Courier, mono">vr[0]</font> 
      (most significant) to <font size="2" face="Courier New, Courier, mono">vr[vr.size() 
      - 1]</font> (least significant). In teh case of nulls, a null value for 
      a field is considered to be less than a non-null one and two null values 
      are treated as equal..</td>
    <td valign="top">&nbsp;</td>
    <td valign="top">&nbsp;</td>
  </tr>
</table>

<h3>Notes</h3>

<p><a name="1">[1]</a> <font size="2" face="Courier New">TypeTranslation</font>
is an internal structure that is used by the library to translate
between C types and SQL types. Details of the mapping that we use
may be found in <font size="2" face="Courier New">bind_basics.h</font>
and <font size="2" face="Courier New">bind_basics.cpp</font>.
Typically, one would not read types directly off of this vector
but would instead use type information functions exposed by the <font
size="2" face="Courier New">variant_field</font> object.</p>

<h3>See also</h3>

<p><a href="variant_field.htm"><font size="2" face="Courier New">variant_field</font></a><font
size="2" face="Courier New">, </font><a
href="DynamicDBView.htm"><font size="2"
face="Courier New">DynamicDBView</font></a><font size="2"
face="Courier New">, </font><a
href="DynamicIndexedDBView.htm"><font size="2"
face="Courier New">DynamicIndexedDBView</font></a><font size="2"
face="Courier New"> </font><font size="2"><!--start footer--></font></p>


<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright © 2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body>
</html>
