diff -Naur ethereal-0.9.8/configure.in ethereal-0.9.8-epaplugin/configure.in
--- ethereal-0.9.8/configure.in	2002-12-04 04:26:12.000000000 +0000
+++ ethereal-0.9.8-epaplugin/configure.in	2008-11-12 09:57:42.129075104 +0000
@@ -766,6 +766,7 @@
   plugins/gryphon/Makefile
   plugins/mgcp/Makefile
   plugins/pcli/Makefile
+  plugins/epa2/Makefile
   tools/Makefile
   tools/lemon/Makefile
   ,)
diff -Naur ethereal-0.9.8/doc/Makefile.am ethereal-0.9.8-epaplugin/doc/Makefile.am
--- ethereal-0.9.8/doc/Makefile.am	2002-09-29 19:10:07.000000000 +0000
+++ ethereal-0.9.8-epaplugin/doc/Makefile.am	2008-11-12 09:57:42.130074952 +0000
@@ -77,4 +77,4 @@
 	../idl2eth.1
 
 EXTRA_DIST = \
-	Ethereal.desktop	\
+	Ethereal.desktop
diff -Naur ethereal-0.9.8/Makefile.am ethereal-0.9.8-epaplugin/Makefile.am
--- ethereal-0.9.8/Makefile.am	2002-12-08 03:38:19.000000000 +0000
+++ ethereal-0.9.8-epaplugin/Makefile.am	2008-11-12 09:57:42.131074800 +0000
@@ -290,7 +290,6 @@
 	packet-ppp.c   \
 	packet-pppoe.c \
 	packet-pptp.c  \
-	packet-prism.c \
 	packet-q2931.c \
 	packet-q931.c  \
 	packet-qllc.c  \
@@ -417,7 +416,8 @@
 	plugins/giop/packet-coseventcomm.c \
 	plugins/gryphon/packet-gryphon.c \
 	plugins/mgcp/packet-mgcp.c \
-	plugins/pcli/packet-pcli.c
+	plugins/pcli/packet-pcli.c \
+	plugins/epa2/packet-epa2.c
 
 plugin_static_ldadd = \
 	plugins/docsis/packet-bpkmattr-static.o \
@@ -447,7 +447,8 @@
 	plugins/giop/packet-coseventcomm-static.o \
 	plugins/gryphon/packet-gryphon-static.o \
 	plugins/mgcp/packet-mgcp-static.o \
-	plugins/pcli/packet-pcli-static.o
+	plugins/pcli/packet-pcli-static.o \
+	plugins/epa2/packet-epa2-static.o
 
 plugin_libs = \
 	plugins/docsis/docsis.la \
@@ -455,7 +456,8 @@
 	plugins/giop/coseventcomm.la \
 	plugins/gryphon/gryphon.la \
 	plugins/mgcp/mgcp.la \
-	plugins/pcli/pcli.la
+	plugins/pcli/pcli.la \
+	plugins/epa2/epa2.la
 
 plugin_ldadd = \
 	"-dlopen" self	\
@@ -464,7 +466,8 @@
 	"-dlopen" plugins/giop/coseventcomm.la \
 	"-dlopen" plugins/gryphon/gryphon.la \
 	"-dlopen" plugins/mgcp/mgcp.la \
-	"-dlopen" plugins/pcli/pcli.la
+	"-dlopen" plugins/pcli/pcli.la \
+	"-dlopen" plugins/epa2/epa2.la
 else
 plugin_src =
 
@@ -562,7 +565,6 @@
 	packet-pim.h   \
 	packet-portmap.h   \
 	packet-ppp.h   \
-	packet-prism.h \
 	packet-q931.h  \
 	packet-raw.h   \
 	packet-ripng.h \
diff -Naur ethereal-0.9.8/plugins/epa2/AUTHORS ethereal-0.9.8-epaplugin/plugins/epa2/AUTHORS
--- ethereal-0.9.8/plugins/epa2/AUTHORS	1970-01-01 00:00:00.000000000 +0000
+++ ethereal-0.9.8-epaplugin/plugins/epa2/AUTHORS	2008-11-12 09:57:42.131074800 +0000
@@ -0,0 +1,5 @@
+Author :
+Klaas Jan Wierenga <wierenga@astron.nl>
+Ruud Overeem <overeem@astron.nl>
+
+
diff -Naur ethereal-0.9.8/plugins/epa2/COPYING ethereal-0.9.8-epaplugin/plugins/epa2/COPYING
--- ethereal-0.9.8/plugins/epa2/COPYING	1970-01-01 00:00:00.000000000 +0000
+++ ethereal-0.9.8-epaplugin/plugins/epa2/COPYING	2008-11-12 09:57:42.132074648 +0000
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -Naur ethereal-0.9.8/plugins/epa2/Makefile.am ethereal-0.9.8-epaplugin/plugins/epa2/Makefile.am
--- ethereal-0.9.8/plugins/epa2/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ ethereal-0.9.8-epaplugin/plugins/epa2/Makefile.am	2008-11-12 09:57:42.132074648 +0000
@@ -0,0 +1,55 @@
+# Makefile.am
+# Automake file for Ethereal/EPA dissectors
+#
+# $Id$
+#
+# Copyright 2004, Astron
+# Klaas Jan Wierenga <wierenga@astron.nl>
+#
+# Ethereal - Network traffic analyzer
+# By Gerald Combs <gerald@ethereal.com>
+# Copyright 1998 Gerald Combs
+#
+# 
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#
+
+INCLUDES = -I$(top_srcdir)
+
+plugindir = @plugindir@
+
+plugin_LTLIBRARIES = epa2.la
+epa2_la_SOURCES = packet-epa2.c moduleinfo.h
+epa2_la_LDFLAGS = -module -avoid-version
+
+# Libs must be cleared, or else libtool won't create a shared module.
+# If your module needs to be linked against any particular libraries,
+# add them here.
+LIBS =
+
+
+# The following allows a non-plugin version of the module to be built to 
+# be linked with a static ethereal binary.
+#
+epa2_la_DEPENDENCIES = packet-epa2-static.o
+
+packet-epa2-static.o:   packet-epa2.c moduleinfo.h
+	$(LTCOMPILE) -c -o packet-epa2-static.o -D__ETHEREAL_STATIC__ $(srcdir)/packet-epa2.c 
+
+CLEANFILES = \
+        epa2
+
+EXTRA_DIST = \
+        Makefile.nmake
diff -Naur ethereal-0.9.8/plugins/epa2/Makefile.nmake ethereal-0.9.8-epaplugin/plugins/epa2/Makefile.nmake
--- ethereal-0.9.8/plugins/epa2/Makefile.nmake	1970-01-01 00:00:00.000000000 +0000
+++ ethereal-0.9.8-epaplugin/plugins/epa2/Makefile.nmake	2008-11-12 09:57:42.133074496 +0000
@@ -0,0 +1,20 @@
+#
+# $Id$
+#
+#include ..\..\config.nmake
+
+############### no need to modify below this line #########
+
+CFLAGS=/DHAVE_CONFIG_H /I../.. /I../../wiretap \
+	/I$(GLIB_DIR) /I$(GTK_DIR) /I$(GLIB_DIR)/gmodule \
+	/I$(GTK_DIR)\gdk /I$(GTK_DIR)\gdk\win32 \
+	/I$(PCAP_DIR)\include $(LOCAL_CFLAGS)
+
+OBJECTS=packet-epa2.obj 
+
+epa2.dll epa2.exp epa2.lib : packet-epa2.obj ..\plugin_api.obj
+	link -dll /out:epa2.dll packet-epa2.obj ..\plugin_api.obj \
+	$(GLIB_DIR)\glib-$(GLIB_VERSION).lib
+
+clean:
+	rm -f $(OBJECTS) epa2.dll epa2.exp epa2.lib
diff -Naur ethereal-0.9.8/plugins/epa2/moduleinfo.h ethereal-0.9.8-epaplugin/plugins/epa2/moduleinfo.h
--- ethereal-0.9.8/plugins/epa2/moduleinfo.h	1970-01-01 00:00:00.000000000 +0000
+++ ethereal-0.9.8-epaplugin/plugins/epa2/moduleinfo.h	2008-11-12 09:57:42.133074496 +0000
@@ -0,0 +1,17 @@
+/* Included *after* config.h, in order to re-define these macros */
+
+#ifdef PACKAGE
+#undef PACKAGE
+#endif
+
+/* Name of package */
+#define PACKAGE "epa2"
+
+
+#ifdef VERSION
+#undef VERSION
+#endif
+
+/* Version number of package */
+#define VERSION "0.0.2"
+
diff -Naur ethereal-0.9.8/plugins/epa2/packet-epa2.c ethereal-0.9.8-epaplugin/plugins/epa2/packet-epa2.c
--- ethereal-0.9.8/plugins/epa2/packet-epa2.c	1970-01-01 00:00:00.000000000 +0000
+++ ethereal-0.9.8-epaplugin/plugins/epa2/packet-epa2.c	2008-11-12 09:58:50.412694416 +0000
@@ -0,0 +1,1569 @@
+/* packet-epa2.c
+ * Routines for LOFAR Embedded Processing Application protocol dissection
+ * Copyright 2004, Klaas Jan Wierenga <wierenga@astron.nl>
+ *
+ * $Id$
+ *
+ * Ethereal - Network traffic analyzer
+ * By Gerald Combs <gerald@ethereal.com>
+ * Copyright 1998 Gerald Combs
+ *
+ * Copied from WHATEVER_FILE_YOU_USED (where "WHATEVER_FILE_YOU_USED"
+ * is a dissector file; if you just copied this from README.developer,
+ * don't bother with the "Copied from" - you don't even need to put
+ * in a "Copied from" if you copied an existing dissector, especially
+ * if the bulk of the code in the new dissector is your code)
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <glib.h>
+
+#ifdef NEED_SNPRINTF_H
+# include "snprintf.h"
+#endif
+
+#include <epan/packet.h>
+#include "packet-epa2.h"
+
+#include <netinet/in.h>
+
+#define MIN2(a,b)	(((a) < (b)) ? (a) : (b))
+#define DATA_SIZE	(*((gint16*)tvb_get_ptr(tvb, 10, sizeof(gint16))))
+#define FRAGMENT_SIZE_BYTES     1024
+#define SS_SELECT_SIZE_BYTES     512
+#define XST_FRAGMENT_SIZE_BYTES  960
+#define DSTART					 16
+#define	N_BLP					 4
+
+/*@{*/
+/**
+ * Message types.
+ */
+#define TYPE_UNSET 0x00
+#define READ       0x01
+#define WRITE      0x02
+#define READACK    0x03
+#define WRITEACK   0x04
+
+#define MAX_TYPE 0x04 /* counting from 0 */
+/*@}*/
+
+/*@{*/
+/**
+ * Address constants
+ *
+ * Destination ID
+ * RSP Board: bit1 of byte 2 set
+ * BLP:       bits 0..3 indicate which BLP is addressed.
+ */
+#define DST_BLP            0x00 /* BLP's are addressed starting from 0x00 */
+#define DST_RSP            0x01 /* Destination id of the RSP board */
+/*@}*/
+
+/*@{*/
+/**
+ * Process IDs
+ */
+#define RSR     0x01 /* Status overview */
+#define RSU		0x02 /* FPGA remote system update */
+#define DIAG	0x03 /* Diagnostics */
+#define SS      0x04 /* Subband select */
+#define BF      0x05 /* Beamformer */
+#define BST     0x06 /* Beamformer statistics */
+#define SST     0x07 /* Subband statistics */
+#define RCU     0x08 /* RCU control */
+#define CR      0x09 /* RSP clock and reset */
+#define XST		0x0A /* Cross correlation statistics */
+#define CDO     0x0B /* CEP Data Output */
+#define BS		0x0C /* Block synchroniaton */
+#define SDS		0x0D
+#define TDS		0x0E /* Time distribution board */
+#define TBB		0x0F /* Transient Buffer Board */
+#define CEP		0x10
+#define LCU		0x11
+#define	RAD		0x12
+
+#define MAX_PID RAD /* counting from 0 */
+/*@}*/
+
+/*@{*/
+/**
+ * Register IDs
+ */
+#define RSR_STATUS			0x00
+#define RSR_VERSION 		0x01
+#define RSR_TIMESTAMP		0x02
+
+#define	RSU_FLASH_RW		0x01
+#define RSU_FLASH_DEL		0x02
+#define RSU_CFG_FPGA		0x03
+#define RSU_CLR_CTL			0x04
+
+#define DIAG_WGSET_X		0x00
+#define DIAG_WGSET_Y		0x01
+#define DIAG_USRWG_X		0x02
+#define DIAG_USRWG_Y		0x03
+#define DIAG_ENABLE_BYPASS	0x04
+#define DIAG_DATA_PROC_RSLT	0x05
+#define DIAG_SELFTEST		0x06
+
+#define SS_SELECT			0x00
+
+#define BF_XROUT			0x00
+#define BF_XIOUT			0x01
+#define BF_YROUT			0x02
+#define BF_YIOUT			0x03
+
+#define BST_PWR_LANE_0		0x00
+#define BST_PWR_LANE_1		0x01
+#define BST_PWR_LANE_2		0x02
+#define BST_PWR_LANE_3		0x03
+
+#define SST_POWER			0x00
+
+#define RCU_SETTINGS		0x00
+#define RCU_XCTL_LIST		0x01
+#define RCU_XCTL_RSLT		0x02
+#define RCU_YCTL_LIST		0x03
+#define RCU_YCTL_RSLT		0x04
+
+#define CR_SOFTRESET		0x00
+#define CR_SOFTPPS			0x01
+#define CR_DIS_SYNC			0x01
+
+#define CDO_SETTINGS  		0x00
+#define CDO_BLET_SEL		0x01
+
+#define BS_NR_SAMPLES		0x00
+
+#define SDS_MDIO_HDR		0x00
+#define SDS_MDIO_DATA		0x10
+
+#define TDS_CTL_LIST		0x01
+#define TDS_CTL_RSLT		0x02
+
+#define TBB_X_SETTINGS		0x00
+#define TBB_Y_SETTINGS		0x01
+#define TBB_X_BANDSEL		0x02
+#define TBB_Y_BANDSEL		0x03
+
+#define CEP_MDIO_HDR		0x00
+#define CEP_MDIO_DATA		0x01
+
+#define LCU_MDIO_HDR		0x00
+#define LCU_MDIO_DATA		0x01
+
+#define RAD_SETTINGS		0x00
+
+#define MAX_REGID 0x06
+
+/*@}*/
+
+/*@{*/
+/**
+ * Define the number of beamlets N_BEAMLETS
+ * supported by the EPA firmware. For FTS-1
+ * the number of beamlets supported is 128.
+ * For the final LOFAR remote station
+ * 256 beamlets will be supported.
+ *
+ * Many register sizes are derived from
+ * the number of beamlets.
+ *
+ * The N_SUBBANDS(512) defines the number of
+ * subbands produced by the EPA digital filter.
+ * The N_BEAMLETS are a selection from this
+ * number of beamlets.
+ */
+#define N_SUBBANDS 512
+#define N_BEAMLETS 128                /* FTS-1. Final remote station = 256 */
+#define N_POL      2                  /* number of polarizations */
+#define N_PHASE    2                  /* number of phases in a complex number */
+#define N_PHASEPOL (N_PHASE * N_POL)  /* number of phase polarizations */
+
+
+/**
+ * Registers too large to send in a single ethernet frame
+ * (> 1500 bytes) will be sent in a number of fragments of this size.
+ */
+#define FRAGMENT_SIZE 1024
+
+/**
+ * Read/write sizes in octets (= bytes)
+ */
+#define RSR_STATUS_SIZE    			-1 /* 164 or 256 ? */
+#define RSR_VERSION_SIZE   			2
+#define RSR_TIMESTAMP_SIZE 			4
+
+#define	RSU_FLASH_RW_SIZE			1024
+#define RSU_FLASH_DEL_SIZE			1
+#define RSU_CFG_FPGA_SIZE			1
+#define RSU_CLR_CTL_SIZE			1
+
+#define DIAG_WGSET_X_SIZE			12
+#define DIAG_WGSET_Y_SIZE			12
+#define DIAG_USRWG_X_SIZE			4096
+#define DIAG_USRWG_Y_SIZE			4096
+#define DIAG_ENABLE_BYPASS_SIZE		2
+#define DIAG_DATA_PROC_RSLT_SIZE	4096
+#define DIAG_SELFTEST_SIZE			4
+
+#define SS_SELECT_SIZE     			960
+//#define SS_SELECT_SIZE     			(N_BEAMLETS * N_POL * sizeof(uint16))
+
+#define BF_XROUT_SIZE      			1760	// (N_BEAMLETS * N_PHASEPOL * sizeof(int16))
+#define BF_XIOUT_SIZE      			1760	// (N_BEAMLETS * N_PHASEPOL * sizeof(int16))
+#define BF_YROUT_SIZE      			1760	// (N_BEAMLETS * N_PHASEPOL * sizeof(int16))
+#define BF_YIOUT_SIZE      			1760	// (N_BEAMLETS * N_PHASEPOL * sizeof(int16))
+
+#define BST_POWER_SIZE     			432		// (N_BEAMLETS * N_POL * sizeof(uint32))
+
+#define SST_POWER_SIZE     			(N_SUBBANDS * N_POL * sizeof(uint32)) // 4096 
+
+#define RCU_SETTINGS_SIZE  			2
+#define RCU_XCTL_LIST_SIZE			512
+#define RCU_XCTL_RSLT_SIZE			512
+#define RCU_YCTL_LIST_SIZE			512
+#define RCU_YCTL_RSLT_SIZE			512
+
+#define CR_SOFTRESET_SIZE			1
+#define CR_SOFTPPS_SIZE				1
+#define CR_DIS_SYNC_SIZE			1
+
+#define CDO_SETTINGS_SIZE  			20
+#define CDO_BLET_SEL_SIZE			32
+
+#define BS_NR_SAMPLES_SIZE			4
+
+#define SDS_MDIO_HDR_SIZE			2
+#define SDS_MDIO_DATA_SIZE			2
+
+#define TDS_CTL_LIST_SIZE			4096
+#define TDS_CTL_RSLT_SIZE			1024
+
+#define TBB_X_SETTINGS_SIZE			8
+#define TBB_Y_SETTINGS_SIZE			8
+#define TBB_X_BANDSEL_SIZE			64
+#define TBB_Y_BANDSEL_SIZE			64
+
+#define CEP_MDIO_HDR_SIZE			2
+#define CEP_MDIO_DATA_SIZE			2
+
+#define LCU_MDIO_HDR_SIZE			2
+#define LCU_MDIO_DATA_SIZE			2
+
+#define RAD_SETTINGS_SIZE			4
+
+
+/*@}*/
+
+/**
+ * EPA protocol constants and value to string mappings.
+ */
+static const value_string type_info_vals[] =
+{
+	{ TYPE_UNSET, "Invalid " },
+	{ READ,       "READ    " },
+	{ WRITE,      "WRITE   " },
+	{ READACK,    "READACK " },
+	{ WRITEACK,   "WRITEACK" },
+	{ 0,     	  NULL		 }
+};
+
+static const value_string type_vals[] =
+{
+	{ TYPE_UNSET, "Invalid message type"         },
+	{ READ,       "Read  request     (READ)"     },
+	{ WRITE,      "Write command     (WRITE)"    },
+	{ READACK,    "Read  acknowledge (READACK)"  },
+	{ WRITEACK,   "Write acknowledge (WRITEACK)" },
+	{ 0,     	  NULL							 }
+};
+
+static const value_string blp_vals[] =
+{
+	{ 0x01, "Beamlet processor 0" },
+	{ 0x02, "Beamlet processor 1" },
+	{ 0x04, "Beamlet processor 2" },
+	{ 0x08, "Beamlet processor 3" },
+	{ 0,    "No Beamlet processor"},
+	{ 0,    NULL				  }  
+};
+
+static const value_string alp_vals[] =
+{
+	{ DST_RSP,     "RSP main FPGA"		 },
+	{ 0,     	   NULL					 }  
+};
+
+static const value_string pid_info_vals[] =
+{
+	{ 0,   "?00" },
+	{ RSR, "RSR" },
+	{ RSU, "RSU" },
+	{ DIAG,"DIA" },
+	{ SS,  "SS " },
+	{ BF,  "BF " },
+	{ BST, "BST" },
+	{ SST, "SST" },
+	{ RCU, "RCU" },
+	{ CR , "CR " },
+	{ XST, "XST" },
+	{ CDO, "CDO" },
+	{ BS , "BS " },
+	{ SDS, "SDS" },
+	{ TDS, "TDS" },
+	{ TBB, "TBB" },
+	{ CEP, "CEP" },
+	{ LCU, "LCU" },
+	{ RAD, "RAD" },
+	{ 0,   NULL  },
+};
+
+static const value_string pid_vals[] =
+{
+	{ 0,	"Unknown (0x00)"					},
+	{ RSR,	"Status overview (RSR)"         	},
+	{ RSU,	"FPGA remote system update (RSU)"	},
+	{ DIAG,	"Selftest functionality (DIA)"  	},
+	{ SS,	"Subband select (SS)"           	},
+	{ BF,	"Beamformer (BF)"               	},
+	{ BST,	"Beamlet statistics (BST)"      	},
+	{ SST,	"Subband statistics (SST)"      	},
+	{ RCU,	"RCU Control (RCU)"             	},
+	{ CR ,	"RSP Clock and Reset (CRR)"     	},
+	{ XST,	"Crosslet statistics (XST)"     	},
+	{ CDO,	"CEP Data Output (CDO)"         	},
+	{ BS,	"Block Synchronisation (BS)"		},
+	{ SDS,	"SERDES management (SDS)"			},
+	{ TDS,	"Time Distribution board (TDS)"		},
+	{ TBB,	"Transient Buffer Board (TBB)"		},
+	{ CEP,	"CEP Ethernet management (CEP)"		},
+	{ LCU,	"LCU Ethernet management (CEP)"		},
+	{ RAD,	"Ring-adder lane settings (RAD)"	},
+	{ 0,	NULL								}
+};
+
+static const value_string rsr_vals[] =
+{
+	{ RSR_STATUS,  		"RSP Status" },
+	{ RSR_VERSION, 		"Version"    },
+	{ RSR_TIMESTAMP, 	"Timestamp"  },
+	{ 0,     			NULL         }
+};
+
+static const value_string rsu_vals[] =
+{
+	{ 0,			"Unknown (0x00)"	},
+	{ RSU_FLASH_RW, "Flash read/write"	},
+	{ RSU_FLASH_DEL,"Flash erase"		},
+	{ RSU_CFG_FPGA, "Reconfigure FPGA"	},
+	{ RSU_CLR_CTL,  "Clear control"		},
+	{ 0,     		NULL		        }
+};
+
+static const value_string diag_vals[] =
+{
+	{ DIAG_WGSET_X,			"Waveform generator settings X pol"	},
+	{ DIAG_WGSET_Y,			"Waveform generator settings Y pol"	},
+	{ DIAG_USRWG_X,			"User waveform X pol"				},
+	{ DIAG_USRWG_Y,			"User waveform Y pol"				},
+	{ DIAG_ENABLE_BYPASS,	"Bypass enable"						},
+	{ DIAG_DATA_PROC_RSLT,	"Data processing results"			},
+	{ DIAG_SELFTEST,		"Selftest"							},
+	{ 0,     				NULL                         		}
+};
+
+static const value_string ss_vals[] =
+{
+	{ SS_SELECT, "Subband Select parameters"	},
+	{ 0,     	 NULL							}
+};
+
+static const value_string bf_vals[] =
+{
+	{ BF_XROUT, "XR,XI,YR,YI coefficients for XR output" },
+	{ BF_XIOUT, "XR,XI,YR,YI coefficients for XI output" },
+	{ BF_YROUT, "XR,XI,YR,YI coefficients for YR output" },
+	{ BF_YIOUT, "XR,XI,YR,YI coefficients for YI output" },
+	{ 0,     	 NULL       							 }
+};
+
+static const value_string bst_vals[] =
+{
+	{ BST_PWR_LANE_0, "Beamlet Statistics lane 0 - X,Y Power"  },
+	{ BST_PWR_LANE_1, "Beamlet Statistics lane 1 - X,Y Power"  },
+	{ BST_PWR_LANE_2, "Beamlet Statistics lane 2 - X,Y Power"  },
+	{ BST_PWR_LANE_3, "Beamlet Statistics lane 3 - X,Y Power"  },
+	{ 0,     	 NULL   }
+};
+
+static const value_string sst_vals[] =
+{
+	{ SST_POWER, "Subband Statistics - X,Y Power"  },
+	{ 0,     	 NULL   }
+};
+
+static const value_string rcu_vals[] =
+{
+	{ RCU_SETTINGS, 	"RCU Settings"						},
+	{ RCU_XCTL_LIST,	"Protocol list for RCU X control"	},
+	{ RCU_XCTL_RSLT,	"Protocol list resuls from RCU X"	},
+	{ RCU_YCTL_LIST,	"Protocol list for RCU Y control"	},
+	{ RCU_YCTL_RSLT,	"Protocol list resuls from RCU Y"	},
+	{ 0,     			NULL   								}
+};
+
+static const value_string cr_vals[] =
+{
+	{ CR_SOFTRESET,	"Soft Reset"	},
+	{ CR_SOFTPPS,	"Soft PPS"		},
+	{ CR_DIS_SYNC,	"Disable sync"	},
+	{ 0,     		NULL   			}
+};
+
+static const value_string cdo_vals[] =
+{
+	{ CDO_SETTINGS, "CEP Data Output Settings"  },
+	{ CDO_BLET_SEL,	"Beamlet selection"			},
+	{ 0,     		NULL   },
+};
+
+static const value_string bs_vals[] =
+{
+	{ BS_NR_SAMPLES,	"Number of samples per sync interval"	},
+	{ 0,       			NULL 									}
+};
+
+static const value_string sds_vals[] =
+{
+	{ SDS_MDIO_HDR,		"Serdes MDIO header"	},
+	{ SDS_MDIO_DATA,	"Serdes MDIO data"		},
+	{ 0,       			NULL 					}
+};
+
+static const value_string tds_vals[] =
+{
+	{ TDS_CTL_LIST_SIZE,	"Protocol list for TDS control"	},
+	{ TDS_CTL_RSLT_SIZE,	"Protocol list results from TDS"},
+	{ 0,					NULL							}
+};
+
+static const value_string tbb_vals[] =
+{
+	{ TBB_X_SETTINGS,	"TBB settings X"		},
+	{ TBB_Y_SETTINGS,	"TBB settings Y"		},
+	{ TBB_X_BANDSEL,	"TBB bandselection X"	},
+	{ TBB_Y_BANDSEL,	"TBB bandselection Y"	},
+	{ 0,       			NULL 					}
+};
+
+static const value_string cep_vals[] =
+{
+	{ CEP_MDIO_HDR,		"CEP MDIO header"	},
+	{ CEP_MDIO_DATA,	"CEP MDIO data"		},
+	{ 0,       			NULL 				}
+};
+
+static const value_string lcu_vals[] =
+{
+	{ LCU_MDIO_HDR,		"LCU MDIO header"	},
+	{ LCU_MDIO_DATA,	"LCU MDIO data"		},
+	{ 0,       			NULL 				}
+};
+
+static const value_string rad_vals[] =
+{
+	{ RAD_SETTINGS,	"RingADder lane settings"	},
+	{ 0,    		NULL 						}
+};
+
+static const value_string eth_error_vals[] =
+{
+	{ 0, "The ethernet frame was received correctly"           },
+	{ 1, "Preamble had other value than 0xAA"                  },
+	{ 2, "Frame delimiter had other value than 0xAB"           },
+	{ 3, "Not enough preamble nibbles"                         },
+	{ 4, "Frame ended during frame header."                    },
+	{ 5, "Calculated CRC does not match received CRC"          },
+	{ 6, "An odd number of nibbles was received from ethernet" },
+	{ 7, "Length specified in the frame size field does not match the real number of received bytes" },
+	{ 0, NULL												   }
+};
+
+static const value_string mep_error_vals[] =
+{
+	{ 0, "The MEP message was processed successfully"	},
+	{ 1, "Unknown message type"							},
+	{ 2, "Illegal BLP addess"							},
+	{ 3, "Invalid PID"									},
+	{ 4, "Register does not exist"						},
+	{ 5, "Offset is too large"							},
+	{ 6, "Message is too large"							},
+	{ 7, "Message CRC error on RSP ring interface"		},
+	{ 8, "No ack message received from BLP"				},
+	{ 0, NULL 											}
+};
+
+static const value_string wg_mode_vals[] =
+{
+	{ 0, "off" 	  },
+	{ 1, "calc"   },
+	{ 3, "single" },
+	{ 5, "repeat" },
+	{ 0, NULL     }
+};
+
+
+/**
+ * Pluginize BEGIN
+ *
+ * Pluginize the EPA dissector
+ */
+#include "plugins/plugin_api.h"
+#include "moduleinfo.h"
+#include <gmodule.h>
+#include "plugins/plugin_api_defs.h"
+
+#ifndef __ETHEREAL_STATIC__
+G_MODULE_EXPORT const gchar version[] = "4.0";
+G_MODULE_EXPORT void plugin_init(plugin_address_table_t *pat);
+G_MODULE_EXPORT void plugin_reg_handoff(void);
+#endif 
+
+/**
+ * Pluginize END
+ */
+
+/**
+ * Constants
+ */
+#define ETHERTYPE_EPA2 0x10FA
+
+/* Initialize the protocol and registered fields */
+static int proto_epa2         = -1;
+static int hf_epa_type        = -1;
+static int hf_epa_error       = -1;
+static int hf_epa_frame_size  = -1;
+static int hf_epa_addr        = -1;
+static int hf_epa_addr_blpid  = -1;
+static int hf_epa_addr_alpid  = -1;
+static int hf_epa_addr_pid    = -1;
+static int hf_epa_addr_regid  = -1;
+static int hf_epa_offset      = -1;
+static int hf_epa_data_size   = -1;
+static int hf_epa_seqnr       = -1;
+static int hf_epa_data        = -1;
+static int hf_epa_int16       = -1;
+static int hf_epa_uint16      = -1;
+static int hf_epa_int32       = -1;
+static int hf_epa_uint32      = -1;
+static int hf_epa_double      = -1;
+
+/**
+ * RSP Status register fields.
+ */
+/*static int df_rspstatus           = -1;*/
+static int df_rspstatus_voltage_1_2 = -1;
+static int df_rspstatus_voltage_2_5 = -1;
+static int df_rspstatus_voltage_3_3 = -1;
+static int df_fpgastatus_pcb_temp   = -1;
+static int df_fpgastatus_bp_temp    = -1;
+static int df_fpgastatus_ap0_temp   = -1;
+static int df_fpgastatus_ap1_temp   = -1;
+static int df_fpgastatus_ap2_temp   = -1;
+static int df_fpgastatus_ap3_temp   = -1;
+static int df_fpgastatus_bp_clock   = -1;
+
+/*static int df_ethstatus           = -1;*/
+static int df_ethstatus_nof_frames  = -1;
+static int df_ethstatus_nof_errors  = -1;
+static int df_ethstatus_last_error  = -1;
+
+/*static int df_mepstatus      = -1;*/
+static int df_mepstatus_seqnr  		= -1;
+static int df_mepstatus_error  		= -1;
+
+#if 0
+/*static int df_diagstatus = -1; */
+static int df_interface			 	= -1;
+static int df_testmode			 	= -1;
+static int df_ri_errors			 	= -1;
+static int df_rcux_errors		 	= -1;
+static int df_rcuy_errors		 	= -1;
+static int df_lcu_errors		 	= -1;
+static int df_cep_errors		 	= -1;
+static int df_serdes_errors		 	= -1;
+static int df_ap0_ri_errors		 	= -1;
+static int df_ap1_ri_errors		 	= -1;
+static int df_ap2_ri_errors		 	= -1;
+static int df_ap3_ri_errors		 	= -1;
+#endif
+
+/*static int df_syncstatus = -1; */	// REO ???
+static int df_blp_extclock		 	= -1;
+static int df_blp_sync			 	= -1;
+static int df_blp_samples		 	= -1;
+static int df_blp_slices		 	= -1;
+
+#if 0
+/*static int df_rcustatus = -1; */
+static int df_blp0_rcu			 	= -1;
+static int df_blp1_rcu			 	= -1;
+static int df_blp2_rcu			 	= -1;
+static int df_blp3_rcu			 	= -1;
+
+/*static int df_rsustatus = -1; */
+static int df_cp_status			 	= -1;
+
+/*static int df_adostatus = -1; */
+static int df_blp0_adc_offset		= -1;
+static int df_blp1_adc_offset		= -1;
+static int df_blp2_adc_offset		= -1;
+static int df_blp3_adc_offset		= -1;
+
+/*static int df_radstatus = -1;	*/
+static int df_lane0_crosslet		= -1;
+static int df_lane0_beamlet			= -1;
+static int df_lane1_crosslet		= -1;
+static int df_lane1_beamlet			= -1;
+static int df_lane2_crosslet		= -1;
+static int df_lane2_beamlet			= -1;
+static int df_lane3_crosslet		= -1;
+static int df_lane3_beamlet			= -1;
+#endif
+
+/**
+ * RSP Version register fields.
+ */
+static int df_rsp_version	= -1;
+static int df_fpga_version  = -1;
+
+/**
+ * RSP TimeStamp register fields.
+ */
+static int df_rsp_timestamp	= -1;
+
+/**
+ * RCU Settings register fields
+ */
+static int df_vddvcc_en    = -1;
+static int df_vh_enable    = -1;
+static int df_vl_enable    = -1;
+static int df_filsel_b     = -1;
+static int df_filsel_a     = -1;
+static int df_bandsel      = -1;
+static int df_hba_enable   = -1;
+static int df_lba_enable   = -1;
+static int df_nof_overflow = -1;
+
+/**
+ * WG settings
+ */
+static int df_wg_freq  		= -1;
+static int df_wg_phase 		= -1;
+static int df_wg_ampl  		= -1;
+static int df_wg_nof_samples= -1;
+static int df_wg_mode 		= -1;
+
+/* Initialize the subtree pointers */
+static gint ett_epa         = -1;
+static gint ett_epa_addr    = -1;
+static gint ett_rspstatus   = -1;
+static gint ett_rspstatus_detail = -1;
+static gint ett_fpgastatus  = -1;
+static gint ett_ethstatus   = -1;
+static gint ett_mepstatus   = -1;
+static gint ett_diagstatus  = -1;
+static gint ett_syncstatus  = -1;
+static gint ett_rcustatus   = -1;
+static gint ett_rcusettings = -1;
+static gint ett_rsustatus   = -1;
+static gint ett_adostatus   = -1;
+static gint ett_radstatus   = -1;
+static gint ett_rspversion  = -1;
+static gint ett_rsptimestamp= -1;
+static gint ett_wgsettings  = -1;
+static gint ett_payload     = -1;
+
+/* Code to actually dissect the packets */
+static void
+dissect_epa(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+	/* Set up structures needed to add the protocol subtree and manage it */
+	proto_item *ti;
+	proto_tree *epa_tree;
+	char*  typestr = NULL;
+	char*  pidstr  = NULL;
+	char*  regstr  = NULL;
+	guint8 type = tvb_get_guint8(tvb, 0);
+	guint8 reg  = tvb_get_guint8(tvb, 7);
+	guint8 pid  = tvb_get_guint8(tvb, 6);
+
+#if 0
+	/* don't know enough about how this conversation stuff works, implement it later */
+	conversation_t* conversation = NULL;
+
+	conversation = find_conversation(&pinfo->net_src, &pinfo->net_dst, 
+									pinfo->ptype, 0, 0, NO_PORT2);
+	if (conversation == NULL) {
+		/* No conversation, create one */
+		conversation = conversation_new(&pinfo->net_src, &pinfo->net_dst, 
+									pinfo->ptype, 0, 0, NO_PORT_B);
+	}
+#endif
+  
+	/* Make entries in Protocol column and Info column on summary display */
+	if (check_col(pinfo->cinfo, COL_PROTOCOL)) {
+		col_set_str(pinfo->cinfo, COL_PROTOCOL, "EPA2");
+	}
+    
+	/* This field shows up as the "Info" column in the display; you should make
+     * it, if possible, summarize what's in the packet, so that a user looking
+     * at the list of packets can tell what type of packet it is. See section 1.5
+     * for more information.
+	 *
+     * If you are setting it to a constant string, use "col_set_str()", as
+     * it's more efficient than the other "col_set_XXX()" calls.
+	 *
+     * If you're setting it to a string you've constructed, or will be
+     * appending to the column later, use "col_add_str()".
+	 *
+     * "col_add_fstr()" can be used instead of "col_add_str()"; it takes
+     * "printf()"-like arguments.  Don't use "col_add_fstr()" with a format
+     * string of "%s" - just use "col_add_str()" or "col_set_str()", as it's
+     * more efficient than "col_add_fstr()".
+	 *
+     * If you will be fetching any data from the packet before filling in
+     * the Info column, clear that column first, in case the calls to fetch
+     * data from the packet throw an exception because they're fetching data
+     * past the end of the packet, so that the Info column doesn't have data
+     * left over from the previous dissector; do
+	 *
+     * if (check_col(pinfo->cinfo, COL_INFO)) 
+     * col_clear(pinfo->cinfo, COL_INFO);
+  	 */
+
+	if (check_col(pinfo->cinfo, COL_INFO))  {
+		col_clear(pinfo->cinfo, COL_INFO);
+	}
+
+	/* decode the typestr */
+	typestr = type_info_vals[type].strptr;
+	pidstr  = pid_info_vals[pid].strptr;
+	switch (pid) {
+	    case RSR:	regstr = rsr_vals[reg].strptr;	break;
+	    case RSU:	regstr = rsu_vals[reg].strptr;	break;
+	    case DIAG:	regstr = diag_vals[reg].strptr;	break;
+	    case SS:	regstr = ss_vals[reg].strptr;	break;
+	    case BF:	regstr = bf_vals[reg].strptr;	break;
+	    case BST:	regstr = bst_vals[reg].strptr;	break;
+	    case SST:	regstr = sst_vals[reg].strptr;	break;
+	    case RCU:	regstr = rcu_vals[reg].strptr;	break;
+	    case CR:	regstr = cr_vals[reg].strptr;	break;
+	    case XST:	regstr = "CrossCorrelation";	break;
+	    case CDO:	regstr = cdo_vals[reg].strptr;	break;
+	    case BS:	regstr = bs_vals[reg].strptr;	break;
+	    case SDS:	regstr = sds_vals[reg].strptr;	break;
+	    case TDS:	regstr = tds_vals[reg].strptr;	break;
+		case TBB:	regstr = tbb_vals[reg].strptr;	break;
+		case CEP:	regstr = cep_vals[reg].strptr;	break;
+		case LCU:	regstr = lcu_vals[reg].strptr;	break;
+		case RAD:	regstr = rad_vals[reg].strptr;	break;
+	}
+
+	if (!typestr) typestr = "Unknown type?";
+	if (!pidstr)  pidstr  = "Unknown process?";
+	if (!regstr)  regstr  = "Unknown register?";
+      
+	/* fill the INFO column */
+	if (check_col(pinfo->cinfo, COL_INFO)) {
+		col_add_fstr(pinfo->cinfo, COL_INFO, "%s %s %s", typestr, pidstr, regstr);
+	}
+  
+	/* In the interest of speed, if "tree" is NULL, don't do any work not
+	   necessary to generate protocol tree items. */
+	if (tree) {
+		proto_item* newitem = 0;
+		proto_tree* newtree = 0;
+		proto_tree* subtree = 0;
+		proto_tree* synctree = 0;
+		proto_tree* rcustatus_tree = 0;
+
+	 	/* NOTE: The offset and length values in the call to
+		 * "proto_tree_add_item()" define what data bytes to highlight in the hex
+		 * display window when the line in the protocol tree display
+		 * corresponding to that item is selected.
+		 *
+		 * Supplying a length of -1 is the way to highlight all data from the
+		 * offset to the end of the packet. 
+		 */
+
+		/* create display subtree for the protocol */
+		ti       = proto_tree_add_item(tree, proto_epa2, tvb, 0, -1, FALSE);
+		epa_tree = proto_item_add_subtree(ti, ett_epa);
+
+		/* Build the level 0 information (=HEADER information)
+		 * type:
+		 * error:
+		 * frame_size:
+		 * seqnr:
+		 */
+		proto_tree_add_item(epa_tree, hf_epa_type,		 tvb,  0,  1, FALSE);
+		proto_tree_add_item(epa_tree, hf_epa_error,		 tvb,  1,  1, FALSE);
+		proto_tree_add_item(epa_tree, hf_epa_frame_size, tvb,  2,  2, TRUE);
+		proto_tree_add_item(epa_tree, hf_epa_seqnr,		 tvb,  12, 2, TRUE);
+
+		/* Add subtree for address info
+		 * +addr:
+		 *		[blpid:]
+		 *		[alpid:]
+		 *		pid:
+		 *		regid:
+		 */
+		newitem = proto_tree_add_item(epa_tree, hf_epa_addr, tvb, 4, 4, FALSE);
+		newtree = proto_item_add_subtree(newitem, ett_epa_addr);
+
+		if (tvb_get_guint8(tvb, 4) != 0) {
+			proto_tree_add_item(newtree, hf_epa_addr_blpid, tvb, 4, 1, FALSE);
+		}
+		if (tvb_get_guint8(tvb, 5) != 0) {
+			proto_tree_add_item(newtree, hf_epa_addr_alpid, tvb, 5, 1, FALSE);
+		}
+		proto_tree_add_item(newtree, hf_epa_addr_pid,    tvb,  6,  1, FALSE);
+		if (regstr) {
+			proto_tree_add_string(newtree, hf_epa_addr_regid, tvb, 7, 1, regstr);
+		}
+		else{
+			proto_tree_add_item(newtree, hf_epa_addr_regid,  tvb,  7,  1, FALSE);
+		}
+
+		/* Continue with header
+		 * offset:
+		 * size:
+		 */
+		proto_tree_add_item(epa_tree, hf_epa_offset, 	tvb,  8,  2, TRUE);
+		proto_tree_add_item(epa_tree, hf_epa_data_size,	tvb, 10,  2, TRUE);
+
+		/* READACK RSR_STATUS */
+	    if (type == READACK && pid == RSR && reg == RSR_STATUS) {
+			/* +RSP Status register */
+			newitem = proto_tree_add_text(epa_tree, tvb, DSTART, 3, "RSP Status register");
+			newtree = proto_item_add_subtree(newitem, ett_rspstatus);
+
+			/* +RSP Status
+			 *		voltage_1_2:
+			 *		voltage_2_5:
+			 *		voltage_3_3:
+			 */
+			newitem = proto_tree_add_text(newtree, tvb, DSTART, 12,  "RSP Status");
+			subtree = proto_item_add_subtree(newitem, ett_rspstatus_detail);
+			proto_tree_add_item(subtree, df_rspstatus_voltage_1_2 ,tvb, DSTART,   1, FALSE);
+			proto_tree_add_item(subtree, df_rspstatus_voltage_2_5 ,tvb, DSTART+1, 1, FALSE);
+			proto_tree_add_item(subtree, df_rspstatus_voltage_3_3 ,tvb, DSTART+2, 1, FALSE);
+
+			/* +FPGA status
+			 *		pcb_temp:
+			 *		bp_temp:
+			 *		ap0_temp:
+			 *		ap1_temp:
+			 *		ap2_temp:
+			 *		ap3_temp:
+			 *		bp_clock:
+			 */
+			newitem = proto_tree_add_text(newtree, tvb, DSTART+3, 7, "FPGA Status");
+			subtree = proto_item_add_subtree(newitem, ett_fpgastatus);
+			proto_tree_add_item(subtree, df_fpgastatus_pcb_temp ,tvb, DSTART+3, 1, FALSE);
+			proto_tree_add_item(subtree, df_fpgastatus_bp_temp  ,tvb, DSTART+4, 1, FALSE);
+			proto_tree_add_item(subtree, df_fpgastatus_ap0_temp ,tvb, DSTART+5, 1, FALSE);
+			proto_tree_add_item(subtree, df_fpgastatus_ap1_temp ,tvb, DSTART+6, 1, FALSE);   
+			proto_tree_add_item(subtree, df_fpgastatus_ap2_temp ,tvb, DSTART+7, 1, FALSE);
+			proto_tree_add_item(subtree, df_fpgastatus_ap3_temp ,tvb, DSTART+8, 1, FALSE);   
+			proto_tree_add_item(subtree, df_fpgastatus_bp_clock ,tvb, DSTART+9, 1, FALSE);
+
+			/* +ETH status
+			 *		nof_frames:
+			 *		nof_errors:
+			 *		last_error:
+			 */
+			newitem = proto_tree_add_text(newtree, tvb, DSTART+12, 12, "ETH Status");
+			subtree = proto_item_add_subtree(newitem, ett_ethstatus);
+			proto_tree_add_item(subtree, df_ethstatus_nof_frames ,tvb, DSTART+12, 4,  TRUE);
+			proto_tree_add_item(subtree, df_ethstatus_nof_errors ,tvb, DSTART+16, 4,  TRUE);
+			proto_tree_add_item(subtree, df_ethstatus_last_error ,tvb, DSTART+20, 1,  FALSE);
+
+			/* +MEP status
+			 *		seqnr:
+			 *		error:
+			 */
+			newitem = proto_tree_add_text(newtree, tvb, DSTART+24, 4, "MEP Status");
+			subtree = proto_item_add_subtree(newitem, ett_mepstatus);
+			proto_tree_add_item(subtree, df_mepstatus_seqnr  ,tvb, DSTART+24, 2,  TRUE);
+			proto_tree_add_item(subtree, df_mepstatus_error  ,tvb, DSTART+26, 1,  FALSE);
+			
+			/* (+)Diag status
+			 */
+			newitem = proto_tree_add_text(newtree, tvb, DSTART+28, 24, "DIAG Status");
+			rcustatus_tree = subtree = proto_item_add_subtree(newitem, ett_diagstatus);
+
+			/* +Sync Status
+			 *		+Beamlet processor 0..3
+			 *			external count:
+			 *			sync count    :
+			 *			sample count  :
+			 *			slice count   :
+			 */
+			newitem = proto_tree_add_text(newtree, tvb, DSTART+52, 64, "SYNC Status");
+			synctree = subtree = proto_item_add_subtree(newitem, ett_syncstatus);
+			int blpnr;
+			for (blpnr = 0; blpnr < N_BLP; blpnr++) {
+				newitem = proto_tree_add_text(synctree, tvb, 
+								DSTART+52+(blpnr*16), 16, blp_vals[blpnr].strptr);
+				subtree = proto_item_add_subtree(newitem, ett_syncstatus);
+				proto_tree_add_item(subtree, df_blp_extclock, tvb, 
+												DSTART+52+(blpnr*16),    4, TRUE);
+				proto_tree_add_item(subtree, df_blp_sync,     tvb, 
+												DSTART+52+(blpnr*16)+4,  4, TRUE);
+				proto_tree_add_item(subtree, df_blp_samples,  tvb, 
+												DSTART+52+(blpnr*16)+8,  4, TRUE);
+				proto_tree_add_item(subtree, df_blp_slices,   tvb, 
+												DSTART+52+(blpnr*16)+12, 4, TRUE);
+			}
+
+			/* (+)RCU Status
+			 */
+			newitem = proto_tree_add_text(newtree, tvb, DSTART+116, 48, "RCU Status");
+			rcustatus_tree = subtree = proto_item_add_subtree(newitem, ett_rcustatus);
+
+			/* (+)RSU Status:
+			 */
+			newitem = proto_tree_add_text(newtree, tvb, DSTART+164, 4, "RSU Status");
+			rcustatus_tree = subtree = proto_item_add_subtree(newitem, ett_rsustatus);
+
+			/* (+)ADO Status:
+			 */
+			newitem = proto_tree_add_text(newtree, tvb, DSTART+168, 32, "ADO Status");
+			rcustatus_tree = subtree = proto_item_add_subtree(newitem, ett_adostatus);
+
+			/* (+)RAD Status:
+			 */
+			newitem = proto_tree_add_text(newtree, tvb, DSTART+200, 36, "RAD Status");
+			rcustatus_tree = subtree = proto_item_add_subtree(newitem, ett_radstatus);
+		}
+
+		/* READACK RSR_VERSION */
+		else if (type == READACK && pid == RSR && reg == RSR_VERSION) {
+			newitem = proto_tree_add_text(epa_tree, tvb, DSTART, RSR_VERSION_SIZE, 
+																"RSP Version register");
+			newtree = proto_item_add_subtree(newitem, ett_rspversion);
+
+			proto_tree_add_item(newtree, df_rsp_version,  tvb, DSTART,   1, FALSE);
+			proto_tree_add_item(newtree, df_fpga_version, tvb, DSTART+1, 1, FALSE);
+	    }
+
+		/* WRITE OR READACK RSR_TIMESTAMP */
+		else if ((type == WRITE || type == READACK) && pid == RSR && reg == RSR_TIMESTAMP) {
+			time_t	tstamp = tvb_get_letohl(tvb, DSTART);
+			newitem = proto_tree_add_text(epa_tree, tvb, DSTART, RSR_TIMESTAMP_SIZE, 
+												"RSP Timestamp register: %d = %s", tstamp, ctime(&tstamp));
+//			newtree = proto_item_add_subtree(newitem, ett_rsptimestamp);
+
+//			proto_tree_add_item(newtree, df_rsp_timestamp, tvb, DSTART,   4, FALSE);
+	    }
+
+		/* WRITE or READACK DIAG_WGSET_[X|Y] */
+		else if ((type == WRITE || type == READACK) && pid == DIAG && 
+				 (reg == DIAG_WGSET_X || reg == DIAG_WGSET_Y)) {
+			if (reg == DIAG_WGSET_X) {
+				newitem = proto_tree_add_text(epa_tree, tvb, DSTART, 
+					DIAG_WGSET_X_SIZE, "Waveform generator settings X-polarization");
+			}
+			else {
+				newitem = proto_tree_add_text(epa_tree, tvb, DSTART, 
+					DIAG_WGSET_Y_SIZE, "Waveform generator settings Y-polarization");
+			}
+			newtree = proto_item_add_subtree(newitem, ett_wgsettings);
+
+			proto_tree_add_item(newtree, df_wg_mode,        tvb, DSTART,   1, FALSE);
+			proto_tree_add_item(newtree, df_wg_phase,       tvb, DSTART+1, 1, FALSE);
+			proto_tree_add_item(newtree, df_wg_nof_samples, tvb, DSTART+2, 2, TRUE);
+			proto_tree_add_item(newtree, df_wg_freq,        tvb, DSTART+4, 4, TRUE);
+			proto_tree_add_item(newtree, df_wg_ampl,        tvb, DSTART+8, 4, FALSE);
+	    }
+
+		/* WRITE or READACK DIAG_USRWG_[X|Y] */
+	    else if ((type == WRITE || type == READACK) && pid == DIAG && 
+				 (reg == DIAG_USRWG_X || reg == DIAG_USRWG_Y)) {
+			if (reg == DIAG_USRWG_X) {
+				newitem = proto_tree_add_text(epa_tree, tvb, DSTART, 
+							DIAG_USRWG_X_SIZE, "User waveform X-polarization");
+			}
+			else {
+				newitem = proto_tree_add_text(epa_tree, tvb, DSTART, 
+							DIAG_USRWG_Y_SIZE, "User Waveform Y-polarization");
+			}
+			newtree = proto_item_add_subtree(newitem, ett_wgsettings);
+
+			int i;
+			for (i = 0; i < 16; i++) {
+				proto_tree_add_item(newtree, hf_epa_int32, tvb,
+									DSTART + (i*sizeof(gint32)),
+									sizeof(gint32), TRUE);
+			}
+			proto_tree_add_text(newtree, tvb, 0, 0, "...");
+			for (i = 0; i < 8; i++) {
+				proto_tree_add_item(newtree, hf_epa_int32, tvb,
+					DSTART + DIAG_USRWG_X_SIZE - (8*sizeof(gint32)) + (i*sizeof(gint32)),
+					sizeof(gint32), TRUE);
+			}
+		}
+
+
+		/* WRITE BF_* */
+		else if ( (type == WRITE || type == READACK) && pid == BF) {
+			newitem = proto_tree_add_text(epa_tree, tvb, DSTART, -1, bf_vals[reg].strptr);
+			newtree = proto_item_add_subtree(newitem, ett_payload);
+
+			guint16 nr_samples = DATA_SIZE / sizeof(gint16);
+			int i;
+			for (i = 0; i < MIN2(16, nr_samples); i++) {
+				proto_tree_add_item(newtree, hf_epa_int16, tvb,
+									DSTART + (i*sizeof(gint16)),
+									sizeof(gint16), TRUE);
+			}
+			if (nr_samples > 16) {
+				proto_tree_add_text(newtree, tvb, 0, 0, "...");
+				for (i = nr_samples - 8; i < nr_samples; i++) {
+					proto_tree_add_item(newtree, hf_epa_int16, tvb,
+										DSTART + (i*sizeof(gint16)),
+										sizeof(gint16), TRUE);
+				}
+			}
+		}
+
+
+		/* WRITE SS_SELECT */
+		else if ( (type == WRITE || type == READACK) && pid == SS && 
+					reg == SS_SELECT) {
+			newitem = proto_tree_add_text(epa_tree, tvb, DSTART, -1, "Subband Select Payload");
+			newtree = proto_item_add_subtree(newitem, ett_payload);
+
+			guint16 nr_subbands = DATA_SIZE / sizeof(gint16);
+			int i;
+			for (i = 0; i < MIN2(16, nr_subbands); i++) {
+				proto_tree_add_item(newtree, hf_epa_uint16, tvb,
+									DSTART + (i*sizeof(guint16)),
+									sizeof(guint16), TRUE);
+			}
+			if (nr_subbands > 16) {
+				proto_tree_add_text(newtree, tvb, 0, 0, "...");
+				for (i = nr_subbands - 8; i < nr_subbands; i++) {
+					proto_tree_add_item(newtree, hf_epa_uint16, tvb,
+										DSTART + (i*sizeof(guint16)),
+										sizeof(guint16), TRUE);
+				}
+			}
+		}
+
+
+		/* READACK [BST|SST]_MEAN POWER */
+		else if (type == READACK && (pid == BST || pid == SST)) { 
+//									(reg == BST_POWER || reg == SST_POWER)) {
+			newitem = proto_tree_add_text(epa_tree, tvb, DSTART, -1, "Statistics Payload (POWER)");
+			newtree = proto_item_add_subtree(newitem, ett_payload);
+
+			guint16 nr_samples = DATA_SIZE / sizeof(guint64);
+			int i;
+			/* print first 16 values */
+			for (i = 0; i < MIN2(16, nr_samples); i++) {
+				guint64 val64 = tvb_get_ntohl(tvb, DSTART + (i*sizeof(guint32)));
+				if (((guint64)1<<31) && val64) {
+					val64 = (val64 & (((guint64)1<<31)-1)) << 25;
+				}
+				double dval = (double)val64;
+	
+				proto_tree_add_double(newtree, hf_epa_double, tvb,
+										DSTART + (i*sizeof(guint32)),
+										sizeof(guint32), dval);
+			}
+			if (nr_samples > 16) {
+				proto_tree_add_text(newtree, tvb, 0, 0, "...");
+
+				/* print last 8 values */
+				for (i = nr_samples - 8; i < nr_samples; i++) {
+					guint64 val64 = tvb_get_ntohl(tvb, DSTART + (i*sizeof(guint32)));
+					if (((guint64)1<<31) && val64) {
+						val64 = (val64 & (((guint64)1<<31)-1)) << 25;
+					}
+					double dval = (double)val64;
+
+					proto_tree_add_double(newtree, hf_epa_double, tvb,
+										DSTART + (i*sizeof(guint32)),
+										sizeof(guint32), dval);
+				}
+			}
+		}
+
+
+		/* READACK XST_* */
+		else if (type == READACK && pid == XST) {
+			newitem = proto_tree_add_text(epa_tree, tvb, DSTART, -1, "Crosslets Payload");
+			newtree = proto_item_add_subtree(newitem, ett_payload);
+
+			guint16 nr_samples = DATA_SIZE / sizeof(guint64);
+			int i;
+			/* print first 16 values */
+			for (i = 0; i < MIN2(16, nr_samples); i++) {
+				guint64 val64 = tvb_get_ntohl(tvb, DSTART + (i*sizeof(guint32)));
+				if (((guint64)1<<31) && val64) {
+					val64 = (val64 & (((guint64)1<<31)-1)) << 25;
+				}
+				double dval = (double)val64;
+
+				proto_tree_add_item(newtree, hf_epa_uint32, tvb,
+									DSTART + (i*sizeof(guint32)),
+									sizeof(guint32), dval);
+			}
+			if (nr_samples > 16) {
+				proto_tree_add_text(newtree, tvb, 0, 0, "...");
+				for (i = nr_samples - 8; i < nr_samples; i++) {
+					guint64 val64 = tvb_get_ntohl(tvb, DSTART + (i*sizeof(guint32)));
+					if (((guint64)1<<31) && val64) {
+						val64 = (val64 & (((guint64)1<<31)-1)) << 25;
+					}
+					double dval = (double)val64;
+
+					proto_tree_add_item(newtree, hf_epa_uint32, tvb,
+										DSTART + (i*sizeof(guint32)),
+										sizeof(guint32), dval);
+				}
+			}
+		}
+
+		/* WRITE or READACK RCU_SETTINGS */
+		else if ((type == WRITE || type == READACK) && pid == RCU && 
+					reg == RCU_SETTINGS) {
+			newitem = proto_tree_add_text(epa_tree, tvb, DSTART, 2, "RCU status");
+			newtree = proto_item_add_subtree(newitem, ett_rcusettings);
+#if 0
+			{
+			/* X-polarization */
+			newitem = proto_tree_add_text(newtree, tvb, DSTART, 2, "X polarization");
+			subtree = proto_item_add_subtree(newitem, ett_rcusettings);
+			proto_tree_add_item(subtree, df_vddvcc_en,  tvb, DSTART, 1, FALSE);
+			proto_tree_add_item(subtree, df_vh_enable,  tvb, DSTART, 1, FALSE);
+			proto_tree_add_item(subtree, df_vl_enable,  tvb, DSTART, 1, FALSE);
+			proto_tree_add_item(subtree, df_filsel_b,   tvb, DSTART, 1, FALSE);
+			proto_tree_add_item(subtree, df_filsel_a,   tvb, DSTART, 1, FALSE);
+			proto_tree_add_item(subtree, df_bandsel,    tvb, DSTART, 1, FALSE);
+			proto_tree_add_item(subtree, df_hba_enable, tvb, DSTART, 1, FALSE);
+			proto_tree_add_item(subtree, df_lba_enable, tvb, DSTART, 1, FALSE);
+			}
+			{
+			/* Y-polarization */
+			newitem = proto_tree_add_text(newtree, tvb, DSTART, 2, "Y polarization");
+			subtree = proto_item_add_subtree(newitem, ett_rcusettings);
+			proto_tree_add_item(subtree, df_vddvcc_en,  tvb, 13, 1, FALSE);
+			proto_tree_add_item(subtree, df_vh_enable,  tvb, 13, 1, FALSE);
+			proto_tree_add_item(subtree, df_vl_enable,  tvb, 13, 1, FALSE);
+			proto_tree_add_item(subtree, df_filsel_b,   tvb, 13, 1, FALSE);
+			proto_tree_add_item(subtree, df_filsel_a,   tvb, 13, 1, FALSE);
+			proto_tree_add_item(subtree, df_bandsel,    tvb, 13, 1, FALSE);
+			proto_tree_add_item(subtree, df_hba_enable, tvb, 13, 1, FALSE);
+			proto_tree_add_item(subtree, df_lba_enable, tvb, 13, 1, FALSE);
+			}
+#endif
+		}
+		else {
+			proto_tree_add_item(epa_tree, hf_epa_data,        tvb, DSTART, -1, FALSE);
+		}
+	}
+
+	/* If this protocol has a sub-dissector call it here, see section 1.8 */
+}
+
+
+/* Register the protocol with Ethereal */
+
+/* this format is require because a script is used to build the C function
+   that calls all the protocol registration.
+*/
+
+void
+proto_register_epa(void)
+{                 
+
+	/* Setup list of header fields  See Section 1.6.1 for details*/
+	static hf_register_info hf[] = {
+	{ &hf_epa_type,
+		{ "type",	"epa.type",		FT_UINT8,  BASE_HEX, 
+			VALS(type_vals), 0x0, "Message type", HFILL 
+		}
+	},
+	{ &hf_epa_error,
+		{ "error",	"epa.error",	FT_UINT8,  BASE_DEC, 
+			VALS(mep_error_vals), 0x0, "Error indicator", HFILL 
+		}
+	},
+	{ &hf_epa_frame_size,
+		{ "frame_size",	"epa.frame_size",	FT_UINT16,  BASE_DEC, 
+			NULL, 0x0, "Frame length", HFILL 
+		}
+	},
+	{ &hf_epa_addr,
+		{ "addr",	"epa.addr",		FT_BYTES,  BASE_HEX, 
+			NULL, 0x0, "Message addressing", HFILL 
+		}
+	},
+	{ &hf_epa_offset,
+		{ "offset",	"epa.offset",	FT_UINT16, BASE_DEC, 
+			NULL, 0x0, "Register offset", HFILL 
+		}
+	},
+	{ &hf_epa_data_size,
+		{ "size",	"epa.data_size",	FT_UINT16, BASE_DEC, 
+			NULL, 0x0, "Read/write size", HFILL 
+		}
+	},
+    { &hf_epa_seqnr,
+		{ "seqnr",	"epa.seqnr",	FT_UINT16, BASE_DEC, 
+			NULL, 0x0, "Sequence number", HFILL 
+		}
+    },
+	{ &hf_epa_data,
+		{ "data",	"epa.data", 	FT_BYTES,  BASE_HEX, 
+			NULL, 0x0, "Userdata", HFILL 
+		}
+	},
+	{ &hf_epa_int16,
+		{ "payload_int16", "epa.payload_int16",		FT_INT16,  BASE_DEC, 
+			NULL, 0x0, "int16 payload", HFILL 
+		}
+    },
+	{ &hf_epa_uint16,
+		{ "payload_uint16", "epa.payload_uint16",	FT_UINT16, BASE_DEC, 
+			NULL, 0x0, "uint16 payload", HFILL 
+		}
+	},
+	{ &hf_epa_int32,
+		{ "payload_int32", "epa.payload_int32",		FT_INT32,  BASE_DEC, 
+			NULL, 0x0, "int32 payload", HFILL 
+		}
+	},
+	{ &hf_epa_uint32,
+		{ "payload_uint32", "epa.payload_uint32",	FT_UINT32, BASE_DEC, 
+			NULL, 0x0, "uint32 payload", HFILL 
+		}
+	},
+	{ &hf_epa_double,
+		{ "payload_double", "epa.payload_double",	FT_DOUBLE, BASE_DEC, 
+			NULL, 0x0, "double precision values payload", HFILL 
+		}
+	},
+  };
+
+  static hf_register_info addr_fields[] = {
+	{ &hf_epa_addr_blpid,
+		  { "blpid",		"epa.addr.blpid", 	FT_UINT8, BASE_HEX, 
+			VALS(blp_vals), 0x0, "BLP Destination ID", HFILL 
+		}
+	},
+	{ &hf_epa_addr_alpid,
+		  { "alp",			"epa.addr.alpid", 	FT_UINT8, BASE_HEX, 
+			VALS(alp_vals), 0x0, "MAIN FPGA ID", HFILL 
+		}
+	},
+	{ &hf_epa_addr_pid,
+		  { "pid",			"epa.addr.pid", 	FT_UINT8, BASE_HEX, 
+			VALS(pid_vals), 0x0, "Process ID", HFILL 
+		}
+	},
+	{ &hf_epa_addr_regid,
+		  { "regid",		"epa.addr.regid", 	FT_STRING, BASE_HEX, 
+			NULL, 0x0, "Register ID", HFILL 
+		}
+	},
+  };
+
+  static hf_register_info rspstatus_fields[] = {
+    { &df_rspstatus_voltage_1_2,
+		{ "voltage_1_2", "epa.data.rspstatus.voltage_1_2", 	FT_UINT8, BASE_DEC, 
+			NULL, 0x0,	"Measured voltage on 1.2V circuit", HFILL 
+		}
+    },
+    { &df_rspstatus_voltage_2_5,
+		{ "voltage_2_5", "epa.data.rspstatus.voltage_2_5", 	FT_UINT8, BASE_DEC, 
+			NULL, 0x0,	"Measured voltage on 2.5V circuit", HFILL 
+		}
+    },
+    { &df_rspstatus_voltage_3_3,
+		{ "voltage_3_3", "epa.data.rspstatus.voltage_3_3", FT_UINT8, BASE_DEC, 
+			NULL, 0x0,	"Measured voltage on 3.3 circuit", HFILL 
+		}
+    },
+    { &df_fpgastatus_pcb_temp,
+		{ "pcb_temp",	"epa.data.fpgastatus.pcb_temp", FT_UINT8, BASE_DEC, 
+			NULL, 0x0,	"Current Board temperature", HFILL 
+		}
+    },
+    { &df_fpgastatus_bp_temp,
+		{ "bp_temp",	"epa.data.fpgastatus.bp_temp", FT_UINT8, BASE_DEC, 
+			NULL, 0x0,	"Current Board Processor temperature", HFILL 
+		}
+    },
+    { &df_fpgastatus_ap0_temp,
+		{ "ap0_temp",	"epa.data.fpgastatus.ap0_temp", FT_UINT8, BASE_DEC, 
+			NULL, 0x0,	"Current Antenna Processor 0 temperature", HFILL 
+		}
+    },
+    { &df_fpgastatus_ap1_temp,
+		{ "ap1_temp",	"epa.data.fpgastatus.ap1_temp", FT_UINT8, BASE_DEC, 
+			NULL, 0x0,	"Current Antenna Processor 1 temperature", HFILL 
+		}
+    },
+    { &df_fpgastatus_ap2_temp,
+		{ "ap2_temp",	"epa.data.fpgastatus.ap2_temp", FT_UINT8, BASE_DEC, 
+			NULL, 0x0,	"Current Antenna Processor 2 temperature", HFILL 
+		}
+    },
+    { &df_fpgastatus_ap3_temp,
+		{ "ap3_temp",	"epa.data.fpgastatus.ap3_temp",	FT_UINT8, BASE_DEC, 
+			NULL, 0x0,	"Current Antenna Processor 3 temperature", HFILL 
+		}
+    },
+    { &df_fpgastatus_bp_clock,
+		{ "bp_clock",	"epa.data.fpgastatus.bp_clock",	FT_UINT8, BASE_DEC, 
+			NULL, 0x0,	"Current board processor system clock speed", HFILL 
+		}
+    },
+    { &df_ethstatus_nof_frames,
+		{ "nof_frames", "epa.data.ethstatus.nof_frames", FT_UINT32, BASE_DEC, 
+			NULL, 0x0, "Number of eth frames received", HFILL 
+		}
+    },
+    { &df_ethstatus_nof_errors,
+		{ "nof_errors", "epa.data.ethstatus.nof_errors", FT_UINT32, BASE_DEC, 
+			NULL, 0x0, "Number of incorrect ethernet frames", HFILL 
+		}
+    },
+    { &df_ethstatus_last_error,
+		{ "last_error", "epa.data.ethstatus.last_error", FT_UINT8, BASE_DEC, 
+			VALS(eth_error_vals), 0x0, "Error status of last received ethernet frame", HFILL 
+		}
+    },
+    { &df_mepstatus_seqnr,
+		{ "seqnr", "epa.data.mepstatus.seqnr", 			FT_UINT16, BASE_DEC, 
+			NULL, 0x0, "Sequence number of previously received message", HFILL 
+		}
+    },
+    { &df_mepstatus_error,
+		{ "error", "epa.data.mepstatus.error", 			FT_UINT8, BASE_DEC, 
+			VALS(mep_error_vals), 0x0, "Error status of previously received message", HFILL 
+		}
+    },
+	{ &df_blp_extclock,
+		{ "external clock", "epa.data.sync.extclock",	FT_UINT32, BASE_DEC, 
+			NULL, 0x0, "clockcycles between ext. and int. sync", HFILL 
+		}
+	},
+	{ &df_blp_sync,
+		{ "sync pulses   ", "epa.data.sync.count",		FT_UINT32, BASE_DEC, 
+			NULL, 0x0, "nr sync pulses since last reset", HFILL 
+		}
+	},
+	{ &df_blp_samples,
+		{ "sample count  ", "epa.data.sync.samples",	FT_UINT32, BASE_DEC, 
+			NULL, 0x0, "nr samples processed since last reset", HFILL 
+		}
+	},
+	{ &df_blp_slices,
+		{ "slice count   ", "epa.data.sync.slices",		FT_UINT32, BASE_DEC, 
+			NULL, 0x0, "nr slices in previous internal sync interval", HFILL 
+		}
+	},
+  };
+
+  static hf_register_info rspversion_fields[] = {
+    { &df_rsp_version,
+      { "rsp_version",	"epa.data.rsp_version", FT_UINT8, BASE_DEC, 
+		NULL, 0x0,	"Version of the RSP board hardware", HFILL 
+	  }
+    },
+    { &df_fpga_version,
+      { "fpga_version",	"epa.data.fpga_version", FT_UINT8, BASE_DEC, 
+		NULL, 0x0,	"Version of the fpga firmware", HFILL 
+	  }
+    }
+  };
+
+  static hf_register_info rsptimestamp_fields[] = {
+    { &df_rsp_timestamp,
+      { "rsp_timestamp", "epa.data.rsp_timestamp", FT_UINT32, BASE_DEC, 
+		NULL, 0x0, "Timestamp of the RSPinfo", HFILL 
+	  }
+    }
+  };
+
+  static hf_register_info rcusettings_fields[] = {
+    { &df_vddvcc_en,
+      { "vddvcc_en",           "epa.data.vddvcc_en",
+	FT_UINT8, BASE_HEX, NULL, 0x80, /* bit 7 */
+	"VDDVCC_EN", HFILL }
+    },
+    { &df_vh_enable,
+      { "vh_enable",           "epa.data.vh_enable",
+	FT_UINT8, BASE_HEX, NULL, 0x40, /* bit 6 */
+	"VH_ENABLE", HFILL }
+    },
+    { &df_vl_enable,
+      { "vl_enable",           "epa.data.vl_enable",
+	FT_UINT8, BASE_HEX, NULL, 0x20, /* bit 5 */
+	"VL_ENABLE", HFILL }
+    },
+    { &df_filsel_b,
+      { "filsel_b",           "epa.data.filsel_b",
+	FT_UINT8, BASE_HEX, NULL, 0x10, /* bit 4 */
+	"FILSEL_B", HFILL }
+    },
+    { &df_filsel_a,
+      { "filsel_a",           "epa.data.filsel_a",
+	FT_UINT8, BASE_HEX, NULL, 0x08, /* bit 3 */
+	"FILSEL_A", HFILL }
+    },
+    { &df_bandsel,
+      { "bandsel",           "epa.data.bandsel",
+	FT_UINT8, BASE_HEX, NULL, 0x04, /* bit 2 */
+	"BANDSEL", HFILL }
+    },
+    { &df_hba_enable,
+      { "hba_enable",           "epa.data.hba_enable",
+	FT_UINT8, BASE_HEX, NULL, 0x02, /* bit 1 */
+	"HBA_ENABLE", HFILL }
+    },
+    { &df_lba_enable,
+      { "lba_enable",           "epa.data.lba_enable",
+	FT_UINT8, BASE_HEX, NULL, 0x01, /* bit 0 */
+	"LBA_ENABLE", HFILL }
+    },
+    { &df_nof_overflow,
+      { "nof_overflow", "epa.data.nof_overflow",
+	FT_UINT32, BASE_DEC, NULL, 0x0,
+	"NOF_OVERFLOW", HFILL }
+    },
+  };
+
+  static hf_register_info wgsettings_fields[] = {
+    { &df_wg_mode,
+		{ "mode", 		"epa.data.wg.mode",			FT_UINT8, BASE_DEC, 
+			VALS(wg_mode_vals), 0x0, "Mode", HFILL 
+		}
+    },
+    { &df_wg_phase,
+		{ "phase", 		"epa.data.wg.phase", 		FT_UINT8, BASE_DEC, 
+			NULL, 0x0, "Phase", HFILL 
+		}
+    },
+    { &df_wg_nof_samples,
+		{ "nof_samples", "epa.data.wg.nof_samples", FT_UINT16, BASE_DEC, 
+			NULL, 0x0, "Number of user waveform samples", HFILL 
+		}
+    },
+	{ &df_wg_freq,
+		{ "freq", 		"epa.data.wg.freq", 		FT_UINT32, BASE_DEC, 
+			NULL, 0x0, "Frequency", HFILL 
+		}
+    },
+    { &df_wg_ampl,
+		{ "ampl", 		"epa.data.wg.ampl",			FT_UINT32, BASE_DEC, 
+			NULL, 0x0, "Amplitude", HFILL 
+		}
+    },
+  };
+
+  /* Setup protocol subtree array */
+  static gint* ett[] = {
+    &ett_epa,
+    &ett_epa_addr,
+    &ett_rspstatus,
+    &ett_rspstatus_detail,
+    &ett_fpgastatus,
+    &ett_ethstatus,
+    &ett_mepstatus,
+    &ett_diagstatus,
+    &ett_syncstatus,
+    &ett_rcustatus,
+    &ett_rcusettings,
+    &ett_rsustatus,
+    &ett_adostatus,
+    &ett_radstatus,
+    &ett_rspversion,
+    &ett_rsptimestamp,
+    &ett_wgsettings,
+    &ett_payload,
+  };
+
+  /* Register the protocol name and description */
+  proto_epa2 = proto_register_protocol("LOFAR EPA2 Protocol", "EPA2", "epa");
+
+  /* Required function calls to register the header fields and subtrees used */
+  proto_register_field_array(proto_epa2, hf, array_length(hf));
+  proto_register_field_array(proto_epa2, addr_fields, array_length(addr_fields));
+  proto_register_field_array(proto_epa2, rspstatus_fields, array_length(rspstatus_fields));
+  proto_register_field_array(proto_epa2, rspversion_fields, array_length(rspversion_fields));
+  proto_register_field_array(proto_epa2, rsptimestamp_fields, array_length(rsptimestamp_fields));
+  proto_register_field_array(proto_epa2, rcusettings_fields, array_length(rcusettings_fields));
+  proto_register_field_array(proto_epa2, wgsettings_fields, array_length(wgsettings_fields));
+  proto_register_subtree_array(ett, array_length(ett));
+}
+
+
+/* If this dissector uses sub-dissector registration add a registration routine.
+ * This format is required because a script is used to find these routines and
+ * create the code that calls these routines.
+ */
+void proto_reg_handoff_epa(void)
+{
+	dissector_handle_t epa_handle;
+
+	epa_handle = create_dissector_handle(dissect_epa, proto_epa2);
+	dissector_add("ethertype", ETHERTYPE_EPA2, epa_handle);
+}
+
+void plugin_init(plugin_address_table_t* pat)
+{
+	/* initialise the table of pointers needed in Win32 DLLs */
+	pat = pat; 				/* shut-up compiler warning on non Win32 hosts */
+	plugin_address_table_init(pat);
+
+	/* register the new protocol, protocol fields, and subtrees */
+	/* execute protocol initialization only once */
+	if (proto_epa2 == -1) { 
+		proto_register_epa();
+	}
+}
+
+void plugin_reg_handoff(void)
+{
+	proto_reg_handoff_epa();
+}
diff -Naur ethereal-0.9.8/plugins/epa2/packet-epa2.h ethereal-0.9.8-epaplugin/plugins/epa2/packet-epa2.h
--- ethereal-0.9.8/plugins/epa2/packet-epa2.h	1970-01-01 00:00:00.000000000 +0000
+++ ethereal-0.9.8-epaplugin/plugins/epa2/packet-epa2.h	2008-11-12 09:58:50.412694416 +0000
@@ -0,0 +1,29 @@
+/* packet-epa2.h
+ *
+ * $Id$
+ *
+ * Ethereal - Network traffic analyzer
+ * By Gerald Combs <gerald@ethereal.com>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __PACKET_EPA2_H__
+#define __PACKET_EPA2_H__
+
+void capture_epa2(const guchar *, int, int, packet_counts *);
+
+#endif
