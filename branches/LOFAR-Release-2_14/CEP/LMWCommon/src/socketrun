#!/bin/sh

# socketrun: Start a distributed process using socket connections
#
# Copyright (C) 2008
# ASTRON (Netherlands Institute for Radio Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands
#
# This file is part of the LOFAR software suite.
# The LOFAR software suite is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# The LOFAR software suite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with the LOFAR software suite. If not, see <http://www.gnu.org/licenses/>.
#
# @author Ger van Diepen <diepen AT astron nl>
#
# $Id$


# This script starts a distributed process to process a dataset.
# The processes will use sockets for communication.
# The processed are started in the MPI-style; a machinefile tells on which
# hosts to start a process; they also get a rank (0..n).
#
# This script is a helper script for startdistproc, but it could be used
# stand-alone as well.
#
# run as: socketrun dry hfn masterhost port wait killfail logfile program envfile
#                   [arg1 arg2 ...]
#
#   dry!=0      means that the command is only printed, not executed.
#   hfn         is the name of an MPI-style machinefile. Each line in it
#               looks like:  host#part,filesys,partvds
#                host     name of the host to start a process on
#                part     name of the dataset part to process on the host
#                filesys  the file system the dataset part is on
#                partvds  name of the VDS-file of the dataset part
#   masterhost  the host the master process is running on; if empty, the first
#               host in the machine file is the master host.
#   port        the port the master host process is using and where the workers
#               can connect to.
#               Note that it is up to implementation to use a masterhost/port.
#               E.g. mwimager only starts distributed processes, but they do
#               not communicate, so there is no master.
#   wait=1      means that socketrun waits for all processes to end.
#   killfail=1  means that all other remote processes are killed if one fails.
#               It is only used if wait=1.
#   logfile     name of the log file to use; It will be suffixed with '-rank'
#               where rank is the process rank.
#   program     name of the program to start.
#   envfile     name of the envfile generated by startdistproc.
#   arg-i       extra arguments directly passed to the program started.
#
# The processes are started with the following fixed arguments:
#   socket      a string with the value 'socket'.
#   masterhost  name of the master host
#   port        port on master host
#   np          number of processes started
#   rank        process rank (0..np-1)
#   part        name of dataset part to process
#   filesys     file system dataset part is on
#   partvds     name of VDS-file describing dataset part
# Thereafter the variable arguments (passed to socketrun) are given.


dry="$1"
shift
hfn="$1"
shift
masterhost="$1"
shift
port="$1"
shift
wait="$1"
shift
killfail="$1"
shift
logfile="$1"
shift
program="$1"
shift
envfile="$1"
shift

np=`wc -l "$hfn" | awk '{print $1}'`

# The first host is the master one.
pidlist=
rank=0

# Start a remote process for each line in the hfn file.
while read inline
do
  if test "$inline" != ""; then
    host=`echo $inline | awk -F'#' '{print $1'}`
    rest=`echo $inline | awk -F'#' '{print $2'}`
    part=`echo $rest | awk -F',' '{print $1'}`
    fsys=`echo $rest | awk -F',' '{print $2'}`
    partvds=`echo $rest | awk -F',' '{print $3'}`
    if test "$part" = ""; then
      part=.
    fi
    if test "$fsys" = ""; then
      fsys=.
    fi
    if test "$partvds" = ""; then
      partvds=.
    fi
    if test "$masterhost" = ""; then
      masterhost="$host"
    fi
    # Quote all arguments ("$@" does not work over ssh).
    arg=
    for a in "$@"
    do
      arg="$arg '$a'"
    done
    echo "ssh -x -n '$host' '$program' socket '$masterhost' $port $np $rank '$part' '$fsys' '$partvds' '$envfile' $arg" " &"
    if test "$dry" = 0; then
      if test "$logfile" = ""; then
        # Use extra quotes in argument that might contain whitespace.
        ssh -o NoHostAuthenticationForLocalhost=yes -o NumberOfPasswordPrompts=0 -x -n "$host" "'$program'" socket "'$masterhost'" "'$port'" "$np" "$rank" "'$part'" "'$fsys'" "'$partvds'" "'$envfile'" $arg &
      else
        ssh -o NoHostAuthenticationForLocalhost=yes -o NumberOfPasswordPrompts=0 -x -n "$host" "'$program'" socket "'$masterhost'" "'$port'" "$np" "$rank" "'$part'" "'$fsys'" "'$partvds'" "'$envfile'" $arg > "$logfile-$rank" 2>&1 &
      fi
      pidlist="$pidlist $!"
    fi
    rank=`expr $rank + 1`
  fi
done < "$hfn"

# If needed, wait for the processes to end.
# If a process ended unsuccessfully, kill the others if needed.
status=0
ignoreStatus=0
if test "$wait" = 1; then
  if test "$killfail" = 1; then
    # After the kill the processes won't exist anymore, so accept status 127
    # in the wait further on.
    ignoreStatus=127
    # If killonfail, wait for the first process to end.
    # Poll every second.
    cont=1
    while test $cont = 1
    do
      sleep 1
      seqnr=0
      for pid in $pidlist
      do
        if ! kill -0 $pid > /dev/null 2>&1; then
          cont=0
          break
        fi
        seqnr=`expr $seqnr + 1`
      done
    done
    if test -f "$envfile.pid-$seqnr"; then
      status=`grep '^status=' "$envfile.pid-$seqnr" | sed -e 's/status=//'`
    fi
    if test $status != 0; then
      echo "Remote process (pid=$pid) with rank $seqnr ended with error status $status"
      echo "Killing the other remote processes ..."
      rank=0
      for inline in `cat "$hfn"`
      do
        if test $rank != $seqnr  -a  -f "$envfile.pid-$rank"; then
          host=`echo $inline | awk -F'#' '{print $1'}`
          rempid=`grep '^pid=' "$envfile.pid-$rank" | sed -e 's/pid=//'`
          echo "ssh -x $host kill -9 $rempid"
          if test "$logfile" = ""; then
            ssh -o NoHostAuthenticationForLocalhost=yes -o NumberOfPasswordPrompts=0 -x -n "$host" kill -9 "$rempid"
          else
            ssh -o NoHostAuthenticationForLocalhost=yes -o NumberOfPasswordPrompts=0 -x -n "$host" kill -9 "$rempid" >> "$logfile-$rank"
          fi
        fi
        rank=`expr $rank + 1`
      done
    fi
  fi
  # Wait for all processes.
  # Ignore status in case the pid does not exist anymore (error 127).
  for pid in $pidlist
  do
    wait $pid > /dev/null 2>&1
    stat=$?
    if test $stat != 0  -a  $stat != $ignoreStatus; then
      status=$stat
    fi
  done
fi

exit $status
