#!/bin/bash 
#
# loadComponents : loads all components in an OTDB database
#
# Copyright (C) 2006-2012
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Syntax: load_components databasename
#
# $Id$
#
VERSION="v2.1"		# Implemented complete new algorithm that works top down iso bottom up.

# SyntaxError msg
#
SyntaxError()
{
	Msg=$1

	[ -z "${Msg}" ] || echo "ERROR: ${Msg}"
	echo ""
	echo "Syntax: $(basename $0) -D databasename [-v versionnr] [-q qualifier]" 
	echo "                       [-H hostname] [-d directory]"
	echo "        - databasename is always needed"
	echo "        - versionnumber is svn revision number (max 6 digits) [Current]"
	echo "        - qualifier can be development|test|operational|example []"
	echo "        - hostname is the hostname of the database server [sas001]" 
	echo "        - directory is the path to the executable load_OTDB_comps [/opt/lofar/bin]"
	echo ""
}

#
# Construct a file that contains node-childnode relations and the file it is mentioned in
# Syntax: componentname file | componentname.childname file
#
makeRelationsFile()
{
	# grep all 'node' and 'uses' lines in all (g)comp files and pipe them through an awk filter
	# that print the 'node' lines as 'node file' and the 'uses' lines as 'parent child uses'
	egrep "^(node|table|uses)[[:space:]]" *comp | sed "s/comp:/comp /" | sed "s/ table[[:space:]]/ node /" | awk '
		/comp node/,/comp node/	{ print $3,$1; parent=$3; next }
								{ print parent,$3,$2 }
	' | while read first second marker
	do
		if [ "$marker" == "uses" ]; then
			# first=parentname, second=childname
			# childname can be plain name or table reference like InputFile<Dataproduct>
			# in that case we need the table name
			# note that the original name is returned in the next line if the < and > are not used.
			nodeName=`echo $second | cut -d'<' -f2 | cut -d'>' -f1`
			newFile=`egrep "^(node|table)[[:space:]]+$nodeName[[:space:]]+" *comp | cut -d':' -f1`
			echo "$first.$nodeName $newFile" >> ${RELATIONFILE}
		else
			echo "$first $second" >>${RELATIONFILE}
			echo -n "."
		fi
	done
	echo "."
}

#
# Recursive solve the childs of the current node and construct a level-file
# with syntax: levelnr componentname file
# 
# solveNode(nodename, level)
solveNode() 
{
	echo -n "." 
	egrep "^$1[ \.]" ${RELATIONFILE} | while read node file
	do
		if [ "$node" == "$1" ]; then		# node itself
			echo $2 $node $file >>${LEVELFILE}
		else	# its a child
			let childlevel=$2+1
			childnode=`echo $node | cut -d'.' -f2`
			solveNode $childnode $childlevel
		fi
	done
}

#
# Construct the orderfile based on the levelfile, in the mean time construct a list on non used files
# Syntax: file
#
makeOrderFile()
{
	prevLevel=0
	>${ORDERFILE}
	# list file, remove componentname, sort reverse on numbers, skip doubles
	cat ${LEVELFILE} | awk '{ print $1, $3 }' | sort -rn | uniq | while read level file
	do
		if [ "$prevLevel" != "$level" ]; then
			echo -n "$level "
			prevLevel=$level
		fi
		
		# update file admin
		grep -v ^${file} ${UNUSEDFILES} >${WORKFILE}
		mv ${WORKFILE} ${UNUSEDFILES}
		egrep ^${file} ${ORDERFILE} >/dev/null
		if [ $? == 1 ]; then # found?
			echo $file >>${ORDERFILE}
		fi
	done
	echo ""
}

#
# MAIN
#

# check invocation syntax

DATABASE=
VERSION=`svn info | grep Revision | awk '{print $2}'`
QUAL=
HOST=`hostname -s`
DIR="/opt/lofar/bin"

while getopts "hD:v:q:H:d:" OPTION
do
     case $OPTION in

         h)
             SyntaxError
             exit 1
             ;;
	 D)
	     DATABASE=$OPTARG
	     ;;
         v)
             VERSION=$OPTARG
             ;;
	 q)
	     QUAL=$OPTARG
	     ;;
	 H)
	     HOST=$OPTARG
	     ;;
	 d)
	     DIR=$OPTARG
	     ;;
	 ?)
             SyntaxError
             exit 1
             ;;
       esac
done

if [[ -z $DATABASE ]]; then 
  echo "Please provide a database name!"
  SyntaxError
  exit
fi

if [ -e $DIR/load_OTDB_comps ]; then 
  # We use a lot of tmpfile to make life easier.
  RELATIONFILE=/tmp/relations
  LEVELFILE=/tmp/levels
  ORDERFILE=/tmp/fileOrder
  UNUSEDFILES=/tmp/unusedFiles
  WORKFILE=/tmp/tmpFile4load_components

  # First construct gcompfile using .base-files.
  ./create_OTDB_comps

  # cleanup old stuff
  rm -f ${RELATIONFILE} ${LEVELFILE} ${ORDERFILE} ${UNUSEDFILES}

  # construct new relationsfile
  echo -n "Analysing relations: "
  makeRelationsFile

  # strip off layer for layer
  echo -n "Analysing dependancy levels: "
  solveNode LOFAR 1
  echo "."

  # construct a file with all componentfiles
  ls -1 *comp >${UNUSEDFILES}

  # Finally construct the load-order file
  echo -n "Analysing load order: "
  makeOrderFile
  rm -f ${RELATIONSFILE} ${LEVELFILE}

  # Construct commandline for load_OTDB_comps
  arguments=$DATABASE
  arguments=$arguments" "${ORDERFILE}
  arguments=$arguments" -v "$VERSION 
  arguments=$arguments" -h "$HOST
  if [ "$QUAL" != "" ]; then 
    arguments=$arguments" -q "$QUAL 
  fi
  echo "Executing: $DIR/load_OTDB_comps $arguments 2>&1 | tee load_components.log"
  $DIR/load_OTDB_comps $arguments 2>&1 | tee load_components.log
  # when there are files we didn't use report that to the user
  if [ -s ${UNUSEDFILES} ]; then
	echo
	echo "  The following files are NOT LOADED into the database because they are NOT part of the current defined LOFAR tree:"
	cat ${UNUSEDFILES}
  fi

  # Cleanup
  rm -f ${UNUSEDFILES} ${ORDERFILE}
else
  echo "Cannot execute $DIR/load_OTDB_comps (not there, or not executable)"
fi

exit


