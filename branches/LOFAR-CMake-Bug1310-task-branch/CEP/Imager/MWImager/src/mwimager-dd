#!/usr/bin/env python

# mwimager-dd: mwimager to do direction-dependent corrections
#
# Copyright (C) 2009
# ASTRON (Netherlands Institute for Radio Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands
#
# This file is part of the LOFAR software suite.
# The LOFAR software suite is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# The LOFAR software suite is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with the LOFAR software suite. If not, see <http://www.gnu.org/licenses/>.
#
# @author Ger van Diepen <diepen AT astron nl>
#
# $Id$

# This script creates images corrected for direction-dependent effects
# in a faceted way. It uses BBS to apply the direction-dependent corrections.

# 1. Use pyquanta to read the ra,dec,cellsize (with default arcsec as unit)
# 2. Make facet list for BBS and run setupsourcedb
# 3. Loop over facet and do BBS, DPPP, and mwimager for each facet.
#    Each of them runs in a distributed way.
#    BBS is only run if correct=T is given.
#    DPPP is only run if average=T is given
#
# parset keywords:
#
#  correct = False
#  Correct.Model.Beam.Element.Type = ""
#  Correct.Model.Beam.Element.Path = "$LOFARROOT/share"
#  Correct.Model.Beam.StationConfig.Name
#  Correct.Model.Beam.StationConfig.Path = "/home/zwieten/StationConfig"
#  Correct.column       = CORRECTED_DATA   # output column after correction
#  Correct.instrumentName = instrument
#  BBDB.Host = ldb001
#  BBDB.Port
#  BBDB.Name
#  BBDB.Username
#  BBDB.Password
#  Images.name
#  Images.ra            = 10:23:53.68
#  Images.dec           = 34.51.04.98
#  Images.shape         = [1024,1024]
#  Images.cellSize      = [20,20]          # default unit is arcsec
#  Images.nfacets       = 8                # nfacets in ra and dec
#  Images.padding       = 2                # padding factor in ra and dec
#  dataset              = my.MS.gds
#  datacolumn           = DATA             # input data column
#  average       = False
#  Average.nfreq = 1
#  Average.ntime = 1
#
# An alternative (and slightly better) approach would be to run mwimager-dd-part
# in a distributed way, which does BBS, DPPP, and mwimager for each facet.
# However, that requires a non-distributed version of BBS which does not exist.
#
# Several temporary files are created to deal with the various steps to
# process MSs called msdir/xxx-SBn.MS described in gdsdir/xxx.MS.gds.
# - gdsdir/facetlist.txt contains the facet centers in ASCII format
# - xxx.facet contains the distributed sourcedb
# - parset files for BBS, DPPP, and mwimager
#    they use the same name as the input parset with an extra extension
#    like -dppp. 
# - images per facet to be combined into the final image; they are called
#    msdir/xxx-SBn
# - the optional output of DPPP called msdir/xxx-SBn.MS-dppp and its GDS file
#    gdsdir/xxx.MS-dppp.gds
# - the image per facet per subband called msdir/xxx-SBn-nnn-nnn.img
# - the overall image per subband called msdir/xxx-SBn.img
#    (for cimager this is a symlink to the .restored image)
# - the overall image gds file called gdsdir/xxx.img.gds
# - when correcting, the MS gets an extra column to hold the corrected data
#    (given in correct.Column)


import os
import sys
import math
import lofar.parameterset as parset
import pyrap.quanta as pyquan

# Remove .gds from name.
def getGdsbase(gdsname):
    gdsbase = gdsname
    if gdsbase.endswith ('.gds'):
        gdsbase = gdsbase[:-4]
    return gdsbase

# Remove .MS or .MS.gds from name.
def getBase(name):
    base = name
    if base.endswith ('.gds'):
        base = base[:-4]
    if base.endswith ('.MS'):
        base = base[:-3]
    return base

def getInfo (ps, gdsname, nfacet):
    # Get center of image.
    # It can be given in the parset, otherwise take it from the GDS file.
    pgds = parset.parameterset(gdsname)
    if ps.isDefined ('Images.ra'):
        ra  = ps.getString('Images.ra')
        dec = ps.getString('Images.dec')
    else:
        ra  = pgds.getString('FieldDirectionRa')
        dec = pgds.getString('FieldDirectionDec')
    # Get the directory name of the first MS in the gds file.
    msdir = os.path.dirname(pgds.getString('Part0.FileName'))
    # Read string and convert to radians.
    qra  = pyquan.quantity(ra)
    qdec = pyquan.quantity(dec)
    ra  =  qra.get_value("rad")
    dec = qdec.get_value("rad")
    # Get other info.
    npix   = ps.getIntVector("Images.shape")
    cellsz = ps.getStringVector("Images.cellSize")
    # Copy value if only one given.
    if len(npix) == 1:
        npix = (npix[0], npix[0])
    # Check if nfacet divides npix integrally.
    if npix[0]%nfacet != 0  or  npix[1]%nfacet != 0:
        raise ValueError, "npix is not an integral multiple of nfacet"
    if len(cellsz) == 1:
        cellsz = (cellsz[0], cellsz[0])
    # Convert cellsize to radians; default unit is arcsec.
    for i in range(2):
        csz = cellsz[i]
        ls = len(csz)
        if ls > 0  and  csz[ls-1] >= '0'  and  csz[ls-1] <= '9':
            csz += 'arcsec'
        qcsz  = pyquan.quantity(csz)
        cellsz[i] = qcsz.get_value("rad")
    return (ra,dec,cellsz,npix,msdir)

def makeFacetSourceList (name, ra, dec, cellwidth, nfacet, imgshape):
    # ra and dec give the image center; cellwidth the width in ra and dec.
    # In declination the facets are placed at distances of cellwidth[1].
    # In right ascension the length is declination dependent.
    # Only at the equator 1 arcsec in image width is 1 arcsec in RA.
    # At dec=d 1 arcsec in RA is 1*cos(d) arcsec in image width
    # (like on earth 360deg = 40000km*cos(d) at dec=d).
    # Note that RA is counter-clockwise.
    facetwidth = (cellwidth[0] * imgshape[0] / nfacet,
                  cellwidth[1] * imgshape[1] / nfacet)
    centers = []
    f = open(name, 'w')
    f.write ('#( Name,Type,Ra,Dec )=format\n')
    decv = dec - facetwidth[1] * (nfacet-1.)/2.
    for j in range(nfacet):
        rawidth = facetwidth[0] / math.cos(decv)
        rav = ra + rawidth * (nfacet-1.)/2.
        for i in range(nfacet):
            centers.append ((rav, decv))
            f.write ("facet-%03d-%03d, Point, %.15f, %.15f\n" % (i,j,rav,decv))
            rav -= rawidth
        decv += facetwidth[1]
    f.write ("# imagecenter=%.10f,%.10f  imageshape=%d,%d  cellwidth=%.10f,%.10f\n" % (ra,dec,imgshape[0],imgshape[1],cellwidth[0],cellwidth[1]))
    return centers

def doBBS (ps, i, j, psname, gdsname, cd, wd, dry, instname, skyname, catname, incol, outcol):
    if dry == 'dry':
        dry = '--dry --verbose'
    else:
        dry = '--verbose'
    print 'doBBS facet',i,j
    # Get BBDB info.
    bbdbhost = ps.getString ('BBDB.Host', 'ldb001')
    bbdbport = ps.getString ('BBDB.Port', '5432')
    bbdbname = ps.getString ('BBDB.Name', '')
    bbdbuser = ps.getString ('BBDB.Username', 'postgres')
    bbdbpw   = ps.getString ('BBDB.Password', '')
    # Get beam info and station config info.
    beamType = ps.getString ('Correct.Model.Beam.Element.Type', '')
    beamPath = ps.getString ('Correct.Model.Beam.Element.Path', '$LOFARROOT/share')
    configName = ps.getString ('Correct.Model.Beam.StationConfig.Name', '')
    configPath = ps.getString ('Correct.Model.Beam.StationConfig.Path', '/home/zwieten/StationConfig')
    # Create the parset file for the calibrate run.
    bbskey = "bbs-%03d-%03d" % (i, j)
    psn = psname + '-' + bbskey
    f = file(psn, 'w')
    f.write ('Strategy.Stations = []\n')
    f.write ('Strategy.InputColumn = %s\n' % incol)
    f.write ('Strategy.TimeWindow = []\n')
    f.write ('Strategy.ChunkSize = 1000\n')
    f.write ('Strategy.UseSolver = F\n')
    f.write ('Strategy.Correlation.Selection = CROSS\n')
    f.write ('Strategy.Correlation.Type = []\n')
    f.write ('Strategy.Steps = [correct]\n')
    f.write ('Step.correct.Correlation.Selection = CROSS\n')
    f.write ('Step.correct.Correlation.Type = []\n')
    f.write ('Step.correct.Baselines.Station1 = []\n')
    f.write ('Step.correct.Baselines.Station2 = []\n')
    f.write ('Step.correct.Model.Sources    = [facet-%03d-%03d]\n' % (i,j))
    if len(beamType) > 0:
        f.write ('Step.correct.Model.Beam.Enable = T\n')
        f.write ('Step.correct.Model.Beam.Element.Type = %s\n' % beamType)
        if len(beamPath) > 0:
            f.write ('Step.correct.Model.Beam.Element.Path = %s\n' % beamPath)
        f.write ('Step.correct.Model.Beam.StationConfig.Name = %s\n' % configName)
        f.write ('Step.correct.Model.Beam.StationConfig.Path = %s\n' % configPath)
    f.write ('Step.correct.Operation             = CORRECT\n')
    f.write ('Step.correct.Output.Column         = %s\n' % outcol)
    f.close()
    os.system ("cat " + psn)
    command = '%s --clean --key %s --cluster-desc "%s" --instrument-name "%s" --sky-name "%s" --skip-instrument-db --skip-sky-db "%s" "%s" "%s" "%s"' % (dry, bbskey, cd, instname, skyname, gdsname, psn, catname, wd)
    command = ('--db %s:%s --db-user %s ' % (bbdbhost,bbdbport,bbdbuser)) + command
    if len(bbdbname) > 0:
        command = ('--db-name %s ' % bbdbname) + command
    print 'calibrate ' + command
    os.system('calibrate ' + command)

def doDPPP (i, j, psname, gdsname, cd, dry, freqstep, timestep):
    # Create the parset file.
    gdsdir = os.path.dirname(gdsname)
    gdsbase = getBase(gdsname)
    psn = psname + '-dppp'
    print 'doDPPP facet',i,j,psn,gdsname,cd,dry
    f = file(psn, 'w')
    f.write('skipflags=False\n')
    f.write('allcolumns=True\n')
    f.write('squasher=1\n')
    f.write('timestep=%d\n' % timestep)
    f.write('step=%d\n' % freqstep)
    f.write('clusterdesc=%s\n' % cd)
    f.write('vdsdir=%s\n' % gdsdir)
    f.close()
    os.system ('rundist -cdn %s mwimager-dd-dppp "%s" "%s" "%s"' % (cd,gdsname,psn,dry))
    if dry == 'dry':
        # Make a copy in dry mode, so next steps work well in dry mode.
        os.system ('cp %s %s.MS-dppp.gds' % (gdsname,gdsbase))
        print 'combinevds %s.MS-dppp.gds %s*.MS-dppp.vds' % (gdsbase,gdsbase)
    else:
        os.system ('combinevds %s.MS-dppp.gds %s*.MS-dppp.vds' % (gdsbase,gdsbase))

def doImager (ps, gdsname, imageext, i, j, center, psname, cd, wd, logfile, dry, hfn, casaopt, pgmpath):
    print 'doImager facet',i,j,center
    # Convert the parset file to a parset file for the facet.
    # It means inserting a new center and image name.
    ps.replace ("Images.ra",  '%.15frad' % center[0])
    ps.replace ("Images.dec", '%.15frad' % center[1])
    ps.replace ("dataset", gdsname)
    newName = '%s-%03d-%03d' % (imageext, i ,j)
    ps.replace ("Images.name", newName)
    psn = "%s-%03d-%03d" % (psname, i, j)
    ps.writeFile (psn)
    print '%s/mwimager %s %s "%s" "%s" "%s" "%s" "%s"' % (pgmpath, casaopt, psn, cd, wd, logfile, dry, hfn)
    os.system ('%s/mwimager %s %s "%s" "%s" "%s" "%s" "%s"' % (pgmpath, casaopt, psn, cd, wd, logfile, dry, hfn))

def clean():
    os.system ('rm -rf *parset-*')
    os.system ('rm -rf *-[0-9][0-9][0-9]-[0-9][0-9][0-9]*')

def main(argv=None):
    if argv is None:
        argv = sys.argv
    pgmpath = os.path.dirname(argv[0])
    if len(argv) != 8:
        print sys.stderr, 'run as:  mwimager-dd parset-file clusterdesc wd logfile dry hfn usecasa'
        return 1

    # Get arguments.
    psn     = os.path.abspath(argv[1])
    cd      = argv[2]
    wd      = argv[3]
    logfile = argv[4]
    dry     = argv[5]
    hfn     = argv[6]
    casaopt = argv[7]

    # Open the parset file.
    ps  = parset.parameterset(psn)
    # Determine which dataset and columns to use.
    gdsname = os.path.abspath (ps.getString('dataset'))
    incol = ps.getString('datacolumn')
    outcol = incol
    correct = ps.getBool ('correct', False)
    if correct:
        outcol = ps.getString('Correct.column')
        if incol == outcol:
            print sys.stderr, 'datacolumn and correctcolumn have to be different'
            return 1
        instname  = ps.getString ('Correct.instrumentName', 'instrument')

    # Get info from the parset file and GDS file.
    nfacet  = ps.getInt('Images.nfacets')
    padding = ps.getDouble ('Images.padding', 2)
    average = ps.getBool ('average', False)
    freqavg = ps.getInt ('Average.nfreq', 1)
    timeavg = ps.getInt ('Average.ntime', 1)
    average = average and (freqavg!=1 or timeavg!=1)
    (ra,dec,cellsz,npix,msdir) = getInfo (ps, gdsname, nfacet)
    # If no working directory given, use that of the MS.
    if len(wd) == 0:
        wd = msdir
    # Form the output image name.
    # Remove parts before / and after .
    imageext  = ps.getString('Images.name', '')
    imagebase = os.path.basename(gdsname).split('.')[0] + imageext
    print ra,dec,cellsz,npix,nfacet,average,freqavg,timeavg,average,imagebase

    # Form the facet centers and source list for BBS.
    gdsdir =  os.path.dirname(gdsname)
    catname = gdsdir + '/facetlist.txt'
    skyname = 'facets'
    centers = makeFacetSourceList(catname, ra, dec, cellsz, nfacet, npix)

    # Remove the parameters not needed for an image per facet.
    ps.remove ("Images.nfacets")
    ps.remove ("Correct.column")
    ps.remove ("Correct.instrumentDB")
    # Put the sizes per facet in the parset object.
    # Take padding into account.
    factor = padding/nfacet
    ps.replace ("Images.shape", '[%d, %d]' % (int(npix[0]*factor+0.5), int(npix[1]*factor+0.5)))
    ps.replace ("Images.cellSize", '[%.15frad, %.15frad]' % (cellsz[0], cellsz[1]))
    ps.replace ("datacolumn", outcol)

    # Create the source data base for the facet centers.
    if dry == 'dry':
        os.system ('cat %s' % (catname))
    print 'os.system (setupsourcedb -overwrite %s %s facets "%s" "%s" "%s" "%s" "%s"' % (gdsname,catname,cd,logfile,dry,hfn,wd)
    os.system ('setupsourcedb -overwrite %s %s facets "%s" "%s" "%s" "%s" "%s"' % (gdsname,catname,cd,logfile,dry,hfn,wd))

    # Do the processing for each facet.
    inx = 0
    for i in range(nfacet):
        for j in range(nfacet):
            if correct:
                doBBS (ps, i, j, psn, gdsname, cd, wd, dry, instname, skyname, catname, incol, outcol)
            gdsin = gdsname
            if average:
                gdsin = getGdsbase(gdsname) + '-dppp.gds'
                doDPPP (i, j, psn, gdsname, cd, dry, freqavg, timeavg)
            doImager (ps, gdsin, imageext, i, j, centers[inx], psn, cd, wd, logfile, dry, hfn, casaopt, pgmpath)
            inx += 1

    # Combine all facets.
    print 'makeCombinedImage ...'
    # Create the parset file for combining the facets.
    psnm = psn + '-combine'
    f = file(psnm, 'w')
    f.write ('useHDF5 = False\n')
    f.write ('ra  = %.15f\n' % ra)
    f.write ('dec = %.15f\n' % dec)
    f.write ('npix = [%d,%d]\n' % (npix[0], npix[1]))
    f.write ('nfacet = [%d,%d]\n' % (nfacet, nfacet))
    f.close()
    os.system ('cat ' + psnm);
    print 'rundist -cdn %s -gdsout img.gds %s/makeCombinedImage-part %s %s "%s" "%s"' % (cd, pgmpath, gdsname, psnm, imageext, dry)
    os.system ('rundist -cdn %s -gdsout img.gds %s/makeCombinedImage-part %s %s "%s" "%s"' % (cd, pgmpath, gdsname, psnm, imageext, dry))
    


if __name__ == "__main__":
    sys.exit(main())
