class ITRFDirectionFunc
{
    Ptr;
    ConstPtr;

    vector3r_t operator()(real_t time, const vector3r_t &position) const

    * mutable cache (if required)
};

class PhasedArrayStation
{
    matrix22c_t response(real_t time,
        const ITRFDirectionFunc::ConstPtr &direction,
        real_t freq, real_t freq0) const;

    template <typename T, typename U>
    void response(size_t count, real_t time,
        const ITRFDirectionFunc::ConstPtr &direction,
        T freq, T freq0, U response) const;

    template <typename T, typename U>
    void response(size_t count, real_t time,
        const ITRFDirectionFunc::ConstPtr &direction,
        T freq, real_t freq0, U response) const;

    diag22c_t arrayFactor(real_t time,
        const ITRFDirectionFunc::ConstPtr &direction,
        real_t freq, real_t freq0) const;

    template <typename T, typename U>
    void arrayFactor(size_t count, real_t time,
        const ITRFDirectionFunc::ConstPtr &direction, T freq, T freq0, U af)
        const;

    template <typename T, typename U>
    void arrayFactor(size_t count, real_t time,
        const ITRFDirectionFunc::ConstPtr &direction, T freq, real_t freq0,
        U af) const;
};


PhasedArrayStation:

matrix22c_t response(real_t time, const vector2r_t &direction, real_t freq,
    real_t freq0)

matrix22c_t response(real_t time, const vector3r_t &direction, real_t freq,
    real_t freq0)

    => compute station0 from time, position, and station0 (J2000) property
    =>



HBATile
    matrix22c_t response(real_t time, const vector2r_t &direction, real_t freq)
        => compute tile0 from time, position, and tile0 (J2000) property?

steeringVector(positions, direction / k, freq)?


station0, tile0 should be constant for the whole array (?), and over frequency,
and in some cases (zenith) over time as well.
        => user performs the conversion?
        => convert within PhasedArrayStation/AntennaField/etc. (at the cost of
           unnecessary conversions).

matrix22c_t response(const MEpoch &epoch, const MDirection &direction,
        real_t frequency, real_t freq0) ??

...



AntennaElement
    => LBADualDipole
    => HBATile

    => response(time, direction, freq)
       arrayfactor(time, direction, freq)

AntennaField
    => element positions
    => antenna element instance

PhasedArrayStation
    => several AntennaFields


AntennaElement
    => LBADualDipole
    => HBATile (needs tile ref. direction) (may need time to convert?)
    => Need PQR definition to compute theta, phi, and parallactic angle.
        => Except when specifying in theta, phi in the first place (but how about tile ref. direction in that case?)
    => response(direction)
