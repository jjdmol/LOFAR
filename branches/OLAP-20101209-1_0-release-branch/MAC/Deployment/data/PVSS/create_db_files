#/bin/bash
#
# create_db_file : Creates files for generating the PVSS and OTDB contents
#
# Copyright (C) 2006
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Syntax: genDBbase modulename precompiled_headerfiles
#
# The generated files must be manually adjusted before they
# can be used by genDBcode.
#
# $Id$
#
VERSION="v2.0"

#
# SyntaxError msg
#
SyntaxError()
{
	Msg=$1

	[ -z "${Msg}" ] || echo "ERROR: ${Msg}"
	echo ""
	echo "Syntax: $(basename $0) [-d destdir] [-s station | -C | -M]"
	echo "    destdir      Relative directory where the resultfiles are placed."
	echo "    station      Name of the station. When omitted the datapoints"
	echo "                 for the main database are generated."
	echo "                 When '-s localhost' is given, files for current station are"
	echo "                 created. Use this for deploying field stations!"
        echo "                 Output dir is then /opt/pvss/dpdef (overrules -d)"
	echo "    -C           CEP datapoints are created (overrules -s)"
	echo "    -M           MainCU datapoints are created (overrules -s)"
	echo "    Default option is -M"
	exit 1
}

#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
cleanlist()
{
	cut -d"#" -f1 $1 | awk '{ if (NF > 0) print $0 }'
}

#
# concatfile filename
#
# concatinates all lines of the file
concatfile()
{
	cleanlist $1 | while read line rest
	do
		result=$result":"$line
		echo $result
	done | tail -1 | sed "s/^://"
}

#
# create_ring_station_list
#
create_ring_station_list()
{
	# stationname ID stationType ...
	cleanlist ${STATIONINFOFILE} | awk '{ 
		if ($3 == "C") {
			print "Core_"$1
		}
		else if ($3 == "R") {
			print "Remote_"$1
		}
		else {
			print "Europe_"$1
		}
	} ' >>/tmp/rslist
	concatfile /tmp/rslist
	rm -f /tmp/rslist
}

#
# create_wan_switch_list
#
create_wan_switch_list()
{
	cleanlist ${WANFILE} | while read wan
	do 
		cleanlist ${wan}Wan.list | awk -v WAN=${wan} \
		'{ 
			print WAN"_"$1 
		}'
	done	>>/tmp/wslist
	concatfile /tmp/wslist
	rm -f /tmp/wslist
}

#
# labelize somename
#
# Capitalizes the name preceding initial capitals with an _
labelize()
{
	echo $1 | sed "s/[A-Z][a-z]/_&/g" | sed "s/^_//" | sed "s/\./_/g" | \
		awk '{ print toupper($1) }'
}

#
# substitute_adder
#
# syntax of the lines must be: dp dpt
#
substitute_adder()
{
	awk '
	{
		hasAdder=index($1,"@adder@");
		if (hasAdder > 0) {
			for (adNr = 0; adNr < 256; adNr++) {  
				printf "Adder%d	%s\n", adNr, $2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_inputbuffer
#
# syntax of the lines must be: dp dpt
#
substitute_inputbuffer()
{
	awk '
	{
		hasInputBuffer=index($1,"@inputbuffer@");
		if (hasInputBuffer > 0) {
			for (ibNr = 0; ibNr < 128; ibNr++) {  
				printf "InputBuffer%d	%s\n", ibNr, $2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_storage
#
# syntax of the lines must be: dp dpt
#
substitute_storage()
{
	awk '
	{
		hasStorage=index($1,"@storage@");
		if (hasStorage > 0) {
			for (sNr = 0; sNr < 192; sNr++) {  
				printf "Storage%d	%s\n", sNr, $2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_BGP
#
# syntax of the lines must be: dp dpt
#
substitute_BGP()
{
	awk '
	{
		hasBGP=index($1,"@bgp@");
		if (hasBGP > 0) {
			for (bgp=0; bgp<2; bgp++) {
				dpname=$1;
				sub("@bgp@", "BGP"bgp, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_BGP_midplane
#
# syntax of the lines must be: dp dpt
#
substitute_BGP_midplane()
{
	awk '
	{
		hasBGPMid=index($1,"@bgp@_@midplane@");
		if (hasBGPMid > 0) {
			for (midplane=0; midplane<4; midplane++) {
				dpname=$1;
				bgp=int(midplane/2)
				sub("@bgp@_@midplane@", "BGP"bgp"_Midplane"midplane, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_BGP_midplane
#
# syntax of the lines must be: dp dpt
#
substitute_BGP_midplane()
{
	awk '
	{
		hasBGPMid=index($1,"@bgp@_@midplane@");
		if (hasBGPMid > 0) {
			for (midplane=0; midplane<4; midplane++) {
				dpname=$1;
				bgp=int(midplane/2)
				sub("@bgp@_@midplane@", "BGP"bgp"_Midplane"midplane, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}
#
# substitute_BGP_midplane_ionode\
#
# syntax of the lines must be: dp dpt
#
substitute_BGP_midplane_ionode()
{
	awk  '
	{
		hasBGPMidIONode=index($1,"@bgp@_@midplane@_@ionode@");
		if (hasBGPMidIONode > 0) {
			for (ionode=0; ionode<128; ionode++) {
				dpname=$1;
				bgp=int(ionode/64)
				midplane=int(ionode/32)
				sub("@bgp@_@midplane@_@ionode@", "BGP"bgp"_Midplane"midplane"_IONode"ionode, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_osrack
#
# syntax of the lines must be: dp dpt
#
substitute_osrack()
{
	awk '
	{
		hasOSRack=index($1,"@osrack@");
		if (hasOSRack > 0) {
			for (osr=0; osr<4; osr++) {
				dpname=$1;
				sub("@osrack@", "OSRack"osr, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}
#
# substitute_osrack_ossubcluster
#
# syntax of the lines must be: dp dpt
#
substitute_osrack_ossubcluster()
{
	awk '
	{
		hasOSRSub=index($1,"@osrack@_@ossubcluster@");
		if (hasOSRSub > 0) {
			for (osrsub=0; osrsub<8; osrsub++) {
				dpname=$1;
				osrack=int(osrsub/2)
				sub("@osrack@_@ossubcluster@", "OSRack"osrack"_OSSubcluster"osrsub, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_osrack_ossubcluster_offlinenode
#
# syntax of the lines must be: dp dpt
#
substitute_osrack_ossubcluster_offlinenode()
{
	awk  '
	{
		hasOSRSubOff=index($1,"@osrack@_@ossubcluster@_@offlinenode@");
		if (hasOSRSubOff > 0) {
			for (offnode=0; offnode<128; offnode++) {
				dpname=$1;
				osrack=int(offnode/18)
				ossub=int(offnode/9)
				sub("@osrack@_@ossubcluster@_@offlinenode@", "OSRack"osrack"_OSSubcluster"ossub"_OfflineNode"offnode, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_osrack_ossubcluster_storagenode
#
# syntax of the lines must be: dp dpt
#
substitute_osrack_ossubcluster_storagenode()
{
	awk  '
	{
		hasOSRSubStor=index($1,"@osrack@_@ossubcluster@_@storagenode@");
		if (hasOSRSubStor > 0) {
			for (stornode=0; stornode<128; stornode++) {
				dpname=$1;
				osrack=int(stornode/6)
				ossub=int(stornode/3)
				sub("@osrack@_@ossubcluster@_@storagenode@", "OSRack"osrack"_OSSubcluster"ossub"_StorageNode"stornode, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}





substitute_CtrlDebug()
{
	awk '
	{
		hasCtrlDebug=index($1,"@ctrldebug@");
		if (hasCtrlDebug > 0) {
			for (debugNr= 5; debugNr < 10; debugNr++) {  
			      printf "_CtrlDebug_%d	%s\n", debugNr, $2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_antenna
#
# syntax of the lines must be: dp dpt
#

substitute_antenna()
{
	awk -v nrLBAs=$NRLBAS -v nrHBAs=$NRHBAS '
	{
		hasAntenna=index($1,"@antenna@");
		if (hasAntenna > 0) {
			for (antNr = 0; antNr < nrLBAs; antNr++) {  # assume nrLBAs >= nrHBAs
				if (antNr < nrHBAs) {
					printf "HBA%d	%s\n", antNr, $2;
				}
				printf "LBA%d	%s\n", antNr, $2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_cluster
#
# syntax of the lines must be: dp dpt
#
substitute_cluster()
{
	awk -v CLUSTERLIST=${CLUSTERLIST} '
	BEGIN {
		nrClusters=split(CLUSTERLIST, clustername, ":");
	};
	{
		hasCluster=index($1,"@cluster@");
		if (hasCluster > 0) {
			for (cluster in clustername) {
				dpname=$1;
				sub("@cluster@", clustername[cluster], dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_cluster_node
#
# syntax of the lines must be: dp dpt
#
substitute_cluster_node()
{
	while read dp dpt
	do
		echo $dp | grep -s '@cluster@_@node@' >/dev/null
		if [ $? -eq 0 ]; then
			cleanlist $CLUSTERFILE | while read cluster nodename count
			do
				echo "$cluster	$nodename	$count" | awk -v dp=$dp -v dpt=$dpt '{
				for (nodenr = 1; nodenr <= $3; nodenr++) {
					dpcopy=dp;
					replacename=sprintf("%s_%s%03d", $1,  $2, nodenr);
					sub("@cluster@_@node@", replacename, dpcopy);
					print dpcopy"	"dpt;
				}
			}'
			done
		else
			echo "$dp	$dpt"
		fi
	done
}

#
# substitute_Cabinet_SubRack_RSPBoard_RCU
#
# syntax of the lines must be: dp dpt
#
substitute_Cabinet_SubRack_RSPBoard_RCU()
{
	awk -v nrBoards=${NRRSPBOARDS} '
	{
		hasCabSubBoardRcu=index($1,"@cabinet@_@subrack@_@RSPBoard@_@rcu@");
		if (hasCabSubBoardRcu > 0) {
			for (rcu=0; rcu<nrBoards*8; rcu++) {
				dpname=$1;
				board=int(rcu/8)
				cabinet=int(board/8)
				subrack=int(board/4)
				sub("@cabinet@_@subrack@_@RSPBoard@_@rcu@", "Cabinet"cabinet"_Subrack"subrack"_RSPBoard"board"_RCU"rcu, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_Cabinet_SubRack_RSPBoard
#
# syntax of the lines must be: dp dpt
#
substitute_Cabinet_SubRack_RSPBoard()
{
	awk -v nrBoards=${NRRSPBOARDS} '
	{
		hasCabSubBoard=index($1,"@cabinet@_@subrack@_@RSPBoard@");
		if (hasCabSubBoard > 0) {
			for (board=0; board<nrBoards; board++) {
				dpname=$1;
				cabinet=int(board/8)
				subrack=int(board/4)
				sub("@cabinet@_@subrack@_@RSPBoard@", "Cabinet"cabinet"_Subrack"subrack"_RSPBoard"board, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_Cabinet_SubRack_TBBoard
#
# syntax of the lines must be: dp dpt
#
substitute_Cabinet_SubRack_TBBoard()
{
	awk -v nrBoards=${NRRSPBOARDS} '
	{
		hasCabSubBoard=index($1,"@cabinet@_@subrack@_@TBBoard@");
		if (hasCabSubBoard > 0) {
			for (board=0; board<nrBoards; board++) {
				dpname=$1;
				cabinet=int(board/8)
				subrack=int(board/4)
				tbNr=int(board/2)
				if (board%2 == 0) {
					sub("@cabinet@_@subrack@_@TBBoard@", "Cabinet"cabinet"_Subrack"subrack"_TBBoard"tbNr, dpname)
					print dpname"	"$2;
				}
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_Cabinet_SubRack
#
# syntax of the lines must be: dp dpt
#
substitute_Cabinet_SubRack()
{
	awk -v nrBoards=${NRRSPBOARDS} '
	{
		hasCabSub=index($1,"@cabinet@_@subrack@");
		if (hasCabSub > 0) {
			for (subrack=0; subrack<int(nrBoards/4); subrack++) {
				dpname=$1;
				cabinet=int(subrack/2)
				sub("@cabinet@_@subrack@", "Cabinet"cabinet"_Subrack"subrack, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_Cabinet
#
# syntax of the lines must be: dp dpt
#
substitute_Cabinet()
{
	awk -v nrBoards=${NRRSPBOARDS} '
	{
		hasCabinet=index($1,"@cabinet@");
		if (hasCabinet > 0) {
			for (cabinet=0; cabinet<int((nrBoards+7)/8); cabinet++) {
				dpname=$1;
				sub("@cabinet@", "Cabinet"cabinet, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_wan_switch
#
# syntax of the lines must be: dp dpt
#
substitute_wan_switch()
{
	awk -v WANSWITCHLIST=${WANSWITCHLIST} '
	BEGIN {
		nrWan=split(WANSWITCHLIST, wanname, ":");
	};
	{
		hasWan=index($1,"@wan@_@switch@");
		if (hasWan > 0) {
			for (wan in wanname) {
				dpname=$1;
				sub("@wan@_@switch@", wanname[wan], dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_wan
#
# syntax of the lines must be: dp dpt
#
substitute_wan()
{
	awk -v WANLIST=${WANLIST} '
	BEGIN {
		nrWan=split(WANLIST, wanname, ":");
	};
	{
		hasWan=index($1,"@wan@");
		if (hasWan > 0) {
			for (wan in wanname) {
				dpname=$1;
				sub("@wan@", wanname[wan], dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_ring_station
#
# replaces all lines containing the marker @ring@_@station@ with the ring_names
# and stationnames
#
# syntax of the lines must be: dp dpt
#
substitute_ring_station()
{
	awk -v RINGSTATIONLIST=${RINGSTATIONLIST} '
	BEGIN {
		nrRings=split(RINGSTATIONLIST, ringstationname, ":");
	};
	{
		hasRingStation=index($1,"@ring@_@station@");
		if (hasRingStation > 0) {
			for (ringstation in ringstationname) {
				dpname=$1;
				sub("@ring@_@station@", ringstationname[ringstation], dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_ring
#
# replaces all lines containing the marker @ring@ with the ring_names
#
# syntax of the lines must be: dp dpt
#
substitute_ring()
{
	awk -v RINGLIST=${RINGLIST} '
	BEGIN {
		nrRings=split(RINGLIST, ringname, ":");
	};
	{
		hasRing=index($1,"@ring@");
		if (hasRing > 0) {
			for (ring in ringname) {
				dpname=$1;
				sub("@ring@", ringname[ring], dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_observation
#
# syntax of the lines must be: dp dpt
#
substitute_observation()
{
	awk '
	{
		hasObservation=index($1,"@observation@");
		if (hasObservation > 0) {
			for (obsNr = 1; obsNr < 101; obsNr++) {  
			    dpname=$1;
			    obsbase="TempObs0"obsNr;
			    if (obsNr < 10) {
			      obsbase="TempObs000"obsNr;
                            } else if (obsNr > 9 && obsNr < 100) {
                              obsbase="TempObs00"obsNr;
			    }
			    sub("@observation@", obsbase, dpname)
			    print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_instancenr
#
# replaces all lines containing the marker @instancenr@ with the instancenr
#
# syntax of the lines must be: dp dpt
#
substitute_instancenr()
{
	awk '
	{
		sub("@instance@", "", $1);
		print $1"	"$2;
	} '
}


#
# number_dps
#
# add action & datapoint number to dplines
# if dpt ($2) is missing, skip line since only type info was needed, no datapoint
# 
number_dps()
{
	awk '
	BEGIN {
		count = 1000;
	};
	{
                if ($2 != "") {
		  print $1"	"$2"	"count;
		  count+=1;
                }
	} '
}

#
# create_dpt_file inputfile dbtype
#

create_dpt_file()
{

	rm -f ${ERRORFILE}

	(
		echo -n "# This file was generated by $(basename $0) ${VERSION} on " ; date
		echo	""
		cat PVSSbase.dpdef
		if [ "$DBTYPE" == "S" ]; then 
		   cat Stationbase.dpdef
		elif [ "$DBTYPE" == "M" ]; then 
                   cat MCUbase.dpdef
		fi

	) >${DESTDIR}/${DPT_FILE}

	prevdpt="abc"
	cleanlist $1 | sort | while read dpt prefix dbtype leaf dp
	do
		if [ "${dbtype}" != "$2" ]; then
			continue
		fi

		if [ "${prevdpt}" == "${dpt}" ]; then
			continue
		fi
		prevdpt=${dpt}

		# create PVSStypes
		echo "TypeName"
		echo "${dpt}.${dpt}	1#"
		let count=2
		# DPs in the LOFAR tree need an ObjectStatus element
		if [ "LOFAR${dp#LOFAR}" == "${dp}" ];then
			echo "	status	41#:ObjectStatus"
			let count=count+1
		fi
		# Adder,InputBuffer and Storage need an ObjectStatus && ProcessStatus element
		if [ "${dpt}" == "Adder" ];then
			echo "	status	41#:ObjectStatus"
		  	echo "	process	41#:ProcessStatus"
			let count=count+2
		fi

		if [ "${dpt}" == "InputBuffer" ];then
			echo "	status	41#:ObjectStatus"
		  	echo "	process	41#:ProcessStatus"
			let count=count+2
		fi

		if [ "${dpt}" == "Storage" ];then
			echo "	status	41#:ObjectStatus"
		  	echo "	process	41#:ProcessStatus"
			let count=count+2
		fi
		echo $dp | grep 'SW_' 2>&1 1>/dev/null
		if [ $? = 0 ]; then
			if [ ! -f ${dpt}.dpdef ]; then
				echo "No definition file for ${dpt}" >> ${ERRORFILE}
			fi
			if [[ ${dpt} != *Observation ]]; then
				echo "	process	41#:ProcessStatus"
				let count=count+1
			fi
		fi

		if [ -f ${dpt}.dpdef ]; then
			let depth=1
			oldnode=""
			cleanlist ${dpt}.dpdef | awk -v elemNr=$count ' 
				BEGIN {  
					PVSStype["string"]	 = "25"
					PVSStype["bool"]	 = "23"
					PVSStype["uint"]	 = "20"
					PVSStype["int"]		 = "21"
					PVSStype["float"]	 = "22"
					PVSStype["double"]	 = "22"
					PVSStype["stringArr"]= "9"
					PVSStype["boolArr"]	 = "7"
					PVSStype["uintArr"]	 = "4"
					PVSStype["intArr"]	 = "5"
					PVSStype["floatArr"] = "6"
					PVSStype["doubleArr"]= "6"
					tabs="										"
					oldnode[1]=""
					prevlevel=0
				} 
				{
					nodename = $1
					level = 0
					do {
						dotpos=index(nodename,".");
						if (dotpos > 0) {
							level++;
							newnode[level]=substr(nodename,0,dotpos-1);
							nodename = substr(nodename,dotpos+1);
							dotpos   = index(nodename,".");
						}
					} while (dotpos > 0);
					
					if (newnode[level] != oldnode[level]) {
						print substr(tabs, 0, level) newnode[level]"	1#";
						elemNr++;
						oldnode[level] = newnode[level];
					}
					if (substr($2,0,1) == ":") {
						print substr(tabs, 0, level+1) nodename"	41#"$2
					}
					else {
						print substr(tabs, 0, level+1) nodename"	"PVSStype[$2]"#"
					}
					elemNr++;

					if (level < prevlevel) {
						for (l = prevlevel; l > level; l--) {
							oldnode[l]=""
						}
					}
					prevlevel = level;
				}'
		fi
		echo ""

	done >>${DESTDIR}/${DPT_FILE}
	echo "created: ${DESTDIR}/${DPT_FILE}"

	# Modify 'leaf' value for some datapoints.
	(
		echo	"# Modify the default value for the leaf-field"
		echo    "ElementName	TypeName	_original.._value	_original.._status"
	) >${TMP_FILE}

	cleanlist $1 | awk -v dbtype=$2 '{ 
		if ($3 == dbtype && $4 == "Y") {
			print "_mp_"$1".status.leaf	"$1"	1	0x101"
		} }' >>${TMP_FILE}

	if [ -f ${ERRORFILE} ]; then
		echo "ERRORS During creation:"
		cat ${ERRORFILE}
		rm -f ${ERRORFILE}
	fi
}

#
# create_dp_file inputfile dbtype
#
create_dp_file()
{
	(
		echo	"#"
		echo -n "# This file was generated by $(basename $0) ${VERSION} on " ; date
		echo	"#"
		echo    "DpName	TypeName	ID"
	) >${DESTDIR}/${DP_FILE}

	# Note: ignore the PermSW_@... lines because they are there only for SAS
	cleanlist $1 | grep -v "PermSW_@" | awk -v dbtype=$2 '{ 
		if ($3 == dbtype ) {
			print $5"	"$1	
		} }' | \
		                substitute_CtrlDebug | \
				substitute_ring_station  | \
				substitute_ring | \
				substitute_observation | \
				substitute_wan_switch  | \
				substitute_wan  | \
				substitute_Cabinet_SubRack_RSPBoard_RCU | \
				substitute_Cabinet_SubRack_RSPBoard | \
				substitute_Cabinet_SubRack_TBBoard | \
				substitute_Cabinet_SubRack | \
				substitute_Cabinet | \
				substitute_cluster_node | \
				substitute_cluster | \
				substitute_instancenr | \
				substitute_antenna | \
				substitute_adder | \
				substitute_inputbuffer | \
				substitute_storage | \
				substitute_BGP_midplane_ionode | \
				substitute_BGP_midplane | \
				substitute_BGP | \
				substitute_osrack_ossubcluster_storagenode | \
				substitute_osrack_ossubcluster_offlinenode | \
				substitute_osrack_ossubcluster | \
				substitute_osrack | \
				sort -k1,1 |\
				number_dps >>${DESTDIR}/${DP_FILE}

	# Setup the values of the antenna datapoints

	if [ $NRLBAS -gt 0 -o $NRHBAS -gt 0 ]; then
	(
		echo ""
		echo "ElementName	TypeName	_original.._value	_original.._status"
		echo "dummy" | awk -v nrHBAs=$NRHBAS -v nrLBAs=$NRLBAS -v nrRSPs=$NRRSPBOARDS '{
			for (antNr = 0; antNr < nrLBAs; antNr++) {  # assume nrLBAs >= nrHBAs
				RSPboard=antNr/4
				Subrack=RSPboard/4
#if [ "${dbtype}" != "$2" ]; then
				Cabinet=Subrack/2
				if (antNr < nrHBAs) {
					printf "HBA%d.RCUX	Antenna	\"LOFAR_PIC_Cabinet%d_Subrack%d_RSPBoard%d_RCU%d.HBAEnable\"	0x101\n", 
							antNr, Cabinet, Subrack, RSPboard, antNr*2;
					printf "HBA%d.RCUY	Antenna	\"LOFAR_PIC_Cabinet%d_Subrack%d_RSPBoard%d_RCU%d.HBAEnable\"	0x101\n", 
							antNr, Cabinet, Subrack, RSPboard, antNr*2+1;
				}
				if (RSPboard >= nrRSPs) {	# use of both LBL and LBH input?
					RSPboard=antNr/4 - nrRSPs
					Subrack=RSPboard/4
					Cabinet=Subrack/2
					printf "LBA%d.RCUX	Antenna	\"LOFAR_PIC_Cabinet%d_Subrack%d_RSPBoard%d_RCU%d.LBLEnable\"	0x101\n", 
							antNr, Cabinet, Subrack, RSPboard, antNr*2-(nrRSPs*8)+1;
					printf "LBA%d.RCUY	Antenna	\"LOFAR_PIC_Cabinet%d_Subrack%d_RSPBoard%d_RCU%d.LBLEnable\"	0x101\n", 
							antNr, Cabinet, Subrack, RSPboard, antNr*2-(nrRSPs*8);
				}
				else {
					printf "LBA%d.RCUX	Antenna	\"LOFAR_PIC_Cabinet%d_Subrack%d_RSPBoard%d_RCU%d.LBHEnable\"	0x101\n", 
							antNr, Cabinet, Subrack, RSPboard, antNr*2;
					printf "LBA%d.RCUY	Antenna	\"LOFAR_PIC_Cabinet%d_Subrack%d_RSPBoard%d_RCU%d.LBHEnable\"	0x101\n", 
							antNr, Cabinet, Subrack, RSPboard, antNr*2+1;
				}
			}
		}'
	) >>${DESTDIR}/${DP_FILE}
	fi
	

	# setup master point and archives 
	# NOTE: THIS IS ADDED TO THE DataPointTYPES file!
	prevdpt="abc"
	cleanlist $1 | sort | while read dpt prefix dbtype leaf dp
	do
		if [ "${dbtype}" != "$2" ]; then
			continue
		fi

		if [ "${prevdpt}" == "${dpt}" ]; then
			continue
		fi
		prevdpt=${dpt}

		# Create MasterDataPoint for LOFAR tree elements
		if [ "LOFAR${dp#LOFAR}" == "${dp}" ];then
			echo "DpName	TypeName	ID"
			echo "_mp_${dpt}	${dpt}	0"
			echo "_dt_${dpt}	_DynamicDatapoints	0"
			echo ""
		fi

		# if software then create an hourarchive for the logMsg in the MasterDataPoint
		echo $dp | grep 'SW_' 2>&1 1>/dev/null
		if [ $? = 0 ]; then
			if [[ ${dpt} != *Observation ]]; then
				echo "ElementName	TypeName	_original.._value	_original.._status"
				echo "_dt_${dpt}.Leaf	_DynamicDatapoints	"'"'_mp_${dpt}.logMsg:_archive'"'"	0x101"
				echo "_dt_${dpt}.DynamicAttribute	_DynamicDatapoints	"'"'_da_none'"'"	0x101"
				echo ""

				echo "StampSec	StampMSec	ElementName	TypeName	DetailNr	_archive.._type	_archive.._archive	_archive.._class"
				echo "0	0	_mp_${dpt}.process.logMsg	${dpt}		45	1"
				echo "0	0	_mp_${dpt}.process.logMsg	${dpt}	1	15		_ValueArchive_2"
				echo ""
			fi
		fi


		# Adder, InputBuffer and Storage need an _mp and _dt also, and logMsg set
		if [ "${dpt}" == "Adder" ];then
			echo "DpName	TypeName	ID"
			echo "_mp_${dpt}	${dpt}	0"
			echo "_dt_${dpt}	_DynamicDatapoints	0"
			echo ""
			echo "ElementName	TypeName	_original.._value	_original.._status"
			echo "_dt_${dpt}.Leaf	_DynamicDatapoints	"'"'_mp_${dpt}.logMsg:_archive'"'"	0x101"
			echo "_dt_${dpt}.DynamicAttribute	_DynamicDatapoints	"'"'_da_none'"'"	0x101"
			echo ""

			echo "StampSec	StampMSec	ElementName	TypeName	DetailNr	_archive.._type	_archive.._archive	_archive.._class"
			echo "0	0	_mp_${dpt}.process.logMsg	${dpt}		45	1"
			echo "0	0	_mp_${dpt}.process.logMsg	${dpt}	1	15		_ValueArchive_2"
			echo ""
		fi

		if [ "${dpt}" == "InputBuffer" ];then
			echo "DpName	TypeName	ID"
			echo "_mp_${dpt}	${dpt}	0"
			echo "_dt_${dpt}	_DynamicDatapoints	0"
			echo ""
		   	echo "ElementName	TypeName	_original.._value	_original.._status"
			echo "_dt_${dpt}.Leaf	_DynamicDatapoints	"'"'_mp_${dpt}.logMsg:_archive'"'"	0x101"
			echo "_dt_${dpt}.DynamicAttribute	_DynamicDatapoints	"'"'_da_none'"'"	0x101"
			echo ""

			echo "StampSec	StampMSec	ElementName	TypeName	DetailNr	_archive.._type	_archive.._archive	_archive.._class"
			echo "0	0	_mp_${dpt}.process.logMsg	${dpt}		45	1"
			echo "0	0	_mp_${dpt}.process.logMsg	${dpt}	1	15		_ValueArchive_2"
			echo ""
		fi

		if [ "${dpt}" == "Storage" ];then
			echo "DpName	TypeName	ID"
			echo "_mp_${dpt}	${dpt}	0"
			echo "_dt_${dpt}	_DynamicDatapoints	0"
			echo ""
		   	echo "ElementName	TypeName	_original.._value	_original.._status"
			echo "_dt_${dpt}.Leaf	_DynamicDatapoints	"'"'_mp_${dpt}.logMsg:_archive'"'"	0x101"
			echo "_dt_${dpt}.DynamicAttribute	_DynamicDatapoints	"'"'_da_none'"'"	0x101"
			echo ""

			echo "StampSec	StampMSec	ElementName	TypeName	DetailNr	_archive.._type	_archive.._archive	_archive.._class"
			echo "0	0	_mp_${dpt}.process.logMsg	${dpt}		45	1"
			echo "0	0	_mp_${dpt}.process.logMsg	${dpt}	1	15		_ValueArchive_2"
			echo ""
		fi




	done >>${DESTDIR}/${DPT_FILE}

	echo "created: ${DESTDIR}/${DP_FILE}"
}

#
# expand_component compname labelprefix DPprefix
#
# format COMPONENT_FILE:
#	comp.comp 1#
#		field1	??#
#		field2	??#
#		...
expand_component()
{
	expanding=false
	cleanlist $COMPONENT_FILE | while read field fldtype
	do
		if [ $expanding == false ]; then
			if [ $field == $1.$1 ]; then
				expanding=true
			fi
			continue
		fi

		if [ -z "${fldtype}" ] || [ "${fldtype:0:8}" == "TypeName" ]; then 
			expanding=false
			continue
		fi
		
		varlabel=`labelize $2_$field`
		echo "#define	PN_${varlabel}	\"$3.${field}\""
	done	
}

#
# create_cpp_headerfile inputfile dbtype
#
create_cpp_headerfile()
{
	# write out the fields of the components
	(
		echo "#ifndef LOFAR_DEPLOYMENT_PVSSDATAPOINTS_H"
		echo "#define LOFAR_DEPLOYMENT_PVSSDATAPOINTS_H"
		echo "// process"
		expand_component ProcessStatus "FSM" "process" 
		echo "// object"
		expand_component ObjectStatus  "OBJ" "object"
		echo ""
	)  >>${DESTDIR}/${CPP_HEADERFILE}

	cleanlist $1 | while read dpt prefix dbtype leaf dp
	do
#		if [ "${dbtype}" != "$2" ]; then
#			continue
#		fi

		if [ $prefix != "-" ]; then
			label=`labelize ${dpt}`
			echo "// $dpt"
			echo "#define PSN_${label}	\"${dp}\""
			echo "#define PST_${label}	\"${dpt}\""
			if [ -f ${dpt}.dpdef ]; then
				cleanlist ${dpt}.dpdef | while read varname vartype
				do
					if [ ${vartype:0:1} == ":" ]; then
						expand_component ${vartype:1} ${prefix}_${varname} ${varname}
					else
						varlabel=`labelize ${varname}`
						echo "#define PN_${prefix}_${varlabel}	\"${varname}\""
					fi
				done
			fi
			echo ""
		fi
	done >>${DESTDIR}/${CPP_HEADERFILE}

	echo "#endif"  >>${DESTDIR}/${CPP_HEADERFILE}
}

#------------------------------ MAIN program ------------------------------
#
# Syntax: create_db_files [-d destdir] [-s station | -C]
#

# setup defaults
DESTDIR="."
DBTYPENAME=Main
DBTYPE=M
STNNAME="Station"

argv=`getopt "d:s:CMh" $*`		# reformat arguments
#eval set argv=`getopt "d:s:Ch" $*`		# reformat arguments
#shift
while [ -n "$1" -a "$1" != "--" ]
do
	case "$1" in
		-d)	DESTDIR=$2
			[ -d ${DESTDIR} ] ||
				SyntaxError "Destination directory >${DESTDIR}< does not exist"
			shift 2
			;;
		-s) STNNAME=$2
			DBTYPENAME=`echo $2 | tr '[a-z]' '[A-Z]'`
			DBTYPE=S
			shift 2
			;;
		-C) DBTYPENAME=CEP
			DBTYPE=C
			shift 1
			;;
		-M) DBTYPENAME=Main
			DBTYPE=M
			shift 1
			;;
		-h) SyntaxError
			;;
		*) SyntaxError
			;;

	esac
done
shift				# remove '--'

# On a real station, we have fixed paths
if [ "$DBTYPE" == "S" -a "$DBTYPENAME" == "LOCALHOST" ]; then
   configdir="/opt/lofar/etc/"
   dpdefdir="/opt/pvss/dpdef/"
   DESTDIR=$dpdefdir
   # Find Station name without last 'C' from hostname (e.g., CS002)
   DBTYPENAME=`hostname -s | tr '[a-z]' '[A-Z]' | sed s/C$//`
   STNNAME=$DBTYPENAME
   cd $DESTDIR
   echo "Making files for station $STNNAME in $DESTDIR"
elif [ "$DBTYPE" == "M" ]; then 
   if [[ $HOSTNAME =~ MCU001 ]]; then  
     configdir="/opt/lofar/etc/"
     dpdefdir="/opt/pvss/dpdef/"
     DESTDIR=$dpdefdir
     STNNAME=$DBTYPENAME
     cd $DESTDIR
     echo "Making files for $STNNAME in $DESTDIR"
   else
     configdir=".."
     dpdefdir=""
   fi    
elif [ "$DBTYPE" == "C" -a "$HOSTNAME" == "CCU001" ]; then  
   configdir="/opt/lofar/etc/"
   dpdefdir="/opt/pvss/dpdef/"
   DESTDIR=$dpdefdir
   STNNAME=$DBTYPENAME
   cd $DESTDIR
   echo "Making files for $STNNAME in $DESTDIR"
else
   configdir=".."
   dpdefdir=""
   STNNAME=$DBTYPENAME
fi

# define the input files
STATIONINFOFILE=${configdir}/StaticMetaData/StationInfo.dat
if [ ! -f $STATIONINFOFILE ]; then
  echo "Cannot find $STATIONINFOFILE"
  exit
fi

COMPONENT_FILE=${dpdefdir}PVSSbase.dpdef
CLUSTERFILE=${dpdefdir}Clusters.list
RINGFILE=${dpdefdir}Rings.list
WANFILE=${dpdefdir}Wan.list
ERRORFILE=/tmp/Crea.Error
INPUTFILE=${dpdefdir}PVSSDataPoints.base

# define the output files
CPP_HEADERFILE=PVSSDatapointDefs.h
DP_FILE=${DBTYPENAME}Datapoints.dpl
DPT_FILE=${DBTYPENAME}Datapointtypes.dpl
TMP_FILE=/tmp/dpts$$.dpl

# construct some lists
CLUSTERLIST=`concatfile $CLUSTERFILE`
RINGLIST=`concatfile $RINGFILE`
RINGSTATIONLIST=`create_ring_station_list`
WANLIST=`concatfile $WANFILE`
WANSWITCHLIST=`create_wan_switch_list`

let NRRSPBOARDS=0
let NRLBAS=0
let NRHBAS=0
if [ "${DBTYPE}" == "S" ]; then
	let NRRSPBOARDS=`grep -s ${STNNAME}[[:space:]]  ${STATIONINFOFILE} | awk '{ print $7 }'`
	let NRLBAS=`grep -s ${STNNAME}[[:space:]] ${STATIONINFOFILE} | awk '{ print $9 }'`
	let NRHBAS=`grep -s ${STNNAME}[[:space:]] ${STATIONINFOFILE} | awk '{ print $10 }'`
fi

# create the desired files
create_dpt_file ${INPUTFILE} ${DBTYPE}
create_dp_file  ${INPUTFILE} ${DBTYPE}
cat ${TMP_FILE} >>${DESTDIR}/${DPT_FILE}
rm -f ${TMP_FILE}

# Creating the c++ header file is for development hosts, only; in that case
# the $dpdefdir is an empty string
if [ "${dpdefdir}" == "" ]; then
  (
	echo -n "// This file was generated by $(basename $0) ${VERSION} on " ; date
	echo	""
  ) >${DESTDIR}/${CPP_HEADERFILE}
  create_cpp_headerfile ${INPUTFILE} ${DBTYPE}
  echo "created: ${DESTDIR}/${CPP_HEADERFILE}"
  mkdir -p ../../../../installed/gnu_debug/include/Deployment/
  cp ${DESTDIR}/${CPP_HEADERFILE} ../../../../installed/gnu_debug/include/Deployment/
fi

