#!/bin/bash
#
# swlevel : bring software on node in certain runlevel
#
# Copyright (C) 2006
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Syntax: swlevel [ 0 | 1 | 2 | 3 | 4 | 5 | 6 ]
#
# $Id$
#
VERSION="v2.1 20100517"		# loading image 1 before starting RSPdriver
BINDIR=/opt/lofar/bin
LOGDIR=${BINDIR}/../log
ETCDIR=${BINDIR}/../etc
LEVELTABLE=${ETCDIR}/swlevel.conf

#
# SyntaxError msg
#
SyntaxError()
{
	Msg=$1

	[ -z "${Msg}" ] || echo "ERROR: ${Msg}"
	echo ""
	echo "Syntax: $(basename $0) [-s/S/v/V] [-i x] [-l][ 0 | 1 | 2 | 3 | 4 | 5 | 6 ]"
	echo "-s: Show current level, exit (-S: only print number)"
	echo "-v: Show running LOFAR version, exit (-V: only print version)"
	echo "-i: Load RSP firmware from image [x] (default image is 1)"
        echo "-l: Set to level as provided (optional)"
        echo
	echo "Levels:"
	echo "0:  Stop all lofar software"
	echo "1:  Run Lofar daemons and PVSS"
	echo "2:  Run Lowlevel hardware drivers"
	echo "3:  Run Calculation services"
	echo "4:  Run Hardware and software monitors"
	echo "5:  Run System Health Management"
	echo "6:  MAC is controlling the software"
	echo ""
	exit 0
}

#
# selectImage(); the image to load has been set in parameter $image in MAIN
#
selectImage()
{
	let nrRSPs=`grep RSPBOARDS ${ETCDIR}/RemoteStation.conf | cut -d'=' -f2 | sed 's/ //g'`
	let board=0
	while [ $board -lt $nrRSPs ]
	do
		# get version of RSPboard
		boardHex=`echo $board | awk '{ printf "%02x", $1 }'`
		rsu=`sudo ${BINDIR}/../sbin/rsuctl3 -m 10:fa:00:00:$boardHex:00 -qV 2>&1 | grep BP | cut -d':' -f2 | sed 's/ //g' | cut -d'.' -f1`
		if [ ${#rsu} -eq 1 ]; then
  		  let version=$rsu
 		  # if board has reset itself to image 0, load image 1 again
		  #if [ $version -le 4 ]; then
		  # AS-20100517: Always load new image!
		     echo "Loading image $image on RSPboard $board ..."
		     sudo ${BINDIR}/../sbin/rsuctl3_reset -m 10:fa:00:00:$boardHex:00 -q -x -p $image 1>/dev/null 2>&1
		  #fi
                else
                  echo "No RSP board $board found"
		fi
		let board+=1
	done
}

#
# Start the program when it exists
#
start_prog()
{
	# make arguments readable
	prog=$1
	asroot=${2:1}
	withmpi=${3:1}

	# special check for logging-daemons
	[ $prog == $logProgToSkip ] && return
	
	# check existance
	[ -x $BINDIR/$prog ] || [ -x $BINDIR/${prog}.sh ] || return

	# if it is a shell script call the script
	if [ -f $BINDIR/${prog}.sh ]; then
		$BINDIR/${prog}.sh start
		return
	fi

	# Check if program is already running
	/sbin/pidof ${prog} 1>/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo Starting $prog
		# PVSS needs special treatment; only start as lofarsys
		# This is to prevent foreign stations not under central
		# control to start their PVSS and thus connect to PVSS
		if [ "$prog" = "PVSS00pmon" ]; then 
		    if [ "$user" = "lofarsys" ]; then
			start_pvss2 1>/dev/null 2>&1 &
			sleep 3
                    fi
		elif [ "$prog" = "SASGateway" ]; then  
		    # Foreign stations not under central control should not
		    # connect to the SAS database; this prevents SAS main-
		    # tenance etc.
		    if [ "$user" = "lofarsys" ]; then
			rm -f $LOGDIR/$prog.log*.? 1>/dev/null 2>&1
			$BINDIR/$prog 1>>/localhome/log/$prog.stdout 2>&1 &
		    fi
  		else
		    if [ -n "$asroot" ]; then
		       sudo rm -f $LOGDIR/$prog.log.? 1>/dev/null 2>&1
		       if [ "$prog" = "RSPDriver" ]; then
			   selectImage
			   sudo -b $BINDIR/$prog 1>>/localhome/log/$prog.stdout 2>&1
		       else
		           sudo -b $BINDIR/$prog 1>>/localhome/log/$prog.stdout 2>&1
		       fi
		    else
			rm -f $LOGDIR/$prog.log*.? 1>/dev/null 2>&1
			$BINDIR/$prog 1>>/localhome/log/$prog.stdout 2>&1 &
		    fi
		fi
		usleep 250000
		ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog}
	fi
}

#
# Stop the program when it is running
#
stop_prog()
{
	# make arguments readable
	prog=$1
	asroot=${2:1}
	withmpi=${3:1}
	[ ! -z "$asroot" ] && asroot=sudo	

	# special check for logging-daemons
	[ $prog == $logProgToSkip ] && return
	
	# check existance
	[ -x $BINDIR/$prog ] || [ -x $BINDIR/${prog}.sh ] || return
	
	# if it is a shell script call the script
	if [ -f $BINDIR/${prog}.sh ]; then
		$BINDIR/${prog}.sh stop
		return
	fi

	# get processlist
	/sbin/pidof ${prog} 1>/dev/null 2>&1
	if [ $? -ne 0 ]; then
		return
	fi

	# PVSS needs special treatment
	if [ "$prog" = "PVSS00pmon" ]; then
		echo "Stopping PVSS database"
		start_pvss2 -stopWait
		return
	fi

	# first handle mpi programs
	if [ ! -z "$withmpi" ]; then
		$asroot cexec :0-11 killall -9 ${prog}
		return
	fi

	# first try normal kill
	for pid in `/sbin/pidof ${prog}`
	do 
		echo "Softly killing ${prog}(${pid})"
		$asroot kill $pid
		sleep 1
	done

	# when normal kill did not work, kill is with -9
	for pid in `/sbin/pidof ${prog}`
	do 
		#sleep 2
		echo "Hard killing ${prog}(${pid})"
		$asroot kill -9 $pid 1>/dev/null 2>&1
	done
}

#
# show status of program
#
status_prog()
{
	echo
	echo Status of all software level:
	prevlevel=1
	list=( `cat $LEVELTABLE | cut -d"#" -f1 | awk '{ if (NF>0) print $0 }' ` )
	for line in ${list[@]}
	do
		levelnr=`echo $line | cut -d":" -f1`
		prog=`echo $line | cut -d":" -f6`
                pid=("")

		# special check for logging-daemons
		[ $prog == $logProgToSkip ] && continue
		
		# check existance
		[ -x $BINDIR/$prog ] || [ -x $BINDIR/${prog}.sh ] || continue
	
		if [ $prevlevel -ne $levelnr ]; then
			echo "---"
			prevlevel=$levelnr
		fi

		# if it is a shell script call the script
		if [ -f $BINDIR/${prog}.sh ]; then
			$BINDIR/${prog}.sh status $levelnr
			continue
		fi

		/sbin/pidof ${prog} 1>/dev/null 2>&1
		if [ $? -eq 0 ]; then
			pid=( `/sbin/pidof ${prog}` )
		else
			pid="DOWN"
		fi
		echo ${levelnr}:${prog}:${pid[*]} | awk -F: '{ printf "%s : %-25s %s\n", $1, $2, $3 }'
		# Some Checks
		# AMCServer needs two instances
		if [ "$prog" == "AMCServer" -a $level -ge 3 ]; then
		    if [ ${#pid[@]} -lt 2 ]; then 
		       missing="$missing ${prog}[$levelnr]"
		    fi
		    if [ ${#pid[@]} -gt 2 ]; then 
                       toomany="$toomany ${prog}[$levelnr]"
		    fi
		else
		    # Other controllers must have one instance, only
		    if [ ${#pid[@]} -ge 2 ]; then 
                       toomany="$toomany ${prog}[$levelnr]"
		    fi
		fi
		
		# Check for missing controllers 
		if [ "$pid" = "DOWN" -o "$pid" = "0" ]; then 
  		  if [ $levelnr -le $level ]; then 
		    if [ $levelnr -le 5 ]; then
			missing="$missing ${prog}[$levelnr]"
		    else
			# LCU level 6 has two permanent controllers running
			if [ "$prog" == "StationControl" \
			    -o "$prog" == "ClockControl" ]; then 
			    missing="$missing ${prog}[$levelnr]"
			fi
			# MCU level 6 must have MACScheduler running
			if [ "$prog" == "MACScheduler" ]; then 
			    missing="$missing ${prog}[$levelnr]"
			fi
		    fi
		  fi
		fi
	done
	echo "---"
	if [ "$missing" ]; then 
		echo "Missing :"$missing
	fi
	if [ "$toomany" ]; then 
		echo "Too many:"$toomany
	fi
}

#
# goto_level levelnr
#
goto_level()
{
	#first power down to new level
	newlevel=$1

	# set rcumode to 0 (power save) when entering level 1
	if [ ${newlevel} -le 1 ]; then
          if [ -e /tmp/level.admin ]; then
            curlevel=`cat /tmp/level.admin`
          else
            curlevel=-1
          fi
          if [ ${curlevel} -ge 2 ]; then 
	    /sbin/pidof RSPDriver 1>/dev/null 2>&1
	    if [ $? -eq 0 ]; then
	      status=`( rspctl --status | grep ERROR ) >& /dev/null; echo $?`
              if [ $status -eq 1 ]; then 
       	        echo "set rcumode to 0 (power save)"
	        rspctl --rcumode=0 1>/dev/null 2>&1
	      else
		echo "Beware: NOT going to rcumode 0 as images are still being initialized"
	      fi
            fi
          fi
	fi

	for (( l=6 ; l>newlevel ; l-- ))
	do
		tac $LEVELTABLE | cut -d"#" -f1 | awk '{ if (NF>0) print $0 }' | \
		grep "^${l}:" | grep ":d:" |  while read line
		do
			asroot=`echo $line | cut -d":" -f4`
			withmpi=`echo $line | cut -d":" -f5`
			program=`echo $line | cut -d":" -f6`
			stop_prog $program x$asroot x$withmpi
		done
	done

	# then power up to new level
	for (( l=1 ; l<=newlevel ; l++ ))
	do
		cat $LEVELTABLE | cut -d"#" -f1 | awk '{ if (NF>0) print $0 }' | \
		grep "^${l}:" | grep ":u:" |  while read line
		do
			asroot=`echo $line | cut -d":" -f4`
			withmpi=`echo $line | cut -d":" -f5`
			program=`echo $line | cut -d":" -f6`
			start_prog $program x$asroot x$withmpi
		done
	done
}

show_level()
{
        if [ -e /tmp/level.admin ]; then
          level=`cat /tmp/level.admin`
	  if [ "$1" != "S" ]; then
	     echo -n "Currently set level is "
	  fi
	  echo $level
        else
          level=-1
          if [ "$1" != "S" ]; then
             echo "Currently set level unknown"
          fi
        fi
        # argument -s/-S only returns level, no list
        if [ -z "$1" ]; then
            status_prog
        fi
        if [ $level -ne -1 ]; then 
          exit 0
        else
          exit $level
        fi
}

show_lofar_version()
{
        if [ -e /opt/lofar/Version.txt ]; then
          version=`cat /opt/lofar/Version.txt`
	  if [ "$1" = "v" ]; then  
            echo -n "Current LOFAR version is "
	  fi
          echo $version
        else
          version="-1"
          if [ "$1" = "v" ]; then
            echo "Current LOFAR version unknown"
          fi
        fi
	if [ "$version" != "-1" ]; then 
  	  exit
        else
          exit $version
        fi
}

handle_args()
{

  # Handle arguments
  while getopts  "hSsVvi:l:" flag
  do
    case "$flag" in
    [sS])
    show_level $flag
    ;;
    [vV])
    show_lofar_version $flag
    ;;
    i)
    image=$OPTARG
    # This is needed to be able to retrieve the requested swlevel
    # when it is not provided with option -l
    shift $((OPTIND-1)); OPTIND=1
    ;;
    l)
    level=$OPTARG
    ;;
    h)
    SyntaxError
    ;;
    *) 
    exit 
    ;;
    esac
  done
  if [ -z $level ]; then
    if [ "$1" != "" ]; then
      level=$1
    else
      level=-1
    fi
  fi

  if [ "$user" != "lofarsys" -a $level -gt 3 ]; then
      echo "Will only start up to level 3 as this appears to be local use"
      $level=3
  fi

  # default image is 1
  if [ -z $image ]; then  
   image=1
  fi

  return
}


#
# MAIN
#


# Find out if we are running on a PVSS system
# Note: on PVSS systems LoggingClient must be ignored, 
# On non-PVSS system LoggingProcessor.

logProgToSkip=LoggingProcessor
if [ -f ${BINDIR}/PVSS00pmon ]; then
	logProgToSkip=LoggingClient
fi


# All users can ask for current level
if [ -z $1 ]; then 
  show_level 
fi

user=`id | cut -d'(' -f2 | cut -d')' -f1`
group=`groups | awk '{print $1}'`

handle_args $*

# All other options that act on the station status are for lofarsys only
# Don't allow root to run swlevel because all logfile get root access.
if [ "$user" != "lofarsys" ]; then
    if [ "$group" != "local" ]; then 
	echo "swlevel must be run by user lofarsys or group local members!"
	exit
    fi
fi

# first power down to this level
case $level in
	0|1|2|3|4|5|6)  
			;;
	*) SyntaxError
esac
echo Going to level $level
cwd=`pwd`
cd ${BINDIR}
goto_level $level
cd ${cwd}
status_prog

# save for later
echo $level > /tmp/level.admin
chmod ug+rw /tmp/level.admin
date=`date +%Y-%m-%d\ %H:%M:%S`
echo [${date}]:$0 $* >> /log/swlevel.log
exit $level
