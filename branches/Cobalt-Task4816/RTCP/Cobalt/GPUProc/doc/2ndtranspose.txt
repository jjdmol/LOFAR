Jan David's raw notes for 2nd transpose investigation
--------------------------------------------------------

The beam-formed data is transposed when transported from GPUProc (rtcp) to OutputProc (outputProc).

The rtcp process has:
  * All TABs and Stokes of 1 subbands per thread,

The outputProc process needs:
  * All subbands of 1 Stokes of 1 TAB per thread.


Generic transpose code:
  writer:
    - one thread / receiver node
    - one write queue / receiver node
    - data supplier copies data into queue:
        * data
        * ID (tab, subband, block)

  reader:
    - one thread / writer node
    - one read queue / writer node
    - receives block (tab, subband, block, data):
       - must construct several blocks for tabs simultaneously (BlockCollector)

(Hooks into CoInterface/src/TABTranspose.h)

-------------------------
SENDER (GPUProc)
-------------------------

* One thread per subband to split each block into its TABs:

* One thread per receiving node to send the TAB blocks:

class TransposeSender {
public:
  TransposeSender()
  {
  }

  void send(BeamFormedData &data) {
    const size_t nrStokes = data.shape()[0];

    for (size_t fileIdx = 0; fileIdx < data.shape()[0]; ++fileIdx) {
      size_t writerRank = outputProcRank(stokesIdx);

      SmartPtr<Subband> subband = writerPool[writerRank].free.remove();

      subband->fileIdx = fileIdx;
      subband->subband = data.blockID.globalSubbandIdx;
      subband->block   = data.blockID.block;

      memcpy(subband->data.origin(), &data[fileIdx].origin(), subband->data.size() * sizeof *subband->data.origin());

      writerPool[writerRank].filled.append(subband);
    }
  }

  // One thread per receiving node,
  void writeOutput(size_t writerRank) {
    SmartPtr<Subband> subband;

    Stream stream(connectToOutputProc(writerRank));

    while ((subband = writerPool[writerRank].filled.remove()) != NULL) {
      subband->write(stream);

      writerPool[writerRank].free.append(subband);
    }
  }

private:
};


-------------------------
RECEIVER (OutputProc)
-------------------------

* In receiving side, one thread per sending node:

class TransposeReceiver {
public:
  TransposeReceiver(std::map<size_t,BlockCollector> &collectors)
  :
    collector(collector)
  {
  }

  void receiveSubbands(Stream &stream)
  {
    Subband subband;

    for(;;) {
      subband.read(stream);

      collectors.at(subband.fileIdx).addSubband(subband);
    }
  }

private:
  std::map<size_t,BlockCollector> &collectors;
};

* And, of course, one output thread per TAB to write to disk:

class BlockWriter {
public:
  void write() {
    SmartPtr<Block> block;

    Stream stream(connectToDisk(writerRank));

    while ((block = outputPool.filled.remove()) != NULL) {
      block->write(stream);

      outputPool.free.append(block);
    }
  }
private:
  Pool< SmartPtr<Block> > &outputPool;
};

