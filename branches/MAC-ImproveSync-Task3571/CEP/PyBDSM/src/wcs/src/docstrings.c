/*
DO NOT EDIT!

This file is autogenerated by setup.py.  To edit its contents,
edit doc/docstrings.py

The weirdness here with strncpy is because some C compilers, notably
MSVC, do not support string literals greater than 256 characters.
*/

#include <string.h>
#include "docstrings.h"

char doc_DistortionLookupTable[369];
char doc_K[152];
char doc_M[56];
char doc_Sip[1017];
char doc_Tabprm[226];
char doc_UnitConverter[2216];
char doc_Wcs[482];
char doc_Wcsprm[1979];
char doc_Wtbarr[195];
char doc_a[222];
char doc_a_order[94];
char doc_all_pix2sky[1204];
char doc_alt[236];
char doc_ap[225];
char doc_ap_order[96];
char doc_axis_types[916];
char doc_b[222];
char doc_b_order[94];
char doc_bp[225];
char doc_bp_order[96];
char doc_cd[1018];
char doc_cdelt[302];
char doc_cel_offset[153];
char doc_celfix[136];
char doc_cname[76];
char doc_colax[91];
char doc_colnum[235];
char doc_convert[120];
char doc_coord[278];
char doc_copy[39];
char doc_cpdis1[99];
char doc_cpdis2[99];
char doc_crder[123];
char doc_crota[1014];
char doc_crpix[88];
char doc_crval[93];
char doc_crval_tabprm[131];
char doc_csyer[132];
char doc_ctype[222];
char doc_cubeface[1209];
char doc_cunit[1161];
char doc_cylfix[127];
char doc_data[72];
char doc_data_wtbarr[51];
char doc_dateavg[146];
char doc_dateobs[127];
char doc_datfix[453];
char doc_delta[195];
char doc_det2im[57];
char doc_det2im1[96];
char doc_det2im2[96];
char doc_dims[98];
char doc_equinox[242];
char doc_extlev[72];
char doc_extnam[73];
char doc_extrema[439];
char doc_extver[72];
char doc_find_all_wcs[846];
char doc_fix[1382];
char doc_get_cdelt[445];
char doc_get_offset[103];
char doc_get_pc[384];
char doc_get_ps[363];
char doc_get_pv[647];
char doc_has_cd[859];
char doc_has_cdi_ja[96];
char doc_has_crota[614];
char doc_has_crotaia[101];
char doc_has_pc[176];
char doc_has_pci_ja[96];
char doc_have[163];
char doc_i[40];
char doc_imgpix_matrix[143];
char doc_is_unity[102];
char doc_kind[129];
char doc_lat[89];
char doc_latpole[75];
char doc_lattyp[227];
char doc_lng[90];
char doc_lngtyp[228];
char doc_lonpole[76];
char doc_m[58];
char doc_map[941];
char doc_mix[4642];
char doc_mjdavg[189];
char doc_mjdobs[189];
char doc_name[74];
char doc_naxis[760];
char doc_nc[121];
char doc_ndim[66];
char doc_obsgeo[186];
char doc_offset[47];
char doc_p0[196];
char doc_p2s[1821];
char doc_p4_pix2foc[556];
char doc_pc[1085];
char doc_phi0[283];
char doc_pix2foc[558];
char doc_piximg_matrix[128];
char doc_power[49];
char doc_print_contents[204];
char doc_print_contents_tabprm[210];
char doc_radesys[77];
char doc_restfrq[94];
char doc_restwav[94];
char doc_row[39];
char doc_s2p[1710];
char doc_scale[56];
char doc_sense[182];
char doc_set[1178];
char doc_set_ps[354];
char doc_set_pv[353];
char doc_set_tabprm[346];
char doc_sip[77];
char doc_sip_foc2pix[573];
char doc_sip_pix2foc[571];
char doc_spcfix[237];
char doc_spec[68];
char doc_specsys[139];
char doc_sptr[1354];
char doc_ssysobs[226];
char doc_ssyssrc[110];
char doc_sub[3096];
char doc_tab[83];
char doc_theta0[282];
char doc_to_header[2086];
char doc_ttype[107];
char doc_unitfix[1008];
char doc_velangl[169];
char doc_velosys[282];
char doc_want[161];
char doc_wcs[75];
char doc_zsource[98];

void fill_docstrings(void)
{
   strncpy(doc_DistortionLookupTable + 0, "DistortionLookupTable(*table*, *crpix*, *crval*, *cdelt*)\n\n- *table*: 2-dimensional array for the distortion lookup table.\n\n- *crpix*: the distortion array reference pixel (a 2-tuple)\n\n- *crval*: is the image array pixel coordinate (a 2-tuple)\n\n- *cdelt*: ", 256);
   strncpy(doc_DistortionLookupTable + 256, "is the grid step size (a 2-tuple)\n\nRepresents a single lookup table for a `Paper IV`_ distortion\ntransformation.\n", 113);

   strncpy(doc_K + 0, "``int array[M]`` (read-only)\n\nAn array of length `M` whose elements record the lengths of the axes of\nthe coordinate array and of each indexing vector.\n", 152);

   strncpy(doc_M + 0, "``int`` (read-only)\n\nNumber of tabular coordinate axes.\n", 56);

   strncpy(doc_Sip + 0, "Sip(*a, b, ap, bp, crpix*)\n\nThe `~pywcs.Sip` class performs polynomial distortion correction using\nthe `SIP`_ convention in both directions.\n\n   Shupe, D. L., M. Moshir, J. Li, D. Makovoz and R. Narron.  2005.\n   \"The SIP Convention for Representing Distor", 256);
   strncpy(doc_Sip + 256, "tion in FITS Image\n   Headers.\"  ADASS XIV.\n\n- *a*: double array[m+1][m+1].  The ``A_i_j`` polynomial for pixel to\n  focal plane transformation.  Its size must be (*m* + 1, *m* + 1)\n  where *m* = ``A_ORDER``.\n\n- *b*: double array[m+1][m+1].  The ``B_i_j`` ", 256);
   strncpy(doc_Sip + 512, "polynomial for pixel to\n  focal plane transformation.  Its size must be (*m* + 1, *m* + 1)\n  where *m* = ``B_ORDER``.\n\n- *ap*: double array[m+1][m+1].  The ``AP_i_j`` polynomial for pixel\n  to focal plane transformation.  Its size must be (*m* + 1, *m* + 1", 256);
   strncpy(doc_Sip + 768, ")\n  where *m* = ``AP_ORDER``.\n\n- *bp*: double array[m+1][m+1].  The ``BP_i_j`` polynomial for pixel to\n  focal plane transformation.  Its size must be (*m* + 1, *m* + 1) where\n  *m* = ``BP_ORDER``.\n\n- *crpix*: double array[2].  The reference pixel.\n", 249);

   strncpy(doc_Tabprm + 0, "A class to store the information related to tabular coordinates,\ni.e. coordinates that are defined via a lookup table.\n\nThis class can not be constructed directly from Python, but instead is\nreturned from `~pywcs.Wcsprm.tab`.\n", 226);

   strncpy(doc_UnitConverter + 0, "UnitConverter(have, want, translate_units=\'\')\n\nCreates an object for performing conversion from one system of units\nto another.\n\n- *have* string: :ref:`fits-unit` to convert from, with or without\n  surrounding square brackets (for inline specifications); t", 256);
   strncpy(doc_UnitConverter + 256, "ext\n  following the closing bracket is ignored.\n\n- *want* string: :ref:`fits-unit` to convert to, with or without\n  surrounding square brackets (for inline specifications); text\n  following the closing bracket is ignored.\n\n- *ctrl* string (optional): Do po", 256);
   strncpy(doc_UnitConverter + 512, "tentially unsafe translations of\n  non-standard unit strings.\n\n  Although ``\"S\"`` is commonly used to represent seconds, its\n  recognizes ``\"S\"`` formally as Siemens, however rarely that may be\n  translation to ``\"s\"`` is potentially unsafe since the stand", 256);
   strncpy(doc_UnitConverter + 768, "ard\n  used.  The same applies to ``\"H\"`` for hours (Henry), and ``\"D\"``\n  for days (Debye).\n\n  This string controls what to do in such cases, and is\n  case-insensitive.\n\n  - If the string contains ``\"s\"``, translate ``\"S\"`` to ``\"s\"``.\n\n  - If the string c", 256);
   strncpy(doc_UnitConverter + 1024, "ontains ``\"h\"``, translate ``\"H\"`` to ``\"h\"``.\n\n  - If the string contains ``\"d\"``, translate ``\"D\"`` to ``\"d\"``.\n\n  Thus ``\'\'`` doesn\'t do any unsafe translations, whereas ``\'shd\'``\n  does all of them.\n\n  See :ref:`fits-unit` for more information.\n\nUse th", 256);
   strncpy(doc_UnitConverter + 1280, "e returned object\'s `~pywcs.UnitConverter.convert` method to\nconvert values from *have* to *want*.\n\nThis function is permissive in accepting whitespace in all contexts in\na units specification where it does not create ambiguity (e.g. not\nbetween a metric p", 256);
   strncpy(doc_UnitConverter + 1536, "refix and a basic unit string), including in strings\nlike ``\"log (m ** 2)\"`` which is formally disallowed.\n\n**Exceptions:**\n\n- `ValueError`: Invalid numeric multiplier.\n\n- `SyntaxError`: Dangling binary operator.\n\n- `SyntaxError`: Invalid symbol in INITIAL", 256);
   strncpy(doc_UnitConverter + 1792, " context.\n\n- `SyntaxError`: Function in invalid context.\n\n- `SyntaxError`: Invalid symbol in EXPON context.\n\n- `SyntaxError`: Unbalanced bracket.\n\n- `SyntaxError`: Unbalanced parenthesis.\n\n- `SyntaxError`: Consecutive binary operators.\n\n- `SyntaxError`: In", 256);
   strncpy(doc_UnitConverter + 2048, "ternal parser error.\n\n- `SyntaxError`: Non-conformant unit specifications.\n\n- `SyntaxError`: Non-conformant functions.\n\n- `ValueError`: Potentially unsafe translation.\n", 168);

   strncpy(doc_Wcs + 0, "Wcs(*sip, cpdis, wcsprm, det2im*)\n\nWcs objects amalgamate basic WCS (as provided by `wcslib`_), with\n`SIP`_ and `Paper IV`_ distortion operations.\n\nTo perform all distortion corrections and WCS tranformation, use\n`all_pix2sky`.\n\n- *sip*: A `~pywcs.Sip` obj", 256);
   strncpy(doc_Wcs + 256, "ect or ``None``\n\n- *cpdis*: A pair of `~pywcs.DistortionLookupTable` objects, or\n  ``(None, None)``.\n\n- *wcsprm*: A `~pywcs.Wcsprm` object\n\n- *det2im*: A pair of `~pywcs.DistortionLookupTable` objects, or\n   ``(None, None)``.\n", 226);

   strncpy(doc_Wcsprm + 0, "Wcsprm(header=None, key=\' \', relax=False, naxis=2, keysel=0, colsel=None)\n\n`~pywcs.Wcsprm` is a direct wrapper around `wcslib`_, and provides\naccess to the core WCS transformations that it supports.\n\nThe FITS header parsing enforces correct FITS \"keyword =", 256);
   strncpy(doc_Wcsprm + 256, " value\" syntax\nwith regard to the equals sign occurring in columns 9 and 10.\nHowever, it does recognize free-format character (NOST 100-2.0,\nSect. 5.2.1), integer (Sect. 5.2.3), and floating-point values\n(Sect. 5.2.4) for all keywords.\n\n- *header*: A PyFIT", 256);
   strncpy(doc_Wcsprm + 512, "S header object or a string containing the raw FITS\n  header data or ``None``.  If ``None``, the object will be\n  initialized to default values.\n\n- *key*: The key referring to a particular WCS transform in the\n  header.  This may be either ``\' \'`` or ``\'A\'", 256);
   strncpy(doc_Wcsprm + 768, "``-``\'Z\'`` and\n  corresponds to the ``\"a\"`` part of ``\"CTYPEia\"``.  (*key*\n  may only be provided if *header* is also provided.)\n\n- *relax*: Degree of permissiveness:\n\n    - `False`: Recognize only FITS keywords defined by the published\n      WCS standard.", 256);
   strncpy(doc_Wcsprm + 1024, "\n\n    - `True`: Admit all recognized informal extensions of the WCS\n      standard.\n\n    - `int`: a bit field selecting specific extensions to accept.  See\n      :ref:`relaxread` for details.\n\n- *naxis*: The number of sky coordinates axes for the object.\n ", 256);
   strncpy(doc_Wcsprm + 1280, " (*naxis* may only be provided if *header* is ``None``.)\n\n- *keysel*: Vector of flag bits that may be used to restrict the\n  keyword types considered:\n\n     - ``WCSHDR_IMGHEAD``: Image header keywords.\n\n     - ``WCSHDR_BIMGARR``: Binary table image array.\n", 256);
   strncpy(doc_Wcsprm + 1536, "\n     - ``WCSHDR_PIXLIST``: Pixel list keywords.\n\n   If zero, there is no restriction.  If -1, the underlying wcslib\n   function ``wcspih()`` is called, rather than ``wcstbh()``.\n\n- *colsel*: A sequence of table column numbers used to restrict the\n  keywor", 256);
   strncpy(doc_Wcsprm + 1792, "ds considered.  ``None`` indicates no restriction.\n\n**Exceptions:**\n\n- `MemoryError`: Memory allocation failed.\n\n- `ValueError`: Invalid key.\n\n- `KeyError`: Key not found in FITS header.\n", 187);

   strncpy(doc_Wtbarr + 0, "Classes to construct coordinate lookup tables from a binary table\nextension (BINTABLE).\n\nThis class can not be constructed directly from Python, but instead is\nreturned from `~pywcs.Wcsprm.wtb`.\n", 195);

   strncpy(doc_a + 0, "``double array[a_order+1][a_order+1]``\n\nThe `SIP`_ ``A_i_j`` matrix used for pixel to focal plane\ntransformation.\n\nIts values may be changed in place, but it may not be resized, without\ncreating a new `~pywcs.Sip` object.\n", 222);

   strncpy(doc_a_order + 0, "``int`` (read-only)\n\nThe order of the polynomial in the `SIP`_ ``A_i_j`` array (``A_ORDER``).\n", 94);

   strncpy(doc_all_pix2sky + 0, "all_pix2sky(pixcrd, origin) -> ``double array[ncoord][nelem]``\n\nTransforms pixel coordinates to sky coordinates by doing all of the\nfollowing:\n\n    - Detector to image plane correction (optionally)\n\n    - SIP distortion correction (optionally)\n\n    - Paper", 256);
   strncpy(doc_all_pix2sky + 256, " IV distortion correction (optionally)\n\n    - wcslib WCS transformation\n\nThe first three (the distortion corrections) are done in parallel.\n\n- *pixcrd*: double array[ncoord][nelem].  Array of pixel coordinates.\n\n\n- *origin*: int. Specifies the origin of pi", 256);
   strncpy(doc_all_pix2sky + 512, "xel values.  The Fortran and\n  FITS standards use an origin of 1.  Numpy and C use array indexing\n  with origin at 0.\n\n\nReturns an array of sky coordinates.\n\n**Exceptions:**\n\n- `MemoryError`: Memory allocation failed.\n\n- `SingularMatrixError`: Linear trans", 256);
   strncpy(doc_all_pix2sky + 768, "formation matrix is singular.\n\n- `InconsistentAxisTypesError`: Inconsistent or unrecognized\n  coordinate axis types.\n\n- `ValueError`: Invalid parameter value.\n\n- `ValueError`: Invalid coordinate transformation parameters.\n\n- `ValueError`: x- and y-coordina", 256);
   strncpy(doc_all_pix2sky + 1024, "te arrays are not the same size.\n\n- `InvalidTransformError`: Invalid coordinate transformation.\n\n- `InvalidTransformError`: Ill-conditioned coordinate transformation\n  parameters.\n", 180);

   strncpy(doc_alt + 0, "``str``\n\nCharacter code for alternate coordinate descriptions.  For example,\nthe ``\"a\"`` in keyword names such as ``CTYPEia``.  This is a space\ncharacter for the primary coordinate description, or one of the 26\nupper-case letters, A-Z.\n", 236);

   strncpy(doc_ap + 0, "``double array[ap_order+1][ap_order+1]``\n\nThe `SIP`_ ``AP_i_j`` matrix used for focal plane to pixel\ntransformation.  Its values may be changed in place, but it may not be\nresized, without creating a new `~pywcs.Sip` object.\n", 225);

   strncpy(doc_ap_order + 0, "``int`` (read-only)\n\nThe order of the polynomial in the `SIP`_ ``AP_i_j`` array\n(``AP_ORDER``).\n", 96);

   strncpy(doc_axis_types + 0, "``int array[naxis]``\n\nAn array of four-digit type codes for each axis.\n\n- First digit (i.e. 1000s):\n\n  - 0: Non-specific coordinate type.\n\n  - 1: Stokes coordinate.\n\n  - 2: Celestial coordinate (including ``CUBEFACE``).\n\n  - 3: Spectral coordinate.\n\n- Seco", 256);
   strncpy(doc_axis_types + 256, "nd digit (i.e. 100s):\n\n  - 0: Linear axis.\n\n  - 1: Quantized axis (``STOKES``, ``CUBEFACE``).\n\n  - 2: Non-linear celestial axis.\n\n  - 3: Non-linear spectral axis.\n\n  - 4: Logarithmic axis.\n\n  - 5: Tabular axis.\n\n- Third digit (i.e. 10s):\n\n  - 0: Group numb", 256);
   strncpy(doc_axis_types + 512, "er, e.g. lookup table number\n\n- The fourth digit is used as a qualifier depending on the axis type.\n\n  - For celestial axes:\n\n    - 0: Longitude coordinate.\n\n    - 1: Latitude coordinate.\n\n    - 2: ``CUBEFACE`` number.\n\n  - For lookup tables: the axis numb", 256);
   strncpy(doc_axis_types + 768, "er in a multidimensional table.\n\n``CTYPEia`` in ``\"4-3\"`` form with unrecognized algorithm code will\nhave its type set to -1 and generate an error.\n", 148);

   strncpy(doc_b + 0, "``double array[b_order+1][b_order+1]``\n\nThe `SIP`_ ``B_i_j`` matrix used for pixel to focal plane\ntransformation.  Its values may be changed in place, but it may not be\nresized, without creating a new `~pywcs.Sip` object.\n", 222);

   strncpy(doc_b_order + 0, "``int`` (read-only)\n\nThe order of the polynomial in the `SIP`_ ``B_i_j`` array\n(``B_ORDER``).\n", 94);

   strncpy(doc_bp + 0, "``double array[bp_order+1][bp_order+1]``\n\nThe `SIP`_ ``BP_i_j`` matrix used for focal plane to pixel\ntransformation.  Its values may be changed in place, but it may not be\nresized, without creating a new `~pywcs.Sip` object.\n", 225);

   strncpy(doc_bp_order + 0, "``int`` (read-only)\n\nThe order of the polynomial in the `SIP`_ ``BP_i_j`` array\n(``BP_ORDER``).\n", 96);

   strncpy(doc_cd + 0, "``double array[naxis][naxis]``\n\nThe ``CDi_ja`` linear transformation matrix.\n\nFor historical compatibility, three alternate specifications of the\nlinear transforations are available in wcslib.  The canonical\n``PCi_ja`` with ``CDELTia``, and the deprecated ", 256);
   strncpy(doc_cd + 256, "``CDi_ja`` and\n``CROTAia`` keywords.  Although the deprecated versions may not\nformally co-exist with ``PCi_ja``, the approach here is simply to\nignore them if given in conjunction with ``PCi_ja``.\n\n`~pywcs.Wcsprm.has_pc`, `~pywcs.Wcsprm.has_cd` and\n`~pywc", 256);
   strncpy(doc_cd + 512, "s.Wcsprm.has_crota` can be used to determine which of these\nalternatives are present in the header.\n\nThese alternate specifications of the linear transformation matrix are\ntranslated immediately to ``PCi_ja`` by `~pywcs.Wcsprm.set` and are\nnowhere visible ", 256);
   strncpy(doc_cd + 768, "to the lower-level routines.  In particular,\n`~pywcs.Wcsprm.set` resets `~pywcs.Wcsprm.cdelt` to unity if\n``CDi_ja`` is present (and no ``PCi_ja``).  If no ``CROTAia`` is\nassociated with the latitude axis, `set` reverts to a unity ``PCi_ja``\nmatrix.\n", 250);

   strncpy(doc_cdelt + 0, "``double array[naxis]``\n\nCoordinate increments (``CDELTia``) for each coord axis.\n\nIf a ``CDi_ja`` linear transformation matrix is present, a warning is\nraised and `~pywcs.Wcsprm.cdelt` is ignored.  The ``CDi_ja`` matrix\nmay be deleted by::\n\n  del wcs.wcs.", 256);
   strncpy(doc_cdelt + 256, "cd\n\nAn undefined value is represented by NaN.\n", 46);

   strncpy(doc_cel_offset + 0, "``boolean``\n\nIf `True`, an offset will be applied to ``(x, y)`` to force ``(x,y) =\n(0,0)`` at the fiducial point, (phi_0, theta_0).  Default is\n`False`.\n", 153);

   strncpy(doc_celfix + 0, "Translates AIPS-convention celestial projection types, ``-NCP`` and\n``-GLS``.\n\nReturns ``0`` for success; ``-1`` if no change required.\n", 136);

   strncpy(doc_cname + 0, "``list of strings``\n\nA list of the coordinate axis names, from ``CNAMEia``.\n", 76);

   strncpy(doc_colax + 0, "``int array[naxis]``\n\nAn array recording the column numbers for each axis in a pixel list.\n", 91);

   strncpy(doc_colnum + 0, "``int``\n\nWhere the coordinate representation is associated with an image-array\ncolumn in a FITS binary table, this property may be used to record the\nrelevant column number.\n\nIt should be set to zero for an image header or pixel list.\n", 235);

   strncpy(doc_convert + 0, "convert(array)\n\nPerform the unit conversion on the elements of the given *array*,\nreturning an array of the same shape.\n", 120);

   strncpy(doc_coord + 0, "``double array[K_M]...[K_2][K_1][M]``\n\nThe tabular coordinate array, with the dimensions::\n\n    (K_M, ... K_2, K_1, M)\n\n(see `~pywcs._pywcs.Tabprm.K`) i.e. with the `M` dimension varying\nfastest so that the `M` elements of a coordinate vector are stored\nco", 256);
   strncpy(doc_coord + 256, "ntiguously in memory.\n", 22);

   strncpy(doc_copy + 0, "Creates a deep copy of the WCS object.\n", 39);

   strncpy(doc_cpdis1 + 0, "`~pywcs.DistortionLookupTable`\n\nThe pre-linear transformation distortion lookup table, ``CPDIS1``.\n", 99);

   strncpy(doc_cpdis2 + 0, "`~pywcs.DistortionLookupTable`\n\nThe pre-linear transformation distortion lookup table, ``CPDIS2``.\n", 99);

   strncpy(doc_crder + 0, "``double array[naxis]``\n\nThe random error in each coordinate axis, ``CRDERia``.\n\nAn undefined value is represented by NaN.\n", 123);

   strncpy(doc_crota + 0, "``double array[naxis]``\n\n``CROTAia`` keyvalues for each coordinate axis.\n\nFor historical compatibility, three alternate specifications of the\nlinear transforations are available in wcslib.  The canonical\n``PCi_ja`` with ``CDELTia``, and the deprecated ``CD", 256);
   strncpy(doc_crota + 256, "i_ja`` and\n``CROTAia`` keywords.  Although the deprecated versions may not\nformally co-exist with ``PCi_ja``, the approach here is simply to\nignore them if given in conjunction with ``PCi_ja``.\n\n`~pywcs.Wcsprm.has_pc`, `~pywcs.Wcsprm.has_cd` and\n`~pywcs.Wc", 256);
   strncpy(doc_crota + 512, "sprm.has_crota` can be used to determine which of these\nalternatives are present in the header.\n\nThese alternate specifications of the linear transformation matrix are\ntranslated immediately to ``PCi_ja`` by `~pywcs.Wcsprm.set` and are\nnowhere visible to t", 256);
   strncpy(doc_crota + 768, "he lower-level routines.  In particular,\n`~pywcs.Wcsprm.set` resets `~pywcs.Wcsprm.cdelt` to unity if\n``CDi_ja`` is present (and no ``PCi_ja``).  If no ``CROTAia`` is\nassociated with the latitude axis, `set` reverts to a unity ``PCi_ja``\nmatrix.\n", 246);

   strncpy(doc_crpix + 0, "``double array[naxis]``\n\nCoordinate reference pixels (``CRPIXja``) for each pixel axis.\n", 88);

   strncpy(doc_crval + 0, "``double array[naxis]``\n\nCoordinate reference values (``CRVALia``) for each coordinate axis.\n", 93);

   strncpy(doc_crval_tabprm + 0, "``double array[M]``\n\nArray whose elements contain the index value for the reference pixel\nfor each of the tabular coordinate axes.\n", 131);

   strncpy(doc_csyer + 0, "``double array[naxis]``\n\nThe systematic error in the coordinate value axes, ``CSYERia``.\n\nAn undefined value is represented by NaN.\n", 132);

   strncpy(doc_ctype + 0, "``list of strings[naxis]``\n\nList of ``CTYPEia`` keyvalues.\n\nThe `~pywcs.Wcsprm.ctype` keyword values must be in upper case and\nthere must be zero or one pair of matched celestial axis types, and\nzero or one spectral axis.\n", 222);

   strncpy(doc_cubeface + 0, "``int``\n\nIndex into the ``pixcrd`` (pixel coordinate) array for the\n``CUBEFACE`` axis.  This is used for quadcube projections where the\ncube faces are stored on a separate axis.\n\nThe quadcube projections (``TSC``, ``CSC``, ``QSC``) may be\nrepresented in FI", 256);
   strncpy(doc_cubeface + 256, "TS in either of two ways:\n\n    - The six faces may be laid out in one plane and numbered as\n      follows::\n\n\n                                       0\n\n                              4  3  2  1  4  3  2\n\n                                       5\n\n      Faces", 256);
   strncpy(doc_cubeface + 512, " 2, 3 and 4 may appear on one side or the other (or both).\n      The sky-to-pixel routines map faces 2, 3 and 4 to the left but\n      the pixel-to-sky routines accept them on either side.\n\n    - The ``COBE`` convention in which the six faces are stored in ", 256);
   strncpy(doc_cubeface + 768, "a\n      three-dimensional structure using a ``CUBEFACE`` axis indexed\n      from 0 to 5 as above.\n\nThese routines support both methods; `~pywcs.Wcsprm.set` determines\nwhich is being used by the presence or absence of a ``CUBEFACE`` axis\nin `~pywcs.Wcsprm.c", 256);
   strncpy(doc_cubeface + 1024, "type`.  `~pywcs.Wcsprm.p2s` and `~pywcs.Wcsprm.s2p`\ntranslate the ``CUBEFACE`` axis representation to the single plane\nrepresentation understood by the lower-level projection routines.\n", 185);

   strncpy(doc_cunit + 0, "``list of strings[naxis]``\n\nList of ``CUNITia`` keyvalues which define the units of measurement of\nthe ``CRVALia``, ``CDELTia`` and ``CDi_ja`` keywords.\n\nAs ``CUNITia`` is an optional header keyword, `~pywcs.Wcsprm.cunit`\nmay be left blank but otherwise is", 256);
   strncpy(doc_cunit + 256, " expected to contain a standard\nunits specification as defined by WCS Paper I.\n`~pywcs.Wcsprm.unitfix` is available to translate commonly used\nnon-standard units specifications but this must be done as a separate\nstep before invoking `~pywcs.Wcsprm.set`.\n\n", 256);
   strncpy(doc_cunit + 512, "For celestial axes, if `~pywcs.Wcsprm.cunit` is not blank,\n`~pywcs.Wcsprm.set` uses `wcsunits` to parse it and scale\n`~pywcs.Wcsprm.cdelt`, `~pywcs.Wcsprm.crval`, and `~pywcs.Wcsprm.cd`\nto decimal degrees.  It then resets `~pywcs.Wcsprm.cunit` to\n``\"deg\"``", 256);
   strncpy(doc_cunit + 768, ".\n\nFor spectral axes, if `~pywcs.Wcsprm.cunit` is not blank,\n`~pywcs.Wcsprm.set` uses `wcsunits` to parse it and scale\n`~pywcs.Wcsprm.cdelt`, `~pywcs.Wcsprm.crval`, and `~pywcs.Wcsprm.cd`\nto SI units.  It then resets `~pywcs.Wcsprm.cunit` accordingly.\n\n`~p", 256);
   strncpy(doc_cunit + 1024, "ywcs.Wcsprm.set` ignores `~pywcs.Wcsprm.cunit` for other coordinate\ntypes; `~pywcs.Wcsprm.cunit` may be used to label coordinate values.\n", 137);

   strncpy(doc_cylfix + 0, "cylfix()\n\nFixes WCS keyvalues for malformed cylindrical projections.\n\nReturns ``0`` for success; ``-1`` if no change required.\n", 127);

   strncpy(doc_data + 0, "``float array``\n\nThe array data for the `~pywcs.DistortionLookupTable`.\n", 72);

   strncpy(doc_data_wtbarr + 0, "``double array``\n\nThe array data for the BINTABLE.\n", 51);

   strncpy(doc_dateavg + 0, "``string``\n\nRepresentative mid-point of the date of observation in ISO format,\n``yyyy-mm-ddThh:mm:ss``.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.dateobs`\n", 146);

   strncpy(doc_dateobs + 0, "``string``\n\nStart of the date of observation in ISO format,\n``yyyy-mm-ddThh:mm:ss``.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.dateavg`\n", 127);

   strncpy(doc_datfix + 0, "datfix()\n\nTranslates the old ``DATE-OBS`` date format to year-2000 standard form\n``(yyyy-mm-ddThh:mm:ss)`` and derives ``MJD-OBS`` from it if not\nalready set.  Alternatively, if `~pywcs.Wcsprm.mjdobs` is set and\n`~pywcs.Wcsprm.dateobs` isn\'t, then `~pywcs.", 256);
   strncpy(doc_datfix + 256, "Wcsprm.datfix` derives\n`~pywcs.Wcsprm.dateobs` from it.  If both are set but disagree by more\nthan half a day then `ValueError` is raised.\n\nReturns ``0`` for success; ``-1`` if no change required.\n", 197);

   strncpy(doc_delta + 0, "``double array[M]`` (read-only)\n\nArray of interpolated indices into the coordinate array such that\nUpsilon_m, as defined in Paper III, is equal to\n(`~pywcs._pywcs.Tabprm.p0` [m] + 1) + delta[m].\n", 195);

   strncpy(doc_det2im + 0, "Convert detector coordinates to image plane coordinates.\n", 57);

   strncpy(doc_det2im1 + 0, "A `~pywcs.DistortionLookupTable` object for detector to image plane\ncorrection in the *x*-axis.\n", 96);

   strncpy(doc_det2im2 + 0, "A `~pywcs.DistortionLookupTable` object for detector to image plane\ncorrection in the *y*-axis.\n", 96);

   strncpy(doc_dims + 0, "``int array[ndim]`` (read-only)\n\nThe dimensions of the tabular array `~pywcs._pywcs.Wtbarr.data`.\n", 98);

   strncpy(doc_equinox + 0, "``double``\n\nThe equinox associated with dynamical equatorial or ecliptic\ncoordinate systems, ``EQUINOXa`` (or ``EPOCH`` in older headers).  Not\napplicable to ICRS equatorial or ecliptic coordinates.\n\nAn undefined value is represented by NaN.\n", 242);

   strncpy(doc_extlev + 0, "``int`` (read-only)\n\n``EXTLEV`` identifying the binary table extension.\n", 72);

   strncpy(doc_extnam + 0, "``str`` (read-only)\n\n``EXTNAME`` identifying the binary table extension.\n", 73);

   strncpy(doc_extrema + 0, "``double array[K_M]...[K_2][2][M]`` (read-only)\n\nAn array recording the minimum and maximum value of each element of\nthe coordinate vector in each row of the coordinate array, with the\ndimensions::\n\n    (K_M, ... K_2, 2, M)\n\n(see `~pywcs._pywcs.Tabprm.K`).", 256);
   strncpy(doc_extrema + 256, "  The minimum is recorded in the first\nelement of the compressed K_1 dimension, then the maximum.  This array\nis used by the inverse table lookup function to speed up table\nsearches.\n", 183);

   strncpy(doc_extver + 0, "``int`` (read-only)\n\n``EXTVER`` identifying the binary table extension.\n", 72);

   strncpy(doc_find_all_wcs + 0, "find_all_wcs(relax=0, keysel=0)\n\nFind all WCS transformations in the header.\n\n- *header*: A string containing the raw FITS header data.\n\n- *relax*: Degree of permissiveness:\n\n    - `False`: Recognize only FITS keywords defined by the published\n      WCS st", 256);
   strncpy(doc_find_all_wcs + 256, "andard.\n\n    - `True`: Admit all recognized informal extensions of the WCS\n      standard.\n\n    - `int`: a bit field selecting specific extensions to accept.  See\n      :ref:`relaxread` for details.\n\n- *keysel*: Vector of flag bits that may be used to rest", 256);
   strncpy(doc_find_all_wcs + 512, "rict the\n  keyword types considered:\n\n     - ``WCSHDR_IMGHEAD``: Image header keywords.\n\n     - ``WCSHDR_BIMGARR``: Binary table image array.\n\n     - ``WCSHDR_PIXLIST``: Pixel list keywords.\n\n   If zero, there is no restriction.  If -1, wcspih() is called,", 256);
   strncpy(doc_find_all_wcs + 768, "\n   rather than wcstbh().\n\nReturns a list of `~pywcs._pywcs._Wcsprm` objects.\n", 78);

   strncpy(doc_fix + 0, "fix(translate_units=\'\', naxis=0)\n\nApplies all of the corrections handled separately by\n`~pywcs.Wcsprm.datfix`, `~pywcs.Wcsprm.unitfix`,\n`~pywcs.Wcsprm.celfix`, `~pywcs.Wcsprm.spcfix` and\n`~pywcs.Wcsprm.cylfix`.\n\n- *translate_units*: string. Do potentially ", 256);
   strncpy(doc_fix + 256, "unsafe translations of\n  non-standard unit strings.\n\n  Although ``\"S\"`` is commonly used to represent seconds, its\n  translation to ``\"s\"`` is potentially unsafe since the standard\n  recognizes ``\"S\"`` formally as Siemens, however rarely that may be\n  used", 256);
   strncpy(doc_fix + 512, ".  The same applies to ``\"H\"`` for hours (Henry), and ``\"D\"``\n  for days (Debye).\n\n  This string controls what to do in such cases, and is\n  case-insensitive.\n\n  - If the string contains ``\"s\"``, translate ``\"S\"`` to ``\"s\"``.\n\n  - If the string contains ``", 256);
   strncpy(doc_fix + 768, "\"h\"``, translate ``\"H\"`` to ``\"h\"``.\n\n  - If the string contains ``\"d\"``, translate ``\"D\"`` to ``\"d\"``.\n\n    Thus ``\'\'`` doesn\'t do any unsafe translations, whereas ``\'shd\'``\n    does all of them.\n\n- *naxis*: int array[naxis].  Image axis lengths.  If this", 256);
   strncpy(doc_fix + 1024, " array is\n  set to zero or ``None``, then `~pywcs.Wcsprm.cylfix` will not be\n  invoked.\n\nReturns a dictionary containing the following keys, each referring to\na status string for each of the sub-fix functions that were\ncalled:\n\n- `~pywcs.Wcsprm.datfix`\n\n- ", 256);
   strncpy(doc_fix + 1280, "`~pywcs.Wcsprm.unitfix`\n\n- `~pywcs.Wcsprm.celfix`\n\n- `~pywcs.Wcsprm.spcfix`\n\n- `~pywcs.Wcsprm.cylfix`\n", 102);

   strncpy(doc_get_cdelt + 0, "get_cdelt() -> double array[naxis]\n\nCoordinate increments (``CDELTia``) for each coord axis.\n\nReturns the ``CDELT`` offsets in read-only form.  Unlike the\n`~pywcs.Wcsprm.cdelt` property, this works even when the header specifies\nthe linear transformation m", 256);
   strncpy(doc_get_cdelt + 256, "atrix in one of the deprecated ``CDi_ja``\nor ``CROTAia`` forms.  This is useful when you want access to the\nlinear transformation matrix, but don\'t care how it was specified in\nthe header.\n", 189);

   strncpy(doc_get_offset + 0, "get_offset(*x, y*) -> (*x, y*)\n\nReturns the offset from the distortion table for pixel point (*x, y*).\n", 103);

   strncpy(doc_get_pc + 0, "get_pc() -> double array[naxis][naxis]\n\nReturns the ``PC`` matrix in read-only form.  Unlike the\n`~pywcs.Wcsprm.pc` property, this works even when the header specifies\nthe linear transformation matrix in one of the deprecated ``CDi_ja``\nor ``CROTAia`` form", 256);
   strncpy(doc_get_pc + 256, "s.  This is useful when you want access to the\nlinear transformation matrix, but don\'t care how it was specified in\nthe header.\n", 128);

   strncpy(doc_get_ps + 0, "get_ps() -> list of tuples\n\nReturns ``PSi_ma`` keywords for each *i* and *m*.  Returned as a list\nof tuples of the form (*i*, *m*, *value*):\n\n    - *i*: int.  Axis number, as in ``PSi_ma``, (i.e. 1-relative)\n\n    - *m*: int.  Parameter number, as in ``PSi_", 256);
   strncpy(doc_get_ps + 256, "ma``, (i.e. 0-relative)\n\n    - *value*: string.  Parameter value.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.set_ps`\n", 107);

   strncpy(doc_get_pv + 0, "get_pv() -> list of tuples\n\nReturns ``PVi_ma`` keywords for each *i* and *m*.  Returned as a list\nof tuples of the form (*i*, *m*, *value*):\n\n    - *i*: int.  Axis number, as in ``PVi_ma``, (i.e. 1-relative)\n\n    - *m*: int.  Parameter number, as in ``PVi_", 256);
   strncpy(doc_get_pv + 256, "ma``, (i.e. 0-relative)\n\n    - *value*: string. Parameter value.\n\nNote that, if they were not given, `~pywcs.Wcsprm.set` resets the\nentries for ``PVi_1a``, ``PVi_2a``, ``PVi_3a``, and ``PVi_4a`` for\nlongitude axis *i* to match (``phi_0``, ``theta_0``), the", 256);
   strncpy(doc_get_pv + 512, " native\nlongitude and latitude of the reference point given by ``LONPOLEa``\nand ``LATPOLEa``.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.set_pv`\n", 135);

   strncpy(doc_has_cd + 0, "has_cd() -> bool\n\nReturns `True` if ``CDi_ja`` is present.  ``CDi_ja`` is an alternate\nspecification of the linear transformation matrix, maintained for\nhistorical compatibility.\n\nMatrix elements in the IRAF convention are equivalent to the product\n``CDi_j", 256);
   strncpy(doc_has_cd + 256, "a = CDELTia * PCi_ja``, but the defaults differ from that of\nthe ``PCi_ja`` matrix.  If one or more ``CDi_ja`` keywords are present\nthen all unspecified ``CDi_ja`` default to zero.  If no ``CDi_ja`` (or\n``CROTAia``) keywords are present, then the header is", 256);
   strncpy(doc_has_cd + 512, " assumed to be in\n``PCi_ja`` form whether or not any ``PCi_ja`` keywords are present\nsince this results in an interpretation of ``CDELTia`` consistent with\nthe original FITS specification.\n\nWhile ``CDi_ja`` may not formally co-exist with ``PCi_ja``, it may", 256);
   strncpy(doc_has_cd + 768, "\nco-exist with ``CDELTia`` and ``CROTAia`` which are to be ignored.\n\n.. seealso::\n\n   `cd`\n", 91);

   strncpy(doc_has_cdi_ja + 0, "has_cdi_ja() -> bool\n\nAlias for `~pywcs.Wcsprm.has_cd`.  Maintained for backward\ncompatibility.\n", 96);

   strncpy(doc_has_crota + 0, "has_crota() -> bool\n\nReturns `True` if ``CROTAia`` is present.  ``CROTAia`` is an\nalternate specification of the linear transformation matrix,\nmaintained for historical compatibility.\n\nIn the AIPS convention, ``CROTAia`` may only be associated with the\nlat", 256);
   strncpy(doc_has_crota + 256, "itude axis of a celestial axis pair.  It specifies a rotation in\nthe image plane that is applied *after* the ``CDELTia``; any other\n``CROTAia`` keywords are ignored.\n\n``CROTAia`` may not formally co-exist with ``PCi_ja``.  ``CROTAia`` and\n``CDELTia`` may f", 256);
   strncpy(doc_has_crota + 512, "ormally co-exist with ``CDi_ja`` but if so are to be\nignored.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.crota`\n", 102);

   strncpy(doc_has_crotaia + 0, "has_crota_ia() -> bool\n\nAlias for `~pywcs.Wcsprm.has_crota`.  Maintained for backward\ncompatibility.\n", 101);

   strncpy(doc_has_pc + 0, "has_pc() -> bool\n\nReturns `True` if ``PCi_ja`` is present.  ``PCi_ja`` is the\nrecommended way to specify the linear transformation matrix.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.pc`\n", 176);

   strncpy(doc_has_pci_ja + 0, "has_pci_ja() -> bool\n\nAlias for `~pywcs.Wcsprm.has_pc`.  Maintained for backward\ncompatibility.\n", 96);

   strncpy(doc_have + 0, "The name of the unit being converted from.\n\nThis value always uses standard unit names, even if the\n`UnitConverter` was initialized with a non-standard unit name.\n", 163);

   strncpy(doc_i + 0, "``int`` (read-only)\n\nImage axis number.\n", 40);

   strncpy(doc_imgpix_matrix + 0, "``double array[2][2]`` (read-only)\n\nInverse of the matrix containing the product of the ``CDELTia``\ndiagonal matrix and the ``PCi_ja`` matrix.\n", 143);

   strncpy(doc_is_unity + 0, "is_unity() -> bool\n\nReturns `True` if the linear transformation matrix\n(`~pywcs.Wcsprm.cd`) is unity.\n", 102);

   strncpy(doc_kind + 0, "``str`` (read-only)\n\nCharacter identifying the wcstab array type:\n\n    - ``\'c\'``: coordinate array,\n    - ``\'i\'``: index vector.\n", 129);

   strncpy(doc_lat + 0, "``int`` (read-only)\n\nThe index into the sky coordinate array containing latitude values.\n", 89);

   strncpy(doc_latpole + 0, "``double``\n\nThe native latitude of the celestial pole, ``LATPOLEa`` (deg).\n", 75);

   strncpy(doc_lattyp + 0, "``string`` (read-only)\n\nCelestial axis type for latitude, e.g. \"RA\", \"DEC\", \"GLON\", \"GLAT\",\netc. extracted from \'RA--\', \'DEC-\', \'GLON\', \'GLAT\', etc. in the first\nfour characters of ``CTYPEia`` but with trailing dashes removed.\n", 227);

   strncpy(doc_lng + 0, "``int`` (read-only)\n\nThe index into the sky coordinate array containing longitude values.\n", 90);

   strncpy(doc_lngtyp + 0, "``string`` (read-only)\n\nCelestial axis type for longitude, e.g. \"RA\", \"DEC\", \"GLON\", \"GLAT\",\netc. extracted from \'RA--\', \'DEC-\', \'GLON\', \'GLAT\', etc. in the first\nfour characters of ``CTYPEia`` but with trailing dashes removed.\n", 228);

   strncpy(doc_lonpole + 0, "``double``\n\nThe native longitude of the celestial pole, ``LONPOLEa`` (deg).\n", 76);

   strncpy(doc_m + 0, "``int`` (read-only)\n\nArray axis number for index vectors.\n", 58);

   strncpy(doc_map + 0, "``int array[M]``\n\nA vector of length `~pywcs._pywcs.Tabprm.M`\nthat defines the association between axis *m* in the *M*-dimensional\ncoordinate array (1 <= *m* <= *M*) and the indices of the intermediate world\ncoordinate and world coordinate arrays.\n\nWhen th", 256);
   strncpy(doc_map + 256, "e intermediate and world coordinate arrays contain the full\ncomplement of coordinate elements in image-order, as will usually be\nthe case, then ``map[m-1] == i-1`` for axis *i* in the *N*-dimensional\nimage (1 <= *i* <= *N*).  In terms of the FITS keywords:", 256);
   strncpy(doc_map + 512, ":\n\n    map[PVi_3a - 1] == i - 1.\n\nHowever, a different association may result if the intermediate\ncoordinates, for example, only contains a (relevant) subset of\nintermediate world coordinate elements.  For example, if *M* == 1 for\nan image with *N* > 1, it", 256);
   strncpy(doc_map + 768, " is possible to fill the intermediate\ncoordinates with the relevant coordinate element with ``nelem`` set to\n1.  In this case ``map[0] = 0`` regardless of the value of *i*.\n", 173);

   strncpy(doc_mix + 0, "mix(mixpix, mixcel, vspan, vstep, viter, world, pixcrd, origin)\n\nGiven either the celestial longitude or latitude plus an element of\nthe pixel coordinate, solves for the remaining elements by iterating\non the unknown celestial coordinate element using `~py", 256);
   strncpy(doc_mix + 256, "wcs.Wcsprm.s2p`.\n\n- *mixpix*: int.  Which element on the pixel coordinate is given.\n\n- *mixcel*: int.  Which element of the celestial coordinate is\n  given. If mixcel* = ``1``, celestial longitude is given in\n  ``world[self.lng]``, latitude returned in ``w", 256);
   strncpy(doc_mix + 512, "orld[self.lat]``.  If\n  *mixcel* = ``2``, celestial latitude is given in\n  ``world[self.lat]``, longitude returned in ``world[self.lng]``.\n\n- *vspan*: pair of floats.  Solution interval for the celestial\n  coordinate, in degrees.  The ordering of the two l", 256);
   strncpy(doc_mix + 768, "imits is\n  irrelevant.  Longitude ranges may be specified with any convenient\n  normalization, for example ``(-120,+120)`` is the same as\n  ``(240,480)``, except that the solution will be returned with the\n  same normalization, i.e. lie within the interval", 256);
   strncpy(doc_mix + 1024, " specified.\n\n- *vstep*: float.  Step size for solution search, in degrees.  If\n  ``0``, a sensible, although perhaps non-optimal default will be\n  used.\n\n- *viter*: int.  If a solution is not found then the step size will be\n  halved and the search recomme", 256);
   strncpy(doc_mix + 1280, "nced.  *viter* controls how many times\n  the step size is halved.  The allowed range is 5 - 10.\n\n- *world*: double array[naxis].  World coordinate elements.\n  ``world[self.lng]`` and ``world[self.lat]`` are the celestial\n  longitude and latitude, in degree", 256);
   strncpy(doc_mix + 1536, "s.  Which is given and which\n  returned depends on the value of *mixcel*.  All other elements are\n  given.  The results will be written to this array in-place.\n\n- *pixcrd*: double array[naxis].  Pixel coordinate.  The element\n  indicated by *mixpix* is giv", 256);
   strncpy(doc_mix + 1792, "en and the remaining elements will be\n  written in-place.\n\n\n- *origin*: int. Specifies the origin of pixel values.  The Fortran and\n  FITS standards use an origin of 1.  Numpy and C use array indexing\n  with origin at 0.\n\n\nReturns dictionary with the follo", 256);
   strncpy(doc_mix + 2048, "wing keys:\n\n- *phi* (double array[naxis])\n\n- *theta* (double array[naxis])\n\n  - Longitude and latitude in the native coordinate system of the\n    projection, in degrees.\n\n- *imgcrd* (double array[naxis])\n\n  - Image coordinate elements.  ``imgcrd[self.lng]`", 256);
   strncpy(doc_mix + 2304, "` and\n    ``imgcrd[self.lat]`` are the projected *x*- and *y*-coordinates,\n    in decimal degrees.\n\n- *world* (double array[naxis])\n\n  - Another reference to the *world* argument passed in.\n\n**Exceptions:**\n\n- `MemoryError` Memory allocation failed.\n\n- `Si", 256);
   strncpy(doc_mix + 2560, "ngularMatrixError`: Linear transformation matrix is singular.\n\n- `InconsistentAxisTypesError`: Inconsistent or unrecognized\n  coordinate axis types.\n\n- `ValueError`: Invalid parameter value.\n\n- `InvalidTransformError`: Invalid coordinate transformation\n  p", 256);
   strncpy(doc_mix + 2816, "arameters.\n\n- `InvalidTransformError` Ill-conditioned coordinate transformation\n  parameters.\n\n- `InvalidCoordinateError`: Invalid world coordinate.\n\n- `NoSolutionError`: No solution found in the specified interval.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.lat`, `", 256);
   strncpy(doc_mix + 3072, "~pywcs.Wcsprm.lng`\n\n.. note::\n\n  Initially, the specified solution interval is checked to see if it\'s\n  a \"crossing\" interval.  If it isn\'t, a search is made for a crossing\n  solution by iterating on the unknown celestial coordinate starting\n  at the upper", 256);
   strncpy(doc_mix + 3328, " limit of the solution interval and decrementing by the\n  specified step size.  A crossing is indicated if the trial value of\n  the pixel coordinate steps through the value specified.  If a\n  crossing interval is found then the solution is determined by a\n", 256);
   strncpy(doc_mix + 3584, "  modified form of \"regula falsi\" division of the crossing interval.\n  If no crossing interval was found within the specified solution\n  interval then a search is made for a \"non-crossing\" solution as may\n  arise from a point of tangency.  The process is c", 256);
   strncpy(doc_mix + 3840, "omplicated by\n  having to make allowance for the discontinuities that occur in all\n  map projections.\n\n  Once one solution has been determined others may be found by\n  subsequent invocations of `~pywcs.Wcsprm.mix` with suitably\n  restricted solution interv", 256);
   strncpy(doc_mix + 4096, "als.\n\n  Note the circumstance that arises when the solution point lies at a\n  native pole of a projection in which the pole is represented as a\n  finite curve, for example the zenithals and conics.  In such cases\n  two or more valid solutions may exist but", 256);
   strncpy(doc_mix + 4352, " `~pywcs.Wcsprm.mix` only\n  ever returns one.\n\n  Because of its generality, `~pywcs.Wcsprm.mix` is very\n  compute-intensive.  For compute-limited applications, more efficient\n  special-case solvers could be written for simple projections, for\n  example non", 256);
   strncpy(doc_mix + 4608, "-oblique cylindrical projections.\n", 34);

   strncpy(doc_mjdavg + 0, "``double``\n\nModified Julian Date ``(MJD = JD - 2400000.5)``, ``MJD-AVG``,\ncorresponding to ``DATE-AVG``.\n\nAn undefined value is represented by NaN.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.mjdobs`\n", 189);

   strncpy(doc_mjdobs + 0, "``double``\n\nModified Julian Date ``(MJD = JD - 2400000.5)``, ``MJD-OBS``,\ncorresponding to ``DATE-OBS``.\n\nAn undefined value is represented by NaN.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.mjdavg`\n", 189);

   strncpy(doc_name + 0, "``string``\n\nThe name given to the coordinate representation ``WCSNAMEa``.\n", 74);

   strncpy(doc_naxis + 0, "``int`` (read-only)\n\nThe number of axes (pixel and coordinate), given by the ``NAXIS`` or\n``WCSAXESa`` keyvalues.\n\nThe number of coordinate axes is determined at parsing time, and can\nnot be subsequently changed.\n\nIt is determined from the highest of the f", 256);
   strncpy(doc_naxis + 256, "ollowing:\n\n  1. ``NAXIS``\n\n  2. ``WCSAXESa``\n\n  3. The highest axis number in any parameterized WCS keyword.  The\n     keyvalue, as well as the keyword, must be syntactically valid\n     otherwise it will not be considered.\n\nIf none of these keyword types i", 256);
   strncpy(doc_naxis + 512, "s present, i.e. if the header only\ncontains auxiliary WCS keywords for a particular coordinate\nrepresentation, then no coordinate description is constructed for it.\n\nThis value may differ for different coordinate representations of the\nsame image.\n", 248);

   strncpy(doc_nc + 0, "``int`` (read-only)\n\nTotal number of coordinate vectors in the coordinate array being the\nproduct K_1 * K_2 * ... * K_M.\n", 121);

   strncpy(doc_ndim + 0, "``int`` (read-only)\n\nExpected dimensionality of the wcstab array.\n", 66);

   strncpy(doc_obsgeo + 0, "``double array[3]``\n\nLocation of the observer in a standard terrestrial reference frame,\n``OBSGEO-X``, ``OBSGEO-Y``, ``OBSGEO-Z`` (in meters).\n\nAn undefined value is represented by NaN.\n", 186);

   strncpy(doc_offset + 0, "``double``\n\nThe offset of the unit conversion.\n", 47);

   strncpy(doc_p0 + 0, "``int array[M]``\n\nVector of length `~pywcs._pywcs.Tabprm.M` of interpolated indices into\nthe coordinate array such that Upsilon_m, as defined in Paper III, is\nequal to ``(p0[m] + 1) + delta[m]``.\n", 196);

   strncpy(doc_p2s + 0, "p2s(pixcrd, origin)\n\nConverts pixel to sky coordinates.\n\n- *pixcrd*: double array[ncoord][nelem].  Array of pixel coordinates.\n\n\n- *origin*: int. Specifies the origin of pixel values.  The Fortran and\n  FITS standards use an origin of 1.  Numpy and C use a", 256);
   strncpy(doc_p2s + 256, "rray indexing\n  with origin at 0.\n\n\nReturns a dictionary with the following keys:\n\n- *imgcrd*: double array[ncoord][nelem]\n\n  - Array of intermediate sky coordinates.  For celestial axes,\n    ``imgcrd[][self.lng]`` and ``imgcrd[][self.lat]`` are the\n    pr", 256);
   strncpy(doc_p2s + 512, "ojected *x*-, and *y*-coordinates, in pseudo degrees.  For\n    spectral axes, ``imgcrd[][self.spec]`` is the intermediate\n    spectral coordinate, in SI units.\n\n- *phi*: double array[ncoord]\n\n- *theta*: double array[ncoord]\n\n  - Longitude and latitude in t", 256);
   strncpy(doc_p2s + 768, "he native coordinate system of the\n    projection, in degrees.\n\n- *world*: double array[ncoord][nelem]\n\n  - Array of sky coordinates.  For celestial axes,\n    ``world[][self.lng]`` and ``world[][self.lat]`` are the celestial\n    longitude and latitude, in ", 256);
   strncpy(doc_p2s + 1024, "degrees.  For spectral axes,\n    ``world[][self.spec]`` is the intermediate spectral coordinate, in\n    SI units.\n\n- *stat*: int array[ncoord]\n\n  - Status return value for each coordinate. ``0`` for success,\n    ``1+`` for invalid pixel coordinate.\n\n**Exce", 256);
   strncpy(doc_p2s + 1280, "ptions:**\n\n- `MemoryError`: Memory allocation failed.\n\n- `SingularMatrixError`: Linear transformation matrix is singular.\n\n- `InconsistentAxisTypesError`: Inconsistent or unrecognized\n  coordinate axis types.\n\n- `ValueError`: Invalid parameter value.\n\n- `V", 256);
   strncpy(doc_p2s + 1536, "alueError`: *x*- and *y*-coordinate arrays are not the same size.\n\n- `InvalidTransformError`: Invalid coordinate transformation\n  parameters.\n\n- `InvalidTransformError`: Ill-conditioned coordinate transformation\n  parameters.\n\n.. seealso::\n\n   `~pywcs.Wcsp", 256);
   strncpy(doc_p2s + 1792, "rm.lat`, `~pywcs.Wcsprm.lng`\n", 29);

   strncpy(doc_p4_pix2foc + 0, "p4_pix2foc(*pixcrd, origin*) -> double array[ncoord][nelem]\n\nConvert pixel coordinates to focal plane coordinates using `Paper IV`_\nlookup-table distortion correction.\n\n- *pixcrd*: double array[ncoord][nelem].  Array of pixel coordinates.\n\n\n- *origin*: int", 256);
   strncpy(doc_p4_pix2foc + 256, ". Specifies the origin of pixel values.  The Fortran and\n  FITS standards use an origin of 1.  Numpy and C use array indexing\n  with origin at 0.\n\n\nReturns an array of focal plane coordinates.\n\n- `MemoryError`: Memory allocation failed.\n\n- `ValueError`: In", 256);
   strncpy(doc_p4_pix2foc + 512, "valid coordinate transformation parameters.\n", 44);

   strncpy(doc_pc + 0, "``double array[naxis][naxis]``\n\nThe ``PCi_ja`` (pixel coordinate) transformation matrix.  The order is::\n\n  [[PC1_1, PC1_2],\n   [PC2_1, PC2_2]]\n\nFor historical compatibility, three alternate specifications of the\nlinear transforations are available in wcsl", 256);
   strncpy(doc_pc + 256, "ib.  The canonical\n``PCi_ja`` with ``CDELTia``, and the deprecated ``CDi_ja`` and\n``CROTAia`` keywords.  Although the deprecated versions may not\nformally co-exist with ``PCi_ja``, the approach here is simply to\nignore them if given in conjunction with ``P", 256);
   strncpy(doc_pc + 512, "Ci_ja``.\n\n`~pywcs.Wcsprm.has_pc`, `~pywcs.Wcsprm.has_cd` and\n`~pywcs.Wcsprm.has_crota` can be used to determine which of these\nalternatives are present in the header.\n\nThese alternate specifications of the linear transformation matrix are\ntranslated immedi", 256);
   strncpy(doc_pc + 768, "ately to ``PCi_ja`` by `~pywcs.Wcsprm.set` and are\nnowhere visible to the lower-level routines.  In particular,\n`~pywcs.Wcsprm.set` resets `~pywcs.Wcsprm.cdelt` to unity if\n``CDi_ja`` is present (and no ``PCi_ja``).  If no ``CROTAia`` is\nassociated with th", 256);
   strncpy(doc_pc + 1024, "e latitude axis, `set` reverts to a unity ``PCi_ja``\nmatrix.\n", 61);

   strncpy(doc_phi0 + 0, "``double``\n\nThe native latitude of the fiducial point, i.e. the point whose\ncelestial coordinates are given in ``ref[1:2]``.  If undefined (NaN)\nthe initialization routine, `~pywcs.Wcsprm.set`, will set this to a\nprojection-specific default.\n\n.. seealso::\n", 256);
   strncpy(doc_phi0 + 256, "\n   `~pywcs.Wcsprm.theta0`\n", 27);

   strncpy(doc_pix2foc + 0, "pix2foc(*pixcrd, origin*) -> double array[ncoord][nelem]\n\nPerform both `SIP`_ polynomial and `Paper IV`_ lookup-table distortion\ncorrection in parallel.\n\n- *pixcrd*: double array[ncoord][nelem].  Array of pixel coordinates.\n\n\n- *origin*: int. Specifies the", 256);
   strncpy(doc_pix2foc + 256, " origin of pixel values.  The Fortran and\n  FITS standards use an origin of 1.  Numpy and C use array indexing\n  with origin at 0.\n\n\nReturns an array of focal plane coordinates.\n\n**Exceptions:**\n\n- `MemoryError`: Memory allocation failed.\n\n- `ValueError`: ", 256);
   strncpy(doc_pix2foc + 512, "Invalid coordinate transformation parameters.\n", 46);

   strncpy(doc_piximg_matrix + 0, "``double array[2][2]`` (read-only)\n\nMatrix containing the product of the ``CDELTia`` diagonal matrix and\nthe ``PCi_ja`` matrix.\n", 128);

   strncpy(doc_power + 0, "``double``\n\nThe exponent of the unit conversion.\n", 49);

   strncpy(doc_print_contents + 0, "print_contents()\n\nPrint the contents of the `~pywcs.Wcsprm` object to stdout.  Probably\nonly useful for debugging purposes, and may be removed in the future.\n\nTo get a string of the contents, use `repr`.\n", 204);

   strncpy(doc_print_contents_tabprm + 0, "print_contents()\n\nPrint the contents of the `~pywcs._pywcs.Tabprm` object to stdout.\nProbably only useful for debugging purposes, and may be removed in the\nfuture.\n\nTo get a string of the contents, use `repr`.\n", 210);

   strncpy(doc_radesys + 0, "``string``\n\nThe equatorial or ecliptic coordinate system type, ``RADESYSa``.\n", 77);

   strncpy(doc_restfrq + 0, "``double``\n\nRest frequency (Hz) from ``RESTFRQa``.\n\nAn undefined value is represented by NaN.\n", 94);

   strncpy(doc_restwav + 0, "``double``\n\nRest wavelength (m) from ``RESTWAVa``.\n\nAn undefined value is represented by NaN.\n", 94);

   strncpy(doc_row + 0, "``int`` (read-only)\n\nTable row number.\n", 39);

   strncpy(doc_s2p + 0, "s2p(sky, origin)\n\nTransforms sky coordinates to pixel coordinates.\n\n- *sky*: double array[ncoord][nelem].  Array of sky coordinates, in\n  decimal degrees.\n\n\n- *origin*: int. Specifies the origin of pixel values.  The Fortran and\n  FITS standards use an ori", 256);
   strncpy(doc_s2p + 256, "gin of 1.  Numpy and C use array indexing\n  with origin at 0.\n\n\nReturns a dictionary with the following keys:\n\n- *phi*: double array[ncoord]\n\n- *theta*: double array[ncoord]\n\n  - Longitude and latitude in the native coordinate system of the\n    projection,", 256);
   strncpy(doc_s2p + 512, " in degrees.\n\n- *imgcrd*: double array[ncoord][nelem]\n\n  - Array of intermediate sky coordinates.  For celestial axes,\n    ``imgcrd[][self.lng]`` and ``imgcrd[][self.lat]`` are the\n    projected *x*-, and *y*-coordinates, in pseudo \"degrees\".  For\n    quad", 256);
   strncpy(doc_s2p + 768, "cube projections with a ``CUBEFACE`` axis, the face number is\n    also returned in ``imgcrd[][self.cubeface]``.  For spectral axes,\n    ``imgcrd[][self.spec]`` is the intermediate spectral coordinate,\n    in SI units.\n\n- *pixcrd*: double array[ncoord][nele", 256);
   strncpy(doc_s2p + 1024, "m]\n\n  - Array of pixel coordinates.  Pixel coordinates are\n    zero-based.\n\n- *stat*: int array[ncoord]\n\n  - Status return value for each coordinate. ``0`` for\n    success, ``1+`` for invalid pixel coordinate.\n\n**Exceptions:**\n\n- `MemoryError`: Memory allo", 256);
   strncpy(doc_s2p + 1280, "cation failed.\n\n- `SingularMatrixError`: Linear transformation matrix is singular.\n\n- `InconsistentAxisTypesError` Inconsistent or unrecognized coordinate\n  axis types.\n\n- `ValueError`: Invalid parameter value.\n\n- `InvalidTransformError`: Invalid coordinat", 256);
   strncpy(doc_s2p + 1536, "e transformation\n  parameters.\n\n- `InvalidTransformError`: Ill-conditioned coordinate transformation\n  parameters.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.lat`, `~pywcs.Wcsprm.lng`\n", 174);

   strncpy(doc_scale + 0, "``double``\n\nThe scaling factor for the unit conversion.\n", 56);

   strncpy(doc_sense + 0, "``int array[M]``\n\nA vector of length `~pywcs._pywcs.Tabprm.M` whose elements indicate\nwhether the corresponding indexing vector is monotonically increasing\n(+1), or decreasing (-1).\n", 182);

   strncpy(doc_set + 0, "set()\n\nSets up a WCS object for use according to information supplied within\nit.\n\nNote that this routine need not be called directly; it will be invoked\nby `~pywcs.Wcsprm.p2s` and `~pywcs.Wcsprm.s2p` if necessary.\n\nSome attributes that are based on other a", 256);
   strncpy(doc_set + 256, "ttributes (such as\n`~pywcs.Wcsprm.lattyp` on `~pywcs.Wcsprm.ctype`) may not be correct\nuntil after `~pywcs.Wcsprm.set` is called.\n\n`~pywcs.Wcsprm.set` strips off trailing blanks in all string members.\n\n`~pywcs.Wcsprm.set` recognizes the ``NCP`` projection ", 256);
   strncpy(doc_set + 512, "and converts it\nto the equivalent ``SIN`` projection and it also recognizes ``GLS`` as\na synonym for ``SFL``.  It does alias translation for the AIPS\nspectral types (``FREQ-LSR``, ``FELO-HEL``, etc.) but without changing\nthe input header keywords.\n\n**Excep", 256);
   strncpy(doc_set + 768, "tions:**\n\n- `MemoryError`: Memory allocation failed.\n\n- `SingularMatrixError`: Linear transformation matrix is singular.\n\n- `InconsistentAxisTypesError`: Inconsistent or unrecognized\n  coordinate axis types.\n\n- `ValueError`: Invalid parameter value.\n\n- `In", 256);
   strncpy(doc_set + 1024, "validTransformError`: Invalid coordinate transformation\n  parameters.\n\n- `InvalidTransformError`: Ill-conditioned coordinate transformation\n  parameters.\n", 154);

   strncpy(doc_set_ps + 0, "set_ps(list)\n\nSets `PSi_ma` keywords for each *i* and *m*.  The input must be a\nsequence of tuples of the form (*i*, *m*, *value*):\n\n    - *i*: int.  Axis number, as in ``PSi_ma``, (i.e. 1-relative)\n\n    - *m*: int.  Parameter number, as in ``PSi_ma``, (i.", 256);
   strncpy(doc_set_ps + 256, "e. 0-relative)\n\n    - *value*: string.  Parameter value.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.get_ps`\n", 98);

   strncpy(doc_set_pv + 0, "set_pv(list)\n\nSets `PVi_ma` keywords for each *i* and *m*.  The input must be a\nsequence of tuples of the form (*i*, *m*, *value*):\n\n    - *i*: int.  Axis number, as in ``PVi_ma``, (i.e. 1-relative)\n\n    - *m*: int.  Parameter number, as in ``PVi_ma``, (i.", 256);
   strncpy(doc_set_pv + 256, "e. 0-relative)\n\n    - *value*: float.  Parameter value.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.get_pv`\n", 97);

   strncpy(doc_set_tabprm + 0, "set()\n\nAllocates memory for work arrays in the Tabprm class and sets up\nthe class according to information supplied within it.\n\nNote that this routine need not be called directly; it will be invoked by\nfunctions that need it.\n\n**Exceptions:**\n\n- `MemoryErr", 256);
   strncpy(doc_set_tabprm + 256, "or`: Memory allocation failed.\n\n- `InvalidTabularParameters`: Invalid tabular parameters.\n", 90);

   strncpy(doc_sip + 0, "Get/set the `~pywcs.Sip` object for performing `SIP`_ distortion\ncorrection.\n", 77);

   strncpy(doc_sip_foc2pix + 0, "sip_foc2pix(*foccrd, origin*) -> double array[ncoord][nelem]\n\nConvert focal plane coordinates to pixel coordinates using the `SIP`_\npolynomial distortion convention.\n\n- *foccrd*: double array[ncoord][nelem].  Array of focal plane\n  coordinates.\n\n\n- *origin", 256);
   strncpy(doc_sip_foc2pix + 256, "*: int. Specifies the origin of pixel values.  The Fortran and\n  FITS standards use an origin of 1.  Numpy and C use array indexing\n  with origin at 0.\n\n\nReturns an array of pixel coordinates.\n\n**Exceptions:**\n\n- `MemoryError`: Memory allocation failed.\n\n-", 256);
   strncpy(doc_sip_foc2pix + 512, " `ValueError`: Invalid coordinate transformation parameters.\n", 61);

   strncpy(doc_sip_pix2foc + 0, "sip_pix2foc(*pixcrd, origin*) -> double array[ncoord][nelem]\n\nConvert pixel coordinates to focal plane coordinates using the `SIP`_\npolynomial distortion convention.\n\n- *pixcrd*: double array[ncoord][nelem].  Array of pixel coordinates.\n\n\n- *origin*: int. ", 256);
   strncpy(doc_sip_pix2foc + 256, "Specifies the origin of pixel values.  The Fortran and\n  FITS standards use an origin of 1.  Numpy and C use array indexing\n  with origin at 0.\n\n\nReturns an array of focal plane coordinates.\n\n**Exceptions:**\n\n- `MemoryError`: Memory allocation failed.\n\n- `", 256);
   strncpy(doc_sip_pix2foc + 512, "ValueError`: Invalid coordinate transformation parameters.\n", 59);

   strncpy(doc_spcfix + 0, "spcfix() -> int\n\nTranslates AIPS-convention spectral coordinate types.  {``FREQ``,\n``VELO``, ``FELO``}-{``OBS``, ``HEL``, ``LSR``} (e.g. ``FREQ-LSR``,\n``VELO-OBS``, ``FELO-HEL``)\n\nReturns ``0`` for success; ``-1`` if no change required.\n", 237);

   strncpy(doc_spec + 0, "``int`` (read-only)\n\nThe index containing the spectral axis values.\n", 68);

   strncpy(doc_specsys + 0, "``string``\n\nSpectral reference frame (standard of rest), ``SPECSYSa``.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.ssysobs`, `~pywcs.Wcsprm.velosys`.\n", 139);

   strncpy(doc_sptr + 0, "sptr(ctype, i=-1)\n\nTranslates the spectral axis in a WCS object.  For example, a ``FREQ``\naxis may be translated into ``ZOPT-F2W`` and vice versa.\n\n- *ctype*: string.  Required spectral ``CTYPEia``, maximum of 8\n  characters.  The first four characters are", 256);
   strncpy(doc_sptr + 256, " required to be given and\n  are never modified.  The remaining four, the algorithm code, are\n  completely determined by, and must be consistent with, the first\n  four characters.  Wildcarding may be used, i.e.  if the final three\n  characters are specified", 256);
   strncpy(doc_sptr + 512, " as ``\"???\"``, or if just the eighth\n  character is specified as ``\"?\"``, the correct algorithm code will\n  be substituted and returned.\n\n- *i*: int.  Index of the spectral axis (0-relative).  If ``i < 0`` (or not\n  provided), it will be set to the first s", 256);
   strncpy(doc_sptr + 768, "pectral axis identified\n  from the ``CTYPE`` keyvalues in the FITS header.\n\n**Exceptions:**\n\n- `MemoryError`: Memory allocation failed.\n\n- `SingularMatrixError`: Linear transformation matrix is singular.\n\n- `InconsistentAxisTypesError`: Inconsistent or unr", 256);
   strncpy(doc_sptr + 1024, "ecognized\n  coordinate axis types.\n\n- `ValueError`: Invalid parameter value.\n\n- `InvalidTransformError`: Invalid coordinate transformation\n  parameters.\n\n- `InvalidTransformError`: Ill-conditioned coordinate transformation\n  parameters.\n\n- `InvalidSubimage", 256);
   strncpy(doc_sptr + 1280, "SpecificationError`: Invalid subimage specification\n  (no spectral axis).\n", 74);

   strncpy(doc_ssysobs + 0, "``string``\n\nThe actual spectral reference frame in which there is no differential\nvariation in the spectral coordinate across the field-of-view,\n``SSYSOBSa``.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.specsys`, `~pywcs.Wcsprm.velosys`\n", 226);

   strncpy(doc_ssyssrc + 0, "``string``\n\nThe spectral reference frame (standard of rest) in which the redshift\nwas measured, ``SSYSSRCa``.\n", 110);

   strncpy(doc_sub + 0, "sub(axes)\n\nExtracts the coordinate description for a subimage from a `~pywcs.WCS`\nobject.\n\nThe world coordinate system of the subimage must be separable in the\nsense that the world coordinates at any point in the subimage must\ndepend only on the pixel coor", 256);
   strncpy(doc_sub + 256, "dinates of the axes extracted.  In\npractice, this means that the ``PCi_ja`` matrix of the original image\nmust not contain non-zero off-diagonal terms that associate any of the\nsubimage axes with any of the non-subimage axes.\n\n- *axes*: int or a sequence.\n\n", 256);
   strncpy(doc_sub + 512, "  - If an int, include the first *N* axes in their original\n    order.\n\n  - If a sequence, may contain a combination of image axis numbers\n    (1-relative) or special axis identifiers (see below).  Order is\n    significant; ``axes[0]`` is the axis number o", 256);
   strncpy(doc_sub + 768, "f the input image that\n    corresponds to the first axis in the subimage, etc.\n\n  - If ``0``, ``[]`` or ``None``, do a deep copy.\n\nCoordinate axes types may be specified using either strings or\nspecial integer constants.  The available types are:\n\n  - ``\'l", 256);
   strncpy(doc_sub + 1024, "ongitude\'`` / ``WCSSUB_LONGITUDE``: Celestial longitude\n\n  - ``\'latitude\'`` / ``WCSSUB_LATITUDE``: Celestial latitude\n\n  - ``\'cubeface\'`` / ``WCSSUB_CUBEFACE``: Quadcube ``CUBEFACE`` axis\n\n  - ``\'spectral\'`` / ``WCSSUB_SPECTRAL``: Spectral axis\n\n  - ``\'sto", 256);
   strncpy(doc_sub + 1280, "kes\'`` / ``WCSSUB_STOKES``: Stokes axis\n\n  - ``\'celestial\'`` / ``WCSSUB_CELESTIAL``: An alias for the\n    combination of ``\'longitude\'``, ``\'latitude\'`` and ``\'cubeface\'``.\n\nReturns a `~pywcs.WCS` object, which is a deep copy of the original\nobject.\n\n**Exc", 256);
   strncpy(doc_sub + 1536, "eptions:**\n\n- `MemoryError`: Memory allocation failed.\n\n- `InvalidSubimageSpecificationError`: Invalid subimage specification\n  (no spectral axis).\n\n- `NonseparableSubimageCoordinateSystem`: Non-separable subimage\n  coordinate system.\n\n.. note::\n\n  Combina", 256);
   strncpy(doc_sub + 1792, "tions of subimage axes of particular types may be extracted\n  in the same order as they occur in the input image by combining the\n  integer constants with the \'binary or\' (``|``) operator.  For\n  example::\n\n    wcs.sub([WCSSUB_LONGITUDE | WCSSUB_LATITUDE |", 256);
   strncpy(doc_sub + 2048, " WCSSUB_SPECTRAL])\n\n  would extract the longitude, latitude, and spectral axes in the same\n  order as the input image.  If one of each were present, the\n  resulting object would have three dimensions.\n\n  For convenience, ``WCSSUB_CELESTIAL`` is defined as ", 256);
   strncpy(doc_sub + 2304, "the combination\n  ``WCSSUB_LONGITUDE | WCSSUB_LATITUDE | WCSSUB_CUBEFACE``.\n\n  The codes may also be negated to extract all but the types\n  specified, for example::\n\n    wcs.sub([\n      WCSSUB_LONGITUDE,\n      WCSSUB_LATITUDE,\n      WCSSUB_CUBEFACE,\n      ", 256);
   strncpy(doc_sub + 2560, "-(WCSSUB_SPECTRAL | WCSSUB_STOKES)])\n\n  The last of these specifies all axis types other than spectral or\n  Stokes.  Extraction is done in the order specified by `axes`, i.e. a\n  longitude axis (if present) would be extracted first (via\n  ``axes[0]``) and ", 256);
   strncpy(doc_sub + 2816, "not subsequently (via ``axes[3]``).  Likewise for\n  the latitude and cubeface axes in this example.\n\n  The number of dimensions in the returned object may be less than or\n  greater than the length of `axes`.  However, it will never exceed\n  the number of a", 256);
   strncpy(doc_sub + 3072, "xes in the input image.\n", 24);

   strncpy(doc_tab + 0, "``list of Tabprm``\n\nA list of tabular coordinate objects associated with this WCS.\n", 83);

   strncpy(doc_theta0 + 0, "``double``\n\nThe native longitude of the fiducial point, i.e. the point whose\ncelestial coordinates are given in ``ref[1:2]``.  If undefined (NaN)\nthe initialization routine, `~pywcs.Wcsprm.set`, will set this to a\nprojection-specific default.\n\n.. seealso::", 256);
   strncpy(doc_theta0 + 256, "\n\n   `~pywcs.Wcsprm.phi0`\n", 26);

   strncpy(doc_to_header + 0, "to_header(relax=False)\n\n`to_header` translates a WCS object into a FITS header.\n\n    - If the `~pywcs.Wcsprm.colnum` member is non-zero then a binary\n      table image array header will be produced.\n\n    - Otherwise, if the `~pywcs.Wcsprm.colax` member is ", 256);
   strncpy(doc_to_header + 256, "set non-zero\n      then a pixel list header will be produced.\n\n    - Otherwise, a primary image or image extension header will be\n      produced.\n\nThe output header will almost certainly differ from the input in a\nnumber of respects:\n\n    1. The output hea", 256);
   strncpy(doc_to_header + 512, "der only contains WCS-related keywords.  In\n       particular, it does not contain syntactically-required keywords\n       such as ``SIMPLE``, ``NAXIS``, ``BITPIX``, or ``END``.\n\n    2. Deprecated (e.g. ``CROTAn``) or non-standard usage will be\n       trans", 256);
   strncpy(doc_to_header + 768, "lated to standard (this is partially dependent on whether\n       `fix` was applied).\n\n    3. Quantities will be converted to the units used internally,\n       basically SI with the addition of degrees.\n\n    4. Floating-point quantities may be given to a di", 256);
   strncpy(doc_to_header + 1024, "fferent decimal\n       precision.\n\n    5. Elements of the ``PCi_j`` matrix will be written if and only if\n       they differ from the unit matrix.  Thus, if the matrix is unity\n       then no elements will be written.\n\n    6. Additional keywords such as ``", 256);
   strncpy(doc_to_header + 1280, "WCSAXES``, ``CUNITia``,\n       ``LONPOLEa`` and ``LATPOLEa`` may appear.\n\n    7. The original keycomments will be lost, although\n       `~pywcs.Wcsprm.to_header` tries hard to write meaningful\n       comments.\n\n    8. Keyword order may be changed.\n\nKeyword", 256);
   strncpy(doc_to_header + 1536, "s can be translated between the image array, binary table, and\npixel lists forms by manipulating the `~pywcs.Wcsprm.colnum` or\n`~pywcs.Wcsprm.colax` members of the `~pywcs.Wcsprm.WCS` object.\n\n- *relax*: Degree of permissiveness:\n\n    - `False`: Recognize ", 256);
   strncpy(doc_to_header + 1792, "only FITS keywords defined by the published\n      WCS standard.\n\n    - `True`: Admit all recognized informal extensions of the WCS\n      standard.\n\n    - `int`: a bit field selecting specific extensions to write.\n      See :ref:`relaxwrite` for details.\n\nR", 256);
   strncpy(doc_to_header + 2048, "eturns a raw FITS header as a string.\n", 38);

   strncpy(doc_ttype + 0, "``str`` (read-only)\n\n``TTYPEn`` identifying the column of the binary table that contains\nthe wcstab array.\n", 107);

   strncpy(doc_unitfix + 0, "unitfix(translate_units=\'\')\n\nTranslates non-standard ``CUNITia`` keyvalues.  For example, ``DEG`` ->\n``deg``, also stripping off unnecessary whitespace.\n\n- *translate_units*: string.  Do potentially unsafe translations of\n  non-standard unit strings.\n\n  Al", 256);
   strncpy(doc_unitfix + 256, "though ``\"S\"`` is commonly used to represent seconds, its\n  recognizes ``\"S\"`` formally as Siemens, however rarely that may be\n  translation to ``\"s\"`` is potentially unsafe since the standard\n  used.  The same applies to ``\"H\"`` for hours (Henry), and ``\"", 256);
   strncpy(doc_unitfix + 512, "D\"``\n  for days (Debye).\n\n  This string controls what to do in such cases, and is\n  case-insensitive.\n\n  - If the string contains ``\"s\"``, translate ``\"S\"`` to ``\"s\"``.\n\n  - If the string contains ``\"h\"``, translate ``\"H\"`` to ``\"h\"``.\n\n  - If the string c", 256);
   strncpy(doc_unitfix + 768, "ontains ``\"d\"``, translate ``\"D\"`` to ``\"d\"``.\n\n  Thus ``\'\'`` doesn\'t do any unsafe translations, whereas ``\'shd\'``\n  does all of them.\n\n  See :ref:`fits-unit` for more information.\n\nReturns ``0`` for success; ``-1`` if no change required.\n", 240);

   strncpy(doc_velangl + 0, "``double``\n\nThe angle in degrees that should be used to decompose an observed\nvelocity into radial and transverse components.\n\nAn undefined value is represented by NaN.\n", 169);

   strncpy(doc_velosys + 0, "``double``\n\nThe relative radial velocity (m/s) between the observer and the\nselected standard of rest in the direction of the celestial reference\ncoordinate, ``VELOSYSa``.\n\nAn undefined value is represented by NaN.\n\n.. seealso::\n\n   `~pywcs.Wcsprm.specsys`", 256);
   strncpy(doc_velosys + 256, ", `~pywcs.Wcsprm.ssysobs`\n", 26);

   strncpy(doc_want + 0, "The name of the unit being converted to.\n\nThis value always uses standard unit names, even if the\n`UnitConverter` was initialized with a non-standard unit name.\n", 161);

   strncpy(doc_wcs + 0, "A `~pywcs.Wcsprm` object to perform the basic `wcslib`_ WCS\ntranformation.\n", 75);

   strncpy(doc_zsource + 0, "``double``\n\nThe redshift, ``ZSOURCEa``, of the source.\n\nAn undefined value is represented by NaN.\n", 98);


}

