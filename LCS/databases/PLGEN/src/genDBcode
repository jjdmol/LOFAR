#!/usr/bin/ksh
#
# genDBcode: Generate the glue layer between your appl. and the PL layer
#
# Copyright (C) 2003-2004
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Generates DTL code for storing/saving an object to a database
# Uses a .map file to lookup the references and a .fun file
# for looking up the routines that should be generated
#
# Syntax: genDBcode P mapfile [class]
# or
# Syntax: genDBcode R mapfile functionfile [class]
#
# $Id$
#
VERSION="v2.6"
DEBUGMODE=false

#
# RECaddBCA class
#
RECaddBCA()
{
	Class=$1
	
	echo "// The ${Class}_BCA structure 'binds' the database columns"
	echo "// to the members of the ${Class} class."
	echo "class ${Class}_BCA {"
	echo "public:"
	echo "	void operator()(dtl::BoundIOs& cols, ${Class}& rowbuf) {"
	# get all 'basic' members of the class
	grep ^$Class ${MAPWRKFILE} | grep "!!" | while read line
	do
		ColName=`echo $line | cut -d"!" -f5`
		DBRepMember=`echo $line | cut -d"!" -f4 | sed "s/[\.:]/_/g"`
		echo "		cols[\"${ColName}\"]	== rowbuf.${DBRepMember};"
	done
	echo "	}"
	echo "};\n"
}

#
# RECaddInsertRoutine class 
#
RECaddInsertRoutine()
{
	Class=$1
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d"!" -f2`

	echo "//"
	echo "// Routine for insert this ${Class} object in the database."
	echo "//"
	echo "void insert_${Class}(${Class}&	insRec) {"
	echo "	DBView<${Class}>	insView(\"${Table}\", ${Class}_BCA());"
	echo "	DBView<${Class}>::insert_iterator	insIter = insView;\n"

	echo "	*insIter = *insRec;"
	echo "}\n"
}

#
# RECaddDeleteRoutine class 
#
RECaddDeleteRoutine()
{
	Class=$1
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d"!" -f2`

	echo "//"
	echo "// Routine for deleting this ${Class} object from the database."
	echo "//"
	echo "void delete_${Class}(${Class}&	delRec) {"
	echo "	DBView<${Class}>	delView(\"${Table}\", ${Class}_BCA());"
	echo "	DBView<${Class}>::delete_iterator	delIter = delView;\n"
	echo "	${Class}		delCondition;"
	echo ""
	echo "	delCondition = ...;"
	echo ""
	echo "	*delIter = delCondition;"
	echo "}\n"
}

#
# RECaddSearchRoutine class clause
#
RECaddSearchRoutine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d"!" -f2`

	echo "vector<${Class}> read_${Class}() {"
	echo "	vector<${Class}> 		results;"
	echo "	DBView<${Class}>			view(\"${Table}\", ${Class}_BCA(),"
	echo "								\"${Clause}\");"
	echo "	DBView<${Class}>::select_iterator	readIter = view.begin();\n"
	echo "	for ( ; readIter != view.end(); ++readIter) {"
	echo "		results.push_back(*readIter);"
	echo "	}"
	echo "	return results;"
	echo "}\n"
}

#
# RECaddUpdateRoutine class clause
#
RECaddUpdateRoutine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d"!" -f2`

	echo "//"
	echo "// Routine for updating this ${Class} object in the database."
	echo "//"
	echo "void update_${Class}(${Class}&	theRecord) {"
	echo "	DBView<${Class}>			view(\"${Table}\", ${Class}_BCA(),"
	echo "								\"${Clause}\");"
	echo "	DBView<${Class}>::update_iterator	updIter = view;"
	echo ""
	echo "	// update the database"
	echo "	*updIter=*theRecord;"
	echo "}\n"
}

#---------------------- Persistency layer routines ----------------------------

#
# TPOopenNamespace
#
TPOopenNamespace()
{
	echo "namespace LOFAR {"
	echo "	namespace PL {"
	echo ""
}

#
# TPOcloseNamespace
#
TPOcloseNamespace()
{
	echo "	} // close namespace PL"
	echo "}	// close namespace LOFAR"
	echo ""
}

#
# TPOaddDTLstruct class
#
TPOaddDTLstruct()
{
	Class=$1
	
	echo ""
	echo "// The DBRep<${Class}> structure is a contigious representation of"
	echo "// all fields that should be stored to the database"

	# define a struct with the PO fields and the DataObj fields
	echo "template <>"
	echo "struct DBRep<${Class}> {"
	
	# every structs needs a bindCols functor.
	echo "	void bindCols(dtl::BoundIOs& cols);"

	# add all 'basic' members of the DataObj
	grep ^$Class ${MAPWRKFILE} | grep "!!" | while read line
	do
		MemType=`echo $line | cut -d"!" -f3`
		DBRepMember=`echo $line | cut -d"!" -f4 | sed "s/[\.:]/_/g"`
		echo "	${MemType}			${DBRepMember};"
	done

	echo "};"
	echo ""
}

#
# TPOaddBCA class
#
TPOaddBCA()
{
	Class=$1
	
	echo "// bindCols() 'binds' the database columns represented by a cols"
	echo "// to the members of the DBRep<${Class}> class."
	echo "void DBRep<${Class}>::bindCols(dtl::BoundIOs& cols) {"

	# add all 'basic' members of the class
	grep ^$Class ${MAPWRKFILE} | grep "!!" | while read line
	do
		ColName=`echo $line | cut -d"!" -f5`
		DBRepMember=`echo $line | cut -d"!" -f4 | sed "s/[\.:]/_/g"`
		echo "	cols[\"${ColName}\"]	== ${DBRepMember};"
	done

	echo "}"
	echo ""
}

#
# TPOaddToDatabaseRep class 
#
# Adds code that copies the values from the real data-objects and the
# persistency object to a local DBRep<xxx> class.
#
TPOaddToDatabaseRep() 
{
	Class=$1

	echo ""
	echo "// toDBRep copies the fields of the ${Class} class to the"
	echo "// DBRep<${Class}> structure"
	echo "void TPersistentObject<${Class}>::toDBRep(DBRep<${Class}>& dest) const"
	echo "{"

	# add all 'basic' members of the Dataobj
	grep ^$Class ${MAPWRKFILE} | grep "!!" | while read line
	do
		Member=`echo $line | cut -d"!" -f4`
		DBRepMember=`echo $Member | sed "s/[\.:]/_/g"`
		echo "	dest.${DBRepMember}	= data().${Member};"
	done
	echo "}\n"
}

#
# TPOaddFromDatabaseRep class
#
# Adds code that copies the values from the local DBRep<xxx> class to the
# real data-objects and the persistency object.
#
TPOaddFromDatabaseRep() 
{
	Class=$1
	Action=$2

	echo ""
	echo "// fromDBRep copies the fields of the DBRep<${Class}> structure"
	echo "// to the ${Class} class."
	echo "void TPersistentObject<${Class}>::fromDBRep(const DBRep<${Class}>& src)"
	echo "{"

	# add all 'basic' members of the Dataobj
	grep ^$Class ${MAPWRKFILE} | grep "!!" | while read line
	do
		Member=`echo $line | cut -d"!" -f4`
		DBRepMember=`echo $Member | sed "s/[\.:]/_/g"`
		echo "	data().${Member}	= src.${DBRepMember};"
	done
	echo "}\n"
}

#
# TPOaddInitRoutine class
#
# Adds code that initializes the internals of a TPersistentObject
#
TPOaddInitRoutine() 
{
	Class=$1
	Action=$2

	echo ""
	echo "// Initialize the internals of TPersistentObject<${Class}>"
	echo "void TPersistentObject<${Class}>::init()"
	echo "{"

	# generate initialization code for all classes and base classes.
	grep ^$Class ${MAPWRKFILE} | grep -v "!!" | while read line
	do
		Table=`echo $line | cut -d'!' -f2`
		Member=`echo $line | cut -d'!' -f4`
		Relation=`echo $line | cut -d'!' -f5`
		RelClass=`echo $line | cut -d'!' -f6`

		echo "	{"
		echo "	// create new TPersistentObject for ${Relation} ${RelClass}"
		if [ "${Relation}" == "BaseClass" ]; then
			echo "	Pointer p(new TPersistentObject<${RelClass}>(data()));"
		else
			echo "	Pointer p(new TPersistentObject<${RelClass}>(data().${Member}));"
		fi
		echo "	// associate ${RelClass}'s owner object-id with ${Class}'s objectid"
		echo "	p->metaData().ownerOid() = metaData().oid();"
		echo "	// add newly created TPersistentObject to container of ownedPOs."
		echo "	ownedPOs().push_back(p);"
		echo "	}"
	done

	echo "	// set the correct database table name"
	echo "	tableName(\"${Class}\");"
	echo "}"
	echo ""
}

#
# TPOaddAttributemap class
#
# Adds code that copies initializes the attribute map from TPO<x>
#
TPOaddAttributemap() 
{
	Class=$1

	echo ""
	echo "// Initialize the attribute map for TPersistenObject<${Class}>"
	echo "template<>"
	echo "void TPersistentObject<${Class}>::initAttribMap()"
	echo "{"

	# add all 'basic' members of the Dataobj
	grep ^$Class ${MAPWRKFILE} | grep "!!" | while read line
	do
		Member=`echo $line | cut -d"!" -f4`
		Colname=`echo $line | cut -d"!" -f5`
		echo "	theirAttribMap[\"${Member}\"]	= \"${Colname}\";"
	done

	# add code for all classes and base classes.
	grep ^$Class ${MAPWRKFILE} | grep -v "!!" | while read line
	do
		Member=`echo $line | cut -d"!" -f4`
		RelType=`echo $line | cut -d"!" -f5`
		SubClass=`echo $line | cut -d'!' -f6`
		if [ "${RelType}" == "BaseClass" ]; then
			echo "	theirAttribMap[\"${SubClass}::\"]	="
			echo "		\"@\" + string(typeid(TPersistentObject<${SubClass}>).name());"
		else
			echo "	theirAttribMap[\"${Member}\"]	="
			echo "		\"@\" + string(typeid(TPersistentObject<${SubClass}>).name());"
		fi
	done
	echo "}\n"
}

#---------------------------- Global routines ---------------------------------
#
# initTmpfile
#
# Writes an informational header to the tempfile in case the file was not
# removed by this script.
#
initTmpfile()
{
	echo "#This temporarely file was generated by genDBcode"
	echo "#It should have been cleaned up by genDBcode, please remove it"
	echo "#ClassName!TableName!Ctype!MemberName!ColumnName!SubclassName!DBtype!File"
}

#
# initSrcfile filetype filename
#
# Adds an informational header to the C++ source- of headerfile.
# and includes the correct headerfiles.
#
initSrcfile()
{
	FileType=$1
	File=$2

	echo -n "//# This file was generated by genDBcode ${VERSION} on " ; date
	echo "//# with the command: genDBcode ${LAYER} ${MAPFILE} ${FUNFILE} ${CLASS}"
	echo -n "//# from the directory: " ; pwd
	echo "//#"
	echo "//# EDITING THIS FILE MANUALLY IS AT YOUR OWN RISK"
	echo "//# IT MIGHT BE OVERWRITTEN BY THE NEXT MAKE OF YOUR PROJECT"
	echo "//#"

	# include the headerfiles in the C++ sourcefile
	if [ "${FileType}" == "cc" ]; then
		# By combining the contents of the ClassLocationFile and the contents
		# of the MapWrkfile we can figure out which files to include.
		# First we look in the ClassLocation file which classes are defined
		# in the given File ($2), next we check for these classes in which
		# files their sub-classses are defined.

		>${INCLUDEWRKFILE}							# clear the work file
		# find the classes defined in the File ($2)
		grep "!${File}.h" ${CLASSLOCATIONWRKFILE} | while read cl_line
		do
			Class=`echo $cl_line | cut -d"!" -f1`
			# find their subclasses
			grep "^${Class}!" ${MAPWRKFILE} | grep -v "!!" | while read m_line
			do
				SubClass=`echo $m_line | cut -d'!' -f6`
				# where is this sub class located? 
				sl_line=`grep "${SubClass}!" ${CLASSLOCATIONWRKFILE}`
				SubClassLocation=`echo $sl_line | cut -d"!" -f2`
				if [ "${SubClassLocation}" != "${File}.h" ]; then
					echo "#include \"${FILEPREFIX}${SubClassLocation}\"" >>${INCLUDEWRKFILE}
				fi
			done
		done
		# Finally add the found files only once
		cat ${INCLUDEWRKFILE} | sort | uniq -u
		rm ${INCLUDEWRKFILE}						# cleanup the mess

		# And include our own header file also ofcourse.
		echo "#include \"${FILEPREFIX}${File}.h\""
		echo "#include <PL/TPersistentObject.h>"
		echo ""
	else	# its a headerfile
		TimeStamp=`date +%y%m%d%H%M%S`
		typeset -u FileLabel=${FILEPREFIX}${TimeStamp}_${Class}_H
		echo "//# only include this file once"
		echo "#if !defined(${FileLabel})"
		echo "#define ${FileLabel}"
		echo ""
		echo "#include \"${File}.h\""
		echo "#include <PL/DBRep.h>"
		echo ""
	fi
}

#
# closeHeaderfile class
#
# write the last '#endif' to the headerfile
#
closeHeaderfile()
{
	Class=$1

	echo "#include \"${FILEPREFIX}${Class}.tcc\"	// Include template code"
	echo ""
	echo "#endif"
}

#
# cleanupWorkFiles
#
# Removes all temporary workfiles
#
cleanupWorkFiles()
{
	if [ "${DEBUGMODE}" != "true" ]; then
		rm -f ${MAPWRKFILE} ${ALLFILESWRKFILE} ${CLASSLOCATIONWRKFILE} \
			  ${INCLUDEWRKFILE}
	else
		echo "DEBUGMODE, NOT REMOVING TEMPFILES IN /tmp"
	fi
}

#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
#
cleanlist()
{
	cut -d"#" -f1 $1 | awk '{ if (NF > 0) print $0 }'
}

#
# convertMapfile mapfile
#
# Convert the user format from the mapfile into something more convenient
# and store this in the tempfile.
#
# Allowed linesyntax of  the mapfile:
#	Class	<ClassName>
#	Table	<TableName>
#	File	<Filename>
#	<Ctype>	<MemberName>	<ColumnName>	<DBtype>
#	<Ctype>	<MemberName>	Class			<ClassName>
#	<Ctype>	<MemberName>	BaseClass		<ClassName>
#
# Syntax of the constructed temp-file:
# ClassName!TableName!Ctype!MemberName!ColumnName!SubclassName!DBtype!File
#
# ATTENTION: The are some issues to remind:
#	Ctype      may be of the form xxx:yyy (like std::string)
#	MemberName may be of the form X::y or X.y when the user merged some 
#			   tables manually
#
# NOTE: THIS ROUTINE ALSO EXISTS IN genDBsql
#
convertMapfile()
{
	Mapfile=$1

	cleanlist ${Mapfile} | while read label name dbname fldtype
	do
		# comment is stripped off, check rest of line
		if [ -z "$label" -o -z "$name" ]; then		# need two fields
			continue
		fi

		case $label in
		Class|class|CLASS)				# Class keyword
			CurClass=$name
			;;
		Table|table|TABLE)				# Table keyword
			CurTable=$name
			;;
		File|file|FILE)					# File keyword
			CurFile=$name				
			# NOTE: we assume that File always comes after Class!!!
			echo "${CurClass}!${CurFile}" >> ${CLASSLOCATIONWRKFILE}
			;;
		*)								# no keyword, assume fieldname
			ctype=$label				# less confusing
			typeset -l SubClass=`echo $dbname | cut -d" " -f1`
			# what kind of field is this?
			if [ "${SubClass}" == "class" -o "${SubClass}" == "baseclass" ]; then
				# it's a (sub)class, get its name.
				SubClassName=`echo $fldtype | cut -d" " -f1`
				echo "$CurClass!$CurTable!$ctype!$name!$dbname!$SubClassName!BIGINT!$CurFile"
			else
				echo "$CurClass!$CurTable!$ctype!$name!$dbname!!$fldtype!$CurFile"
			fi
			;;
		esac
	done
}

# hasSubClasses class
#
# Routine that figures out if the given class has subclasses.
# Returns true or false
#
hasSubClasses()
{
	Class=$1

	# Note: grep returns 0 if something found, 1 or -1 if not.
	grep ^$Class ${MAPWRKFILE} | grep -v "!!" >>/dev/null
	GrepOk=`echo $?`
	
	if [ ${GrepOk} == "0" ]; then			# something found?
		echo true
	else
		echo false
	fi

}

# SyntaxError msg
#
# Shows the right syntax on stdout together with the given msg.
# Exits afterwards.
SyntaxError()
{
	Msg=$1

	[ "X${Msg}" != "X" ] && echo "ERROR: ${Msg}"
	echo "Syntax: $(basename $0) P mapfile [class]"
	echo "or"
	echo "Syntax: $(basename $0) R mapfile functionfile [class]"
	exit 1
}

#------------------------------- MAIN program ---------------------------------
#
# Check invocation syntax: genDBcode [-d destdir] P mapfile [class]
# Check invocation syntax: genDBcode [-d destdir] R mapfile funfile [class]
#

# Check option argument
DESTDIR="."							# assume no destination directory
eval set argv=`getopt "d:" $*`		# reformat arguments
shift
case "$1" in
	-d)	DESTDIR=$2
		[ -d ${DESTDIR} ] || 
				SyntaxError "Destination directory >${DESTDIR}< does not exist"
		shift 2
		;;
esac
shift								# remove --

# Need at least two arguments
[ $# -ge 2 ] || SyntaxError "Need at least the layer arguments and a mapfile."

typeset -u LAYER=$1
MAPFILE=$2

# Check Layer type
case "${LAYER}" in
R)		FILEPREFIX="Rec"		;;
P)		FILEPREFIX="PO_"		;;
*)		SyntaxError "Layer should be R(ecord) or P(ersistency), not >${LAYER}<"
esac

# Check other arguments
case $# in
	2)	if [ "${LAYER}" == "R" ]; then		# only genDBcode P mapfile is allowed
			SyntaxError "Wrong number of arguments"
		fi
		;;
	3)  if [ "${LAYER}" == "R" ]; then		# genDBcode R mapfile funfile
			FUNFILE=$3
			GREPMASK=""
			CLASS=""
		else								# genDBcode P mapfile class
			FUNFILE=""
			GREPMASK=" | grep ^$3"
			CLASS=$3
		fi
		;;
	4)  if [ "${LAYER}" == "R" ]; then		# genDBcode R mapfile funfile class
			FUNFILE=$3
			GREPMASK=" | grep ^$4"
			CLASS=$4
		else								# genDBcode P mapfile ???
			SyntaxError "Too many arguments"
		fi
		;;
	*)	SyntaxError "Wrong number of arguments"
		;;
esac

# Mapfile must exist
[ -s ${MAPFILE} ] || SyntaxError "File ${MAPFILE} doesn't exist"

# Functionfile must exist
[ "X${FUNFILE}" != "X" -a ! -s "${FUNFILE}" ] && 
									SyntaxError "File ${FUNFILE} doesn't exist"

# All arguments seem ok, continue processing

# Initialize some variables
#
ROLLBACKCODE=false				# whether or not generate rollback code
MAPWRKFILE=/tmp/mapinfo.LCS.$$
ALLFILESWRKFILE=/tmp/created.LCS.$$
CLASSLOCATIONWRKFILE=/tmp/classloc.LCS.$$
INCLUDEWRKFILE=/tmp/include.LCS.$$

# Make sure there are no old workfiles left
cleanupWorkFiles

# Set trap handler before we create anything
trap "cleanupWorkFiles ; exit" 1 2 3 13 15

# convert the human readable format of the mapfile into something
# more convenient for shell-programming
echo "Analysing mapfile"
initTmpfile					> ${MAPWRKFILE}
convertMapfile ${MAPFILE}	>>${MAPWRKFILE}

# When generating the Record layer use the functionfile as primary input
# Scan the functionfile to determine what code should be generated
if [ "${LAYER}" == "R" ]; then
	PrevClass="Unknown"
	eval "cleanlist $FUNFILE $GREPMASK" | \
	while read class action clause
	do
		# minimal check on layout of line
		if [ -z "$class" -o -z "$action" ]; then
			continue
		fi

		# New class? generate the necc. structures in the new sourcefile.
		# generate exacly one BCA for each class
		if [ "${PrevClass}" != "${class}" ]; then
			SOURCEFILE=${DESTDIR}/${FILEPREFIX}${class}.tcc
			HEADERFILE=${DESTDIR}/${FILEPREFIX}${class}.h
			initSrcfile "cc" ${class}  > ${SOURCEFILE}
			RECaddBCA 	     ${class}  >>${SOURCEFILE}
			PrevClass=${class}
		fi

		# dispatch the action
		typeset -u action=${action}						# to uppercase
		case $action in
		I) RECaddInsertRoutine $class 			>>${SOURCEFILE}		;;
		U) RECaddUpdateRoutine $class "$clause"	>>${SOURCEFILE}		;;
		D) RECaddDeleteRoutine $class "$clause"	>>${SOURCEFILE}		;;
		S) RECaddSearchRoutine $class "$clause"	>>${SOURCEFILE}		;;
		*) echo "ERROR:Unknown function >$action< for class >$class< in file >$FUNFILE<"
		   ;;
		esac
	done
fi	# Record layer

# When generating the Persistence layer use the mapfile as primairy input
if [ "${LAYER}" == "P" ]; then
	PrevClass="Unknown"
	PrevFile="Unknown"
	eval "cleanlist $MAPWRKFILE $GREPMASK" | \
	while read line
	do
		# Where is this line about?
		Class=`echo $line | cut -d'!' -f1`
		File=`echo $line | cut -d'!' -f8 | sed "s/\.h$//"`
		
		if [ "${PrevFile}" != "${File}" ]; then
			SOURCEFILE=${DESTDIR}/${FILEPREFIX}${File}.tcc
			HEADERFILE=${DESTDIR}/${FILEPREFIX}${File}.h

			# Brand new file or already created?
			grep ${File} ${ALLFILESWRKFILE} >/dev/null 2>&1
			if [ $? -ne 0 ]; then
				initSrcfile "cc"			${File} 	> ${SOURCEFILE}
				TPOopenNamespace						>>${SOURCEFILE}
				initSrcfile "h"				${File} 	> ${HEADERFILE}
				TPOopenNamespace						>>${HEADERFILE}
				echo ${File} 							>>${ALLFILESWRKFILE}
			fi
			PrevFile=${File}
		fi
	
		if [ "${PrevClass}" != "${Class}" ]; then
			echo "Creating code for class ${Class}"
			TPOaddBCA 						${Class} 	>>${SOURCEFILE}
			TPOaddToDatabaseRep				${Class} 	>>${SOURCEFILE} 
			TPOaddFromDatabaseRep			${Class} 	>>${SOURCEFILE} 
			TPOaddInitRoutine				${Class} 	>>${SOURCEFILE} 
			TPOaddAttributemap				${Class} 	>>${SOURCEFILE} 
			TPOaddDTLstruct					${Class} 	>>${HEADERFILE}
			PrevClass=${Class}
		fi
	done

	# Finish all created .tcc files
	cat ${ALLFILESWRKFILE} | while read File
	do
		SOURCEFILE=${DESTDIR}/${FILEPREFIX}${File}.tcc
		HEADERFILE=${DESTDIR}/${FILEPREFIX}${File}.h
		TPOcloseNamespace			>>${HEADERFILE}
		closeHeaderfile		${File}	>>${HEADERFILE}
		TPOcloseNamespace 			>>${SOURCEFILE}
	done
fi

# Finally cleanup our mess
cleanupWorkFiles
