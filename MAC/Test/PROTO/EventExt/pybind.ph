//
//  DO NOT EDIT THIS FILE   (MY_Protocol.ph)
//  
//  It has been AutoGen-ed  Wednesday April 28, 2004 at 12:32:38 PM CEST
//  From the definitions    MY_Protocol.prot
//  and the template file   protocol
//
//  MY_Protocol.h: Protocol definition for the Test
//
//  Copyright (C) 2003
//  ASTRON (Netherlands Foundation for Research in Astronomy)
//  P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//  
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//  
//  You should have received a copy of the GNU Lesser General Public
//  License along with This program; if not, write to:
//             The Free Software Foundation, Inc.,
//             59 Temple Place - Suite 330,
//             Boston,  MA  02111-1307, USA.
//
//  $Id$
//

#ifndef MY_PROTOCOL_H
#define MY_PROTOCOL_H

#ifdef SWIG
%module pybind
%include GCF/GCF_Event.h
%include carrays.i
%include std_string.i

%include <TransObject.h>
%array_class(int, int_array)
%array_class(char, char_array)
%{
#include "pybind.ph"

#include <TransObject.h>
#include <GCF/GCF_TMProtocols.h>
%}
#else
#include "pybind.ph"

#include <TransObject.h>
#include <GCF/GCF_TMProtocols.h>
#endif

namespace MY_Protocol
{
  //
  // Define protocol ID
  //
  enum {
    MY_PROTOCOL = (F_GCF_PROTOCOL + 3)
  };

  //
  // Define protocol message types
  //
  enum { 
    ABS_BEAM_ALLOC_ID = 1
  };
 
#define ABS_BEAM_ALLOC F_SIGNAL(MY_PROTOCOL, ABS_BEAM_ALLOC_ID, F_IN)

  class ABSBeamAllocEvent : public GCFEvent
  {
    public:
      ABSBeamAllocEvent(
        int aParam1,
        int aParam2)
      : GCFEvent(ABS_BEAM_ALLOC),
        param1(aParam1),
        param2(aParam2)
      {
        length = sizeof(ABSBeamAllocEvent);
        
        
      }

      ABSBeamAllocEvent() : GCFEvent(ABS_BEAM_ALLOC)
      {
        length = sizeof(ABSBeamAllocEvent);
      }
      
      int param1;
      int param2;
  };
  
  class ABSBeamAllocEventExt : public GCFEventExt
  {
    public:
      ABSBeamAllocEventExt(ABSBeamAllocEvent& be, ACTION action = SENDING) 
      : base(be),
        ext1Dim(0), ext1(0),
        ext2Dim(0), ext2(0),
        ext3(),
        pObj1(0)
      {        
       if (action == RECEIVED) 
       {
          unpack();       
         _unpackDone = true;
        }
      }
      
      virtual ~ABSBeamAllocEventExt() 
      {
        if (_unpackDone)
       {
          if (pObj1) delete pObj1;
       }
      }
#ifdef SWIG
    private:
#endif
      ABSBeamAllocEvent& base;      
#ifdef SWIG
    public:
#endif
      GCFEvent& getEvent() { return base; }

     // IMPORTANT: User may only free the member data if he also constructed it.
      // sequence parameters
      
      int* ext1; unsigned int ext1Dim;
      char* ext2; unsigned int ext2Dim;
      
      // parameters of userdefined types (incl. string)
      std::string ext3;      
      GCFTransportable* pObj1;
      
      void* pack(unsigned int& packsize)
      {
        unsigned int requiredSize = 
          sizeof(ext1Dim) + (ext1Dim * sizeof(int)) +
          sizeof(ext2Dim) + (ext2Dim * sizeof(char)) ;
        
        requiredSize += ext3.length() + sizeof(unsigned int); // needed bufferspace for string ext3
        assert(pObj1);
        requiredSize += pObj1->getSize();

        resizeBuf(requiredSize);
        unsigned int offset = 0;
        // pack sequence members
        offset += packMember(offset, ext1, ext1Dim,  sizeof(int));
        offset += packMember(offset, ext2, ext2Dim,  sizeof(char));
        
        // pack members of user defined types (incl. "string")
        offset += packMember(offset, ext3.c_str(), ext3.length(),  sizeof(char));
        offset += pObj1->pack(_buffer + offset);
        
        packsize = offset;
        base.length += offset;
        return _buffer;
      }

 private:
      void unpack()
      {
        unsigned int offset = sizeof(ABSBeamAllocEvent);
        if (offset < base.length)
        {
          char* data = (char*) &base;
          // unpack sequence members
          ext1 = (int*) unpackMember(data, offset, ext1Dim,  sizeof(int));
          ext2 = (char*) unpackMember(data, offset, ext2Dim,  sizeof(char));
         // unpack members of user defined types (incl. "string")
         offset += GCFEventExt::unpackString(ext3, data + offset);          
          pObj1 = new TransObject();
         offset += pObj1->unpack(data + offset);
        }
      }
            
    private:
      ABSBeamAllocEventExt();
  };
} // namespace MY_Protocol

using namespace MY_Protocol;

#ifdef DECLARE_SIGNAL_NAMES

const char* MY_PROTOCOL_signalnames[] = {
  "MY_PROTOCOL: invalid signal",
  "ABS_BEAM_ALLOC"
};

#else

// extern declaration of protocol event names
extern const char* MY_PROTOCOL_signalnames[];

#endif

#endif
