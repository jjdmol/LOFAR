#!/bin/sh
#
# assay: Invoke a test program and verify its output
#
#  Copyright (C) 2001
#  ASTRON (Netherlands Foundation for Research in Astronomy)
#  P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#  $Id$


#-----------------------------------------------------------------------------
# Usage: assay <max run-time(sec)> <testexe> [<arguments>]
#-----------------------------------------------------------------------------
# This script is an adapted version of the AIPS++ assay script.
#
# assay invokes a LofarSim test program. If the test program has an associated
# .run file then it simply invokes it. Otherwise assay invokes the test
# executable directly
#
# assay redirects the output of program or .run file to a temporary file
# and compare it with a corresponding .out file (if there) using diff.
# Parts of the output can be skipped using special markers (>>> and <<<).
#
# example:
#
# >>>
# This total line will be skipped
# <<<
#
# Only >>>this<<< will be skipped 
#
#
#
# A .run file is necessary in the following cases:
# 1. There are other input files. In that case the .run file should
#    copy those files to the working directory. If needed, it should
#    guard against the case where the working directory is already the
#    directory containing the input files.
# 2. There are multiple output files that should be compared.
# 3. The test program has to be run multiple times with various arguments.
# Note that the .run file can be executed from the source directory
# or from the machine/test directory.
#
# An example t_fft.run file could look like:
#
#  #!/bin/sh
#
#  # Get working directory.
#  wdir=`pwd`
#  # Get source directory (by removing trailing part like /dop08/test).
#  sdir=`pwd | sed 's#/[^/]*/test$##'`
#  echo $wdir
#  echo $sdir
#  # Copy input files (actually, guard is not needed in this case).
#  if [ "$wdir" != "$sdir/BASELINE" ]
#  then
#    cp $sdir/BASELINE/*.coef .
#  fi
#  # Execute the program.
#  t_fft
#  STATUS=$?
#  if [ $STATUS ]
#  then
#    # Do a difference of all output files.
#    mdiff *.out $sdir/BASELINE
#    STATUS=$?
#  fi
#  # Remove the files created.
#  if [ "$wdir" != "$sdir/BASELINE" ]
#  then
#    \rm -f  *.coef
#  fi
#  # Remove .out files only if succesfully ended.
#  if [ $STATUS ]
#  then
#    \rm -f *.out*
#  fi
#  exit $STATUS
##########################################################
#
# Options:
#   none
#
# Status returns:
#    0:  success
#    1:  test execution failed
#    2:  test output disagreement
#   77:  untested (conforming make check) (3 is returned from a .run)
#  130:  interrupt
#
# Notes:
#    1) It is assumed that the test executable exists in the working directory.
#
# Original: 1995/11/01 by Mark Calabretta, ATNF
#
#=============================================================================

# CHECKTOOL is a Make option that contains the checktoolcommand. To be able to 
# insert the programname into the options (for logfile nameing for example)
# a [PROGNAME] can be inserted into the call, this will be substituted by the
# program name that stands in $1.
#
# For example:
#  make check CHECKTOOL='valgrind --tool=memcheck \
#                                 --num-callers=50 \
#                                 --workaround-gcc296-bugs=yes \
#                                 --leak-check=yes \
#                                 --track-fds=yes \
#                                 --logfile=[PROGNAME]_valgrind'

  if test $# -lt 2; then
    echo "usage: assay <max run-time(sec)> <testexe> [<arguments>]"
    exit 1
  fi

  MAXTIME=$1
  shift

# Use LimitExec if available
  if [ -x $LOFARROOT/bin/LimitExec ]
  then
    CMDPREFIX="$LOFARROOT/bin/LimitExec $MAXTIME"
  elif [ -x $lofar_sharedir/limitexec.sh ]
  then
    CMDPREFIX="$lofar_sharedir/limitexec.sh $MAXTIME"
  fi
  
  if [ "x$CHECKTOOL" != "x" ]
  then
    CHKTOOL=`echo "$CHECKTOOL" | sed -e 's/\[PROGNAME\]/'$1'/g'`
  fi

# Initialize the command to be executed.
  COMMAND="$CMDPREFIX ./$@"
  CHECKTOOLCOMMAND="$CHKTOOL ./$@"


# Define exit and interrupt handler.
  trap 'rm -rf core ${1}_tmp* ; \
        trap 0 ; \
        exit $STATUS' 0 1 2 3 15

# If there is a .run file then use it.
  if [ -f "$1.run" ]
  then
     COMMAND="./$1.run"
     LOFAR_CHECKTOOL="$CHKTOOL"
     export LOFAR_CHECKTOOL
     CHECKTOOLCOMMAND="./$1.run"
  fi

# Determine if this program also needs another checktool check.
# (like valgrind for example)
# Check for the variable name CHECKTOOLPROGS in Makefile.
# that variable should contain the programs that need to be run through 
# an extra checktool that has been supplied via the CHECKTOOL line in Make
  match=`cat Makefile |awk '/CHECKTOOLPROGS/,/ENDCHECKTOOLPROGS/ {print $0}'|grep -v '#'| grep -w $1`

  if [ "x$CHECKTOOL" != "x" ]
  then
    if [ "x$match" != "x" ] 
    then
      eval "$CHECKTOOLCOMMAND" > /dev/null
    fi
  fi

# Execute the command.
  if eval "$COMMAND" > ${1}_tmp.out
  then
     if [ -f $1.out ]
     then
        CAT=cat
     else
        echo "PASS (execution succeeded): $*"
        STATUS=0
        exit
     fi
  else
     STATUS=$?
     if [ $STATUS = 3 ]
     then
        echo "UNTESTED: $*"
        STATUS=77
     else
        echo "FAIL (execution failure): $*"
        # We may want to know what went wrong, so we'll secure the log file
        if [ -f ${1}_tmp.log ]
        then
           mv ${1}_tmp.log ${1}.err
        fi
     fi
     exit
  fi

  echo "Comparing output with $1.out ..."
# Strip out demarked text.
# inline parts enclosed by >>> && <<<
  sed -e 's/>>>.*<<<//' ${1}_tmp.out > ${1}_tmp.out2
# lines enclosed by >>> && <<<
  sed -e '/^>>>/,/^<<</d' ${1}_tmp.out2 > ${1}_tmp.out

# Compare with the expected output.
  if $CAT $1.out | sed -e 's/>>>.*<<<//' | sed -e '/^>>>/,/^<<</d' | diff ${1}_tmp.out -
  then
     echo "PASS (output verified): $*"
     STATUS=0
     exit
  else
     echo "FAIL (output not verified): $*"
     STATUS=2
     exit
  fi
