#!/usr/bin/ksh
#
# genDBsql: Generates SQL scripts for creating tables in Postgres.
#
# Copyright (C) 2003-2004
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Generates a mapfile and a functionfile for genDBcode.
# The generated files must be manually adjusted before they
# can be used by genDBcode.
#
# Syntax: genDBsql modulename headerfiles
#
# $Id$
#
VERSION="v1.6"
DEBUGMODE=false

#---------------------------- Global routines ---------------------------------
#
# initTmpfile
#
# Writes an informational header to the tempfile in case the file was not
# removed by this script.
#
initTmpfile()
{
	echo "#This temporarely file was generated by genDTL"
	echo "#It should have been cleaned up by genDTL, please remove it"
	echo "#ClassName!TableName!Ctype!MemberName!ColumnName!SubclassName!DBtype!File"
}

#
# initSQLfile filetype name
#
# Adds an informational header to a sql file.
#
initSQLfile()
{
	echo -n "-- This file was generated by genDBsql ${VERSION} on " ; date
	echo "-- with the command: ${COMMAND} ${LAYER} ${MAPFILE}"
	echo -n "-- from the directory: " ; pwd
	echo "--"
	echo "-- EDITING THIS FILE MANUALLY IS AT YOUR OWN RISK"
	echo "-- IT MIGHT BE OVERWRITTEN THE NEXT TIME YOU RUN genDBsql"
	echo "--"

	if [ "$1" == "m" ]; then
		echo "-- When you run this file all databasetables for the"
		echo "-- sources listed below are created."
		echo "--"
		echo "-- WARNING: EXISTING TABLES ARE DROPPED BEFORE CREATION!!!"
		echo "--"
	else
		echo "-- This file creates the databasetable for class $2"
		echo "--"
		echo "-- WARNING: THE TABLE IS DROPPED BEFORE CREATION!!!"
		echo "--"
	fi
}

#
# convertMapfile mapfile
#
# Convert the user format from the mapfile into something more convenient
# and store this in the tempfile.
#
# Allowed linesyntax of  the mapfile:
#	Class	<ClassName>
#	Table	<TableName>
#	File	<Filename>
#	<Ctype>	<MemberName> <Symb.Name> <ColumnName> <DBtype>
#	<Ctype>	<MemberName> <Symb.Name> Class		  <ClassName>
#	<Ctype>	<MemberName> <Symb.Name> BaseClass	  <ClassName>
#
# Syntax of the constructed temp-file:
# ClassName!TableName!Ctype!MemberName!SymbName!ColumnName!SubclassName!DBtype!File
#
# ATTENTION: The are some issues to remind:
#	Ctype      may be of the form xxx:yyy (like std::string)
#	MemberName may be of the form X::y or X.y when the user merged some 
#			   tables manually
#
# NOTE: THIS ROUTINE ALSO EXISTS IN genDBcode
#
convertMapfile()
{
	Mapfile=$1

	cleanlist ${Mapfile} | while read label name symbname dbname fldtype
	do
		# comment is stripped off, check rest of line
		if [ -z "$label" -o -z "$name" ]; then		# need two fields
			continue
		fi

		case $label in
		Class|class|CLASS)				# Class keyword
			CurClass=$name
			;;
		Table|table|TABLE)				# Table keyword
			CurTable=$name
			;;
		File|file|FILE)					# File keyword
			CurFile=$name				
			# NOTE: we assume that File always comes after Class!!!
			echo "${CurClass}!${CurFile}" >> ${CLASSLOCATIONWRKFILE}
			;;
		*)								# no keyword, assume fieldname
			ctype=$label				# less confusing
			typeset -l SubClass=`echo $dbname | cut -d" " -f1`
			# what kind of field is this?
			if [ "${SubClass}" == "class" -o "${SubClass}" == "baseclass" ]; then
				# it's a (sub)class, get its name.
				SubClassName=`echo $fldtype | cut -d" " -f1`
				echo "$CurClass!$CurTable!$ctype!$name!$symbname!$dbname!$SubClassName!BIGINT!$CurFile"
			else
				echo "$CurClass!$CurTable!$ctype!$name!$symbname!$dbname!!$fldtype!$CurFile"
			fi
			;;
		esac
	done
}

#
# addCreateTableCommand tablename
#
# Generates the SQL command for creating the table
#
addCreateTableCommand()
{
	Table=$1

	echo "drop table ${Table};"
	echo "create table ${Table} ("
	# P layer always starts with 3 administrative fields
	if [ "${LAYER}" == "P" ]; then
		echo    "	ObjId		BIGINT		NOT NULL UNIQUE PRIMARY KEY,"
		echo    "	Owner		BIGINT		NOT	NULL,"
		echo -n "	VersionNr	INTEGER		NOT NULL"
		firstLine=false
	else
		firstLine=true
	fi
	
	# scan mapfile for all fields of the current table
	cleanlist ${MAPWORKFILE} | grep "!${Table}!" | while read line
	do
		TableName=`echo $line | cut -d'!' -f2`
		if [ "${TableName}" != "${Table}" ]; then
			continue
		fi

		ColumnName=`echo $line | cut -d'!' -f6`
		ColumnType=`echo $line | cut -d'!' -f8`
		# Add only 'plain' fields
		if [ "${ColumnName}" != "Class" -a "${ColumnName}" != "BaseClass" ]; then
			[ "${firstLine}" == "false" ] && echo ","
			echo -n "	${ColumnName}	${ColumnType}"
			firstLine=false
		fi
	done

	echo "\n);"
	echo ""

}

#
# addCreateTriggerCommand tablename
#
# A trigger must be defined for tables in the P layer. This trigger will 
# update the VersionNr field and may prevent an update when the VersionNr
# doesnot match the one in the database.
#
addCreateTriggerCommand()
{
	[ "${LAYER}" == "R" ] && return;		# only for P layer

	Table=$1

	echo "CREATE TRIGGER ${Table}UpdateVersionNr BEFORE INSERT OR UPDATE ON ${Table}"
	echo "FOR EACH ROW EXECUTE PROCEDURE UpdateVersionNr();"
	echo ""
}

#
# cleanupWorkFiles
#
# Cleanup the temporary workfiles we used
#
cleanupWorkFiles()
{
	if [ "${DEBUGMODE}" != "true" ]; then
		rm -f ${MAPWORKFILE} ${ALLFILESWRKFILE}
	else
		echo "DEBUGMODE, NOT REMOVING TEMPFILES in /tmp"
	fi
}

#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
#
cleanlist()
{
	cut -d"#" -f1 $1 | awk '{ if (NF > 0) print $0 }'
}

#
# ControlledFileDeletion FileName
#
# Asks the user if the file may be removed. If not the program is terminated.
# When the FORCE option is on the file is removed without interference of the user.
ControlledFileDeletion()
{
	FileName=$1

	# Does file exist
	if [ ! -f "${FileName}" ]; then
		return
	fi

	# If FORCE option is off let the user decide.
	if [ "${FORCE}" != "true" ]; then
		ready=false
		while [ "$ready" == "false" ]
		do
			echo -n "Targetfile ${FileName} already exists, remove it (y/n)? "
			read answer
			case $answer in
			y|Y|yes|Yes)	ready=true
							;;
			n|N|no|No)		Fail "Target ${FileName} may not be overwritten"
							;;
			esac
		done
	fi
	echo "Removing file ${FileName}"
	rm -f ${FileName}
}

#
# Fail msg
#
# Shows the message on stdout and exits
Fail()
{
	echo "FAIL: $*"
	cleanupWorkFiles
	exit 1
}

#
# SyntaxError msg
#
# Shows the right syntax on stdout together with the given msg.
# Exits afterwards.
SyntaxError()
{
	Msg=$1

	[ -z "${Msg}" ] || echo "ERROR: ${Msg}"
	echo "Syntax: $(basename $0) [-d destdir] [-f] layer mapfile"
	echo "  layer: R(ecord) or P(ersistency)"
	echo "    -f   Force removal of target(s) if it already exists"
	echo ""
	exit 1
}

#------------------------------- MAIN program ---------------------------------
#
# Syntax: genDBsql [-d destdir] [-f] P|R mapfile
#
# Check invocation syntax
DESTDIR="."							# assume no destination directory
FORCE=false							# do not overwrite existing files
COMMAND=$(basename $0)				# reconstruction of the commandline

eval set argv=`getopt "d:f" $*`		# reformat arguments
shift								# cut off programname
while [ "$1" != "--" ]
do
	case "$1" in
		-d)	DESTDIR=$2
			if [ ! -d ${DESTDIR} ]; then
				echo "Destination directory >${DESTDIR}< does not exist"
				exit 1
			fi
			shift 2
			COMMAND="${COMMAND} -d ${DESTDIR}"
			;;
		-f) FORCE=true
			shift 1
			COMMAND="${COMMAND} -f"
			;;
		esac
done
shift								# remove --

# Need at least two arguments
[ $# -eq 2 ] || SyntaxError "Need the layer argument and the mapfilename."

typeset -u LAYER=$1
MAPFILE=$2

# Check layer type
case "${LAYER}" in
R)		PREFIX="Rec"	;;
P)		PREFIX="PO_"	;;
*)		SyntaxError "Layer should be R(ecord) or P(ersistency), not >${LAYER}<"
esac

# Mapfile must exist
[ -s ${MAPFILE} ] || SyntaxError "File ${MAPFILE} doesn't exist"

# Initialize some variables
ALLFILESWRKFILE=/tmp/allfiles.LCS.$$
CLASSLOCATIONWRKFILE=/dev/null				# to satisfy convertMapfile
MAPWORKFILE=/tmp/mapinfo.sql.LCS.$$
MODULEFILE=${DESTDIR}/${PREFIX}create_databases.sql

# Make sure there are no old workfiles left
cleanupWorkFiles

# Set trap handler before we create anything
trap "cleanupWorkFiles ; exit" 1 2 3 13 15

# initialize the files we have to create.
initTmpfile					> ${MAPWORKFILE}
convertMapfile ${MAPFILE}	>>${MAPWORKFILE}

# Now the converted mapfile exists we can check for file duplicates.
# If targets exist, let the user or the FORCE option decide what to do
# Note: we have to do this a bit clumsy because ControlledFileDeletion
#	does a 'read' and 'read's may not be nested.
cleanlist ${MAPWORKFILE} | cut -d'!' -f9 | sed "s/\.h$//" >>${ALLFILESWRKFILE}
while [ -s ${ALLFILESWRKFILE} ]
do
	File=`head -1 ${ALLFILESWRKFILE}`
	ControlledFileDeletion ${DESTDIR}/${PREFIX}${File}.sql
	sed "1,1D" ${ALLFILESWRKFILE} >>${ALLFILESWRKFILE}2
	mv ${ALLFILESWRKFILE}2 ${ALLFILESWRKFILE}
done
ControlledFileDeletion ${MODULEFILE}

# Once we are here we are allowed to overwrite all targetfiles.
initSQLfile m 				> ${MODULEFILE}

# Scan the functionfile to determine what code should be generated
PrevTable="Unknown"
cleanlist ${MAPWORKFILE} | while read line
do
	ClassName=`echo $line | cut -d'!' -f1`
	TableName=`echo $line | cut -d'!' -f2`
	FileName=`echo $line | cut -d'!' -f9 | sed "s/\.h$//"`
	SQLFILE=${DESTDIR}/${PREFIX}${FileName}.sql
	# Create file if it does not exists yet.
	if [ ! -f "${SQLFILE}" ]; then
		echo "Creating file ${SQLFILE}"
		initSQLfile c ${ClassName}				  >${SQLFILE}
		echo "\i " $(basename ${SQLFILE})		 >>${MODULEFILE}
	fi
	# Add code for this table
	if [ "${PrevTable}" != "${TableName}" ]; then
		addCreateTableCommand ${TableName} 		 >>${SQLFILE}
		addCreateTriggerCommand ${TableName}	 >>${SQLFILE}
		PrevTable=${TableName}
	fi
done
echo "Creating file ${MODULEFILE}"

# Finally cleanup our mess
cleanupWorkFiles
