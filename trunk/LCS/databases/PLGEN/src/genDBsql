#!/usr/bin/ksh
#
# genDBsql
#
# Generates a mapfile and a functionfile for genDBcode.
# The generated files must be manually adjusted before they
# can be used by genDBcode.
#
# Syntax: genDBsql modulename headerfiles
#
# $Id$
#
VERSION="v1.0"

#---------------------------- Global routines ---------------------------------
#
# initTmpfile
#
# Writes an informational header to the tempfile in case the file was not
# removed by this script.
#
initTmpfile()
{
	echo "#This temporarely file was generated by genDTL"
	echo "#It should have been cleaned up by genDTL, please remove it"
	echo "#ClassName:TableName:Ctype:MemberName:ColumnName:SubclassName:DBtype"
}

#
# initSQLfile filetype name
#
# Adds an informational header to a sql file.
#
initSQLfile()
{
	echo -n "-- This file was generated by genDBsql ${VERSION} on " ; date
	echo "-- with the command: genDBsql ${MODULE}"
	echo -n "-- from the directory: " ; pwd
	echo "--"
	echo "-- EDITING THIS FILE MANUALLY IS AT YOUR OWN RISK"
	echo "-- IT MIGHT BE OVERWRITTEN THE NEXT TIME YOU RUN genDBsql"
	echo "--"

	if [ "$1" == "m" ]; then
		echo "-- When you run this file all databasetables for module $2"
		echo "-- are created."
		echo "--"
		echo "-- WARNING: EXISTING TABLES ARE DROPPED BEFORE CREATION!!!"
		echo "--"
	else
		echo "-- This file creates the databasetable for class $2"
		echo "--"
		echo "-- WARNING: THE TABLE IS DROPPED BEFORE CREATION!!!"
		echo "--"
	fi
}

#
# convertMapfile mapfile
#
# Convert the user format from the mapfile into something more convenient
#
# Allowed linesyntax of the mapfile:
#	Class	<ClassName>
#	Table	<TableName>
#	<Ctype>	<MemberName>	<ColumnName>	<DBtype>
#	<Ctype>	<MemberName>	class			<ClassName>
#
# Syntax of the constructed temp-file:
# ClassName:TableName:Ctype:MemberName:ColumnName:SubclassName:DBtype
#
# NOTE: THIS ROUTINE ALSO EXISTS IN genDBcode
#
convertMapfile()
{
	Mapfile=$1

	cleanlist ${Mapfile} | while read label name dbname fldtype
	do
		# comment is stripped off, check rest of line
		if [ -z "$label" -o -z "$name" ]; then		# need two fields
			continue
		fi

		case $label in
		Class|class|CLASS)				# Class keyword
			CurClass=$name
			;;
		Table|table|TABLE)				# Table keyword
			CurTable=$name
			;;
		*)								# no keyword, assume fieldname
			typeset -l SubClass=`echo $dbname | cut -d" " -f1`
			# what kind of field is this?
			if [ "${SubClass}" == "class" ]; then
				# it's a (sub)class, get its name.
				SubClassName=`echo $fldtype | cut -d" " -f1`
			echo "$CurClass:$CurTable:$label:$name:$dbname:$SubClassName:BIGINT"
			else
				echo "$CurClass:$CurTable:$label:$name:$dbname::$fldtype"
			fi
			;;
		esac
	done
}

#
# addCreateTableCommand tablename
#
# Generates the SQL command for creating the table
#
addCreateTableCommand()
{
	Table=$1

	echo "drop table ${Table};"
	echo "create table ${Table} ("
	echo    "	ObjId		BIGINT		NOT NULL UNIQUE PRIMARY KEY,"
	echo    "	Owner		BIGINT		NOT	NULL,"
	echo -n "	VersionNr	INTEGER		NOT NULL"
	
	cleanlist ${MAPWORKFILE} | grep ":${Table}:" | while read line
	do
		TableName=`echo $line | cut -d':' -f2`
		if [ "${TableName}" != "${Table}" ]; then
			continue
		fi

		ColumnName=`echo $line | cut -d':' -f5`
		ColumnType=`echo $line | cut -d':' -f7`
		if [ "${ColumnName}" != "Class" ]; then
			echo ","
			echo -n "	${ColumnName}	${ColumnType}"
		fi
	done

	echo "\n);"
	echo ""

}
#
# addCreateTriggerCommand tablename
#
addCreateTriggerCommand()
{
	Table=$1

	echo "CREATE TRIGGER ${Table}UpdateVersionNr BEFORE INSERT OR UPDATE ON ${Table}"
	echo "FOR EACH ROW EXECUTE PROCEDURE UpdateVersionNr();"
	echo ""
}

#
# cleanupWorkFiles
#
# Cleanup the temporary workfiles we used
#
cleanupWorkFiles()
{
	rm -f ${MAPWORKFILE}
}

#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
#
cleanlist()
{
	cut -d"#" -f1 $1 | awk '{ if (NF > 0) print $0 }'
}


#------------------------------- MAIN program ---------------------------------
#
# Check invocation syntax: genDBsql [-d destdir] module headerfiles
#

# Check option argument
DESTDIR="./"						# assume no destination directory
eval set argv=`getopt "d:" $*`		# reformat arguments
shift
case "$1" in
	-d)	DESTDIR=$2
		if [ ! -d ${DESTDIR} ]; then
			echo "Destination directory >${DESTDIR}< does not exist"
			exit 1
		fi
		shift 2
		;;
esac
shift								# remove --

# Check other arguments
case $# in
	1)	MAPFILE=$1
		MODULE=`echo ${MAPFILE} | cut -d"." -f1`
		;;
	*)	echo "Syntax: $0 mapfile"
		exit 0
		;;
esac

# Mapfile must exist
#
if [ ! -s ${MAPFILE} ]; then
    echo "File ${MAPFILE} doesn't exist\n"
    exit 1
fi

# Initialize some variables
#
MAPWORKFILE=/tmp/mapinfo.sql.LCS.$$
MODULEFILE=${DESTDIR}/${MODULE}_create_databases.sql

# Make sure there are no old workfiles left
cleanupWorkFiles

# Set trap handler before we create anything
trap "cleanupWorkFiles ; exit" 1 2 3 13 15

# initialize the files we have to create.
initTmpfile					> ${MAPWORKFILE}
convertMapfile ${MAPFILE}	>>${MAPWORKFILE}
initSQLfile m ${MODULE}		> ${MODULEFILE}

# Scan the functionfile to determine what code should be generated
#
PrevTable="Unknown"
cleanlist ${MAPWORKFILE} | while read line
do
	ClassName=`echo $line | cut -d':' -f1`
	TableName=`echo $line | cut -d':' -f2`
	if [ "${TableName}" != "${PrevTable}" ]; then	# new table?
		SQLFILE=${DESTDIR}/${ClassName}.sql
		initSQLfile c ${ClassName}				  >${SQLFILE}
		addCreateTableCommand ${TableName} 		 >>${SQLFILE}
		addCreateTriggerCommand ${TableName}	 >>${SQLFILE}
		echo "\i ${SQLFILE}"					 >>${MODULEFILE}
		PrevTable=${TableName}
	fi
done

# Finally cleanup our mess
cleanupWorkFiles
