#!/usr/bin/ksh
#
# genDBcode
#
# Generates DTL code for storing/saving an object to a database
# Uses a .map file to lookup the references and a .fun file
# for looking up the routines that should be generated
#
# Syntax: genDBcode mapfile functionfile R|P [class]
#
# $Id$
#
VERSION="v2.0"

#
# RECaddBCA class
#
RECaddBCA()
{
	Class=$1
	
	echo "// The ${Class}_BCA structure 'binds' the database columns"
	echo "// to the members of the ${Class} class."
	echo "class ${Class}_BCA {"
	echo "public:"
	echo "	void operator()(BoundIOs& cols, ${Class}& rowbuf) {"
	# get all 'basic' members of the class
	grep ^$Class ${MAPWRKFILE} | grep "::" | while read line
	do
		ColName=`echo $line | cut -d":" -f5`
		Member=`echo $line | cut -d":" -f4`
		echo "		cols[\"${ColName}\"]	== rowbuf.${Member};"
	done
	echo "	}"
	echo "};\n"
}

#
# RECaddInsertRoutine class 
#
RECaddInsertRoutine()
{
	Class=$1
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d":" -f2`

	echo "//"
	echo "// Routine for insert this ${Class} object in the database."
	echo "//"
	echo "void insert_${Class}(${Class}&	insRec) {"
	echo "	DBView<${Class}>	insView(\"${Table}\", ${Class}_BCA());"
	echo "	DBView<${Class}>::insert_iterator	insIter = insView;\n"

	echo "	*insIter = *insRec;"
	echo "}\n"
}

#
# RECaddSearchRoutine class clause
#
RECaddSearchRoutine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d":" -f2`

	echo "vector<${Class}> read_${Class}() {"
	echo "	vector<${Class}> 		results;"
	echo "	DBView<${Class}>			view(\"${Table}\", ${Class}_BCA(),"
	echo "								\"${Clause}\");"
	echo "	DBView<${Class}>::select_iterator	readIter = view.begin();\n"
	echo "	for ( ; readIter != view.end(); ++readIter) {"
	echo "		results.push_back(*readIter);"
	echo "	}"
	echo "	return results;"
	echo "}\n"
}

#
# RECaddUpdateRoutine class clause
#
RECaddUpdateRoutine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d":" -f2`

	echo "//"
	echo "// Routine for updating this ${Class} object in the database."
	echo "//"
	echo "void update_${Class}(${Class}&	theRecord) {"
	echo "	DBView<${Class}>			view(\"${Table}\", ${Class}_BCA(),"
	echo "								\"${Clause}\");"
	echo "	DBView<${Class}>::update_iterator	updIter = view;"
	echo ""
	echo "	// update the database"
	echo "	*updIter=*theRecord;"
	echo "}\n"
}

#---------------------- Persistency layer routines ----------------------------

#
# TPOopenNamespace
#
TPOopenNamespace()
{
	echo "namespace LOFAR {"
	echo "	namespace PL {"
	echo ""
}

#
# TPOcloseNamespace
#
TPOcloseNamespace()
{
	echo "	} // close namespace PL"
	echo "}	// close namespace LOFAR"
	echo ""
}

#
# TPOcloseSrcFile class
#
TPOcloseSrcFile()
{
	Class=$1

	echo "template class TPersistentObject<${Class}>;"
	echo ""

	TPOcloseNamespace
}

#
# TPOaddGenericStructures
#
# All TPO types have one thing in common: the ObjectId field. Many database
# actions are based on this field, so we define some generic structures that
# may be used by all kind of TPO's
#
TPOaddGenericStructures()
{
	TPOopenNamespace

	# define a struct with the PO fields and the DataObj fields
	echo ""
	echo "// --------------- generic DTL structures -----------------------"
	echo "// The Persistency Layer uses an ObjectID to unique identify"
	echo "// an object. This field can be used in queries to update"
	echo "// or delete an object. Since the ObjectID is the same for"
	echo "// every type of object some generic DTL structs can be defined."
	echo ""
	echo "template<>"
	echo "struct DBRep<ObjectId> {"
	echo "	ObjectId::oid_t		itsOid;"
	echo "};"
	echo ""
	echo "template<>"
	echo "void BCA<ObjectId>::operator()(dtl::BoundIOs& cols, DataObj& rowbuf) {"
	echo "	cols[\"ObjId\"]	== rowbuf.itsOid;"
	echo "}"
	echo ""
	echo "template<>"
	echo "void BPA<ObjectId>::operator()(dtl::BoundIOs& pos, ParamObj& param) {"
	echo "	pos[0]	== param.itsOid;"
	echo "}"
	echo ""
	echo "template<>"
	echo "struct DBRep<PersistentObject::MetaData> {"
	echo "	ObjectId::oid_t		itsOid;"
	echo "	ObjectId::oid_t		itsOwner;"
	echo "	unsigned int		itsVersionNr;"
	echo "};"
	echo ""
	echo "template<>"
	echo "void BCA<PersistentObject::MetaData>::operator()(dtl::BoundIOs& cols,"
	echo "					 DataObj& rowbuf) {"
	echo "	cols[\"ObjId\"]		== rowbuf.itsOid;"
	echo "	cols[\"Owner\"]	    == rowbuf.itsOwner;"
	echo "	cols[\"VersionNr\"]	== rowbuf.itsVersionNr;"
	echo "}"
	echo ""

	TPOcloseNamespace

	echo ""
	echo "#endif"
}

#
# TPOaddDTLstruct class
#
TPOaddDTLstruct()
{
	Class=$1
	
	echo ""
	echo "// The DBRep<${Class}> structure is a compilation of the fields"
	echo "// of the ${Class} class and the persistency layer. It contains"
	echo "// all fields that should be stored to the database"

	# define a struct with the PO fields and the DataObj fields
	echo "template <>"
	echo "struct DBRep<${Class}> {"

	# First add the PO fields, this is always the same
	echo "	ObjectId::oid_t		Oid;"
	echo "	ObjectId::oid_t		Owner;"
	echo "	unsigned int		VersionNr;"

	# add all 'basic' members of the DataObj
	grep ^$Class ${MAPWRKFILE} | grep "::" | while read line
	do
		MemType=`echo $line | cut -d":" -f3`
		Member=`echo $line | cut -d":" -f4`
		echo "	${MemType}			${Member};"
	done

	echo "};"
	echo ""
}

#
# TPOaddBCA class
#
TPOaddBCA()
{
	Class=$1
	
	echo "// The BCA<${Class}> structure 'binds' the database columns"
	echo "// to the members of the DBRep<${Class}> class."
	echo "template<>"
	echo "void BCA<${Class}>::operator()(BoundIOs& cols, DataObj& rowbuf) {"
	# First add the PO fields, this is always the same
	echo "	cols[\"ObjID\"]		== rowbuf.Oid;"
	echo "	cols[\"Owner\"]	    == rowbuf.Owner;"
	echo "	cols[\"VersionNr\"]	== rowbuf.VersionNr;"

	# add all 'basic' members of the class
	grep ^$Class ${MAPWRKFILE} | grep "::" | while read line
	do
		ColName=`echo $line | cut -d":" -f5`
		Member=`echo $line | cut -d":" -f4`
		echo "	cols[\"${ColName}\"]	== rowbuf.${Member};"
	done

	echo "}"
	echo ""
}

#
# TPOaddToDatabaseRep class 
#
# Adds code that copies the values from the real data-objects and the
# persistency object to a local DBRep<xxx> class.
#
TPOaddToDatabaseRep() 
{
	Class=$1

	echo ""
	echo "// toDatabaseRep copies the fields of the persistency layer"
	echo "// and of the ${Class} class to the given DBRep<${Class}> structure"
	echo "template<>"
	echo "void TPersistentObject<${Class}>::toDatabaseRep(DBRep<${Class}>& dest) const"
	echo "{"
	echo "	// copy info of the ${Class} to the DBRep<${Class}> class"
	echo "	// First copy the PO part"
	echo "	dest.Oid		= metaData().oid()->get();"
	echo "	dest.Owner		= metaData().ownerOid()->get();"
	echo "	dest.VersionNr	= metaData().versionNr();"
	echo ""
	echo "	// Finally copy the info from ${Class}"

	# add all 'basic' members of the Dataobj
	grep ^$Class ${MAPWRKFILE} | grep "::" | while read line
	do
		Member=`echo $line | cut -d":" -f4`
		echo "	dest.${Member}	= itsObjectPtr->${Member};"
	done
	echo "}\n"
}

#
# TPOaddFromDatabaseRep class
#
# Adds code that copies the values from the local DBRep<xxx> class to the
# real data-objects and the persistency object.
#
TPOaddFromDatabaseRep() 
{
	Class=$1
	Action=$2

	echo ""
	echo "// fromDatabaseRep copies the fields of the DBRep<${Class}> structure"
	echo "// to the persistency layer and the ${Class} class."
	echo "template<>"
	echo "void TPersistentObject<${Class}>::fromDatabaseRep(const DBRep<${Class}>& org)"
	echo "{"
	echo "	// copy info of the ${Class} to the DBRep<${Class}> class"
	echo "	// First copy the metadata of the PO"
	echo "	metaData().oid()->set(org.Oid);"
	echo "	metaData().ownerOid()->set(org.Owner);"
	echo "	metaData().versionNr() = org.VersionNr;"
	echo ""
	echo "	// Finally copy the info from ${Class}"

	# add all 'basic' members of the Dataobj
	grep ^$Class ${MAPWRKFILE} | grep "::" | while read line
	do
		Member=`echo $line | cut -d":" -f4`
		echo "	itsObjectPtr->${Member}	= org.${Member};"
	done
	echo "}\n"
}

#
# TPOaddInitRoutine class
#
# Adds code that initializes the internals of a TPersistentObject
#
TPOaddInitRoutine() 
{
	Class=$1
	Action=$2

	echo ""
	echo "// Initialize the internals of TPersistentObject<${Class}>"
	echo "template<>"
	echo "void TPersistentObject<${Class}>::init()"
	echo "{"

	# generate initialization code for all classes and base classes.
	grep ^$Class ${MAPWRKFILE} | grep -v "::" | while read line
	do
		Member=`echo $line | cut -d':' -f4`
		Relation=`echo $line | cut -d':' -f5`
		RelClass=`echo $line | cut -d':' -f6`

		echo "	// create new TPersistentObject for ${Relation} ${RelClass}"
		if [ "${Relation}" == "BaseClass" ]; then
			echo "	Pointer p(new TPersistentObject<${RelClass}>(*itsObjectPtr));"
		else
			echo "	Pointer p(new TPersistentObject<${RelClass}>(itsObjectPtr->${Member}));"
		fi
		echo "	// Associate ${RelClass}'s owner object-id with ${Class}'s objectid"
		echo "	p->metaData().ownerOid() = metaData().oid();"
		echo "	// Add newly created TPersistentObject to container of ownedPOs."
		echo "	ownedPOs().push_back(p);"
	done

	echo "}"
	echo ""
}
#
# TPOcodeCopyToLocal class action
#
# Adds code that copies the values from the real data-objects and the
# persistency object to a local DBRep<xxx> class.
#
TPOcodeCopyToLocal() 
{
	Class=$1
	Action=$2

	echo "	// copy info of the ${Class} to the DBRep<${Class}> class"
	echo "	DBRep<${Class}>		rec;"
	echo "	toDatabaseRep 	(rec);"

	#echo "	rec.Owner		= mdOwner.itsOid.get();"
	#if [ "${Action}" == "insert" ]; then
	#	echo "	rec.Oid			= metaData().itsOid.get();"
	#fi
}

#
# TPOaddInsertRoutine class 
#
# Adds code to insert an instance of the data-object to the database,
# including its subclasses
#
TPOaddInsertRoutine()
{
	Class=$1
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d":" -f2`

	# generate a DBview with table and standard BCA
	echo "//"
	echo "// Routine for insert this ${Class} object in the database."
	echo "//"
	echo "template<>"
	echo "void TPersistentObject<${Class}>::doInsert() const"
	echo "{"
	echo "	typedef	DBView<DBRep<${Class}> >	DBViewType;"
	echo "	DBViewType	insView(\"${Table}\", BCA<${Class}>());"
	echo "	DBViewType::insert_iterator	insIter = insView;"
	echo ""

	TPOcodeCopyToLocal ${Class} insert

	echo ""
	echo "	// save this record"
	echo "	*insIter = rec;"
	echo ""

	echo "	metaData().versionNr()++;"
	echo "}\n"
}

#
# TPOaddUpdateRoutine class clause
#
# Adds a routine for updating a data-object in the database. The data-object
# is searched using its unique ObjectId.
#
TPOaddUpdateRoutine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d":" -f2`

	# generate a DBview with table and standard BCA
	echo "//"
	echo "// Routine for updating this ${Class} object in the database."
	echo "//"
	echo "template<>"
	echo "void TPersistentObject<${Class}>::doUpdate() const"
	echo "{"
	echo "	typedef DBView<DBRep<${Class}>, DBRep<ObjectId> > DBViewType;"
	echo "	DBViewType	updView(\"${Table}\", BCA<${Class}>(),"
	echo "			\"WHERE ObjId=(?)\", BPA<ObjectId>());"
	echo "	DBViewType::update_iterator 	updIter = updView;"
	echo ""

	TPOcodeCopyToLocal ${Class} update

	echo ""
	echo "	// setup the selection parameters"
	echo "	updIter.Params().itsOid = rec.Oid;"
	echo ""
	echo "	// save this record"
	echo "	*updIter = rec;"
	echo ""

	echo "	metaData().versionNr()++;"
	echo "}\n"
}

#
# TPOaddDeleteRoutine class clause
#
# Adds a routine for deleting a data-object from the database. The deletion
# is based on the unique ObjectID of the object.
#
TPOaddDeleteRoutine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d":" -f2`

	# generate a DBview with table and standard BCA
	echo "//"
	echo "// Routine for deleting this ${Class} object in the database."
	echo "//"
	echo "template<>"
	echo "void TPersistentObject<${Class}>::doErase() const"
	echo "{"
	echo "	typedef DBView<DBRep<ObjectId> > DBViewType;"
	echo "	DBViewType	delView(\"${Table}\", BCA<ObjectId>());"
	echo "	DBViewType::delete_iterator		delIter = delView;"
	echo ""

	echo "	// setup the selection parameters"
	echo "	DBRep<ObjectId>		rec;"
	echo "	rec.itsOid = metaData().oid()->get();"
	echo ""
	echo "	// delete this record"
	echo "	*delIter = rec;"
	echo ""

	echo "	metaData().reset();"
	echo "}\n"
}

#
# TPOaddInternalSearchRoutine class 
#
# Adds code to retrieve an instance of the data-object to the database,
# including its subclasses
#
TPOaddInternalSearchRoutine()
{
	Class=$1
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d":" -f2`

	# generate a DBview with table and standard BCA
	echo "//"
	echo "// Routine to retrieve this ${Class} object from the database."
	echo "//"
	echo "template<>"
	echo "void TPersistentObject<${Class}>::doRetrieve(const ObjectId&	aOid,"
	echo "												 bool isOwnerOid)"
	echo "{"
	echo "	std::string		whereClause;"
	echo "	if (isOwnerOid) {	whereClause = \"WHERE Owner = (?)\";  }"
	echo "			else {	whereClause = \"WHERE ObjId=(?)\"; }"
	echo ""
	echo "	typedef DBView<DBRep<${Class}>, DBRep<ObjectId> >  DBViewType;"
	echo "	DBViewType 	selView(\"${Table}\", BCA<${Class}>(), whereClause, BPA<ObjectId>());"
	echo "	DBViewType::select_iterator	selIter = selView.begin();"
	echo ""

	echo "	selIter.Params().itsOid = aOid.get();"
	echo ""
	echo "	// Should we throw an exception if there are no matching records?"
	echo "	// Let's do it for the time being; that's easier for debugging."
	echo "	if (selIter != selView.end()) {"
	echo "		fromDatabaseRep(*selIter);"
	echo "	}"
	echo "	else {"
	echo "		THROW (PLException, \"No matching records found!\");"
	echo "	}"
	echo "}\n"
}

#
# TPOaddSearchRoutine class 
#
# Adds code to retrieve an instance of the data-object to the database,
# including its subclasses
#
TPOaddSearchRoutine()
{
	Class=$1
	Table=`grep ^$Class ${MAPWRKFILE} | head -1 | cut -d":" -f2`

	# generate a DBview with table and standard BCA
	echo "//"
	echo "// Routine to retrieve this ${Class} object from the database."
	echo "//"
	echo "template<>"
	echo "Collection<TPersistentObject<${Class}> > "
	echo "TPersistentObject<${Class}>::retrieve(const Query&	query, int maxObjects)"
	echo "{"
	echo "	std::cout << \"retrieve ${Class}\" << std::endl;"
	echo "	typedef DBView<DBRep<${Class}> >  DBViewType;"
	echo "	DBViewType 	selView(\"${Table}\", BCA<${Class}>(), query.getSql());"
	echo "	DBViewType::select_iterator	selIter = selView.begin();"
	echo "	Collection<TPersistentObject<${Class}> > 	selResult;"
	echo ""

	echo "	for (int nrRecs = 0; selIter != selView.end() && nrRecs < maxObjects; ++selIter, ++nrRecs) {"
	echo "		TPersistentObject<${Class}>		TPO${Class};"
	echo "		TPO${Class}.fromDatabaseRep(*selIter);"

	echo "		TPO${Class}.retrieve();		// refresh object, should be changed"
	echo "		selResult.add(TPO${Class});"
	echo "	}"
	echo "		// @@@ TO BE DEFINED @@@"
	echo ""

	echo "	return (selResult);"
	echo "}\n"
}

#---------------------------- Global routines ---------------------------------
#
# initTmpfile
#
# Writes an informational header to the tempfile in case the file was not
# removed by this script.
#
initTmpfile()
{
	echo "#This temporarely file was generated by genDBcode"
	echo "#It should have been cleaned up by genDBcode, please remove it"
	echo "#ClassName:TableName:Ctype:MemberName:ColumnName:SubclassName:DBtype"
}

#
# initSrcfile filetype class
#
# Adds an informational header to the C++ source- of headerfile.
#
initSrcfile()
{
	FileType=$1
	Class=$2

	echo -n "//# This file was generated by genDBcode ${VERSION} on " ; date
	echo "//# with the command: genDBcode ${MAPFILE} ${FUNFILE} ${LAYER} ${CLASS}"
	echo -n "//# from the directory: " ; pwd
	echo "//#"
	echo "//# EDITING THIS FILE MANUALLY IS AT YOUR OWN RISK"
	echo "//# IT MIGHT BE OVERWRITTEN BY THE NEXT MAKE OF YOUR PROJECT"
	echo "//#"

	# include the headerfiles in the C++ sourcefile
	if [ "${FileType}" == "cc" ]; then
		# Grep all subclasses of this class and include those headerfiles also.
		grep ^${Class} ${MAPWRKFILE} | grep -v "::" | while read line
		do
			subClass=`echo $line | cut -d':' -f6`
			echo "#include \"${FILEPREFIX}${subClass}.h\""
		done
		echo "#include \"${FILEPREFIX}${Class}.h\""
		echo "#include \"LCS_base.h\""
		echo "#include <PL/Collection.h>"
		echo "#include <PL/DTLHelperClasses.h>"
		echo "#include <PL/Query.h>"
		echo "#include <PL/TPersistentObject.h>"
		echo ""
		echo "using namespace dtl;"
		echo ""
	else	# its a headerfile
		typeset -u FileLabel=${FILEPREFIX}${Class}_H
		echo "//# only include this file once"
		echo "#if !defined(${FileLabel})"
		echo "#define ${FileLabel}"
		echo ""
		if [ "${Class}" == "lcs_base" ]; then
			echo "#include <PL/DTLHelperClasses.h>"
			echo "#include <PL/ObjectId.h>"
			echo "#include <PL/PersistentObject.h>"
			echo "#include <dtl/DTL.h>"
		else
			echo "#include \"${Class}.h\""
		fi
		echo ""
	fi
}

#
# closeHeaderfile class
#
# write the last '#endif' to the headerfile
#
closeHeaderfile()
{
	Class=$1

	echo "#include \"${FILEPREFIX}${Class}.tcc\"	// Include template code"
	echo ""
	echo "#endif"
}

#
# cleanupWorkFiles
#
# Removes all temporary workfiles
#
cleanupWorkFiles()
{
	rm -f ${MAPWRKFILE} ${ALLCLASSESWRKFILE}
}

#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
#
cleanlist()
{
	cut -d"#" -f1 $1 | awk '{ if (NF > 0) print $0 }'
}

#
# convertMapfile mapfile
#
# Convert the user format from the mapfile into something more convenient
# and store this in the tempfile.
#
# Allowed linesyntax of  the mapfile:
#	Class	<ClassName>
#	Table	<TableName>
#	<Ctype>	<MemberName>	<ColumnName>	<DBtype>
#	<Ctype>	<MemberName>	class			<ClassName>
#
# Syntax of the constructed temp-file:
# ClassName:TableName:Ctype:MemberName:ColumnName:SubclassName:DBtype
#
# NOTE: THIS ROUTINE ALSO EXISTS IN genDBsql
#
convertMapfile()
{
	Mapfile=$1

	cleanlist ${Mapfile} | while read label name dbname fldtype
	do
		# comment is stripped off, check rest of line
		if [ -z "$label" -o -z "$name" ]; then		# need two fields
			continue
		fi

		case $label in
		Class|class|CLASS)				# Class keyword
			CurClass=$name
			;;
		Table|table|TABLE)				# Table keyword
			CurTable=$name
			;;
		*)								# no keyword, assume fieldname
			typeset -l SubClass=`echo $dbname | cut -d" " -f1`
			# what kind of field is this?
			if [ "${SubClass}" == "class" -o "${SubClass}" == "baseclass" ]; then
				# it's a (sub)class, get its name.
				SubClassName=`echo $fldtype | cut -d" " -f1`
				echo "$CurClass:$CurTable:$label:$name:$dbname:$SubClassName:BIGINT"
			else
				echo "$CurClass:$CurTable:$label:$name:$dbname::$fldtype"
			fi
			;;
		esac
	done
}

# hasSubClasses class
#
# Routine that figures out if the given class has subclasses.
# Returns true or false
#
hasSubClasses()
{
	Class=$1

	# Note: grep returns 0 if something found, 1 or -1 if not.
	grep ^$Class ${MAPWRKFILE} | grep -v "::" >>/dev/null
	GrepOk=`echo $?`
	
	if [ ${GrepOk} == "0" ]; then			# something found?
		echo true
	else
		echo false
	fi

}
#------------------------------- MAIN program ---------------------------------
#
# Check invocation syntax: [-d destdir] genDBcode mapfile cmdfile layer [class]
#

# Check option argument
DESTDIR="./"						# assume no destination directory
eval set argv=`getopt "d:" $*`		# reformat arguments
shift
case "$1" in
	-d)	DESTDIR=$2
		if [ ! -d ${DESTDIR} ]; then
			echo "Destination directory >${DESTDIR}< does not exist"
			exit 1
		fi
		shift 2
		;;
esac
shift								# remove --

# Check other arguments
case $# in
	3)	MAPFILE=$1					# genDBcode mapfile funfile layer
		FUNFILE=$2
		typeset -u LAYER=$3
		GREPMASK=""
		CLASS=""
		;;
	4)	MAPFILE=$1					# genDBcode mapfile funfile layer classname
		FUNFILE=$2
		typeset -u LAYER=$3
		GREPMASK=" | grep ^$4"
		CLASS=$4
		;;
	*)	echo "Syntax: $0 mapfile functionfile layer [class]"
		echo "        where layer is R(ecord) or P(ersistency)"
		exit 0
		;;
esac

# Mapfile must exist
#
if [ ! -s ${MAPFILE} ]; then
	echo "File ${MAPFILE} doesn't exist\n"
	exit 1
fi

# Functionfile must exist
#
if [ ! -s ${FUNFILE} ]; then
	echo "File ${FUNFILE} doesn't exist\n"
	exit 1
fi

# Check Layer type
#
case "${LAYER}" in
R)		FILEPREFIX="Rec"		;;
P)		FILEPREFIX="PO_"		;;
*)		echo "Layer should be R(ecord) or P(ersistency), not >${LAYER}<\n"
		exit 1
esac

# All arguments seem ok, continue processing

# Initialize some variables
#
ROLLBACKCODE=false				# whether or not generate rollback code
LCSBASEFILE=${DESTDIR}/LCS_base.h
MAPWRKFILE=/tmp/mapinfo.LCS.$$
ALLCLASSESWRKFILE=/tmp/created.LCS.$$

# Make sure there are no old workfiles left
cleanupWorkFiles

# Set trap handler before we create anything
trap "cleanupWorkFiles ; exit" 1 2 3 13 15

# convert the human readable format of the mapfile into something
# more convenient for shell-programming
echo "Analysing mapfile"
initTmpfile					> ${MAPWRKFILE}
convertMapfile ${MAPFILE}	>>${MAPWRKFILE}

#
# Build the sourcecode for the record- or the persistency-layer
#
if [ "${LAYER}" == "P" ]; then
	# always need this in the tpo layer
	initSrcfile "h" lcs_base 	> ${LCSBASEFILE}
	TPOaddGenericStructures		>>${LCSBASEFILE}
fi

# Scan the functionfile to determine what code should be generated
#
PrevClass="Unknown"
eval "cleanlist $FUNFILE $GREPMASK" | \
while read class action clause
do
	# minimal check on layout of line
	if [ -z "$class" -o -z "$action" ]; then
		continue
	fi

	# New class? generate the necc. structures in the new sourcefile.
	# generate exacly one BCA for each class
	if [ "${PrevClass}" != "${class}" ]; then
		#RedefineTPOclass=`hasSubClasses ${class}`
		RedefineTPOclass=true
		case ${LAYER} in
		R) 	SOURCEFILE=${DESTDIR}/${FILEPREFIX}${class}.cc
			HEADERFILE=${DESTDIR}/${FILEPREFIX}${class}.h
			initSrcfile "cc" ${class}  > ${SOURCEFILE}
			RECaddBCA 	     ${class}  >>${SOURCEFILE}
			;;
		P) 	# start a new headerfile and sourcefile
			SOURCEFILE=${DESTDIR}/${FILEPREFIX}${class}.tcc
			HEADERFILE=${DESTDIR}/${FILEPREFIX}${class}.h
			echo ${class}	 							>>${ALLCLASSESWRKFILE}
			echo "Creating code for class ${class}"
			initSrcfile "cc"				${class} 	> ${SOURCEFILE}
			TPOopenNamespace							>>${SOURCEFILE}
			TPOaddBCA 						${class} 	>>${SOURCEFILE}
			TPOaddToDatabaseRep				${class} 	>>${SOURCEFILE} 
			TPOaddFromDatabaseRep			${class} 	>>${SOURCEFILE} 
			TPOaddInitRoutine				${class} 	>>${SOURCEFILE} 
			initSrcfile "h"					${class} 	> ${HEADERFILE}
			TPOopenNamespace							>>${HEADERFILE}
			TPOaddDTLstruct					${class} 	>>${HEADERFILE}
			TPOcloseNamespace							>>${HEADERFILE}
			closeHeaderfile					${class}	>>${HEADERFILE}
			;;
		esac
		PrevClass=${class}
	fi

	# dispatch the action
	typeset -u action=${action}						# to uppercase
	case ${LAYER} in
	R)
		case $action in
		I) RECaddInsertRoutine $class 			>>${SOURCEFILE}		;;
		U) RECaddUpdateRoutine $class "$clause"	>>${SOURCEFILE}		;;
		D) RECaddDeleteRoutine $class "$clause"	>>${SOURCEFILE}		;;
		S) RECaddSearchRoutine $class "$clause"	>>${SOURCEFILE}		;;
		*) echo "ERROR:Unknown function >$action< for class >$class< in file >$FUNFILE<"
		   ;;
		esac
		;;
	P)
		case $action in
		I) TPOaddInsertRoutine 		   $class 			>>${SOURCEFILE}	;;
		U) TPOaddUpdateRoutine 		   $class "$clause"	>>${SOURCEFILE}	;;
		D) TPOaddDeleteRoutine 		   $class "$clause"	>>${SOURCEFILE}	;;
		S) TPOaddSearchRoutine 		   $class "$clause"	>>${SOURCEFILE}	
		   TPOaddInternalSearchRoutine $class "$clause"	>>${SOURCEFILE}	;;
		*) echo "ERROR:Unknown function >$action< for class >$class< in file >$FUNFILE<"
		   ;;
		esac
		;;
	esac
done

# Finish all created .tcc files
if [ "${LAYER}" == "P" ]; then
	cat ${ALLCLASSESWRKFILE} | while read Class
	do
		TPOcloseSrcFile	${Class} >>${DESTDIR}/${FILEPREFIX}${Class}.tcc
	done
fi

# Finally cleanup our mess
cleanupWorkFiles
