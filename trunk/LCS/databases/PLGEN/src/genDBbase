#!/usr/bin/ksh
#
# genDBbase : generates a mapfile and a functionfile for genDBcode.
#
# Copyright (C) 2003
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# Syntax: genDBbase modulename headerfiles
#
# The generated files must be manually adjusted before they
# can be used by genDBcode.
#
# $Id$
#
VERSION="v1.2"

#---------------------------- Global routines ---------------------------------
#
# initResultFile
#
# Adds an informational header to the result files
#
initResultFile()
{
	echo -n "# This file was generated by genDBbase ${VERSION} on " ; date
	echo "# with the command: genDBbase ${MODULE} <headerfiles>"
	echo -n "# from the directory: " ; pwd
	echo "#"
	echo "# PLEASE COMPLETE THIS FILE AND REMOVE THE .proto EXTENSION"
	echo "# IT MIGHT BE OVERWRITTEN THE NEXT TIME YOU RUN genDBbase"
	echo "#"
}

#
# cleanupWorkFiles
#
# Removes all temporary workfiles
#
cleanupWorkFiles()
{
	rm -f ${ADDINGWORKFILE} ${FUNCTIONWORKFILE} ${GREPWORKFILE}	\
		  ${MAPPEDWORKFILE} ${MEMBERWORKFILE}   ${MISSINGWORKFILE}	\
		  ${NEEDEDWORKFILE} ${TYPEDEFWORKFILE}
}

#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
#
cleanlist()
{
	cat $* |  \
		# replace {} by ; , place { or } on new lines and force \n after ;
		sed "s/{[ \t]*}/; /g ; s/[{}]/\n&\n/g ; s/;[ \t]/;\n/g" | \
		# skip empty lines
		awk '{ if (NF > 0) print $0 }'
}

#
# analyseInfoFile file
#
# Breaks down the info file (=precompiled headerfile) into the
# functions, typedefs and variables.
# The results are written to several temp files.
#
analyseInfoFile()
{
	# awk is used in this routine as pattern scanner. The lines of the
	# infofile are sent through a set of patterns, when a lines matches
	# a pattern the corresponding code is executed. In this way awk is
	# used as a kind of lex and yacc.

	awk -v TYPEDEFFILE=${TYPEDEFWORKFILE} 		\
		-v FUNCTIONFILE=${FUNCTIONWORKFILE}		\
		-v MEMBERFILE=${MEMBERWORKFILE}		'
	# First define some functions for handling difficult actions

	#
	# skipTillNext delimiter
	#
	# Skips the inputstream until the given delimiter is found
	# The delimiter may be an regular expression.
	#
	function skipTillNext(delimiter) {
		while (match ($0, delimiter) == 0) {	# search delimiter
			getline
		}
		$0=substr($0, RSTART+RLENGTH)
		gsub("^[ 	]*", "")					# skip leading spaces
	}

	#
	# getTillNext delimiter
	#
	# Skips the inputstream until the given delimiter is found
	# The skipped characters are return to the caller.
	# The delimiter may be an regular expression.
	#
	function getTillNext(delimiter,     result) {
		result=""
		while (match ($0, delimiter) == 0) {	# delimiter found?
			result=result $0					# No, add line to result
			getline
		}
		result=result substr($0,1,RSTART+RLENGTH)  # add last part to result
		$0=substr($0, RSTART+RLENGTH)			# cut last part from inputstream
		gsub("^[ 	]*", "")					# skip leading spaces
		gsub("[ \t]+", " ", result)				# skip double whitespace
		return result
	}

	#
	# handleTypedef 
	#
	# Cuts the typedef from the inputstream and stores them in the
	# TYPEDEFS file.
	# A typedef can have two forms:
	# typedef xxx yyy;   or typedef xxx { aaa; bbb; };
	#
	function handleTypedef(    theTD) {
		theTD=getTillNext(";");					# find first ;
		if (index(theTD, "{") != 0) {			# { char in typedef? srch }
			while (split(theTD, dummy, "{") > split(theTD, dummy, "}")) {
				theTD=theTD getTillNext("}") getTillNext(";");
			}
		}
		gsub ("[ \t]+", " ", theTD)				# remove double spaces
		print theTD >> TYPEDEFFILE
	}

	#
	# handleFunction 
	#
	# Cuts the function definition from the inputstream and stores it 
	# in the FUNCTION file.
	# The diff. with a typedef is that a function does not have a ;
	# after the last }
	#
	function handleFunction(    theFunc) {
		theFunct=getTillNext(";|{");
		if (index(theFunct, "{") != 0) {
			while (split(theFunct, dummy, "{") > split(theFunct, dummy, "}")) {
				theFunct=theFunct getTillNext("}");
			}
		}
		print theFunct >> FUNCTIONFILE
	}

	#
	# pushOnStack type name
	#
	# This function is used to handle nested namespaces and classes.
	# Whenever a namespace or class starts it pushes the current state
	# on this stack. When a loose } is found the stack is used to see
	# to which namespace or class it belongs.
	#
	function pushOnStack(theType, theName) {
		nameStack[stackSize]=theName
		typeStack[stackSize]=theType
		stackSize++
	}

	#
	# pullFromStack
	#
	# See comment of psuhOnStack
	#
	function pullFromStack(   topOfStack) {
		stackSize--
		topOfStack=typeStack[stackSize] nameStack[stackSize]
		return topOfStack
	}

	BEGIN {
		stackSize=1
	}

	#
	# All lines of the infofile are passed through these pattern filters.
	#
	/^[ \t]*/			{ gsub("^[ 	]*", "") }		# skip leading spaces
	/[ \t]*$/			{ gsub("^[ 	]*", "") }		# skip trailing spaces
	/^;/				{ next }					# remove loose ;
	/^#/				{ File=$3 ; next }			# remember the sourcefile
	/[ \t]*const[ \t]*/	{ gsub("[ \t]*const[ \t]*", "") }	# remove const
	/[ \t]*static[ \t]*/{ gsub("[ \t]*static[ \t]*", "") }	# remove static
	/\[.*[a-zA-Z]+.*]/	{ bpos=index($0,"[")		# function in array size?
						  epos=index($0,"]")		# replace it with @@@
						  $0=substr($0,1,bpos) "@@@" substr($0,epos)
						}
	/^using /			{ next }					# skip using commands
	/^friend/			{ next }					# skip friend lines
	/^public[ \t]*:/	{ Mode="publ" ; gsub("public[ \t]*:[ \t]*"   ,"") }
	/^protected[ \t]*:/	{ Mode="prot" ; gsub("protected[ \t]*:[ \t]*","") }
	/^private[ \t]*:/	{ Mode="priv" ; gsub("private[ \t]*:[ \t]*"  ,"") }
	/^mutable/			{ gsub("mutable[ \t]*"  ,"") }
	/^__extension__/	{ gsub("__extension__[ \t]*"  ,"") }
	/^typedef/			{ handleTypedef() }
	/^template/			{ skipTillNext(">") }
	/^extern/			{ skipTillNext(";") }
	/^enum/				{ skipTillNext("}") }
	/^virtual/			{ handleFunction() }
	/^inline/			{ handleFunction() }
	/^[ \t]*\n/			{ next }					# line with only whitespace
	# at last something we are interested in
	/^class|^struct/	{ if (index($0,";")) {		# forward declaration?
							next
						  }
						  else {
							pushOnStack("C", Class)		# remember current state
							Class=getTillNext("{")		# get name of class
							gsub("[ \t]*{", "", Class)	# skip double spaces
							gsub("^class ", "", Class)	# cut of class keyword
							nrMembers=0					# no members yet
							# note class may be of the form:
							# xxx : public yyy;
						  }
						}
	/^namespace/		{ pushOnStack("N", NameSpace)	# remember current NS
						  if (length(NameSpace) == 0) {	# no NS already?
							NameSpace=$2				# just copy this one.
						  }
						  else {						# extend current NS
							NameSpace=NameSpace "::" $2
						  }
						  skipTillNext("{")				
						}
						# closing bracket from NS or class
	/}/					{ prevName = pullFromStack() 
						  if (substr(prevName,0,1) == "N") {	# from NS?
							NameSpace=substr(prevName,2)
						  }
						  else {						# from Class
	  						if (nrMembers > 0) {
							  # end the class definition with a marker
							  # the contains the filename and the classname
							  # note: the class MUST be on a non-existing place
							  printf "%s@@@@@%s@\n", File , Class >MEMBERFILE
							}
							Class=substr(prevName,2)
						  }
						  next
						}

	# Finally the non-conditional code which might contain the members
	{ if (index($0,"(")) {
		handleFunction()
	  }

	  if (length($0) == 0) {		# nothing left?
		next
	  }

	  # This must be a variable declaration
	  printf "%s@%s@%s@%s@%s\n", File, NameSpace, Class, Mode, $0 >MEMBERFILE
	  nrMembers++
	}
	'
}

#
# addToMapFile memberfile [class]
#
# Scan the just created memberfile and construct the mapfile
# This routine is first called without the class parameter, in that case
# we must add all classes of the main headerfile. Then this function may
# be called several times to add a single class to the mapfile.
#
addToMapFile()
{
	if [ "$2" == "" ]; then
		# no class specification: everything in main headerfile
		# first line of preprocessed file contains name of this file
		grepmask=`tail -1 $1 | cut -d"@" -f1`
		grepmask="^${grepmask}"						# grep on filename
	else
		# grep @class@ or @class : public xxx@
		grepmask="@$2[ \t:publiclastru]*[a-zA-Z0-9_]*@"
	fi
	eval "grep '$grepmask' $1" | \

	awk -v TYPEDEFFILE=${TYPEDEFWORKFILE}	\
		-v GREPFILE=${GREPWORKFILE}			\
		-v MAPPEDFILE=${MAPPEDWORKFILE}		\
		-v NEEDEDFILE=${NEEDEDWORKFILE}	'

	BEGIN {
		prevClass="NoSuchClass"
		prevBaseClass=""

		# This table is used for transforming C types to Postgres types.
		BasicType["short"]				= "SMALLINT"
		BasicType["ushort"] 			= "SMALLINT"
		BasicType["int"]				= "INTEGER"
		BasicType["uint"]				= "INTEGER"
		BasicType["long"]				= "BIGINT"
		BasicType["ulong"]				= "BIGINT"
		BasicType["longlong"]			= "BIGINT"
		BasicType["ulonglong"]			= "BIGINT"
		BasicType["double"]				= "DOUBLE PRECISION"
		BasicType["float"]				= "FLOAT"
		BasicType["bool"]				= "SMALLINT"
		BasicType["TIMESTAMP_STRUCT"]	= "TIMESTAMP"
		BasicType["string"]				= "TEXT"
		BasicType["blob"]				= "TEXT"
		BasicType["char["]				= "VARCHAR"
		BasicType["uchar["]				= "VARCHAR"
		BasicType["char"]				= "VARCHAR"
		BasicType["uchar"]				= "VARCHAR"
		BasicType["void"]				= "@@@???"
	}

	#
	# resolveVariableType C-type
	#
	# Recursively tries to resolve the given C-type to a basictype
	# known by Postgres.
	#
	function resolveVariableType(Ctype) {
		if (Ctype in BasicType) {			# basic type?
			return BasicType[Ctype]			# life is easy sometimes.
		}

		VarType=resolveTypedef(Ctype)		# try resolving it as a typedef
		if (substr(VarType,1,3) == "@@@") {	# unresolvable?
			return VarType					# return failure
		}

		return resolveVariableType(VarType);	# resolve the result
	}

	#
	# resolveTypedef someType
	#
	# Searches the given variable_type in the typedefs-file created in
	# the analyze-phase. When found it returns the original type.
	# Otherwise @@@ is returned.
	#
	function resolveTypedef(varType,   theTypedef) {
		# note: the get a result from a system command into awk we must
		# pass it to a file and then read the file again.
		Command=sprintf("grep %c %s;%c %s >%s 2>/dev/null", 39, varType, 39, TYPEDEFFILE, GREPFILE);
		system(Command)							# execute grep

		theTypedef=""							# reset result
		getline theTypedef < GREPFILE			# get grep result
		close(GREPFILE)						# not needed anymore
		if (length(theTypedef) <= 0) {			# not found?
			return "@@@"						# return failure
		}

		gsub("^typedef ", "", theTypedef)		# cut off keyword typedef
		gsub(" [a-zA-Z][^;]+;", "", theTypedef)	# cut off last word
		gsub("{[^}]*}", "", theTypedef)			# cut struct definition

		return theTypedef
	}

	#
	# resolveMemberInfo infotype definition_string
	#
	# A C(++) like variable declaration can be passed to this routine
	# The routine analyzes and reformats the declaration and returns
	# the required information (infotype)
	# infotype: MT  Member Type
	#			MN	Member Name
	#			CT	Column Type (in database)
	#			CN	Column Name (in database)
	#
	# Note: Since this routine makes up the database properties this is
	# 		where the link between the C-code and the database is defined.
	#
	function resolveMemberInfo(infoType, argString) {
		# infoType: MT / MN / CT / CN
		gsub("[ \t][ \t]+", " ", argString)	# skip double spaces
		split(argString, element, " ")
		if (element[1] == "unsigned") {
			# unsigned xxx --> uxxx
			MemberType="u" element[2]
			MemberName=element[3]
			ArgNr=3
		}
		else {
			MemberType=element[1]
			MemberName=element[2]
			ArgNr=2
		}
		if (MemberName == "long") {		# (unsigned) long long ?
			MemberType=MemberType MemberName
			MemberName=element[++ArgNr]
		}
		
		# When the member is a pointer or a reference append
		# a * to the MemberType and remove to original & or *
		# NOTE: it is trivial whether is was a * or a & we dont
		# handle both types in this version

		# * or & attached to membername? move it to membertype
		if ((MemberName == "&") || (MemberName == "*")) {
			MemberType=MemberType"*"
			MemberName=element[++ArgNr]
		}
		gsub("&","*",MemberType)				# treat & as *
		gsub("[ \t]*;","",MemberName)			# strip off line termination

		# move pointer and references to the MemberType
		if (index(MemberName,"*") || index(MemberName,"&")) {
			gsub("*","",MemberName)
			gsub("&","",MemberName)
			MemberType=MemberType"*"
		}
		PlainMemberType=MemberType
		gsub("*","",PlainMemberType)		# MemberType without '*'

		if (infoType == "MN") { return MemberName }
		if (infoType == "MT") { return MemberType }

		# Convert the member-characteristics to database characteristics.

		# When the variable is an array, find out its length
		ArrSize=1
		ArrOpen=index($0,"[")
		ArrClose=index($0,"]")
		if (ArrOpen && ArrClose) {
			ArrSize=0+substr($0,ArrOpen+1, ArrClose-ArrOpen)
			pos=index(MemberName,"[")		# attached to membername?
			if (pos) {
				MemberName=substr(MemberName,1,pos-1)
			}
		}

		# Construct the database equivalents
		ColumnType=resolveVariableType(PlainMemberType)
		if (substr(ColumnType,1,3) != "@@@") {			# familiar type?
			ColumnName=toupper(MemberName)
			if (ColumnType == "VARCHAR") {
				ColumnType=ColumnType "(" ArrSize ")"
			}
		}
		else {											# unknown type
			ColumnType="@@@"PlainMemberType
			ColumnName="Class"
		}
		if (infoType == "CN") 
			return ColumnName
		else
			return ColumnType
	}

	#
	# addBaseClass classname
	#
	# Adds the given class as base class to the map file.
	function addBaseClass(baseClass) {
		if (length(baseClass) <= 0) {
			return;
		}
		MemberName="BC" baseClass
		ColumnName="BaseClass"
		printf "%-18s %-18s %-18s %s\n", baseClass, MemberName, ColumnName, baseClass
	}

	# MAIN awk loop
	{ 
		split($0, field, "@")
		Class=field[3]							# xxx or xxx : public yyy
		BaseClass=""
		if (index(Class,":")>0) {				# is class derived from other?
			gsub("[ \t]*:[ \t]*public", "", Class)	# --> xxx yyy
			split(Class, part, " ")
			Class=part[1]
			BaseClass=part[2]
		}

		if (Class != prevClass) {				# start of a new class?
			addBaseClass(prevBaseClass);		# class last class

			if (Class == "") {					# EndOfClass marker?
				next
			}

			printf "\n"
			printf "Class		%s\n", Class
			printf "Table		%s\n", Class
			printf "#TYPE              MEMBER             COLUMN             TYPE\n"
			printf "#--------------------------------------------------------------------\n"
			prevClass=Class
			prevBaseClass=BaseClass

			# remember this class is in the map file
			print Class >>MAPPEDFILE

			if (BaseClass != "") {
				print BaseClass >>NEEDEDFILE		# add this class later
			}
		}

		MemberType=resolveMemberInfo("MT", field[5])
		MemberName=resolveMemberInfo("MN", field[5])
		ColumnType=resolveMemberInfo("CT", field[5])
		ColumnName=resolveMemberInfo("CN", field[5])

		printf "%-18s %-18s %-18s %s\n", MemberType, MemberName, ColumnName, ColumnType
		if (ColumnName == "Class" || ColumnName == "BaseClass") {
			print substr(ColumnType,4) >>NEEDEDFILE
		}
	} '
}

#
# constructFunfile usedClassesFile
#
constructFunfile()
{
	grep -v "#" $1 | sort | uniq | awk '{
		printf "%-15s		I\n", $1
		printf "%-15s		U\n", $1
		printf "%-15s		D\n", $1
		printf "%-15s		S    WHERE ???\n", $1
	}'
}

#------------------------------- MAIN ----------------------------------------
#
# Syntax: genDBbase [-d destdir] module headerfiles
#

DESTDIR="./"

# Check invocation syntax
#
eval set argv=`getopt "d:" $*`			# reformat arguments
shift
case "$1" in
	-d) DESTDIR=$2
		if [ ! -d ${DESTDIR} ]; then
			echo "Destination directory >${DESTDIR}< does not exist"
			exit 1
		fi
		shift 2
		;;
esac
shift									# remove --

case $# in
	0|1)	echo "Syntax: $0 [-d destdir] module headerfiles"
		exit 0
		;;
	*)	MODULE=$1
		shift
		HEADERFILES="$*"
		;;
esac

# Initialize some variables
#
MAPFILE=${DESTDIR}/${MODULE}.map.proto		# resultfile
FUNFILE=${DESTDIR}/${MODULE}.fun.proto		# resultfile

# A lot of temp files but this makes life much easier
ADDINGWORKFILE=/tmp/adding.LCS.$$			# subclasses curr. adding
FUNCTIONWORKFILE=/tmp/functions.LCS.$$		# functions in the inputfile
GREPWORKFILE=/tmp/grep.LCS.$$				# tmp grep result
MAPPEDWORKFILE=/tmp/mapped.LCS.$$			# classes already mapped
MEMBERWORKFILE=/tmp/members.LCS.$$			# datamembers in the inputfile
MISSINGWORKFILE=/tmp/missing.LCS.$$			# classes not in the inputfile
NEEDEDWORKFILE=/tmp/needed.LCS.$$			# subclasses to add later
TYPEDEFWORKFILE=/tmp/typedefs.LCS.$$		# typedefs in the inputfile

# make sure there are no old workfiles left
cleanupWorkFiles

# Set trap handler before we create anything
trap "cleanupWorkFiles ; exit" 1 2 3 13 15

# Write headers to the result files.
initResultFile  	> ${MAPFILE}
initResultFile  	> ${FUNFILE}

# Scan the headerfiles and substract the class hierarchy
for file in ${HEADERFILES}
do
	# cleanup intermediate results
	rm -f ${TYPEDEFWORKFILE} ${FUNCTIONWORKFILE} ${MEMBERWORKFILE} \
		  ${NEEDEDWORKFILE}

	# First stage: break down precompiled headerfile into:
	#		typedefs.LCS.$$
	#		functions.LCS.$$
	#		members.LCS.$$
	echo -n "${file}: analysing"
	cleanlist $file | analyseInfoFile

	# Second stage: Construct mapfile from all classes in main headerfile
	#	This stage might produce a needed.LCS.$$ file.
	echo -n ", adding main classes"
	addToMapFile ${MEMBERWORKFILE} >>${MAPFILE}

	# Third stage (repeating): Add the base- and embedded- classes
	echo -n ", adding base classes"
	complete=false
	while (! $complete)
	do
		if [ ! -f "${NEEDEDWORKFILE}" ]; then	# nothing needed anymore?
			complete=true						# then we are done
			break
		fi

		sort ${NEEDEDWORKFILE} | uniq >${ADDINGWORKFILE} 	# skip doubles
		rm -f ${NEEDEDWORKFILE}				# will be recreated in next loop
		cat ${ADDINGWORKFILE} | while read classname
		do
			# make sure this class is not already in the map file
			grep $classname ${MAPPEDWORKFILE} >/dev/null 2>&1
			if [ $? -ne 0 ]; then			# not found?
				addToMapFile ${MEMBERWORKFILE} $classname >>${MAPFILE}
				# class succesfully added?
				grep $classname ${MAPPEDWORKFILE} >/dev/null 2>&1
				if [ $? -ne 0 ]; then		# still not found?
					echo $classname >>${MISSINGWORKFILE}
				fi
			fi
		done
		rm ${ADDINGWORKFILE}
	done
	echo ", ready"
done

# The embedded and base classes are still in the map file as @@@xxx
# Remove the @@@ from the classes that were resolved.
cat ${MAPPEDWORKFILE} | while read class
do
	cat ${MAPFILE} | sed "s/@@@${class}$/${class}/" >> ${MAPFILE}tmp
	mv ${MAPFILE}tmp ${MAPFILE}
done

# Almost done, construct the fun file for the implemented classes
constructFunfile ${MAPPEDWORKFILE} >>${FUNFILE}

# Notify user for missing sub classes
if [ -f ${MISSINGWORKFILE} ]; then
	echo "WARNING: The following types or classes could not be resolved:"
	cat ${MISSINGWORKFILE}
fi

# Finally cleanup our mess.
cleanupWorkFiles

