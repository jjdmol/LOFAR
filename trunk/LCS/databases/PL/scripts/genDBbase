#!/usr/bin/ksh
#
# genDBbase : generates a mapfile and a functionfile for genDBcode.
#
# Copyright (C) 2003-2004
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# Syntax: genDBbase modulename precompiled_headerfiles
#
# The generated files must be manually adjusted before they
# can be used by genDBcode.
#
# $Id$
#
VERSION="v1.9"
DEBUGMODE=false

#---------------------------- Global routines ---------------------------------
#
# initResultFile
#
# Adds an informational header to the result files
#
initResultFile()
{
	echo -n "# This file was generated by genDBbase ${VERSION} on " ; date
	if [ ${#HEADERFILES}+${#COMMAND} -gt 55 ]; then
		echo "# with the command: ${COMMAND} <precompiled_headerfiles>"
	else
		echo "# with the command: ${COMMAND} ${HEADERFILES}"
	fi
	echo -n "# from the directory: " ; pwd
	echo "#"
	echo "# PLEASE COMPLETE THIS FILE AND REMOVE THE .proto EXTENSION"
	echo "# IT MIGHT BE OVERWRITTEN THE NEXT TIME YOU RUN genDBbase"
	echo "#"
}

#
# cleanupWorkFiles
#
# Removes all temporary workfiles
#
cleanupWorkFiles()
{
	if [ "${DEBUGMODE}" != "true" ]; then
		rm -f ${ADDINGWORKFILE} ${FUNCTIONWORKFILE} ${GREPWORKFILE}	\
			  ${MAPPEDWORKFILE} ${MEMBERWORKFILE}   ${MISSINGWORKFILE}	\
			  ${NEEDEDWORKFILE} ${TYPEDEFWORKFILE}  ${USINGWORKFILE} \
			  ${MODCLASSWRKFILE}
	else
		echo "DEBUGMODE, NOT REMOVING TEMPFILES in /tmp"
	fi
}

#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
#
cleanlist()
{
	cat $* |  \
		# replace {} by ; , place { or } on new lines and force \n after ;
		sed "s/{[ \t]*}/; /g ; s/[{}]/\n&\n/g ; s/;[ \t]/;\n/g" | \
		# skip empty lines
		awk '{ if (NF > 0) print $0 }'
}

#
# analyseInfoFile file
#
# Breaks down the info file (=precompiled headerfile) into the
# functions, typedefs and variables.
# The results are written to several temp files.
#
analyseInfoFile()
{
	# awk is used in this routine as pattern scanner. The lines of the
	# infofile are sent through a set of patterns, when a lines matches
	# a pattern the corresponding code is executed. In this way awk is
	# used as a kind of lex and yacc.

	awk -v TYPEDEFFILE=${TYPEDEFWORKFILE} 		\
		-v FUNCTIONFILE=${FUNCTIONWORKFILE}		\
		-v GREPFILE=${GREPWORKFILE}				\
		-v USINGFILE=${USINGWORKFILE}			\
		-v MODULECLASSFILE=${MODCLASSWRKFILE}			\
		-v MEMBERFILE=${MEMBERWORKFILE}		'
	# First define some functions for handling difficult actions

	#
	# skipTillNext delimiter
	#
	# Skips the inputstream until the given delimiter is found
	# The delimiter may be an regular expression.
	#
	function skipTillNext(delimiter) {
		while (match ($0, delimiter) == 0) {	# search delimiter
			getline
		}
		$0=substr($0, RSTART+RLENGTH)
		gsub("^[ 	]*", "")					# skip leading spaces
	}

	#
	# getTillNext delimiter
	#
	# Skips the inputstream until the given delimiter is found
	# The skipped characters are return to the caller.
	# The delimiter may be an regular expression.
	#
	function getTillNext(delimiter,     result) {
		result=""
		while (match ($0, delimiter) == 0) {	# delimiter found?
			result=result $0					# No, add line to result
			getline
		}
		result=result substr($0,1,RSTART+RLENGTH)  # add last part to result
		$0=substr($0, RSTART+RLENGTH)			# cut last part from inputstream
		gsub("^[ 	]*", "")					# skip leading spaces
		gsub("[ \t]+", " ", result)				# skip double whitespace
		return result
	}

	#
	# handleTypedef 
	#
	# Cuts the typedef from the inputstream and stores them in the
	# TYPEDEFS file.
	# A typedef can have two forms:
	# typedef xxx yyy;   or typedef xxx { aaa; bbb; };
	#
	function handleTypedef(    theTD) {
		theTD=getTillNext(";");					# find first ;
		if (index(theTD, "{") != 0) {			# { char in typedef? srch }
			while (split(theTD, dummy, "{") > split(theTD, dummy, "}")) {
				theTD=theTD getTillNext("}") getTillNext(";");
			}
		}
		gsub ("[ \t]+", " ", theTD)				# remove double spaces
		print theTD >> TYPEDEFFILE
	}

	#
	# handleUsing 
	#
	# A using-statement can have two forms:
	# using namespace xxx;   or using xxx::yyy;
	# The second form is stored in the USING file
	#
	function handleUsing(    theUD) {
		theUD=getTillNext(";");					# find first ;
		if (index(theUD, ":") != 0) {			# : char in using?
			gsub ("using[ \t]*", "", theUD)		# remove double spaces
			print theUD >> USINGFILE
		}
	}

	#
	# handleFriend 
	#
	# A friend-statement can have three forms:
	# friend class xxx;
	# friend xxx::yyy(arg1, argn);
	# friend xxx::yyy(arg1, ..argn) { stmt1; stmt n; }
	#
	# We should skip all three forms.
	#
	function handleFriend(    theFD) {
		theFD=getTillNext(";");					# find first ;
		if (index(theFD, "{") != 0) {			# form 3?
			theFD="{"
			while (split(theFD, dummy, "{") > split(theFD, dummy, "}")) {
				theFD=theFD getTillNext("}");
			}
		}
	}

	#
	# handleFunction 
	#
	# Cuts the function definition from the inputstream and stores it 
	# in the FUNCTION file.
	# The diff. with a typedef is that a function does not have a ;
	# after the last }
	#
	function handleFunction(    theFunc) {
		theFunct=getTillNext(";|{");
		if (index(theFunct, "{") != 0) {
			while (split(theFunct, dummy, "{") > split(theFunct, dummy, "}")) {
				theFunct=theFunct getTillNext("}");
			}
		}
		print theFunct >> FUNCTIONFILE
	}

	#
	# resolveNameSpace someType
	#
	# Searches the given variable_type in the using-file created in
	# the analyze-phase. When found it returns the namespace of the type;
	# Otherwise an empty string is returned.
	#
	function resolveNameSpace(varType,   theOrgType) {
		# note: the get a result from a system command into awk we must
		# pass it to a file and then read the file again.
		Command=sprintf("grep %c::%s%c %s >%s 2>/dev/null", 39, varType, 39, USINGFILE, GREPFILE);
		system(Command)							# execute grep

		theOrgType=""							# reset result
		getline theOrgType < GREPFILE			# get grep result
		close(GREPFILE)							# not needed anymore
		if (length(theOrgType) <= 0) {			# not found?
			return ""							# return failure
		}

		gsub("[ a-zA-Z0-9;_]*$", "", theOrgType)	# cut off ::xxx;
		printf "."									# feedback to user
		return theOrgType
	}

	#
	# pushOnStack type name
	#
	# This function is used to handle nested namespaces and classes.
	# Whenever a namespace or class starts it pushes the current state
	# on this stack. When a loose } is found the stack is used to see
	# to which namespace or class it belongs.
	#
	function pushOnStack(theType, theName) {
		nameStack[stackSize]=theName
		typeStack[stackSize]=theType
		stackSize++
	}

	#
	# pullFromStack
	#
	# See comment of pushOnStack
	#
	function pullFromStack(   topOfStack) {
		stackSize--
		topOfStack=typeStack[stackSize] nameStack[stackSize]
		return topOfStack
	}

	#
	# getStack
	#
	# Returns the stack-chain of the given type (elements sep. by ::)
	#
	function getStack(theType,       theChain) {
		i=stackSize-1
		theChain=""
		while (i > 0 && typeStack[i] == theType) {
			if (nameStack[i] != "") {
				theClass=nameStack[i]			# may be xxx : public yyy
				gsub("[: \t].+", "", theClass);	# cut off after : or whitespace
				theChain=sprintf("%s%s::", theChain, theClass)
			}
			i--
		}
		return theChain
	}

	BEGIN {
		stackSize=1
	}

	#
	# All lines of the infofile are passed through these pattern filters.
	#
	/^[ \t]*/			{ gsub("^[ 	]*", "") }		# skip leading spaces
	/[ \t]*$/			{ gsub("^[ 	]*", "") }		# skip trailing spaces
	/^;/				{ next }					# remove loose ;
	/^#/				{ File=$3 ; next }			# remember the sourcefile
	/[ \t]*const[ \t]*/	{ gsub("[ \t]*const[ \t]*", "") }	# remove const
	/[ \t]*static[ \t]*/{ gsub("[ \t]*static[ \t]*", "") }	# remove static
	/\[.*[a-zA-Z]+.*]/	{ bpos=index($0,"[")		# function in array size?
						  epos=index($0,"]")		# replace it with @@@
						  $0=substr($0,1,bpos) "@@@" substr($0,epos)
						}
	/^using /			{ handleUsing() }
	/^friend/			{ handleFriend() }			# skip friend lines
	/^public[ \t]*:/	{ Mode="publ" ; gsub("public[ \t]*:[ \t]*"   ,"") }
	/^protected[ \t]*:/	{ Mode="prot" ; gsub("protected[ \t]*:[ \t]*","") }
	/^private[ \t]*:/	{ Mode="priv" ; gsub("private[ \t]*:[ \t]*"  ,"") }
	/^mutable/			{ gsub("mutable[ \t]*"  ,"") }
	/^__extension__/	{ gsub("__extension__[ \t]*"  ,"") }
	/^typedef/			{ handleTypedef() }
	/^template/			{ skipTillNext(">") }
	/^extern/			{ skipTillNext(";") }
	/^enum/				{ skipTillNext("}") }
	/^virtual/			{ handleFunction() }
	/^inline/			{ handleFunction() }
	/^[ \t]*\n/			{ next }					# line with only whitespace
	# at last something we are interested in
	/^class|^struct/	{ if (index($0,";")) {		# forward declaration?
							next
						  }
						  else {
							pushOnStack("C", Class)		# remember current state
							Class=getTillNext("{")		# get name of class
							gsub("[ \t]*{", "", Class)	# skip double spaces
							gsub("^class ", "", Class)	# cut of class keyword
							nrMembers=0					# no members yet
	  						FullClass=getStack("C") Class
							# note class may be of the form:
							# xxx : public yyy;
						  }
						}
	/^namespace/		{ pushOnStack("N", NameSpace)	# remember current NS
						  if (length(NameSpace) == 0) {	# no NS already?
							NameSpace=$2				# just copy this one.
						  }
						  else {						# extend current NS
							NameSpace=NameSpace "::" $2
						  }
						  skipTillNext("{")				
						}
						# closing bracket from NS or class
	/}/					{ prevName = pullFromStack() 
						  if (substr(prevName,0,1) == "N") {	# from NS?
							NameSpace=substr(prevName,2)	# cut off theType
						  }
						  else {						# from Class
	  						if (nrMembers > 0) {

							  # end the class definition with a marker
							  # the contains the filename and the classname
							  # note: the class MUST be on a non-existing place
							  printf "%s@@@@@%s@\n", File, FullClass >MEMBERFILE

							  # Add full class name to module_classes file
							  # but without the :public yyy part
							  # xxx::zzz : public yyy --> xxx::zzz
							  # xxx      : public yyy --> xxx
							  # xxx::zzz              --> xxx::zzz
							  gsub("::", "@@", FullClass)
	  						  gsub("[: \t].+", "", FullClass)	# cut after :|wspc
							  gsub("@@", "::", FullClass)
							  print "@"FullClass"@" >MODULECLASSFILE
							}
							Class=substr(prevName,2)	# cut off theType
	  						FullClass=getStack("C") Class
						  }
						  next
						}

	# Finally the non-conditional code which might contain the members
	{ if (index($0,"(")) {
		handleFunction()
	  }

	  if (length($0) == 0) {		# nothing left?
		next
	  }

	  # This must be a variable declaration
	  PresumedType=$0
	  gsub(" [a-zA-Z][^;]+;", "", PresumedType)	# cut off last word
	  NSVariable=resolveNameSpace(PresumedType)
	  printf "%s@%s@%s@%s@%s%s\n", File, NameSpace, FullClass, Mode, NSVariable, $0 >MEMBERFILE
	  nrMembers++
	}
	'
}

#
# addToMapFile memberfile [class]
#
# Scan the just created memberfile and construct the mapfile
# This routine is first called without the class parameter, in that case
# we must add all classes of the main headerfile. Then this function may
# be called several times to add a single class to the mapfile.
#
addToMapFile()
{
	if [ "$2" == "" ]; then
		# no class specification: everything in main headerfile
		# first line of preprocessed file contains name of this file
		grepmask=`tail -1 $1 | cut -d"@" -f1`
		grepmask="^${grepmask}"						# grep on filename
	else
		# grep @class@ or @class : public xxx@
		grepmask="@$2[ \t:publiclastru]*[a-zA-Z0-9_]*@"
	fi
	eval "grep '$grepmask' $1" | \

	awk -v TYPEDEFFILE=${TYPEDEFWORKFILE}	\
		-v GREPFILE=${GREPWORKFILE}			\
		-v MAPPEDFILE=${MAPPEDWORKFILE}		\
		-v MODULECLASSFILE=${MODCLASSWRKFILE}			\
		-v NEEDEDFILE=${NEEDEDWORKFILE}	'

	BEGIN {
		prevClass="NoSuchClass"
		prevBaseClass=""

		# This table is used for transforming C types to Postgres types.
		BasicType["short"]				= "SMALLINT"
		BasicType["ushort"] 			= "SMALLINT"
		BasicType["int"]				= "INTEGER"
		BasicType["uint"]				= "INTEGER"
		BasicType["long"]				= "BIGINT"
		BasicType["ulong"]				= "BIGINT"
		BasicType["longlong"]			= "BIGINT"
		BasicType["ulonglong"]			= "BIGINT"
		BasicType["double"]				= "DOUBLE PRECISION"
		BasicType["float"]				= "FLOAT"
		BasicType["bool"]				= "SMALLINT"
		BasicType["TIMESTAMP_STRUCT"]	= "TIMESTAMP"
		BasicType["string"]				= "TEXT"
		BasicType["blob"]				= "TEXT"
		BasicType["char["]				= "VARCHAR"
		BasicType["uchar["]				= "VARCHAR"
		BasicType["char"]				= "VARCHAR"
		BasicType["uchar"]				= "VARCHAR"
		BasicType["void"]				= "@@@???"
	}

	#
	# resolveVariableType C-type
	#
	# Recursively tries to resolve the given C-type to a basictype
	# known by Postgres.
	#
	# NOTE: C-type may be of the form scope::type.
	#
	function resolveVariableType(Ctype) {
		gsub("[a-zA-Z0-9_]*::", "", Ctype);
		if (Ctype in BasicType) {			# basic type?
			return BasicType[Ctype]			# life is easy sometimes.
		}

		VarType=resolveTypedef(Ctype)		# try resolving it as a typedef
		if (substr(VarType,1,3) == "@@@") {	# unresolvable?
			return VarType					# return failure
		}

		return resolveVariableType(VarType);	# resolve the typedef result
	}

	#
	# resolveTypedef someType
	#
	# Searches the given variable_type in the typedefs-file created in
	# the analyze-phase. When found it returns the original type.
	# Otherwise @@@ is returned.
	#
	function resolveTypedef(varType,   theTypedef) {
		# note: the get a result from a system command into awk we must
		# pass it to a file and then read the file again.
		Command=sprintf("grep %c %s;%c %s >%s 2>/dev/null", 39, varType, 39, TYPEDEFFILE, GREPFILE);
		system(Command)							# execute grep

		theTypedef=""							# reset result
		getline theTypedef < GREPFILE			# get grep result
		close(GREPFILE)						# not needed anymore
		if (length(theTypedef) <= 0) {			# not found?
			return "@@@"						# return failure
		}

		gsub("^typedef ", "", theTypedef)		# cut off keyword typedef
		gsub(" [a-zA-Z][^;]+;", "", theTypedef)	# cut off last word
		gsub("{[^}]*}", "", theTypedef)			# cut struct definition

		return theTypedef
	}

	#
	# resolveMemberInfo infotype definition_string
	#
	# A C(++) like variable declaration can be passed to this routine
	# The routine analyzes and reformats the declaration and returns
	# the required information (infotype)
	# infotype: MT  Member Type
	#			MN	Member Name
	#			CT	Column Type (in database)
	#			CN	Column Name (in database)
	#
	# Note: Since this routine makes up the database properties this is
	# 		where the link between the C-code and the database is defined.
	#
	function resolveMemberInfo(infoType, argString, theClass) {
		# infoType: MT / MN / CT / CN
		gsub("[ \t][ \t]+", " ", argString)	# skip double spaces
		split(argString, element, " ")
		if (element[1] == "unsigned") {
			# unsigned xxx --> uxxx
			MemberType="u" element[2]
			MemberName=element[3]
			ArgNr=3
		}
		else {
			MemberType=element[1]
			MemberName=element[2]
			ArgNr=2
		}
		if (MemberName == "long") {		# (unsigned) long long ?
			MemberType=MemberType MemberName
			MemberName=element[++ArgNr]
		}
		
		# When the member is a pointer or a reference append
		# a * to the MemberType and remove to original & or *
		# NOTE: it is trivial whether is was a * or a & we dont
		# handle both types in this version

		# * or & attached to membername? move it to membertype
		if ((MemberName == "&") || (MemberName == "*")) {
			MemberType=MemberType"*"
			MemberName=element[++ArgNr]
		}
		gsub("&","*",MemberType)				# treat & as *
		gsub("[ \t]*;","",MemberName)			# strip off line termination

		# move pointer and references to the MemberType
		if (index(MemberName,"*") || index(MemberName,"&")) {
			gsub("*","",MemberName)
			gsub("&","",MemberName)
			MemberType=MemberType"*"
		}
		PlainMemberType=MemberType
		gsub("*","",PlainMemberType)		# MemberType without '*'

		if (infoType == "MN") { return MemberName }
		if (infoType == "MT") { return MemberType }

		# Convert the member-characteristics to database characteristics.

		# When the variable is an array, find out its length
		ArrSize=1
		ArrOpen=index($0,"[")
		ArrClose=index($0,"]")
		if (ArrOpen && ArrClose) {
			ArrSize=0+substr($0,ArrOpen+1, ArrClose-ArrOpen)
			pos=index(MemberName,"[")		# attached to membername?
			if (pos) {
				MemberName=substr(MemberName,1,pos-1)
			}
		}

		# Construct the database equivalents
		# Note: in the construction class A{ class B {...} }
		#	we must resolve A::B instead of B.
		ColumnType=resolveVariableType(PlainMemberType)	# First try B
		if (substr(ColumnType,1,3) != "@@@") {			# familiar type?
			ColumnName=toupper(MemberName)
			gsub("^ITS", "", ColumnName)				# strip leading "ITS"
			if (ColumnType == "VARCHAR") {
				ColumnType=ColumnType "(" ArrSize ")"
			}
		}
		else {											# unknown type
			# Now try to find A::B in the module-classes workfile
			Command=sprintf("grep %c@%s::%s@%c %s >%s 2>/dev/null", 39, theClass, PlainMemberType, 39, MODULECLASSFILE, GREPFILE);
			result=system(Command)						# execute grep
			if (result == "0") {
				ColumnType=theClass"::"PlainMemberType
			} 
			else {
				ColumnType="@@@"PlainMemberType
			}
			ColumnName="Class"
		}
		if (infoType == "CN") 
			return ColumnName
		else
			return ColumnType
	}

	#
	# makeSymbolicName membername
	#
	# Constructs some symbolicname for the given member
	# 'its' is stripped of and the first letter is forced to lowercase
	function makeSymbolicName(theMember) {
		gsub("^its", "", theMember)
		SymName=tolower(substr(theMember,1,1)) substr(theMember,2)
		return SymName
	}

	#
	# addBaseClass classname
	#
	# Adds the given class as base class to the map file.
	function addBaseClass(baseClass) {
		if (length(baseClass) <= 0) {
			return;
		}
		MemberName="BC" baseClass
		ColumnName="BaseClass"
		printf "%-16s %-16s %-14s %-16s %s\n", baseClass, MemberName, baseClass, ColumnName, baseClass
	}

	# MAIN awk loop
	{ 
		split($0, field, "@")
		nrParts=split(field[1],pathParts, "/")	# pP[nP]=basename(filename)
		gsub("\"", "", pathParts[nrParts])		# remove double quote

		Class=field[3]							# xxx or xxx : public yyy
		BaseClass=""
		if (index(Class,":")>0) {				# is class derived from other?
			gsub("[ \t]*:[ \t]*public", "", Class)	# --> xxx yyy
			split(Class, part, " ")
			Class=part[1]						# xxx
			BaseClass=part[2]					# yyy
		}
		if (Class != prevClass) {				# start of a new class?
			addBaseClass(prevBaseClass);		# class last class
			prevClass=""
			prevBaseClass=""

			if (Class == "") {					# EndOfClass marker?
				next
			}

			printf "\n"
			printf "Class      %s\n", Class
			printf "Table      %s\n", Class
			printf "File       %s\n", pathParts[nrParts]
			printf "#C-TYPE          MEMBER           SYMB.NAME      COLUMN           DB.TYPE\n"
			printf "#-------------------------------------------------------------------------------\n"
			prevClass=Class
			prevBaseClass=BaseClass

			# remember this class is in the map file
			print Class >>MAPPEDFILE

			if (BaseClass != "") {
				print BaseClass >>NEEDEDFILE		# add this class later
			}
		}

		MemberType=resolveMemberInfo("MT", field[5], Class)
		MemberName=resolveMemberInfo("MN", field[5], Class)
		ColumnType=resolveMemberInfo("CT", field[5], Class)
		ColumnName=resolveMemberInfo("CN", field[5], Class)
		SymbolicName=makeSymbolicName(MemberName)

		printf "%-16s %-16s %-14s %-16s %s\n", MemberType, MemberName, SymbolicName, ColumnName, ColumnType
		if (substr(ColumnType,1,3) == "@@@") {
			print substr(ColumnType,4) >>NEEDEDFILE
		}
	} '
}

#
# constructFunfile usedClassesFile
#
constructFunfile()
{
	grep -v "#" $1 | sort | uniq | awk '{
		printf "%-15s	I   insert%s\n", $1, $1
		printf "%-15s	U   update%s	WHERE @@@\n", $1, $1
		printf "%-15s	D   delete%s	WHERE @@@\n", $1, $1
		printf "%-15s	S   search%s	WHERE @@@\n", $1, $1
	}'
}

#-------------------- General subroutines --------------------
#
# Fail msg
#
# Shows the message on stdout and exits
Fail()
{
	echo "FAIL: $*"
	cleanupWorkFiles
	exit 1
}

#
# ControlledFileDeletion FileName
#
# Asks the user if the file may be removed. If not the program is terminated.
# When the FORCE option is on the file is removed without interference of the user.
ControlledFileDeletion()
{
	FileName=$1

	# Does file exist
	if [ ! -f "${FileName}" ]; then
		return
	fi

	# If FORCE option is off let the user decide.
	if [ "${FORCE}" != "true" ]; then
		ready=false
		while [ "$ready" == "false" ]
		do
			echo -n "Targetfile ${FileName} already exists, remove it (y/n)? "
			read answer
			case $answer in
			y|Y|yes|Yes)	ready=true
							;;
			n|N|no|No)		Fail "Target ${FileName}.i may not be overwritten"
							;;
			esac
		done
	fi
	echo "Removing file ${FileName}"
	rm -f ${FileName}
}

#
# SyntaxError msg
#
# Shows the right syntax on stdout with the given message.
# Exists afterwards.
SyntaxError()
{
	Msg=$1

	[ -z "${Msg}" ] || echo "ERROR: ${Msg}"
	echo "Syntax: $(basename $0) [-d destdir] [-t target] [-f] precompiled_headerfile(s)"
	echo "    destdir   Relative directory where the map and functionfile are placed"
	echo "    target    First part of the name of the map and functionfile"
	echo "    -f        Force removal of target(s) if it already exists"
	echo ""
	exit 1
}

#------------------------------- MAIN program --------------------------------
#
# Syntax: genDBbase [-d destdir] [-t target] [-f] precompiled_headerfiles
#

# Check invocation syntax
#
DESTDIR="."
FORCE=false
TARGET=""
COMMAND=$(basename $0)
eval set argv=`getopt "d:t:f" $*`			# reformat arguments
shift
while [ "$1" != "--" ]
do
	case "$1" in
		-d) DESTDIR=$2
			[ -d ${DESTDIR} ] ||
				SyntaxError "Destination directory >${DESTDIR}< does not exist"
			shift 2
			COMMAND="${COMMAND} -d ${DESTDIR}"
			;;
		-t)	TARGET=$2
			shift 2
			COMMAND="${COMMAND} -t ${TARGET}"
			;;
		-f)	FORCE=true
			shift 1
			COMMAND="${COMMAND} -f"
			;;
	esac
done
shift									# remove --

# Need at least one precompfile
[ $# -ge 1 ] || SyntaxError "Need at least one precompiled headerfile."

# All precompfiles must exist
for file in $*
do
	[ -s ${file} ] || SyntaxError "File ${file} doesn't exist"
done

# When target is empty use name of 1st precompfile as a base.
[ -z "${TARGET}" ] && TARGET=`echo $1 | cut -d"." -f1`

# construct name of targetfiles
MAPFILE=${DESTDIR}/${TARGET}.plmap.proto		# resultfile
FUNFILE=${DESTDIR}/${TARGET}.plfun.proto		# resultfile

# If targets exist, let the user or the FORCE option decide what to do
ControlledFileDeletion ${MAPFILE}
ControlledFileDeletion ${FUNFILE}

# All arguments seem ok, continue porcessing

# Initialize some variables
HEADERFILES="$*"

# An awfull lot of temp files but this makes life much easier
ADDINGWORKFILE=/tmp/adding.LCS.$$			# subclasses curr. adding
FUNCTIONWORKFILE=/tmp/functions.LCS.$$		# functions in the inputfile
GREPWORKFILE=/tmp/grep.LCS.$$				# tmp grep result
MAPPEDWORKFILE=/tmp/mapped.LCS.$$			# classes already mapped
MEMBERWORKFILE=/tmp/members.LCS.$$			# datamembers in the inputfile
MISSINGWORKFILE=/tmp/missing.LCS.$$			# classes not in the inputfile
NEEDEDWORKFILE=/tmp/needed.LCS.$$			# subclasses to add later
TYPEDEFWORKFILE=/tmp/typedefs.LCS.$$		# typedefs in the inputfile
USINGWORKFILE=/tmp/using.LCS.$$				# using stmts in the inputfile
MODCLASSWRKFILE=/tmp/classes.LCS.$$			# all classes define in the .i file

# make sure there are no old workfiles left
cleanupWorkFiles

# Set trap handler before we create anything
trap "cleanupWorkFiles ; exit" 1 2 3 6 9 13 15

# Write headers to the result files.
initResultFile 	> ${MAPFILE}
initResultFile 	> ${FUNFILE}

echo "Creating file ${MAPFILE} ..."
# Scan the precompiled_headerfiles and substract the class hierarchy
for file in ${HEADERFILES}
do
	# cleanup intermediate results
	rm -f ${TYPEDEFWORKFILE} ${FUNCTIONWORKFILE} ${MEMBERWORKFILE} \
		  ${NEEDEDWORKFILE}

	# First stage: break down precompiled headerfile into:
	#		typedefs.LCS.$$
	#		functions.LCS.$$
	#		members.LCS.$$
	echo -n "${file}: analysing"
	cleanlist $file | analyseInfoFile

	# Second stage: Construct mapfile from all classes in main headerfile
	#	This stage might produce a needed.LCS.$$ file.
	echo -n ", adding main classes"
	addToMapFile ${MEMBERWORKFILE} >>${MAPFILE}

	# Third stage (repeating): Add the base- and embedded- classes
	echo -n ", adding base classes"
	complete=false
	while (! $complete)
	do
		if [ ! -f "${NEEDEDWORKFILE}" ]; then	# nothing needed anymore?
			complete=true						# then we are done
			break
		fi

		sort ${NEEDEDWORKFILE} | uniq >${ADDINGWORKFILE} 	# skip doubles
		rm -f ${NEEDEDWORKFILE}				# will be recreated in next loop
		cat ${ADDINGWORKFILE} | while read classname
		do
			# make sure this class is not already in the map file
			grep $classname ${MAPPEDWORKFILE} >/dev/null 2>&1
			if [ $? -ne 0 ]; then			# not found?
				addToMapFile ${MEMBERWORKFILE} $classname >>${MAPFILE}
				# class succesfully added?
				grep $classname ${MAPPEDWORKFILE} >/dev/null 2>&1
				if [ $? -ne 0 ]; then		# still not found?
					echo $classname >>${MISSINGWORKFILE}
				fi
			fi
		done
		rm ${ADDINGWORKFILE}
	done
	echo ", ready"
done

# The embedded and base classes are still in the map file as @@@xxx
# Remove the @@@ from the classes that were resolved.
cat ${MAPPEDWORKFILE} | while read class
do
	cat ${MAPFILE} | sed "s/@@@${class}$/${class}/" >> ${MAPFILE}tmp
	mv ${MAPFILE}tmp ${MAPFILE}
done

# Almost done, construct the fun file for the implemented classes
echo "Creating file ${FUNFILE}"
constructFunfile ${MAPPEDWORKFILE} >>${FUNFILE}

# Notify user for missing sub classes
if [ -f ${MISSINGWORKFILE} ]; then
	echo "WARNING: The following types or classes could not be resolved:"
	cat ${MISSINGWORKFILE}
fi

# Finally cleanup our mess.
cleanupWorkFiles

