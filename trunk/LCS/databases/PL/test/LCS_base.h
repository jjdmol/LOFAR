//# This file was generated by genDTL v1.0 on Thu Oct 16 11:14:46 CEST 2003
//# with the command: genDTL myClass.map.proto myClass.fun.proto P 
//# from the directory: /export/home/loose/LOFAR/LCS/PL/test
//#
//# EDITING THIS FILE MANUALLY IS AT YOUR OWN RISK
//# IT MIGHT BE OVERWRITTEN BY THE NEXT MAKE OF YOUR PROJECT
//#
//# only include this file once
#ifndef PL_LCS_BASE_H
#define PL_LCS_BASE_H

#include <PL/DTLHelperClasses.h>
#include <PL/ObjectId.h>
#include <PL/PersistentObject.h>
#include <dtl/DTL.h>

namespace LOFAR
{
  namespace PL
  {

    template<>
    struct DBRep<ObjectId> {
      ObjectId::oid_t itsOid;
    };

    template<>
    struct DBRep<PersistentObject::MetaData> {
      ObjectId::oid_t itsOid;
      ObjectId::oid_t itsOwner;
      unsigned int    itsVersionNr;
    };

    // --------------- generic DTL structures -----------------------
    // The Persistency Layer uses an ObjectID to unique identify
    // an object. This field can be used in queries to update
    // or delete an object. Since the ObjectID is the same for
    // every type of object some generic DTL structs can be defined.

    template<>
    void BCA<ObjectId>::operator()(dtl::BoundIOs& cols, DataObj& rowbuf)
    {
      cols["ObjId"] == rowbuf.itsOid;
    }

    template<>
    void BPA<ObjectId>::operator()(dtl::BoundIOs& pos, ParamObj& param)
    {
      pos[0] == param.itsOid;
    }
    
    template<>
    void 
    BCA<PersistentObject::MetaData>::operator()(dtl::BoundIOs& cols, 
						DataObj& rowbuf)
    {
	cols["ObjId"] == rowbuf.itsOid;
	cols["Owner"] == rowbuf.itsOwner;
	cols["VersionNr"] == rowbuf.itsVersionNr;
    }
      
  } // namespace PL
  
} // namespace LOFAR

#endif
