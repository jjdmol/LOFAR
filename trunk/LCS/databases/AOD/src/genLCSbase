#!/usr/bin/ksh
#
# genLCSbase
#
# Generates a mapfile and a functionfile for genLCScode.
# The generated files must be manually adjusted before they
# can be used by genLCScode.
#
# Syntax: genLCSbase modulename headerfiles
#
VERSION="v1.0"

#---------------------------- Global routines ---------------------------------
#
# InitTmpfile
#
# Writes an informational header to the tempfile in case the file was not
# removed by this script.
#
InitTmpfile()
{
	echo "#This temporarely file was generated by genDTL"
	echo "#It should have been cleaned up by genDTL, please remove it"
	echo "#ClassName:TableName:Ctype:MemberName:ColumnName:SubclassName:DBtype"
}

#
# InitSrcfile
#
# Adds an informational header to the C++ source- of headerfile.
#
InitSrcfile()
{
	echo -n "# This file was generated by genLCSbase ${VERSION} on " ; date
	echo "# with the command: genLCSbase ${MODULE} <headerfiles>"
	echo -n "# from the directory: " ; pwd
	echo "#"
	echo "# PLEASE COMPLETE THIS FILE AND REMOVE THE .proto EXTENSION"
	echo "# IT MIGHT BE OVERWRITTEN THE NEXT TIME YOU RUN genLCSbase"
	echo "#"
}

#
# ConvertToMapfile filename
#
# Removes all (partial) comment lines from the file
#
ConvertToMapfile()
{
	cat $1 | awk '{ 				# first remove all commentparts
		CommentPos=index($0,"//")
		if (CommentPos==0)
			print $0
		else
			print substr($0,1,CommentPos-1)
	}' | sed "s/^[ 	]//g" | \
	# process the remaining lines
	awk -v TMPFILE="$TMPFILE" ' 	
	BEGIN { 
		NestedLevel=0
		BasicType["short"]	= "SMALLINT"
		BasicType["ushort"] = "SMALLINT"
		BasicType["int"]	= "INTEGER"
		BasicType["uint"]	= "INTEGER"
		BasicType["long"]	= "BIGINT"
		BasicType["ulong"]	= "BIGINT"
		BasicType["double"]	= "DOUBLE PRECISION"
		BasicType["float"]	= "FLOAT"
		BasicType["bool"]	= "SMALLINT"
		BasicType["date"]	= "TIMESTAMP"
		BasicType["string"]	= "TEXT"
		BasicType["char"]	= "TEXT"
		BasicType["blob"]	= "TEXT"
		BasicType["uchar"]	= "TEXT"
		BasicType["char"]	= "TEXT"
		BasicType["void"]	= "???"
	}
	{ 
		# skip empty and comment lines
		if ((length($0) == 0) || (substr($0,1,1) == "#")) {
			next
		}

		# determine nesting level 'after' this line
		NestedLevel+=(split($0, dummy, "{")-1)
		NestedLevel-=(split($0, dummy, "}")-1)

		# When line contains "template<...>", cut it off
		if (index($0,"template")) {
			templateEnd=index($0, ">")+1
			$0=substr($0,templateEnd)
		}

		# begin of a class or struct?
		if (index($0,"class") || index($0,"struct")) {
			# assume a forward declaration when line ends in a semi-colon
			if (index($0,";")) {
				next
			}
			ClassName=$2
			NestedBrackets=0
			printf "\n"
			printf "Class		%s\n",	ClassName
			printf "Table		%s\n",	ClassName
			printf "#\n"
			printf "#TYPE           MEMBER          COLUMN          TYPE\n"
			printf "#--------------------------------------------------------\n"
			next
		}

		# when outside any struct or class, just continue
		if (NestedLevel != 1) {
			next
		}

		# skip several keywords
		if (index($0,"public:") 	|| 
			index($0,"protected:")	|| 
			index($0,"private:")	||
			index($0,"friend")) {
			next
		}

		# Function declaration may contain "(" and ")" on one line but
		# the arguments may also be on several lines.

		# determine bracket nesting 'after' this line
		NestedBrackets+=(split($0, dummy, "(")-1)
		NestedBrackets-=(split($0, dummy, ")")-1)

		# Inside some brackets or brackets on this line? its a function
		if (index($0,"(") || index($0,")") || (NestedBrackets>0)) {
			next
		}

		# A brace on the line? ignore this line its not a variable.
		if (index($0,"{") || index($0,"}")) {
			next
		}

		# seems we have found a variable declaration
		# change the 'unsigned' word into 'u'xxxx
		if ($1 == "unsigned") {
			MemberType="u"$2
			MemberName=$3
		}
		else {
			MemberType=$1
			MemberName=$2
		}
		gsub(";","",MemberName)			# strip off line termination

		# move pointer and references to the MemberType
		if (index(MemberName,"*") || index(MemberName,"&")) {
			gsub("*","",MemberName)
			gsub("&","",MemberName)
			MemberType=MemberType"*"
		}

		# Construct the database equivalents
		PlainMemberType=MemberType
		gsub("*","",PlainMemberType)		# MemberType without '*'
		if (PlainMemberType in BasicType) {
			ColumnType=BasicType[PlainMemberType]
			ColumnName=toupper(MemberName)
		}
		else {
			ColumnType=PlainMemberType
			ColumnName="Class"
		}

		printf "%-15s %-15s %-15s %s\n", MemberType, MemberName, ColumnName, ColumnType

		printf "%s\n", ClassName >>TMPFILE
	}'
}

#
# ConstructFunfile usedClassesFile
#
ConstructFunfile()
{
	grep -v "#" $1 | sort | uniq | awk '{
		printf "%-15s		I\n", $1
		printf "%-15s		U\n", $1
		printf "%-15s		D\n", $1
		printf "%-15s		S    WHERE ???\n", $1
	}'
}

#------------------------------- MAIN program ---------------------------------
#
# Check invocation syntax: genLCSbase module headerfiles
#
case $# in
	0)	echo "Syntax: $0 module headerfiles"
		exit 0
		;;
	*)	MODULE=$1
		shift
		HEADERFILES="$*"
		;;
esac

# Initialize some variables
#
TMPFILE=map.genLCSbase.$$
MAPFILE=${MODULE}.map.proto
FUNFILE=${MODULE}.fun.proto

# convert the human readable format of the mapfile into something
# more convenient for shell-programming
InitTmpfile		> ${TMPFILE}
InitSrcfile  	> ${MAPFILE}
InitSrcfile  	> ${FUNFILE}

# Scan the functionfile to determine what code should be generated
#
for file in ${HEADERFILES}
do
	ConvertToMapfile $file >>${MAPFILE}
done

# TMPFILE contains the used classes now
ConstructFunfile ${TMPFILE} >>${FUNFILE}
	
rm -f ${TMPFILE}
