#!/usr/bin/ksh
#
# genLCSbase : generates a mapfile and a functionfile for genLCScode.
#
# Copyright (C) 2003
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# Syntax: genLCSbase modulename headerfiles
#
# The generated files must be manually adjusted before they
# can be used by genLCScode.
#
# $:Id $
#
VERSION="v1.0"

#---------------------------- Global routines ---------------------------------
#
# InitTmpfile
#
# Writes an informational header to the tempfile in case the file was not
# removed by this script and to simplify debugging.
#
InitTmpfile()
{
	echo "#This temporarely file was generated by genDTL"
	echo "#It should have been cleaned up by genDTL, please remove it"
	echo "#ClassName:TableName:Ctype:MemberName:ColumnName:SubclassName:DBtype"
}

#
# InitSrcfile
#
# Adds an informational header to the result files
#
InitSrcfile()
{
	echo -n "# This file was generated by genLCSbase ${VERSION} on " ; date
	echo "# with the command: genLCSbase ${MODULE} <headerfiles>"
	echo -n "# from the directory: " ; pwd
	echo "#"
	echo "# PLEASE COMPLETE THIS FILE AND REMOVE THE .proto EXTENSION"
	echo "# IT MIGHT BE OVERWRITTEN THE NEXT TIME YOU RUN genLCSbase"
	echo "#"
}

#
# StripComments filename
#
StripComments()
{
	cat $1 | awk '{ 				# first remove all commentparts
		CommentPos=index($0,"//")
		if (CommentPos==0)
			print $0
		else
			print substr($0,1,CommentPos-1)
	}' | sed "s/^[ 	]//g" 			# strip leading spaces
}

#
# StripNameSpaces
#
# Leaves out the lines which belong to the namespace begin and end
#
StripNameSpaces()
{
	awk ' 	
	BEGIN { 
		BraceLevel=0		# Level of nested braces
		NSStackSize=0		# Nr of namespaces on stack
	}
	{ 
		# skip empty and comment lines
		if ((length($0) == 0) || (substr($0,1,1) == "#")) {
			next
		}

		# When a begin of a namespace is found add the current BraceLevel
		# to the namespace stack.
		while (index($0,"namespace")) {
			NameSpaceStack[NSStackSize++]=BraceLevel
			while (index ($0, "{") == 0) {
				getline
			}
			getline
		}

		# determine nesting level 'after' this line
		BraceLevel+=(split($0, dummy, "{")-1)
		BraceLevel-=(split($0, dummy, "}")-1)

		# when deeper nested than inner namespace, print the line
		if (BraceLevel > NameSpaceStack[NSStackSize-1]) {
			print $0
		}
		else {
			# Level of inner namespace reached, pop namespace of stack
			while (BraceLevel <= NameSpaceStack[NSStackSize-1]) {
				BraceLevel++;
				NSStackSize--;
			}
		}
	}'
}

#
# ConvertToMapfile filename
#
# Scans the header (and C++?) files to substract the class definitions
#
ConvertToMapfile()
{
	awk -v TMPFILE="$TMPFILE" ' 	
	BEGIN { 
		# By counting the '{' and '}' we know how deep we are nested. We are
		# only interrested in level 1 information (declarations in a class).
		NestedLevel=0

		# This table is used for transforming C types to Postgres types.
		BasicType["short"]				= "SMALLINT"
		BasicType["ushort"] 			= "SMALLINT"
		BasicType["int"]				= "INTEGER"
		BasicType["uint"]				= "INTEGER"
		BasicType["long"]				= "BIGINT"
		BasicType["ulong"]				= "BIGINT"
		BasicType["double"]				= "DOUBLE PRECISION"
		BasicType["float"]				= "FLOAT"
		BasicType["bool"]				= "SMALLINT"
		BasicType["TIMESTAMP_STRUCT"]	= "TIMESTAMP"
		BasicType["string"]				= "TEXT"
		BasicType["blob"]				= "TEXT"
		BasicType["char["]				= "VARCHAR"
		BasicType["uchar["]				= "VARCHAR"
		BasicType["char"]				= "VARCHAR"
		BasicType["uchar"]				= "VARCHAR"
		BasicType["void"]				= "@@@???"
	}
	{ 
		# skip empty and comment lines
		if ((length($0) == 0) || (substr($0,1,1) == "#")) {
			next
		}

		# determine nesting level 'after' this line
		NestedLevel+=(split($0, dummy, "{")-1)
		NestedLevel-=(split($0, dummy, "}")-1)

		# When line contains "template<...>", cut it off
		if (index($0,"template")) {
			templateEnd=index($0, ">")+1
			$0=substr($0,templateEnd)
		}

		# begin of a class or struct?
		if (index($0,"class") || index($0,"struct")) {
			# assume a forward declaration when line ends in a semi-colon
			if (index($0,";")) {
				next
			}

			# It looks like a real class
			ClassName=$2
			NestedBrackets=0
			printf "\n"
			printf "Class		%s\n",	ClassName
			printf "Table		%s\n",	ClassName
			printf "#\n"
			printf "#TYPE              MEMBER             COLUMN             TYPE\n"
			printf "#--------------------------------------------------------------------\n"
			next
		}

		# when outside any struct or class, just continue
		if (NestedLevel != 1) {
			next
		}

		# skip several keywords
		if (index($0,"public:") 	|| 
			index($0,"protected:")	|| 
			index($0,"private:")	||
			index($0,"friend")) {
			next
		}

		# Function declaration may contain "(" and ")" on one line but
		# the arguments may also be on several lines.

		# determine bracket nesting 'after' this line
		NestedBrackets+=(split($0, dummy, "(")-1)
		NestedBrackets-=(split($0, dummy, ")")-1)

		# Inside some brackets or brackets on this line? its a function
		if (index($0,"(") || index($0,")") || (NestedBrackets>0)) {
			next
		}

		# A brace on the line? ignore this line its prob. not a variable.
		if (index($0,"{") || index($0,"}")) {
			next
		}

		# Seems we have found a variable declaration
		# Change the 'unsigned' word into 'u'xxxx
		if ($1 == "unsigned") {
			MemberType="u"$2
			MemberName=$3
			ArgNr=3
		}
		else {							# no keyword 'unsigned'
			MemberType=$1
			MemberName=$2
			ArgNr=2
		}
		if (MemberName == "long") {		# (unsigned) long long ?
			MemberType=MemberType MemberName
			MemberName=$(++ArgNr)
		}

		# When the member is a pointer or a reference append
		# a * to the MemberType and remove to original & or *
		# NOTE: it is trivial whether is was a * or a & we dont
		# handle both types in this version

		# * or & attached to membername? move it to membertype
		if ((MemberName == "&") || (MemberName == "*")) {
			MemberType=MemberType"*"
			MemberName=$(++ArgNr)
		}
		gsub("&","*",MemberType)		# treat & as *
		gsub(";","",MemberName)			# strip off line termination

		# move pointer and references to the MemberType
		if (index(MemberName,"*") || index(MemberName,"&")) {
			gsub("*","",MemberName)
			gsub("&","",MemberName)
			MemberType=MemberType"*"
		}

		# When the variable is an array, find out its length
		ArrSize=1
		ArrOpen=index($0,"[")
		ArrClose=index($0,"]")
		if (ArrOpen && ArrClose) {
			ArrSize=0+substr($0,ArrOpen+1, ArrClose-ArrOpen)
			pos=index(MemberName,"[")		# attached to membername?
			if (pos) {
				MemberName=substr(MemberName,1,pos-1)
			}
		}

		# Construct the database equivalents
		PlainMemberType=MemberType
		gsub("*","",PlainMemberType)		# MemberType without '*'
		if (PlainMemberType in BasicType) {
			ColumnType=BasicType[PlainMemberType]
			ColumnName=toupper(MemberName)
			if (ColumnType == "VARCHAR") {
				ColumnType=ColumnType "(" ArrSize ")"
			}
		}
		else {
			ColumnType="@@@"PlainMemberType
			ColumnName="Class"
		}

		printf "%-18s %-18s %-18s %s\n", MemberType, MemberName, ColumnName, ColumnType

		printf "%s\n", ClassName >>TMPFILE
	}'
}

#
# ConstructFunfile usedClassesFile
#
ConstructFunfile()
{
	grep -v "#" $1 | sort | uniq | awk '{
		printf "%-15s		I\n", $1
		printf "%-15s		U\n", $1
		printf "%-15s		D\n", $1
		printf "%-15s		S    WHERE ???\n", $1
	}'
}

#------------------------------- MAIN program ---------------------------------
#
# Check invocation syntax: genLCSbase module headerfiles
#
case $# in
	0)	echo "Syntax: $0 module headerfiles"
		exit 0
		;;
	*)	MODULE=$1
		shift
		HEADERFILES="$*"
		;;
esac

# Initialize some variables
#
TMPFILE=map.genLCSbase.$$
MAPFILE=${MODULE}.map.proto
FUNFILE=${MODULE}.fun.proto

# Write headers to the result files.
InitTmpfile		> ${TMPFILE}
InitSrcfile  	> ${MAPFILE}
InitSrcfile  	> ${FUNFILE}

# Scan the headerfiles and substract the class hierarchy
for file in ${HEADERFILES}
do
	StripComments $file | StripNameSpaces | ConvertToMapfile >>${MAPFILE}
done

# TMPFILE contains the used classes now
ConstructFunfile ${TMPFILE} >>${FUNFILE}
	
rm -f ${TMPFILE}
