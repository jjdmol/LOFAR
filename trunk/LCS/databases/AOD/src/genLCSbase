#!/usr/bin/ksh
#
# genLCSbase : generates a mapfile and a functionfile for genLCScode.
#
# Copyright (C) 2003
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# Syntax: genLCSbase modulename headerfiles
#
# The generated files must be manually adjusted before they
# can be used by genLCScode.
#
# $Id$
#
VERSION="v1.1"

#---------------------------- Global routines ---------------------------------
#
# InitResultFile
#
# Adds an informational header to the result files
#
InitResultFile()
{
	echo -n "# This file was generated by genLCSbase ${VERSION} on " ; date
	echo "# with the command: genLCSbase ${MODULE} <headerfiles>"
	echo -n "# from the directory: " ; pwd
	echo "#"
	echo "# PLEASE COMPLETE THIS FILE AND REMOVE THE .proto EXTENSION"
	echo "# IT MIGHT BE OVERWRITTEN THE NEXT TIME YOU RUN genLCSbase"
	echo "#"
}

#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
#
cleanlist()
{
	cat $* |  \
		# replace {} by ; , place { or } on new lines and force \n after ;
		sed "s/{[ \t]*}/; /g ; s/[{}]/\n&\n/g ; s/;[ \t]/;\n/g" | \
		# cut everthing after hashes
		#		cut -d"#" -f1 | \
		awk '{ if (NF > 0) print $0 }'
}

#
# analyseInfoFile file
#
# Breaks down the info file (=precompiled headerfile) into the
# functions, typedefs and variables.
# The results are written to several temp files.
#
analyseInfoFile()
{
	awk '
	function skipTillNext(delimiter) {
		while (match ($0, delimiter) == 0) {	# search delimiter
			getline
		}
		$0=substr($0, RSTART+RLENGTH)
		gsub("^[ 	]*", "")					# skip leading spaces
	}

	function getTillNext(delimiter,     result) {
		result=""
		while (match ($0, delimiter) == 0) {	# search delimiter
			result = sprintf ("%s%s", result, $0)
			getline
		}
		result = sprintf ("%s%s", result, substr($0,1,RSTART+RLENGTH))
		$0=substr($0, RSTART+RLENGTH)
		gsub("^[ 	]*", "")					# skip leading spaces
		gsub("[ \t][ \t]+", " ", result)		# skip double whitespace
		return result
	}

	function handleTypedef(delimiter,    theTD) {
		theTD=getTillNext(";");
		if (index(theTD, "{") != 0) {
			while (split(theTD, dummy, "{") > split(theTD, dummy, "}")) {
				theTD=theTD getTillNext("}") getTillNext(";");
			}
		}
		gsub ("[ \t]+", " ", theTD)				# remove double spaces
		print theTD >> "typedefs.LCS"
	}

	function handleFunction(delimiter,    theFunc) {
		theFunct=getTillNext(";|{");
		if (index(theFunct, "{") != 0) {
			while (split(theFunct, dummy, "{") > split(theFunct, dummy, "}")) {
				theFunct=theFunct getTillNext("}");
			}
		}
		print theFunct >> "functions.LCS"
	}

	function pushOnStack(theType, theName) {
		nameStack[stackSize]=theName
		typeStack[stackSize]=theType
		stackSize++
	}

	function pullFromStack(   topOfStack) {
		stackSize--
		topOfStack=typeStack[stackSize] nameStack[stackSize]
		return topOfStack
	}

	BEGIN {
		stackSize=1
	}

	/^[ 	]*/			{ gsub("^[ 	]*", "") }		# skip leading spaces
	/[ 	]*$/			{ gsub("^[ 	]*", "") }		# skip trailing spaces
	/^;/				{ next }					# remove loose ;
	/^#/				{ File=$3 ; next }
	/[ \t]*const[ \t]*/	{ gsub("[ \t]*const", "") }	# remove const
	/\[.*[a-zA-Z]+.*]/	{ bpos=index($0,"[")
						  epos=index($0,"]")
						  $0=substr($0,1,bpos) "@@@" substr($0,epos)
						}
	/^using /			{ next }					# skip using commands
	/^friend/			{ next }					# skip friend lines
	/^public:/			{ Mode="publ" ; gsub("public:[ \t]*"   ,"") }
	/^protected:/		{ Mode="prot" ; gsub("protected:[ \t]*","") }
	/^private:/			{ Mode="priv" ; gsub("private:[ \t]*"  ,"") }
	/^mutable/			{ gsub("mutable[ \t]*"  ,"") }
	/^__extension__/	{ gsub("__extension__[ \t]*"  ,"") }
	/^typedef/			{ handleTypedef(";|{") }
	/^template/			{ skipTillNext(">") }
	/^extern/			{ skipTillNext(";") }
	/^enum/				{ skipTillNext("}") }
	/^virtual/			{ handleFunction(";|{") }
	/^inline/			{ handleFunction(";|{") }
	/^[ \t]*\n/			{ next }
	/^class|^struct/	{ if (index($0,";")) {		# forward declaration
							next
						  }
						  else {
							pushOnStack("C", Class)
							Class=getTillNext("{")
							gsub("[ \t]*{", "", Class)
							gsub("^class ", "", Class)
							nrMembers=0
						  }
						}
	/^namespace/		{ pushOnStack("N", NameSpace)
						  if (length(NameSpace) == 0) {
							NameSpace=$2
						  }
						  else {
							NameSpace=NameSpace "::" $2
						  }
						  skipTillNext("{")
						}
	/}/					{ prevName = pullFromStack() 
						  if (substr(prevName,0,1) == "N") {
							NameSpace=substr(prevName,2)
						  }
						  else {
	  						if (nrMembers > 0) {
							  # end the class definition with a marker
							  # the contains the filename and the classname
							  # note: the class MUST be on a non-existing place
							  printf "%s@@@@@%s@\n", File , Class >"members.LCS"
							}
							Class=substr(prevName,2)
						  }
						  next
						}

	# Finally the non-conditional code
	{ if (index($0,"(")) {
		handleFunction(";|{")
	  }
	  if (length($0) == 0) {
		next
	  }
	  printf "%s@%s@%s@%s@%s\n", File, NameSpace, Class, Mode, $0 >"members.LCS"
	  nrMembers++
	}
	'
}

#
# buildMapFile memberfile [class]
#
# scan the just created memberfile and construct the mapfile
# expanding the classes in the core-headerfile
#
buildMapFile()
{
	if [ "$2" == "" ]; then
		# no class specification: everything in main headerfile
		# first line of preprocessed file contains name of this file
		grepmask=`tail -1 $1 | cut -d"@" -f1`
		grepmask="^${grepmask}"
	else
		grepmask="@$2[ \t:publiclastru]*[a-zA-Z0-9_]*@"
	fi
	eval "grep '$grepmask' $1" | awk '

	BEGIN {
		prevClass="NoSuchClass"
		prevBaseClass=""

		# This table is used for transforming C types to Postgres types.
		BasicType["short"]				= "SMALLINT"
		BasicType["ushort"] 			= "SMALLINT"
		BasicType["int"]				= "INTEGER"
		BasicType["uint"]				= "INTEGER"
		BasicType["long"]				= "BIGINT"
		BasicType["ulong"]				= "BIGINT"
		BasicType["double"]				= "DOUBLE PRECISION"
		BasicType["float"]				= "FLOAT"
		BasicType["bool"]				= "SMALLINT"
		BasicType["TIMESTAMP_STRUCT"]	= "TIMESTAMP"
		BasicType["string"]				= "TEXT"
		BasicType["blob"]				= "TEXT"
		BasicType["char["]				= "VARCHAR"
		BasicType["uchar["]				= "VARCHAR"
		BasicType["char"]				= "VARCHAR"
		BasicType["uchar"]				= "VARCHAR"
		BasicType["void"]				= "@@@???"
	}

	#
	# resolveVariableType C-type
	#
	# Recursively tries to resolve the given C-type to a basictype
	# known by Postgres.
	#
	function resolveVariableType(Ctype) {
		if (Ctype in BasicType) {			# basic type?
			return BasicType[Ctype]			# life is easy sometimes.
		}

		VarType=resolveTypedef(Ctype)		# try resolving it as a typedef
		if (substr(VarType,1,3) == "@@@") {	# unresolvable?
			return VarType					# return failure
		}

		return resolveVariableType(VarType);	# resolve the result
	}

	#
	# resolveTypedef someType
	#
	# Searches the given variable_type in the typedefs-file created in
	# the analyze-phase. When found it returns the original type.
	# Otherwise @@@ is returned.
	#
	function resolveTypedef(varType,   theTypedef) {
		# note: the get a result from a system command into awk we must
		# pass it to a file and then read the file again.
		Command=sprintf("grep %c %s;%c typedefs.LCS >tmp.LCS 2>/dev/null", 39, varType, 39);
		system(Command)							# execute grep

		theTypedef=""							# reset result
		getline theTypedef <"tmp.LCS"			# get grep result
		close("tmp.LCS")						# not needed anymore
		if (length(theTypedef) <= 0) {			# not found?
			return "@@@"						# return failure
		}

		gsub("^typedef ", "", theTypedef)		# cut off keyword typedef
		gsub(" [a-zA-Z][^;]+;", "", theTypedef)	# cut off last word
		gsub("{[^}]*}", "", theTypedef)			# cut struct definition

		return theTypedef
	}

	#
	# resolveMemberInfo infotype definition_string
	#
	# A C(++) like variable declaration can be passed to this routine
	# The routine analyzes and reformats the declaration and returns
	# the required information (infotype)
	# infotype: MT  Member Type
	#			MN	Member Name
	#			CT	Column Type (in database)
	#			CN	Column Name (in database)
	#
	# Note: Since this routine makes up the database properties this is
	# 		where the link between the C-code and the database is defined.
	#
	function resolveMemberInfo(infoType, argString) {
		# infoType: MT / MN / CT / CN
		gsub("[ \t][ \t]+", " ", argString)	# skip double spaces
		split(argString, element, " ")
		if (element[1] == "unsigned") {
			# unsigned xxx --> uxxx
			MemberType="u" element[2]
			MemberName=element[3]
			ArgNr=3
		}
		else {
			MemberType=element[1]
			MemberName=element[2]
			ArgNr=2
		}
		if (MemberName == "long") {		# (unsigned) long long ?
			MemberType=MemberType MemberName
			MemberName=element[++ArgNr]
		}
		
		# When the member is a pointer or a reference append
		# a * to the MemberType and remove to original & or *
		# NOTE: it is trivial whether is was a * or a & we dont
		# handle both types in this version

		# * or & attached to membername? move it to membertype
		if ((MemberName == "&") || (MemberName == "*")) {
			MemberType=MemberType"*"
			MemberName=element[++ArgNr]
		}
		gsub("&","*",MemberType)				# treat & as *
		gsub("[ \t]*;","",MemberName)			# strip off line termination

		# move pointer and references to the MemberType
		if (index(MemberName,"*") || index(MemberName,"&")) {
			gsub("*","",MemberName)
			gsub("&","",MemberName)
			MemberType=MemberType"*"
		}
		PlainMemberType=MemberType
		gsub("*","",PlainMemberType)		# MemberType without '*'

		if (infoType == "MN") { return MemberName }
		if (infoType == "MT") { return MemberType }

		# Convert the member-characteristics to database characteristics.

		# When the variable is an array, find out its length
		ArrSize=1
		ArrOpen=index($0,"[")
		ArrClose=index($0,"]")
		if (ArrOpen && ArrClose) {
			ArrSize=0+substr($0,ArrOpen+1, ArrClose-ArrOpen)
			pos=index(MemberName,"[")		# attached to membername?
			if (pos) {
				MemberName=substr(MemberName,1,pos-1)
			}
		}

		# Construct the database equivalents
		ColumnType=resolveVariableType(PlainMemberType)
		if (substr(ColumnType,1,3) != "@@@") {			# familiar type?
			ColumnName=toupper(MemberName)
			if (ColumnType == "VARCHAR") {
				ColumnType=ColumnType "(" ArrSize ")"
			}
		}
		else {											# unknown type
			ColumnType="@@@"PlainMemberType
			ColumnName="Class"
		}
		if (infoType == "CN") 
			return ColumnName
		else
			return ColumnType
	}

	function addBaseClass(baseClass) {
		if (length(baseClass) <= 0) {
			return;
		}
		MemberName="BC" baseClass
		ColumnName="BaseClass"
		printf "%-18s %-18s %-18s %s\n", baseClass, MemberName, ColumnName, baseClass
	}

	# MAIN awk loop
	{ 
		split($0, field, "@")
		Class=field[3]
		BaseClass=""
		if (index(Class,":")>0) {				# is class derived from other?
			gsub("[ \t]*:[ \t]*public", "", Class)
			split(Class, part, " ")
			Class=part[1]
			BaseClass=part[2]
		}

		if (Class != prevClass) {				# start of a new class?
			addBaseClass(prevBaseClass);		# class last class

			if (Class == "") {				# EndOfClass marker?
				next
			}

			printf "\n"
			printf "Class		%s\n", Class
			printf "Table		%s\n", Class
			printf "#TYPE              MEMBER             COLUMN             TYPE\n"
			printf "#--------------------------------------------------------------------\n"
			prevClass=Class
			prevBaseClass=BaseClass

			print Class >>"mapped.LCS"
			if (BaseClass != "") {
				print BaseClass >>"needed.LCS"
			}
		}

		MemberType=resolveMemberInfo("MT", field[5])
		MemberName=resolveMemberInfo("MN", field[5])
		ColumnType=resolveMemberInfo("CT", field[5])
		ColumnName=resolveMemberInfo("CN", field[5])

		printf "%-18s %-18s %-18s %s\n", MemberType, MemberName, ColumnName, ColumnType
		if (ColumnName == "Class" || ColumnName == "BaseClass") {
			print substr(ColumnType,4) >>"needed.LCS"
		}
	} '
}

#
# ConstructFunfile usedClassesFile
#
ConstructFunfile()
{
	grep -v "#" $1 | sort | uniq | awk '{
		printf "%-15s		I\n", $1
		printf "%-15s		U\n", $1
		printf "%-15s		D\n", $1
		printf "%-15s		S    WHERE ???\n", $1
	}'
}

#------------------------------- MAIN ----------------------------------------
#
# Check invocation syntax: genLCSbase module headerfiles
#
case $# in
	0|1)	echo "Syntax: $0 module headerfiles"
		exit 0
		;;
	*)	MODULE=$1
		shift
		HEADERFILES="$*"
		;;
esac

# Initialize some variables
#
MAPFILE=${MODULE}.map.proto
FUNFILE=${MODULE}.fun.proto

# Write headers to the result files.
InitResultFile  	> ${MAPFILE}
InitResultFile  	> ${FUNFILE}

# Scan the headerfiles and substract the class hierarchy
for file in ${HEADERFILES}
do
	rm -f typedefs.LCS functions.LCS members.LCS \
		  needed.LCS mapped.LCS missing.LCS

	# First stage: break down precompiled headerfile into:
	#		typedefs.LCS
	#		functions.LCS
	#		members.LCS
	cleanlist $file | analyseInfoFile

	# Second stage: Construct mapfile from all classes in main headerfile
	buildMapFile members.LCS >>${MAPFILE}

	# Third stage (repeating): Add the base- and embedded- classes
	complete=false
	while (! $complete)
	do
		if [ ! -f "needed.LCS" ]; then
			complete=true
			break
		fi

		sort needed.LCS | uniq >adding.LCS
		rm -f needed.LCS
		cat adding.LCS | while read classname
		do
			grep $classname mapped.LCS >/dev/null 2>&1
			if [ $? -ne 0 ]; then		# not found?
				buildMapFile members.LCS $classname >>${MAPFILE}
				grep $classname mapped.LCS >/dev/null 2>&1
				if [ $? -ne 0 ]; then		# still not found?
					echo $classname >>missing.LCS
				fi
			fi
		done
		rm adding.LCS
	done

	ConstructFunfile mapped.LCS >>${FUNFILE}
done

if [ -f missing.LCS ]; then
	echo "WARNING: The following types or classes could not be resolved:"
	cat missing.LCS
fi

