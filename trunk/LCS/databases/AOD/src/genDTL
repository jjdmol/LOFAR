#!/usr/bin/ksh
#
# genDTL
#
# Generates DTL code for storing/saving an object to a database
# Uses a .map file to lookup the references and a .fun file
# for looking up the routines that should be generated
#
# Syntax: genDTL mapfile functionfile R|P [class]
#
VERSION="v1.0"

#
# rec_add_BCA class
#
rec_add_BCA()
{
	Class=$1
	
	echo "// The ${Class}_BCA structure 'binds' the database columns"
	echo "// to the members of the ${Class} class."
	echo "class ${Class}_BCA {"
	echo "public:"
	echo "	void operator()(BoundsIO& cols, ${Class}& rowbuf) {"
	# get all 'basic' members of the class
	grep ^$Class ${TMPFILE} | grep "::" | while read line
	do
		ColName=`echo $line | cut -d":" -f5`
		Member=`echo $line | cut -d":" -f4`
		echo "		cols[\"${ColName}\"]	== rowbuf.${Member};"
	done
	echo "	}"
	echo "};\n"
}

#
# rec_add_insert_routine class 
#
rec_add_insert_routine()
{
	Class=$1
	Table=`grep ^$Class ${TMPFILE} | head -1 | cut -d":" -f2`

	echo "//"
	echo "// Routine for insert this ${Class} object in the database."
	echo "//"
	echo "void insert_${Class}(${Class}&	ins_rec) {"
	echo "	DBView<${Class}>	ins_view(\"${Table}\", ${Class}_BCA());"
	echo "	DBView<${Class}>::insert_iterator	ins_iter = ins_view;\n"

	echo "	*ins_iter = *ins_rec;"
	echo "}\n"
}

#
# rec_add_search_routine class clause
#
rec_add_search_routine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class ${TMPFILE} | head -1 | cut -d":" -f2`

	echo "vector<${Class}> read_${Class}() {"
	echo "	vector<${Class}> 		results;"
	echo "	DBView<${Class}>			view(\"${Table}\", ${Class}_BCA(),"
	echo "								\"${Clause}\");"
	echo "	DBView<${Class}>::select_iterator	read_iter = view.begin();\n"
	echo "	for ( ; read_iter != view.end(); ++read_iter) {"
	echo "		results.push_back(*read_iter);"
	echo "	}"
	echo "	return results;"
	echo "}\n"
}

#
# rec_add_update_routine class clause
#
rec_add_update_routine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class ${TMPFILE} | head -1 | cut -d":" -f2`

	echo "//"
	echo "// Routine for updating this ${Class} object in the database."
	echo "//"
	echo "void update_${Class}(${Class}&	theRecord) {"
	echo "	DBView<${Class}>			view(\"${Table}\", ${Class}_BCA(),"
	echo "								\"${Clause}\");"
	echo "	DBView<${Class}>::update_iterator	upd_iter = view;"
	echo ""
	echo "	// update the database"
	echo "	*upd_iter=*theRecord;"
	echo "}\n"
}

#---------------------- Persistency layer routines ----------------------------
#
# tpo_add_generic_structures
#
tpo_add_generic_structures()
{
	# define a struct with the PO fields and the DataObj fields
	echo "// --------------- generic DTL structures -----------------------"
	echo "// The Persistency Layer uses an ObjectID to unique identify"
	echo "// an object. This field can be used in queries to update"
	echo "// or delete an object. Since the ObjectID is the same for"
	echo "// every type of object some generic DTL structs can be defined."
	echo ""
	echo "struct Generic_DTL_OID {"
	echo "	ObjectId		Oid;"
	echo "};"
	echo ""
	echo "class Generic_DTL_BCA {"
	echo "public:"
	echo "	void operator()(BoundsIO& cols, Generic_DTL_OID& rowbuf) {"
	echo "		cols[\"ObjId\"]	== rowbuf.Oid;"
	echo "	}"
	echo "};\n"
	echo ""
	echo "class Generic_DTL_BPA {"
	echo "public:"
	echo "	void operator()(BoundsIO& pos, Generic_DTL_OID& param) {"
	echo "		pos[0]	== param.Oid;"
	echo "	}"
	echo "};\n"
}

#
# tpo_add_header_info class
#
tpo_add_header_info()
{
	Class=$1

	# construct a headerfile for all the methods and members of the TPO
	echo "template<>"
	echo "void TPO<${Class}>::toDatabaseRep(${Class}_DTL	&dest) const;"
	echo ""
	echo "template<>"
	echo "void TPO<${Class}>::fromDatabaseRep(const ${Class}_DTL	&org);"
	echo ""

	cleanlist $FUNFILE | grep ^${Class} | while read theClass theAction rest
	do
		echo "template<>"
		typeset -u theAction=${theAction}
		case $theAction in
		I)	echo "void TPO<${Class}>::insert(const long			theState,"
			;;
		D)	echo "void TPO<${Class}>::erase(const long			theState,"
			;;
		U)	echo "void TPO<${Class}>::update(const long			theState,"
			;;
		S)	echo "void TPO<${Class}>::search(const long			theState,"
			;;
		*)	echo "Unknown function >$function< for class ${Class} in file ${FUNFILE}" >&2
			;;
		esac
	
		echo "							const ObjectId		theParent,"
		echo "							const SQLTimeStamp	theTime);"
		echo ""
	done
}

#
# tpo_add_BCA class
#
tpo_add_BCA()
{
	Class=$1
	
	echo ""
	echo "// The ${Class}_DTL structure is a compilation of the fields"
	echo "// of the ${Class} class and the persistency layer. It contains"
	echo "// all fields that should be stored to the database"

	# define a struct with the PO fields and the DataObj fields
	echo "struct ${Class}_DTL {"
	# First add the PO fields, this is always the same
	echo "	ObjectId		Oid;"
	echo "	ObjectId		Parent;"
	echo "	SQLTimeStamp	Timestamp;"

	# add all 'basic' members of the DataObj
	grep ^$Class ${TMPFILE} | grep "::" | while read line
	do
		MemType=`echo $line | cut -d":" -f3`
		Member=`echo $line | cut -d":" -f4`
		echo "	${MemType}			${Member};"
	done

	echo "}"
	echo ""
	echo "// The ${Class}_DTL_BCA structure 'binds' the database columns"
	echo "// to the members of the ${Class}_DTL class."
	echo "class ${Class}_DTL_BCA {"
	echo "public:"
	echo "	void operator()(BoundsIO& cols, ${Class}_DTL& rowbuf) {"
	# First add the PO fields, this is always the same
	echo "		cols[\"ObjID\"]		== rowbuf.Oid;"
	echo "		cols[\"Parent\"]	== rowbuf.Parent;"
	echo "		cols[\"Timestamp\"]	== rowbuf.Timestamp;"

	# add all 'basic' members of the class
	grep ^$Class ${TMPFILE} | grep "::" | while read line
	do
		ColName=`echo $line | cut -d":" -f5`
		Member=`echo $line | cut -d":" -f4`
		echo "		cols[\"${ColName}\"]	== rowbuf.${Member};"
	done

	echo "	}"
	echo "}\n"
}

#
# tpo_add_to_X_DTL class 
#
# Adds code that copies the values from the real data-objects and the
# persistency object to a local xxx_DTL class.
#
tpo_add_to_X_DTL() 
{
	Class=$1

	echo ""
	echo "// toDatabaseRep copies the fields of the persistency layer"
	echo "// and of the ${Class} class to the given ${Class}_DTL structure"

	echo "template<>"
	echo "void TPO<${Class}>::toDatabaseRep(${Class}_DTL	&dest) const"
	echo "{"
	echo "	// copy info of the ${Class} to the ${Class}_DTL class"
	echo "	// First copy the PO part"
	echo "	dest->Oid		= itsOid;"
	echo "	dest->Parent	= itsParent;"
	echo "	dest->Timestamp	= itsTime;"
	echo ""
	echo "	// Finally copy the info from ${Class}"

	# add all 'basic' members of the Dataobj
	grep ^$Class ${TMPFILE} | grep "::" | while read line
	do
		Member=`echo $line | cut -d":" -f4`
		echo "	dest->${Member}	= itsT->${Member};"
	done
	echo "}\n"
}

#
# tpo_add_from_X_DTL class
#
# Adds code that copies the values from the local XXX_DTL class to the
# real data-objects and the persistency object.
#
tpo_add_from_X_DTL() 
{
	Class=$1
	Action=$2

	echo ""
	echo "// fromDatabaseRep copies the fields of the ${Class}_DTL structure"
	echo "// to the persistency layer and the ${Class} class."

	echo "template<>"
	echo "void TPO<${Class}>::fromDatabaseRep(const ${Class}_DTL	&org)"
	echo "{"
	echo "	// copy info of the ${Class} to the ${Class}_DTL class"
	echo "	// First copy the PO part"
	echo "	itsOid			= org->Oid;"
	echo "	itsParent		= org->Parent;"
	echo "	itsTimestamp	= org->Time;"
	echo ""
	echo "	// Finally copy the info from ${Class}"

	# add all 'basic' members of the Dataobj
	grep ^$Class ${TMPFILE} | grep "::" | while read line
	do
		Member=`echo $line | cut -d":" -f4`
		echo "	itsT->${Member}	= org->${Member};"
	done
	echo "}\n"
}

#
# tpo_add_class_spec class
#
tpo_add_class_spec()
{
	Class=$1

	# When the Class contains subclasses we must make an specialisation
	# for the constructor of the Class.

	# See if there are any subclasses.
	# Note: grep returns 0 if something found, 1 or -1 if not.
	grep ^$Class ${TMPFILE} | grep -v "::" >>/dev/null
	GrepOk=`echo $?`
	if [ ${GrepOk} != "0" ]; then			# no subclasses found?
		return
	fi

	# Add a template specialisation for this class
	echo ""
	echo "// ${Class} contains subclasses so we need template specialisation"
	echo "template<>"
	echo "class TPO<${Class}> : public PersistentObject"
	echo "{"
	echo "public:"
	echo "	TPO(const ${Class}&	t);"
	echo ""
	echo "private:"
	echo "	${Class}*		itsT;"
	echo "	long			itsOid;"
	echo "	date			itsTimeStamp;"
	echo "	bool			itsPersistent;"

	# Add the specialisation part
	echo "	// Also create subclasses"
	grep ^$Class ${TMPFILE} | grep -v "::" | while read line
	do
		VarName=`echo $line | cut -d':' -f4`
		SubClass=`echo $line | cut -d':' -f6`
		echo "	TPO<${SubClass}>	its${VarName}TPO;"
	done

	echo "}\n"

	# Add a constructor method to the TPO class
	echo "// We also need a spec. for the TPO<${Class}> constructor"
	echo "template<>"
	echo "TPO<${Class}>::TPO(const ${Class}& theObj) :"
	echo "	itsT(&x),"
	echo "	itsOid(0),"
	echo "	itsTimeStamp(0),"
	echo -n "	itsPersistent(false)"
	grep ^$Class ${TMPFILE} | grep -v "::" | while read line
	do
		VarName=`echo $line | cut -d':' -f4`
		SubClass=`echo $line | cut -d':' -f6`
		echo ","
		echo "	its${VarName}(theObj->${VarName})"
	done
	echo "{ };\n"

}

#
# tpo_code_copy_to_local class action
#
# Adds code that copies the values from the real data-objects and the
# persistency object to a local xxx_DTL class.
#
tpo_code_copy_to_local() 
{
	Class=$1
	Action=$2

	echo "	// copy info of the ${Class} to the ${Class}_DTL class"
	echo "	${Class}_DTL		rec;"
	echo "	toDatabaseRep (&rec);"

	if [ "${Action}" == "insert" ]; then
		echo "	rec.Oid			= newnumber();		// use new number for Oid"
	fi
	echo "	rec.Parent		= theParent;"
	echo "	rec.Timestamp	= theTime;"
}

#
# tpo_code_handle_all_subclasses class action
#
# Adds code for calling the same routine for all sub-classes of this
# object, and code for handling any errors from these subclass routines.
# When the object has no subclasses a comment line is generated.
#
tpo_code_handle_all_subclasses()
{
	Class=$1
	Action=$2
	typeset -u CapAction=${Action}

	# Grep all subclasses of this class.
	# Note: grep returns 0 if something found, 1 or -1 if not.
	grep ^$Class ${TMPFILE} | grep -v "::" >>/dev/null
	GrepOk=`echo $?`
	
	if [ ${GrepOk} != "0" ]; then			# nothing found?
		echo "	// No subclasses to ${Action}"
		echo ""
		echo "	// Update the PO members to reflect the database"
		return
	fi

	# There are subclasses construct a try-catch area
	echo "	// ${Action} all subclasses"
	echo "	try {"
	echo "		// Note: all (sub(sub))subclasses use the OID of the root"

	# Call all subclasses
	grep ^$Class ${TMPFILE} | grep -v "::" | while read line
	do
		Member=`echo $line | cut -d':' -f4`
		echo "		PO_${Member}.${Action}(theState, (rec.Parent == ROOT_PARENT_NR) ? "
		echo "							rec.Oid : rec.Parent, rec.TimeStamp);"
	done

	# Close the try and build the catch
	echo "	}"
	echo "	catch (LCS_${CapAction}_ERROR&	err_obj) {"
	if [ "${Action}" == "erase" ]; then
		echo "		DBConnection::GetDefaultConnection().RollbackAll();"
	fi
	grep ^$Class ${TMPFILE} | grep -v "::" | while read line
	do
		Member=`echo $line | cut -d':' -f4`
		echo "		PO_${Member}.rollback(theState);"
	done
	echo "		return;"
	echo "	}"
	echo ""
	echo "	// We didn't ran into the catch, so everything went well"
}

#
# tpo_code_update_current_state action
#
# Adds code to update the PO-members to reflect thedatabase changes.
# For 'erase' this means clear the members, for the other actions this
# means copy the values of the local record 'rec' to the PO-members
#
tpo_code_update_current_state()
{
	Action=$1

	if [ "${Action}" == "erase" ]; then
		echo "	itsOid        = 0;"
		echo "	itsParent     = 0;"
		echo "	itsTimeStamp  = 0;"
		echo "	itsPersistent = false;"
	else
		echo "	itsOid        = rec.Oid;"
		echo "	itsParent     = rec.Parent;"
		echo "	itsTimeStamp  = rec.Timestamp;"
		echo "	itsPersistent = true;"
	fi
	echo ""
}

#
# tpo_add_insert_routine class 
#
# Adds code to insert an instance of the data-object to the database,
# including its subclasses
#
tpo_add_insert_routine()
{
	Class=$1
	Table=`grep ^$Class ${TMPFILE} | head -1 | cut -d":" -f2`

	# generate a DBview with table and standard BCA
	echo "//"
	echo "// Routine for insert this ${Class} object in the database."
	echo "//"
	echo "template<>"
	echo "void TPO<${Class}>::insert(const long			theState,"
	echo "								const ObjectId		theParent,"
	echo "								const SQLTimeStamp	theTime) {"
	echo "	DBView<${Class}_DTL>	ins_view(\"${Table}\", ${Class}_DTL_BCA());"
	echo "	DBView<${Class}_DTL>::insert_iterator	ins_iter = ins_view;"
	echo ""

	echo "	saveState(theState);		// remember values for rollback"
	echo ""

	tpo_code_copy_to_local ${Class} insert

	echo ""
	echo "	// save this record"
	echo "	*ins_iter = rec;"
	echo ""

	tpo_code_handle_all_subclasses ${Class} insert

	tpo_code_update_current_state insert

	echo "}\n"
}

#
# tpo_add_update_routine class clause
#
# Adds a routine for updating a data-object in the database. The data-object
# is searched using its unique ObjectId.
#
tpo_add_update_routine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class ${TMPFILE} | head -1 | cut -d":" -f2`

	# generate a DBview with table and standard BCA
	echo "//"
	echo "// Routine for updating this ${Class} object in the database."
	echo "//"
	echo "template<>"
	echo "void TPO<${Class}>::update(const long			theState,"
	echo "								const ObjectId		theParent,"
	echo "								const SQLTimeStamp	theTime) {"
	echo "	DBView<${Class}_DTL, ${Class}_PAR>"
	echo "			upd_view(\"${Table}\", ${Class}_DTL_BCA(),"
	echo "			\"WHERE ObjId=(?)\", Generic_DTL_BPA());"
	echo "	DBView<${Class}_DTL, ${Class}_PAR>::update_iterator"
	echo "			upd_iter = upd_view;"
	echo ""

	echo "	saveState(theState);		// remember values for rollback"
	echo ""

	tpo_code_copy_to_local ${Class} update

	echo ""
	echo "	// setup the selection paramters"
	echo "	upd_iter.Params().Oid = rec.Oid;"
	echo ""
	echo "	// save this record"
	echo "	*upd_iter = rec;"
	echo ""

	tpo_code_handle_all_subclasses ${Class} update

	tpo_code_update_current_state update

	echo "}\n"
}

#
# tpo_add_delete_routine class clause
#
# Adds a routine for deleting a data-object from the database. The deletion
# is based on the unique ObjectID of the object.
#
tpo_add_delete_routine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class ${TMPFILE} | head -1 | cut -d":" -f2`

	# generate a DBview with table and standard BCA
	echo "//"
	echo "// Routine for deleting this ${Class} object in the database."
	echo "//"
	echo "template<>"
	echo "void TPO<${Class}>::erase(const long			theState,"
	echo "								const ObjectId		theParent,"
	echo "								const SQLTimeStamp	theTime) {"
	echo "	DBView<${Class}_DTL>"
	echo "			del_view(\"${Table}\", Generic_DTL_BCA());"
	echo "	DBView<${Class}_DTL>::delete_iterator"
	echo "			del_iter = del_view;"
	echo ""

	echo "	saveState(theState);		// remember values for rollback"
	echo ""

	echo "	// setup the selection paramters"
	echo "	Generic_DTL_OID		rec;"
	echo "	rec.Oid = itsOid;"
	echo ""
	echo "	// delete this record"
	echo "	*del_iter = rec;"
	echo ""

	tpo_code_handle_all_subclasses ${Class} erase

	tpo_code_update_current_state erase

	echo "}\n"
}

#---------------------------- Global routines ---------------------------------
#
# init_tmpfile
#
# Writes an informational header to the tempfile in case the file was not
# removed by this script.
#
init_tmpfile()
{
	echo "#This temporarely file was generated by genDTL"
	echo "#It should have been cleaned up by genDTL, please remove it"
	echo "#ClassName:TableName:Ctype:MemberName:ColumnName:SubclassName:DBtype"
}

#
# init_srcfile filetype class
#
# Adds an informational header to the C++ source- of headerfile.
#
init_srcfile()
{
	FileType=$1
	Class=$2

	echo -n "//# This file was generated by genDTL ${VERSION} on " ; date
	echo "//# with the command: genDTL ${MAPFILE} ${FUNFILE} ${LAYER} ${CLASS}"
	echo -n "//# from the directory: " ; pwd
	echo "//#"
	echo "//# EDITING THIS FILE MANUALLY IS AT YOUR OWN RISK"
	echo "//# ITS MIGHT BE OVERWRITTEN BY THE NEXT MAKE OF YOUR PROJECT"
	echo "//#"

	# include the headerfiles in the C++ sourcefile
	if [ "${FileType}" == "cc" ]; then
		echo "#include \"${FILEPREFIX}${Class}.h\""

		# Grep all subclasses of this class and include those headerfiles also.
		grep ^${Class} ${TMPFILE} | grep -v "::" | while read line
		do
			subClass=`echo $line | cut -d':' -f6`
			echo "#include \"${FILEPREFIX}${subClass}.h\""
		done
	else	# its a headerfile
		typeset -u FileLabel=${FILEPREFIX}${Class}_H
		echo "//# only include this file once"
		echo "#if !defined(${FileLabel})"
		echo "#define ${FileLabel}"
		echo ""
	fi
}

#
# close_headerfile
#
# write the last '#endif' to the headerfile
#
close_headerfile()
{
	echo "#endif"
}
#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
#
cleanlist()
{
	cut -d"#" -f1 $1 | awk '{ if (NF > 0) print $0 }'
}

#
# convert_mapfile mapfile
#
# Convert the user format from the mapfile into something more convenient
# and store this in the tempfile.
#
# Allowed linesyntax of  the mapfile:
#	Class	<ClassName>
#	Table	<TableName>
#	<Ctype>	<MemberName>	<ColumnName>	<DBtype>
#	<Ctype>	<MemberName>	class			<ClassName>
#
# Syntax of the constructed temp-file:
# ClassName:TableName:Ctype:MemberName:ColumnName:SubclassName:DBtype
#
convert_mapfile()
{
	Mapfile=$1

	cleanlist ${Mapfile} | while read label name dbname fldtype
	do
		# comment is stripped off, check rest of line
		if [ -z "$label" -o -z "$name" ]; then		# need two fields
			continue
		fi

		case $label in
		Class|class|CLASS)				# Class keyword
			CurClass=$name
			;;
		Table|table|TABLE)				# Table keyword
			CurTable=$name
			;;
		*)								# no keyword, assume fieldname
			typeset -l SubClass=`echo $dbname | cut -d" " -f1`
			# what kind of field is this?
			if [ "${SubClass}" == "class" ]; then
				# it's a (sub)class, get its name.
				SubClassName=`echo $fldtype | cut -d" " -f1`
			echo "$CurClass:$CurTable:$label:$name:$dbname:$SubClassName:OID"
			else
				echo "$CurClass:$CurTable:$label:$name:$dbname::$fldtype"
			fi
			;;
		esac
	done
}

#------------------------------- MAIN program ---------------------------------
#
# Check invocation syntax: genDTL mapfile cmdfile layer [class]
#
case $# in
	3)	MAPFILE=$1					# genDTL mapfile funfile layer
		FUNFILE=$2
		typeset -u LAYER=$3
		GREPMASK=""
		CLASS=""
		;;
	4)	MAPFILE=$1					# genDTL mapfile funfile layer classname
		FUNFILE=$2
		typeset -u LAYER=$3
		GREPMASK=" | grep ^$4"
		CLASS=$4
		;;
	*)	echo "Syntax: $0 mapfile functionfile layer [class]"
		echo "        where layer is R(ecord) or P(ersistency)"
		exit 0
		;;
esac

# Mapfile must exist
#
if [ ! -s ${MAPFILE} ]; then
	echo "File ${MAPFILE} doesn't exist\n"
	exit 1
fi

# Functionfile must exist
#
if [ ! -s ${FUNFILE} ]; then
	echo "File ${FUNFILE} doesn't exist\n"
	exit 1
fi

# Check Layer type
#
case "${LAYER}" in
R)		FILEPREFIX="rec_"		;;
P)		FILEPREFIX="PO_"		;;
*)		echo "Layer should be R(ecord) or P(ersistency), not >${LAYER}<\n"
		exit 1
esac

# All arguments seem ok, continue processing

# Initialize some variables
#
LCSBASEFILE="LCS_base.h"
TMPFILE=map.genDTL.$$

# convert the human readable format of the mapfile into something
# more convenient for shell-programming
init_tmpfile					> ${TMPFILE}
convert_mapfile ${MAPFILE}		>>${TMPFILE}

#
# Build the sourcecode for the record- or the persistency-layer
#
if [ "${LAYER}" == "P" ]; then
	# always need this in the tpo layer
	init_srcfile "h" no_class 	> ${LCSBASEFILE}
	tpo_add_generic_structures	>>${LCSBASEFILE}
fi

# Scan the functionfile to determine what code should be generated
#
PrevClass="Unknown"
#eval "cut -d'#' -f1 $FUNFILE $GREPMASK" | \
eval "cleanlist $FUNFILE $GREPMASK" | \
while read class action clause
do
	# minimal check on layout of line
	if [ -z "$class" -o -z "$action" ]; then
		continue
	fi

	# New class? generate the necc. structures in the new sourcefile.
	# generate exacly one BCA for each class
	if [ "${PrevClass}" != "${class}" ]; then
		case ${LAYER} in
		R) 	SOURCEFILE=${FILEPREFIX}${class}.cc
			HEADERFILE=${FILEPREFIX}${class}.h
			init_srcfile "cc" ${class}  > ${SOURCEFILE}
			rec_add_BCA 	  ${class}  >>${SOURCEFILE}
			;;
		P) 	# if this is not the first class, close the headerfile
			# of the last class
			if [ "${PrevClass}" != "Unknown" ]; then
				close_headerfile	>>${HEADERFILE}
			fi
			# start a new headerfile and sourcefile
			SOURCEFILE=${FILEPREFIX}${class}.cc
			HEADERFILE=${FILEPREFIX}${class}.h
			init_srcfile "cc"		${class} 	> ${SOURCEFILE}
			tpo_add_class_spec		${class} 	>>${SOURCEFILE} 
			tpo_add_to_X_DTL		${class} 	>>${SOURCEFILE} 
			tpo_add_from_X_DTL		${class} 	>>${SOURCEFILE} 
			tpo_add_BCA 			${class} 	>>${SOURCEFILE}
			init_srcfile "h"		${class} 	> ${HEADERFILE}
			tpo_add_header_info		${class} 	>>${HEADERFILE}
			;;
		esac
		PrevClass=${class}
	fi

	# dispatch the action
	typeset -u action=${action}						# to uppercase
	case ${LAYER} in
	R)
		case $action in
		I) rec_add_insert_routine $class 			>>${SOURCEFILE}		;;
		U) rec_add_update_routine $class "$clause"	>>${SOURCEFILE}		;;
		D) rec_add_delete_routine $class "$clause"	>>${SOURCEFILE}		;;
		S) rec_add_search_routine $class "$clause"	>>${SOURCEFILE}		;;
		*) echo "ERROR:Unknown function >$action< for class >$class< in file >$FUNFILE<"
		   ;;
		esac
		;;
	P)
		case $action in
		I) tpo_add_insert_routine $class 			>>${SOURCEFILE}		;;
		U) tpo_add_update_routine $class "$clause"	>>${SOURCEFILE}		;;
		D) tpo_add_delete_routine $class "$clause"	>>${SOURCEFILE}		;;
		S) tpo_add_search_routine $class "$clause"	>>${SOURCEFILE}		;;
		*) echo "ERROR:Unknown function >$action< for class >$class< in file >$FUNFILE<"
		   ;;
		esac
		;;
	esac
done

# close last headerfile
#close_headerfile	>>${HEADERFILE}		@@@ HEADERFILE IS UNKNOWN HERE!

rm -f ${TMPFILE}
