#!/usr/bin/ksh
#
# genDTL
#
# Generates DTL code for storing/saving an object to a database
# Uses a .map file to lookup the references and a .fun file
# for looking up the routines that should be generated
#
# Syntax: genDTL mapfile functionfile R|P [class]
#
VERSION="v1.0"

#
# rec_add_BCA class
#
rec_add_BCA()
{
	Class=$1
	
	echo "// The ${Class}_BCA structure 'binds' the database columns"
	echo "// to the members of the ${Class} class."
	echo "class ${Class}_BCA {"
	echo "public:"
	echo "	void operator()(BoundsIO& cols, ${Class}& rowbuf) {"
	# get all 'basic' members of the class
	grep ^$Class $TMPFILE | grep "::" | while read line
	do
		ColName=`echo $line | cut -d":" -f5`
		Member=`echo $line | cut -d":" -f4`
		echo "		cols[\"${ColName}\"]	== rowbuf.${Member};"
	done
	echo "	}"
	echo "};\n"
}

#
# rec_add_insert_routine class 
#
rec_add_insert_routine()
{
	Class=$1
	Table=`grep ^$Class $TMPFILE | head -1 | cut -d":" -f2`

	echo "//"
	echo "// Routine for insert this ${Class} object in the database."
	echo "//"
	echo "void insert_${Class}(${Class}&	ins_rec) {"
	echo "	DBView<${Class}>	ins_view(\"${Table}\", ${Class}_BCA());"
	echo "	DBView<${Class}>::insert_iterator	ins_iter = ins_view;\n"

	echo "	*ins_iter = *ins_rec;"
	echo "}\n"
}

#
# rec_add_search_routine class clause
#
rec_add_search_routine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class $TMPFILE | head -1 | cut -d":" -f2`

	echo "vector<${Class}> read_${Class}() {"
	echo "	vector<${Class}> 		results;"
	echo "	DBView<${Class}>			view(\"${Table}\", ${Class}_BCA(),"
	echo "								\"$1\");"
	echo "	DBView<${Class}>::select_iterator	read_iter = view.begin();\n"
	echo "	for ( ; read_iter != view.end(); ++read_iter) {"
	echo "		results.push_back(*read_iter);"
	echo "	}"
	echo "	return results;"
	echo "}\n"
}

#
# rec_add_update_routine
#
rec_add_update_routine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class $TMPFILE | head -1 | cut -d":" -f2`

	echo "//"
	echo "// Routine for updating this ${Class} object in the database."
	echo "//"
	echo "void update_${Class}(${Class}&	theRecord) {"
	echo "	DBView<${Class}, ${Class}_PAR>"
	echo "			view(\"${Table}\", ${Class}_BCA(),"
	echo "			\"$1\", ${Class}_PAR());"
	echo "	DBView<${Class}, ${Class}_PAR>::update_iterator	upd_iter = view;"
	echo ""
	echo "	// Setup the selection parameters"
	echo "	upd_iter.Params().??? = ???;"
	echo ""
	echo " // update the database"
	echo "	*upd_iter=*theRecord;"
	echo "}\n"
}

#---------------------- Persistency layer routines ----------------------------
#
# tpo_add_generic_structures
#
tpo_add_generic_structures()
{
	# define a struct with the PO fields and the DataObj fields
	echo "// --------------- generic DTL strucures -----------------------"
	echo "// The Persistency Layer uses an ObjectID to unique identify"
	echo "// an object. This field can be used in queries to update"
	echo "// or delete an object. Since the ObjectID is the same for"
	echo "// every type of object some generic DTL structs can be defined."
	echo ""
	echo "struct Generic_DTL_OID {"
	echo "	ObjectId		Oid;"
	echo "};"
	echo ""
	echo "class Generic_DTL_BCA {"
	echo "public:"
	echo "	void operator()(BoundsIO& cols, Generic_DTL_OID& rowbuf) {"
	echo "		cols[\"ObjId\"]	== rowbuf.Oid;"
	echo "	}"
	echo "};\n"
	echo ""
	echo "class Generic_DTL_BPA {"
	echo "public:"
	echo "	void operator()(BoundsIO& pos, Generic_DTL_OID& param) {"
	echo "		pos[0]	== param.Oid;"
	echo "	}"
	echo "};\n"
}

#
# tpo_add_BCA class
#
tpo_add_BCA()
{
	Class=$1
	
	echo ""
	echo "// The ${Class}_DTL structure is a compilation of the fields"
	echo "// of the ${Class} class and the persistency layer. It contains"
	echo "// all fields that should be stored to the database"

	# define a struct with the PO fields and the DataObj fields
	echo "struct ${Class}_DTL {"
	# First add the PO fields, this is always the same
	echo "	ObjectId		Oid;"
	echo "	ObjectId		Parent;"
	echo "	SQLTimeStamp	Timestamp;"

	# add all 'basic' members of the DataObj
	grep ^$Class $TMPFILE | grep "::" | while read line
	do
		MemType=`echo $line | cut -d":" -f3`
		Member=`echo $line | cut -d":" -f4`
		echo "	${MemType}			${Member};"
	done

	echo "}"
	echo ""
	echo "// The ${Class}_DTL_BCA structure 'binds' the database columns"
	echo "// to the members of the ${Class}_DTL class."
	echo "class ${Class}_DTL_BCA {"
	echo "public:"
	echo "	void operator()(BoundsIO& cols, ${Class}_DTL& rowbuf) {"
	# First add the PO fields, this is always the same
	echo "		cols[\"ObjID\"]		== rowbuf.Oid;"
	echo "		cols[\"Parent\"]	== rowbuf.Parent;"
	echo "		cols[\"Timestamp\"]	== rowbuf.Timestamp;"

	# add all 'basic' members of the class
	grep ^$Class $TMPFILE | grep "::" | while read line
	do
		ColName=`echo $line | cut -d":" -f5`
		Member=`echo $line | cut -d":" -f4`
		echo "		cols[\"${ColName}\"]	== rowbuf.${Member};"
	done

	echo "	}"
	echo "}\n"
}

#
# tpo_code_copy_to_local class action
#
# Adds code that copies the values from the real data-objects and the
# persistency object to a local xxx_DTL class.
#
tpo_code_copy_to_local() 
{
	Class=$1
	Action=$2

	echo "	// copy info of the ${Class} to the ${Class}_DTL class"
	echo "	${Class}_DTL		rec;"
	echo ""
	echo "	// First copy the PO part"
	if [ "${Action}" == "insert" ]; then
		echo "	rec.Oid			= newnumber();"
	else
		echo "	rec.Oid			= itsOid;"
	fi
	echo "	rec.Parent		= theParent;"
	echo "	rec.Timestamp	= theTime;"
	echo "	// Finally copy the info from ${Class}"

	# add all 'basic' members of the Dataobj
	grep ^$Class $TMPFILE | grep "::" | while read line
	do
		Member=`echo $line | cut -d":" -f4`
		echo "	rec.${Member}	= itsT->${Member};"
	done
}

#
# tpo_code_handle_all_subclasses class action
#
# Adds code for calling the same routine for all sub-classes of this
# object, and code for handling any errors from these subclass routines.
# When the object has no subclasses a comment line is generated.
#
tpo_code_handle_all_subclasses()
{
	Class=$1
	Action=$2
	typeset -u CapAction=${Action}

	# Grep all subclasses of this class.
	# Note: grep returns 0 if something found, 1 or -1 if not.
	grep ^$Class $TMPFILE | grep -v "::" >>/dev/null
	GrepOk=`echo $?`
	
	if [ ${GrepOk} != "0" ]; then			# nothing found?
		echo "	// No subclasses to ${Action}"
		echo ""
		echo "	// Update the PO members to reflect the database"
		return
	fi

	# There are subclasses construct a try-catch area
	echo "	// ${Action} all subclasses"
	echo "	try {"
	echo "		// Note: all (sub(sub))subclasses use the OID of the root"

	# Call all subclasses
	grep ^$Class $TMPFILE | grep -v "::" | while read line
	do
		Member=`echo $line | cut -d':' -f4`
		echo "		PO_${Member}.${Action}(theState, (rec.Parent == ROOT_PARENT_NR) ? "
		echo "							rec.Oid : rec.Parent, rec.TimeStamp);"
	done

	# Close the try and build the catch
	echo "	}"
	echo "	catch (LCS_${CapAction}_ERROR&	err_obj) {"
	if [ "${Action}" == "erase" ]; then
		echo "		DBConnection::GetDefaultConnection().RollbackAll();"
	fi
	grep ^$Class $TMPFILE | grep -v "::" | while read line
	do
		Member=`echo $line | cut -d':' -f4`
		echo "		PO_${Member}.rollback(theState);"
	done
	echo "		return;"
	echo "	}"
	echo ""
	echo "	// We didn't ran into the catch, so everything went well"
}

#
# tpo_code_update_current_state action
#
# Adds code to update the PO-members to reflect thedatabase changes.
# For 'erase' this means clear the members, for the other actions this
# means copy the values of the local record 'rec' to the PO-members
#
tpo_code_update_current_state()
{
	Action=$1

	if [ "${Action}" == "erase" ]; then
		echo "	itsOid        = 0;"
		echo "	itsParent     = 0;"
		echo "	itsTimeStamp  = 0;"
		echo "	itsPersistent = false;"
	else
		echo "	itsOid        = rec.Oid;"
		echo "	itsParent     = rec.Parent;"
		echo "	itsTimeStamp  = rec.Timestamp;"
		echo "	itsPersistent = true;"
	fi
	echo ""
}

#
# tpo_add_insert_routine class 
#
# Adds code to insert an instance of the data-object to the database,
# including its subclasses
#
tpo_add_insert_routine()
{
	Class=$1
	Table=`grep ^$Class $TMPFILE | head -1 | cut -d":" -f2`

	# generate a DBview with table and standard BCA
	echo "//"
	echo "// Routine for insert this ${Class} object in the database."
	echo "//"
	echo "void TPO<${Class}>::insert(const long			theState,"
	echo "								const ObjectId		theParent,"
	echo "								const SQLTimeStamp	theTime) {"
	echo "	DBView<${Class}_DTL>	ins_view(\"${Table}\", ${Class}_DTL_BCA());"
	echo "	DBView<${Class}_DTL>::insert_iterator	ins_iter = ins_view;"
	echo ""

	echo "	saveState(theState);		// remember values for rollback"
	echo ""

	tpo_code_copy_to_local ${Class} insert

	echo ""
	echo "	// save this record"
	echo "	*ins_iter = rec;"
	echo ""

	tpo_code_handle_all_subclasses ${Class} insert

	tpo_code_update_current_state insert

	echo "}\n"
}

#
# tpo_add_update_routine class clause
#
# Adds a routine for updating a data-object in the database. The data-object
# is searched using its unique ObjectId.
#
tpo_add_update_routine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class $TMPFILE | head -1 | cut -d":" -f2`

	# generate a DBview with table and standard BCA
	echo "//"
	echo "// Routine for updating this ${Class} object in the database."
	echo "//"
	echo "void TPO<${Class}>::update(const long			theState,"
	echo "								const ObjectId		theParent,"
	echo "								const SQLTimeStamp	theTime) {"
	echo "	DBView<${Class}_DTL, ${Class}_PAR>"
	echo "			upd_view(\"${Table}\", ${Class}_DTL_BCA(),"
	echo "			\"WHERE ObjId=(?)\", Generic_DTL_BPA());"
	echo "	DBView<${Class}_DTL, ${Class}_PAR>::update_iterator"
	echo "			upd_iter = upd_view;"
	echo ""

	echo "	saveState(theState);		// remember values for rollback"
	echo ""

	tpo_code_copy_to_local ${Class} update

	echo ""
	echo "	// setup the selection paramters"
	echo "	upd_iter.Params().Oid = rec.Oid;"
	echo ""
	echo "	// save this record"
	echo "	*upd_iter = rec;"
	echo ""

	tpo_code_handle_all_subclasses ${Class} update

	tpo_code_update_current_state update

	echo "}\n"
}

#
# tpo_add_delete_routine class clause
#
# Adds a routine for deleting a data-object from the database. The deletion
# is based on the unique ObjectID of the object.
#
tpo_add_delete_routine()
{
	Class=$1
	Clause=$2
	Table=`grep ^$Class $TMPFILE | head -1 | cut -d":" -f2`

	# generate a DBview with table and standard BCA
	echo "//"
	echo "// Routine for deleting this ${Class} object in the database."
	echo "//"
	echo "void TPO<${Class}>::erase(const long			theState,"
	echo "								const ObjectId		theParent,"
	echo "								const SQLTimeStamp	theTime) {"
	echo "	DBView<${Class}_DTL>"
	echo "			del_view(\"${Table}\", Generic_DTL_BCA());"
	echo "	DBView<${Class}_DTL>::delete_iterator"
	echo "			del_iter = del_view;"
	echo ""

	echo "	saveState(theState);		// remember values for rollback"
	echo ""

	echo "	// setup the selection paramters"
	echo "	Generic_DTL_OID		rec;"
	echo "	rec.Oid = itsOid;"
	echo ""
	echo "	// delete this record"
	echo "	*del_iter = rec;"
	echo ""

	tpo_code_handle_all_subclasses ${Class} erase

	tpo_code_update_current_state erase

	echo "}\n"
}

#---------------------------- Global routines ---------------------------------
#
# init_tmpfile
#
# Writes an informational header to the tempfile in case the file was not
# removed by this script.
#
init_tmpfile()
{
	(
	echo "#This temporarely file was generated by genDTL"
	echo "#It should have been cleaned up by genDTL, please remove it"
	echo "#ClassName:TableName:Ctype:MemberName:ColumnName:SubclassName:DBtype" 	) >$TMPFILE
}

#
# init_srcfile
#
# Adds an informational header to the C++ sourcefile.
#
init_srcfile()
{
	echo -n "// This file was generated by genDTL ${VERSION} on " ; date
	echo "// with the command: genDTL ${MAPFILE} ${FUNFILE} ${LAYER} ${CLASS}"
	echo -n "// from the directory: " ; pwd
	echo "//"
	echo "// EDITING THIS FILE MANUALLY IS AT YOUR OWN RISK"
	echo "// ITS MIGHT BE OVERWRITTEN BY THE NEXT MAKE OF YOUR PROJECT"
	echo "//"
}

#------------------------------- MAIN program ---------------------------------
#
# Check invocation syntax: genDTL mapfile cmdfile layer [class]
#
case $# in
	3)	MAPFILE=$1					# genDTL mapfile funfile layer
		FUNFILE=$2
		typeset -u LAYER=$3
		GREPMASK=""
		CLASS=""
		;;
	4)	MAPFILE=$1					# genDTL mapfile funfile layer classname
		FUNFILE=$2
		typeset -u LAYER=$3
		GREPMASK=" | grep ^$4"
		CLASS=$4
		;;
	*)	echo "Syntax: $0 mapfile functionfile layer [class]"
		echo "        where layer is R(ecord) or P(ersistency)"
		exit 0
		;;
esac

# Mapfile must exist
#
if [ ! -s ${MAPFILE} ]; then
	echo "File ${MAPFILE} doesn't exist\n"
	exit 1
fi

# Functionfile must exist
#
if [ ! -s ${FUNFILE} ]; then
	echo "File ${FUNFILE} doesn't exist\n"
	exit 1
fi

# Check Layer type
#
case "$LAYER" in
R|P)	;;
*)		echo "Layer should be R(ecord) or P(ersistency), not >$LAYER<\n"
		exit 1
esac

# All arguments seem ok, continue processing

# Initialize some variables
#
TMPFILE=map.genDTL.$$

init_tmpfile

# Convert the user format from the mapfile into something more convenient
# and store this in the tempfile.
#
# Allowed linesyntax of  the mapfile:
#	Class	<ClassName>
#	Table	<TableName>
#	<Ctype>	<MemberName>	<ColumnName>	<DBtype>
#	<Ctype>	<MemberName>	class			<ClassName>
#
# Syntax of the constructed temp-file:
# ClassName:TableName:Ctype:MemberName:ColumnName:SubclassName:DBtype
#
cut -d"#" -f1 $MAPFILE | while read label name dbname fldtype
do
	# comment is stripped off, check rest of line
	if [ -z "$label" -o -z "$name" ]; then		# need two fields
		continue
	fi

	case $label in
	Class|class|CLASS)				# Class keyword
		CurClass=$name
		;;
	Table|table|TABLE)				# Table keyword
		CurTable=$name
		;;
	*)								# no keyword, assume fieldname
		typeset -l SubClass=`echo $dbname | cut -d" " -f1`
		# what kind of field is this?
		if [ "${SubClass}" == "class" ]; then
			# it's a (sub)class, get its name.
			SubClassName=`echo $dbname | cut -d" " -f2`
			echo "$CurClass:$CurTable:$label:$name:$dbname:$SubClassName:OID" >>$TMPFILE
		else
			echo "$CurClass:$CurTable:$label:$name:$dbname::$fldtype" >>$TMPFILE
		fi
		;;
	esac
done

#
# Build the sourcecode for the record- or the persistency-layer
#
init_srcfile							# write header to source file

if [ "${LAYER}" == "P" ]; then
	tpo_add_generic_structures			# always need this in the tpo layer
fi

# Scan the functionfile to determine what code should be generated
#
PrevClass="Unknown"
eval "cut -d'#' -f1 $FUNFILE $GREPMASK" | \
while read class function clause
do
	# minimal check on layout of line
	if [ -z "$class" -o -z "$function" ]; then
		continue
	fi

	# generate exacly one BCA for each class
	if [ "$PrevClass" != "$class" ]; then
		case $LAYER in
		R) 	rec_add_BCA $class		;;
		P) 	tpo_add_BCA $class 		;;
		esac
		PrevClass=$class
	fi

	# dispatch the function
	typeset -u function							# to uppercase
	case $LAYER in
	R)
		case $function in
		I) rec_add_insert_routine $class 				;;
		U) rec_add_update_routine $class $clause		;;
		D) rec_add_delete_routine $class $clause		;;
		S) rec_add_search_routine $class $clause		;;
		*) echo "ERROR:Unknown function >$function< for class >$class< in file >$FUNFILE<"
		   ;;
		esac
		;;
	P)
		case $function in
		I) tpo_add_insert_routine $class 				;;
		U) tpo_add_update_routine $class $clause		;;
		D) tpo_add_delete_routine $class $clause		;;
		S) tpo_add_search_routine $class $clause		;;
		*) echo "ERROR:Unknown function >$function< for class >$class< in file >$FUNFILE<"
		   ;;
		esac
		;;
	esac
done

rm -f ${TMPFILE}
