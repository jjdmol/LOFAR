// The code in this layer is assumed by the code generated with genDTL
//
// Assumptions
// [1] The basic idea is that the programmer only calls the xxx(void) routines
// for the 'top'-object. The DTL code will call the xxx(parent, time)
// routines for all sub-objects.
// [2] All ((sub)sub)subclasses of an object store the ParentOid of the
// root object.
// [3] Every time a routine of the PO-object is called a 'state(ment)'counter
// is incremented and passed to the subclasses. In this way each subclass
// knows if it is save to rollback when asked for.
//
void PersistenObject::insert()
{
	// called by user --> thus for top-object [1]
	itsParent = 0;

	// do object-specific insert
	insert(++itsStateNr, itsParent, now());
}

void PersistenObject::update()
{
	// do object-specific update
	update(++itsStateNr, itsParent, itsTimeStamp);
}

void PersistenObject::save()
{
	if (itsPersistent) {
		update();
	}
	else {
		insert();
	}
}

void PersistenObject::retieve()
{
	// TODO: don't know this code yet.
}

void PersistenObject::erase()
{
	// do object-specific erase
	erase(++itsStateNr, itsOid, itsTimeStamp);

}

void PersistenObject::saveState(const long		stateNr)
{
	// backup the values to their 'prev' counterparts
	itsPrevOid		  = itsOid;
	itsPrevParent 	  = itsParent;
	itsPrevTimeStamp  = itsTimeStamp;
	itsPrevPersistent = itsPersistent;

	itsStateNr = stateNr;				// remember which state is saved
}

bool PersistenObject::rollback(const long		stateNr)
{
	if (itsStateNr != stateNr) {		// rollback to the saved state?
		return (false);					// sorry don't have that state.
	}

	// its save to restore the values.
	itsOid		  = itsPrevOid;
	itsParent 	  = itsPrevParent;
	itsTimeStamp  = itsPrevTimeStamp;
	itsPersistent = itsPrevPersistent;

	return (true);
}

