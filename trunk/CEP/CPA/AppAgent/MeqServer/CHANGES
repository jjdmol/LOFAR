  * Parm ignores the default depend_mask_, instead it returns a combination
    of its own domain_depend_mask and solve_depend_mask, depending on
    what kind of polc is being evaluated. 

  * added symbolic dependencies to Node, along with Set/Clear.Depend.Mask
    rider commands, to facilitate automatic building of dependency masks.
    
  * processCommands() is now allowed to modify the request (presumably,
    by modifying/adding commands)

  * added auto_resample field to Node (currently called auto_depend: change
    this!) controlling auto-resampling of child results:
    -2 to fail; -1 to integrate, 0 to do none, 1 to upsample
    Also added caching of resampled child results within Node; still have to
    update documentation and work through the caching issues.
  
  * added "integrated" property to Result. Set in leaf nodes to indicate
    whether the value is a sampling or an integration; handled by the
    resampling code. Spigot always produces an integrated result, Time/Freq
    always produce a sampling, Parm/Constant produce a sampling by default,
    or an integration if staterec.integrated=T

  * Cells are now split into regular segments based on step _and_ cell size
    (used to be only step)

  * revised the request_id structure; added depend_mask to all nodes,
    plus solve_depend_mask to Solver, and domain_depend_mask + 
    solve_depend_mask to Parm. Defaults should be fine 99% of the time.

  * added MeqReqMux node: request multiplexer
    can be used to drive one tree at full resolution, and the other at
    partial resolution

  * added flag_mask state field to all Function nodes. Use, e.g.:
      initrec.flag_mask := mask
    where mask is a single common mask applied to all flags (-1 to pass
    all flags, 0 to pass no flags), or a vector of numChildren masks, 
    one per child.
    
  * C++: prohibited Vells from automatic copy-on-write, as that can
    confuse their containers. 
    
  * C++: changed Result and VellSet interfaces for consistency:
    Result::vellSet(), vellSetWr(); VellSet::getValue(), getValueWr()

  * C++: changed signature of Function::evaluate() to take a vector of
    const Vells *. Must change JEN's code generator.
    
  * added MergeFlagger node. Init with:
      initrec.flag_mask := []
    where mask is a single mask, or a vector of numChildren masks, one 
    per child.
    
  * added ZeroFlagger node. Init with:
    initrec.oper     := hiid(op)    # op=EQ/NE/GT/LT/GE/LE, EQ by default
    initrec.flag_bit :=             # Flag mask to raise, 1 by default      

  * added optional flags field to VellSet. Reading controlled by flag_mask
    and row_flag_mask in Spigot. 

Checked in by 19/03/2004:

  * new solver commands/states:
    clear_matrix, invert_matrix, num_iter, save_polcs, weight
    (also, default.nnn, for default settings of same)
  
Checked in by 17/03/2004:

  * aded mqs.track_results() function

  * added error logging to app_proxy objects (e.g. meq.server):
      mqs.num_error()
      mqs.get_error_log(clear=T)

  * added Disable.Publish.Results command, to make all nodes shut up
  
  * removed meq.get_freq/time_grid() functions (meptools.g), since
    these are now available as cells.grid.freq and cells.grid.time.
    
  * changed meq.domain internals -- should not be referenced as
    domain[1..4], but rather domain.freq[1,2]; domain.time[1,2].
    Constructor is the same.

  * changed meq.cells, now has a more regular structure:
    - the meq.cells(domain,nx,ny) constructor is unchanged;
    - other constructor forms (with times and steps) need to be modified;
    - cells.num_freq, cells.times, cells.time_steps: no longer available
    
Checked in by 03/03/2004:

  * a parm now has a solvable polc and a predict polc, so it can answer
    off-the-wall predict requests w/o disrupting the solve.
    parm state record fields are now:
      polcs             # always a vector, so use polcs[1] for single polc
      solve_polcs       # always a vector, so use solve_polcs[1] for single polc
      domain_id         # current domain IDs
      solve_domain_id
      domain            # current domains
    
      
  * added a Clear.Polcs command to MeqParm; renamed Save.Polc to
    Save.Polcs
  
  * added a meq.solvable_list() function to create lists of solvable
    parms (suitable for assigning to solver's defrec.solvable), see 
    MeqServer/test/meqtest.g

  * added a meq.reclist() function to meqtypes, to make lists of records.
    meq.init/addcmdlist() now uses it

  * renamed config_groups into node_groups
    (meq.node() has a "groups" argument now)
    Affected: meqtypes.g, solvable parms
  
  * merged node_state with the rider; changed the rider structure:
  
      rider.group.command_all
      rider.group.command_by_nodeindex
      rider.group.command_by_list
    
    and command can now include "state=[...]"
    Affected: meqtypes.g, solvable parms, solver tests
    
  * changed structure of solver staterec:
  
      rec.parm_group        parm group to use ("Parm" by default)
      rec.solvable          solvable parms (used to be rec.solvable_parm)
      
  * renamed ini/addstatelist to init/addcmdlist in meqtypes.g

Check in of 18/02/04:

  * stuffed everything into namespace meq.

  * Renamed parmtable.g to meptable.g; the object is now called 'meptable()'
  
  * parm defrec:
      defrec.default: must be a meqpolc() now, not an arbitrary value
      defrec.auto_save = T: enables auto-saving of intermediate polc values
      
  * request rider:
      req.rider.save_polc = T: saves polc values
      
  * polc attributes:
      polc.grow_domain: enables growing domains
      polc.inf_domain:  makes domain "infinite" (i.e. applies to all)


Check in of 12/12/03:

  * Changed MeqServer command names:
  
    command_map["Create.Node"] = &MeqServer::createNode;
    command_map["Delete.Node"] = &MeqServer::deleteNode;
    command_map["Resolve.Children"] = &MeqServer::resolveChildren;
    command_map["Get.Node.List"] = &MeqServer::getNodeList;
    command_map["Node.Get.State"] = &MeqServer::getNodeState;
    command_map["Node.Set.State"] = &MeqServer::setNodeState;
    command_map["Node.Execute"] = &MeqServer::getNodeResult;
    
  * For result, vellssets lists:
    Use '#1', "#2', etc. for field names. Shouldn't matter as long
    as record is accessed as [1], [2], etc.
  
  * Changed state record names:
      cache_result
      cache_result_code
    
  * Added node_state to request, see meqrequest() in meqserver.g
  
  * Meq::Parm:
    initrec.table_name!
    initrec.parm_name   (optional, node name used by default)
    
(Changes relative to 08/12/03)
