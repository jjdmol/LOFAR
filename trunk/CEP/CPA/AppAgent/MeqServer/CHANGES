  * a parm now has a solvable polc and a predict polc, so it can answer
    off-the-wall predict requests w/o disrupting the solve
      
  * added a Clear.Polcs command to MeqParm; renamed Save.Polc to
    Save.Polcs
  
  * added a meq.solvable_list() function to create lists of solvable
    parms (suitable for assigning to solver's defrec.solvable), see 
    MeqServer/test/meqtest.g

  * added a meq.reclist() function to meqtypes, to make lists of records.
    meq.init/addcmdlist() now uses it

  * renamed config_groups into node_groups
    (meq.node() has a "groups" argument now)
    Affected: meqtypes.g, solvable parms
  
  * merged node_state with the rider; changed the rider structure:
  
      rider.group.command_all
      rider.group.command_by_nodeindex
      rider.group.command_by_list
    
    and command can now include "state=[...]"
    Affected: meqtypes.g, solvable parms, solver tests
    
  * changed structure of solver staterec:
  
      rec.parm_group        parm group to use ("Parm" by default)
      rec.solvable          solvable parms (used to be rec.solvable_parm)
      
  * renamed ini/addstatelist to init/addcmdlist in meqtypes.g

Check in of 18/02/04:

  * stuffed everything into namespace meq.

  * Renamed parmtable.g to meptable.g; the object is now called 'meptable()'
  
  * parm defrec:
      defrec.default: must be a meqpolc() now, not an arbitrary value
      defrec.auto_save = T: enables auto-saving of intermediate polc values
      
  * request rider:
      req.rider.save_polc = T: saves polc values
      
  * polc attributes:
      polc.grow_domain: enables growing domains
      polc.inf_domain:  makes domain "infinite" (i.e. applies to all)


Check in of 12/12/03:

  * Changed MeqServer command names:
  
    command_map["Create.Node"] = &MeqServer::createNode;
    command_map["Delete.Node"] = &MeqServer::deleteNode;
    command_map["Resolve.Children"] = &MeqServer::resolveChildren;
    command_map["Get.Node.List"] = &MeqServer::getNodeList;
    command_map["Node.Get.State"] = &MeqServer::getNodeState;
    command_map["Node.Set.State"] = &MeqServer::setNodeState;
    command_map["Node.Execute"] = &MeqServer::getNodeResult;
    
  * For result, vellssets lists:
    Use '#1', "#2', etc. for field names. Shouldn't matter as long
    as record is accessed as [1], [2], etc.
  
  * Changed state record names:
      cache_result
      cache_result_code
    
  * Added node_state to request, see meqrequest() in meqserver.g
  
  * Meq::Parm:
    initrec.table_name!
    initrec.parm_name   (optional, node name used by default)
    
(Changes relative to 08/12/03)
