MEQ in general:

  * Rename getResult() to execute(). Execute() will call getResultImpl
    and such if Cells are present, process the rider otherwise. This will
    make it possible to send up "empty" (command-only) requests
    
  * Map rider to setState(), via configuration classes and such.
  
  * Store nodeindex in node, provie accessor.

  * Delete.All.Nodes command
    
    + automatically add the cells to the ResultSet? Some nodes (Freq,Time)
      are still missing it!
      01/12/03: done in Node.cc (check for cells after getResultImpl,
      insert if none)
    
    + think through writability & privatization issues. Perhaps finally
      implement simple copy-on-write as the default policy in DMI?
      27/11/03: good to go for now. Still thinking about COW.
    
    + ResultSet shows up in Glish with ::dmi_actual_type=datarecord. WTF?
      24/11/03: it got cloned along the way, clone's not implemented, and
      the parent's version produces a DataRecord. To solve this, need to
      clear up this whole writability/privatization shebang, see above.

ResultSet:

  * Check for USE_THREADS when playing with mutexes

      + Remove empty first fail generated by ResultSet(-1) constructor.
      + Should fails be individual results, perhaps?
        01/12/03: yes, done, Result can now be a fail
  
      + test fail propagation: see items below
        24/11/03: done
    
      + In resultConst() and result(), handle uninitalized results in a more 
        clever way. Perhaps not allow them at all, or return a dummy result?
        Actually -- uninitialized results only occur on a FAIL, so perhaps
        automatically clean up the ResultSet when a FAIL is returned?
        24/11/03: yes, implemented it that way

      + Check that FAILs propagate properly.
        24/11/03: should do, testing

      + Add an descriptive error string to the ResultSet when a result is a fail.
        When multiple children fail, concatenate?
        Better yet, construct a fail-record (origin, description, etc.)
        24/11/03: implemented

      + catch exceptions during getResult, return a FAIL.
        24/11/03: implemented

      + cdebug() the result differently when WAIT or FAIL is returned
        24/11/03: OK


Spigot:

  * Allow string specification for correlations

      + Check the situation with test.ms. Be a little less fussy, even with
        technically invalid MSs (in this case, POLARIZATION not filled)
        24/11/03: fughedabottait. Garbage in, garbage out. The problem lies
          with the input agent, anyway. I must know the # of polarizations
          to expect. Easier to edit the MS.

      + Verify proper output from test.ms.
        24/11/03: done, once POLARIZATION has been fixed up.

Request: 

  * when Jan supplied an illegal request (wrong fields, unmatched IDs), the 
    error message was not exactly descriptive

Vells:

  * Vells(DataArray*) constructor: if rank<2 but nelements==1, reform the 
    array (otherwise, won't instantiate from scalars!)

General:

  * Check how a zero-length string or hiid array from Glish shows up in
    AppAgent -- because it looked like a 1-element DataField when 
    processing child specs.
    
  * Figure out why the hell it freezes on a single-CPU machine sometimes. A
    race condition somewhere? NB: a sure way to do it (on zeppelin) seems to
    enable wait_reply=T in the Resolve.Children calls in meqtest.g.

