% -----------------------  Define your Preamble Here 
\documentclass[]{lofar}
\usepackage{layout}

\include{definitions}
%\usepackage{amsmath,amsthm, amsfonts, amssymb, amsxtra,amsopn}
%\usepackage{graphicx}
%\usepackage{float}
%\usepackage{times}
%\usepackage{algorithmic}
\usepackage[dvips]{hyperref}
\usepackage{theorem}
\DeclareGraphicsExtensions{.eps}

\newtheorem{requirement}{Requirement}[subsection]
\newtheorem{assumption}{Assumption}[section]
\newtheorem{prerequisite}[enumi]{Prerequisite}

% ------------------------  End of your preamble.
\begin{document}

  \maketitle

  \begin{abstract}

    \em{The implementation details of a blackboard application
      framework for self calibration in the LOFAR Central Processor}

    For the LOFAR project a self-calibration program shall be
    written. The idea is that this program will have the architectural
    structure of a "BlackBoard". The design and implementation details
    of this application, are described here.
   
  \end{abstract}

  \tableofcontents

  \listoffigures

%  \listoftables

  \section{introduction}
  \label{sec:introduction}\hypertarget{sec:introduction}{}

    \subsection{Purpose of this document}
    \label{subsec:purpose}\hypertarget{subsec:purpose}{}

      This document describes how the Blackboard architectural pattern
      is implemented to fit the needs and requirements for the LOFAR
      self-calibration-application. An demo application has been made,
      and test-runs have been performed in order to get a feeling of
      what is really needed. Those are described in
      \hyperlink{bib:LOFAR-ASTRON-MEM-096}{[LOFAR-ASTRON-MEM-096]}.

    \subsection{context}
    \label{subsec:context}\hypertarget{subsec:context}{}

      This document describes a high-level design of a blackboard
      framework for use in imaging applications within th LOFAR Central
      Processor. It does not contain a design for such an application,
      even though it refers to the self-calibration a lot, it is
      intended to be as generic as possible.

  \section{data storage}
  \label{sec:data-storage}\hypertarget{sec:data-storage}{}

    The major classes of storage requirements are

    \begin{itemize}
      \item parameters
      \item datasets
      \item the strategy
      \item the blackboard logistics
    \end{itemize}

    \subsection{Parameter administration}
    \label{subsec:parameter-administration}\hypertarget{subsec:parameter-administration}{}

      Parameters are solved locally, on subclusters of the LOFAR
      central processor and then distributed or discarded along the
      rest of the cluster.

      \begin{prerequisite}
        A full fledged database management system (DBMS),
        object oriented or relational, must be available.
        \label{pre:dbms}
      \end{prerequisite}

      \begin{prerequisite}
        The DBMS must be able to perform transaction based processing.
        \label{pre:transactions}
      \end{prerequisite}

      \begin{prerequisite}
        The DBMS should support table inheritance.
        \label{pre:table-inheritance}
      \end{prerequisite}

      \begin{requirement}
        There must be a mechanism that can cleverly distribute
        parameters to any interested party upon request by the
        originator.\label{req:parameter-distribution}
      \end{requirement}

      \begin{figure}
        \includegraphics[]{../figures/local-_global-commit.eps}
        \hypertarget{fig:localGlobalCommit}{}
        \caption{a simple topology for a distributed blackboard database\label{fig:localGlobalCommit}}
      \end{figure}

      In the distributed selfcal program, the available cluster will
      be partitioned as well as the data the be calibrated on. several
      sub-clusters will have responsibility over part of the data and
      hence part of the parameters to be calibrated.

      A calibrating cluster is a set of programs running on a (set of)
      node(s), that is doing part of the calibration.  A calibrating
      cluster might use more parameters then it has responsibility
      over. Therefor it must have all parameters to its disposal.

      A calibrating cluster is converging parameters from assumed
      values to corrected values. This converging might go in the
      wrong direction so a set of transactions might be leading to
      invalid results and must not be distributed. It might also lead
      to good results and be approved by a controlling program for
      distribution. The idea is that this program will then close a
      more global transaction, leading to the replication of the data.

      The essence of the requirement is that we have logical
      transactions that have to be nested. The fact that they seem to
      be centered around separate database-engines does not seem to be
      important. We need only one level of nesting.

      \subsubsection{nested cooperative transactions}
      \label{subsubsec:nested-cooperative-transaction}\hypertarget{subsubsec:nested-cooperative-transaction}{}

        One solution for this requirement is that transactions in fact
        can be nested by virtue of the database-vendor. Let's assume
        we only need one level of nesting. However several processes
        with their own connections to the database must be able to
        participate in a single global level transaction.

        \begin{figure}
          \includegraphics[]{../figures/database.eps}
          \hypertarget{fig:database}{}
          \caption{database use in a distributed blackboard\label{fig:database}}
        \end{figure}

        For this nesting to make sense, a database client must be able
        to start a transaction and get an transaction id to distribute
        among co-workers.

        These co-workers can then work on the global transaction, by
        "connecting to" or "joining" a transaction by id. Once joined,
        they can change data within the scope of global
        transaction. This can be as singular operations or as
        transactions. Any changes committed is valid an visible to any
        client joining in the transaction. Once the owner decides so
        he can close the global transaction. This closing can be a
        commit as well as a rollback, both with the expected result.
     
        So should participants be notified of the closing of the
        transaction?  No, they will notice when trying to manipulate
        data.

        \begin{figure}
          \includegraphics[]{../figures/nestedTransaction.eps}
          \hypertarget{fig:nestedTransaction}{}
          \caption{an action sequence that asks for nested transactions\label{fig:nestedTransactions}}
        \end{figure}

      \subsubsection{selective replication}
      \label{subsubsec:selective-replication}\hypertarget{subsubsec:selective-replication}{}%

        Another solution would be to use selective replication. This
        could mean that records will only be replicated after a
        specific trigger. It could also mean that only part of the
        datamodel will be replicated to other engines.

    \subsection{Datasets}
    \label{subsec:Datasets}\hypertarget{subsec:Datasets}{}%

      Datasets are high-volume and intensively queried. Updates are
      mostly copies. Using a database engine would be to much of a
      CPU-cycle and memory hog.

      \begin{assumption}
        There is a measurement-set package in AIPS++ that will be used
        for manipulating measurement data
        \label{ass:aips++}
      \end{assumption}

      \begin{prerequisite}
        A package for manipulation of measurement sets.
        \label{pre:aips++}
      \end{prerequisite}

    \subsection{The strategy}{A high level script}
    \label{subsec:strategy}\hypertarget{subsec:strategy}{}

      The implementation of the strategy is a python script using the
      components defined in the selfcal framework. In the final
      (c++-)implementation of selfcal, the high level control object
      is a process with an embedded python interpreter. It reads the
      script when started and executes it, creating the processes
      needed on the nodes available to the program.

      In an advanced enterprise-pro-gold version the control object
      might supply a GUI to interrupt and/or change the strategy on
      the fly. The database used supplies the possibility to watch
      progress on-line and intervene if needed.

      The in core storage of the script byte be python byte code, but
      it might be a database as well. It must be taken into account
      that user representation for both database and in-core code
      being synchronized and with integrity guaranteed, will be hard
      to implement.

      \begin{figure}
        \includegraphics[]{../figures/strategy_interpreter.eps}
        \hypertarget{fig:strategy_interpreter}{}
        \caption{strategy interpreter\label{fig:strategy_interpreter}}
      \end{figure}

    \subsection{The blackboard logistics}
    \label{subsec:blackboard-logistics}\hypertarget{subsec:blackboard-logistics}{}

      For the blackboard to function several protocols need to be
      described. To guarantee loose coupling between components it is
      not desirable to have the dialogs in these protocols be needing
      real-time message interchange. Therefor a database-based
      approach is chosen, which is described in
      \hyperlink{sec:logistical-datamodel}{Section
      \ref{sec:logistical-datamodel}}.

      \begin{requirement}
        Protocol dialogues should be asynchronous.
        \label{req:asynchronous}
      \end{requirement}

  \section{distributed hierarchical blackboard}
  \label{sec:distributed-hierarchical-blackboard}\hypertarget{sec:distributed-hierarchical-blackboard}{}%

%%       \begin{figure}
%%         \includegraphics[]{../figures/start.usecase.eps}
%%         \hypertarget{fig:start.usecase}{}
%%         \caption{a simplified use-case for a self-calibration run\label{fig:start.usecase}}
%%       \end{figure}

      \begin{figure}
        \includegraphics[]{../figures/main.usecase.eps}
        \hypertarget{fig:main.usecase}{}
        \caption{the main use-cases for the calibration program\label{fig:main.usecase}}
      \end{figure}

    \subsection{distribution over nodes and sub-clusters}
    \label{subsec:distribution}\hypertarget{subsec:distribution}{}%

      For performance reasons we want to divide the measurement data
      over the cluster in a way that distributes the disk-usage and
      minimizes the network-usage.

      Logically there is only one Blackboard. It is a distributed
      application however, each instance dividing it's workload to
      it's own liking. Each blackboard
      \begin{em}\large{Note: }
        no capital here
      \end{em}
      knows what nodes it has to start KnowledgeSources on.

      For this to work it has to be possible to distribute
      responsibility in this fashion as well. For instance; If a
      blackboard has responsibility for a certain time-frame, it must
      be able to change any time dependent parameters at will as long
      as they fall completely in this time frame.
      \begin{em}\large{Note: }Continuity in a function for a parameter over time will pose a problem at the edges of the time frame.\end{em}

    \subsection{Workload distribution}
    \label{subsec:workload-distribution}\hypertarget{subsec:workload-distribution}{}%

      The workload for a self-calibration process, might be
      distributed in several ways. It is a design choice to decide
      that only partitioning to data, as opposed to partitioning to
      parameters, is opportune. This is based on the order of
      magnitude that the volume of data is bigger then the amount of
      parameters. The data has a limited number of dimensions.

      \begin{assumption}
        The number of dimensions in a measurement set is four.
        \label{ass:dimensions}
      \end{assumption}

      \begin{assumption}
        Data can be partitioned over the dimensions in the dataset,
        without disturbing the self-calibration process.
        \label{ass:partitioning}
      \end{assumption}

      These are.

      \begin{itemize}

        \item 

          time

	\item 

          frequency

	\item 

          baseline

	\item 

          observatory-direction or field.

      \end{itemize}

      The Blackboard will be configured to delegate tasks to children,
      divided along one of these dimensions.

      \begin{assumption}
        It isn't necessary to divide along a dimension more then once.
        \label{ass:devision}
      \end{assumption}

    \subsection{components}
    \label{subsec:components}\hypertarget{subsec:components}{}

      \subsubsection{controllers}
      \label{subsubsec:controllers}\hypertarget{subsubsec:controllers}{}

        A Blackboard has a controller that can be asked to start a
        process for a blackboard. Such a process can be a
        child-blackboard including its controller, or one of the
        knowledge sources associated with the blackboard.

      \subsubsection{watchers}
      \label{subsubsec:watchers}\hypertarget{subsubsec:watchers}{}

        \paragraph{simple watchers}
        \label{par:simple-watchers}\hypertarget{par:simple-watchers}{}
          \begin{figure}
            \includegraphics[]{../figures/watch.eps}
            \hypertarget{fig:watchers}{}
            \caption{The case that a watcher decides to advice
            abandoning a solution thread.\label{fig:watchers}}
          \end{figure}

          A watcher polls for changes in a couple of solution
          threads. It might decide that one of them is remarkably more
          sound then the others(see
          hyperlink{fig:watchers}{[\ref{fig:watchers}]}).

          Usually it will have to decide that it can't decide yet.

          \begin{requirement}
            A watcher has to be able to make a tristate decision on
            which of two threads is leading to desirable results.
            \label{req:no-decision}
          \end{requirement}

        \paragraph{more complex watchers}
        \label{par:complex-watchers}\hypertarget{par:complex-watchers}{}

          More complex watcher could decide that the results of two or
          more threads should be merged.

          \begin{requirement}
            A watcher should be able to see a possibility to merge the
            results of two solution threads.
            \label{req:merge}
          \end{requirement}

  \section{logistical database}
  \label{sec:logistical-datamodel}
  \hypertarget{sec:logistical-datamodel}{}

    \subsection{Workload distribution}
    \label{subsec:workload-distribution-2}\hypertarget{subsec:workload-distribution-2}{}

      The data, resulting from an observation will be several TB in
      volume
      \hyperlink{LOFAR-ASTRON-MEM-035}{[LOFAR-ASTRON-MEM-035]}. To
      conveniently handle this it will have to be partitioned. To
      handle part of the data a specialised sub-cluster will be
      defined. (see \hyperlink{subcluster}{Figure 1}).

      \begin{figure}
        \includegraphics[]{../figures/bb.subcluster.eps}
        \hypertarget{fig:bb.subcluster}{}
        \caption{the layout of a self-calibration sub-cluster.\label{fig:bb.subcluster}}
      \end{figure}

      As a result of this partitioning the Blackboard will be
      responsible for a subset of the data. This it will know:

      \{self\}1, \{parent-id\}1, \{range\}1

      \begin{itemize}

        \item 

          "self" is the id of this blackboard.

        \item 

          "parent\_id" is the obvious.

        \item 

          "range" is the set of values that defines the dataset used
          for solving parameters.

      \end{itemize}

      the range can vary over several dimensions

      \{time\}1, \{frequency\}1, \{interferometers\}1, \{direction\}1

      \begin{itemize}

	\item 

          "time" is a time range this blackboard is concerned with.
          \begin{assumption}
            There are no time-gaps in a measurement set.
            \label{ass:time-gaps}
          \end{assumption}

	\item 

          "frequency" is the frequency range or band this blackboard
          is concerned with.

          \begin{assumption}
            There is a single continuous band of frequencies in a
            measurement set.
            \label{ass:one-band}
          \end{assumption}

	\item 

          "interferometers" is the set of baselines that this
          BlackBoard is responsible for.

	\item 

          "directions" is a range of points in the sky that function
          as field-centers.

      \end{itemize}

      If for some reason it is considered that on one of the
      dimensions the range to evaluate is to large to do in one step,
      the Blackboard can ask it's BlackBoardController to spawn
      children. The Blackboard will have to know what children it has:

      \{child-id\}1, \{self\}1, \{range\}1

      For all of "time" through "objects" goes that they are a subset
      of the parents fields with the same name.

    \subsection{Workload level}
    \label{subsec:workload-level}\hypertarget{subsec:workload-level}{}%

      The idea is that several analysis threads can exist
      simultaneously. In each of these threads several processes are
      active. In our blackboard model we have the following
      Knowledge-Sources

      \begin{itemize}

	\item 

          A SelfCalEngine. Which contains processes at several
          nodes. There are a solve process and an array of predict
          processes.

	\item 

          A SelfCalController starts engines and forks new
          child-threads if opportune.

	\item 

          A SelfCalWatcher that monitors threads and decides on what
          is or is not a dead end.

      \end{itemize}

      All three have their controlling BB tables.

      \subsubsection{SelfcalEngine}
      \label{subsubsec:SelfcalEngine}\hypertarget{subsubsec:SelfcalEngine}{}

        A SelfcalEngine solves for a set of parameters based on part
        of the data.

        A SelfcalEngine writes a record with globally the following
        structure.

        \{meta-data\}1, \{next-action-type\}1, \{quality\}1, \{p-name, p-value, p-delta\}1-*

        meta-data will contain:

        \{workload-id\}1, \{engine-id\}1, \{controller-id\}1, \{parent-id\}1, \{range\}1

        \begin{itemize}

	  \item 

            the id for the SelfcalEngine that produced the result.

	  \item 

            the id for the SelfcalController that created the workload.

	  \item 

            The parent id of this workload. This could be a thread-id
            or the id of another workload.

	  \item 

            The time that the data was captured.

	  \item 

            The frequency-range examined.

        \end{itemize}

      \subsubsection{SelfcalController}
      \label{subsubsec:SelfcalController}\hypertarget{subsubsec:SelfcalController}{}

        A SelfcalController writes records of workloads like the
        SelfcalEngine, except the it does give a quality and it
        doesn't write the SelfcalEngine id. An engine writes its id in
        a record as it accepts it and starts the associated
        calculation. When it is finished it writes the deltas for all
        parameters and the quality.

        A SelfcalController decides what the next step in a analysis
        path should be. The range might be smaller then that of the
        parent dataset.

        \{controller-id\}1, \{strategy-description\}1, \{range\}1, \{child-id\}0-*

      \subsubsection{SelfcalWatcher}
      \label{subsubsec:SelfcalWatcher}\hypertarget{subsubsec:SelfcalWatcher}{}

        A SelfcalWatcher has to have access to the records of the
        engines. It has a domain to watch containing several analysis
        threads.

        \{watcher-id\}1 \{controller-id\}2-*

  \section{to do}
  \label{sec:todo}\hypertarget{sec:todo}{}

    Whether in code or in configuration, it should be easy to adjust
    the BlackBoard. This should result in a different
    state-machine. An interface has to be written for that. It will
    include definitions of preconditions, postconditions and
    quality-of-results types for different knowledge-sources.

    All of this can be hard-coded in c++, as long as it is easy to
    write and in the first place efficient to run.

    \subsection{extra figures}
    \begin{figure}
      \includegraphics[]{../figures/control-hierarchy.eps}
    \end{figure}

    \subsection{extra figures}
    \begin{figure}
      \includegraphics[]{../figures/fork.eps}
    \end{figure}

    \subsection{extra figures}
    \begin{figure}
      \includegraphics[]{../figures/solve-step.eps}
    \end{figure}

    \subsection{extra figures}
    \begin{figure}
      \includegraphics[]{../figures/strategy-distribution.eps}
    \end{figure}

\newcommand{\dbappendix}[1]{\section{#1}}%

\appendix

  \dbappendix{assumptions}
  \label{app:assumptions}\hypertarget{app:assumptions}{}

    \begin{itemize}
      \item [\ref{ass:aips++}]There is a measurement-set package in
        AIPS++ that will be used for manipulating measurement data.
      \item [\ref{ass:dimensions}]The number of dimensions in a
        measurement set is four.
      \item [\ref{ass:partitioning}]Data can be partitioned over the
        dimensions in the dataset, without disturbing the
        self-calibration process.
      \item [\ref{ass:devision}]It isn't necessary to divide along a
        dimension more then once.
      \item [\ref{ass:time-gaps}]There are no time-gaps in a
        measurement set.
      \item [\ref{ass:one-band}]There is a single continuous band of
        frequencies in a measurement set.
    \end{itemize}

  \dbappendix{prerequisites}
  \label{app:prerequisites}\hypertarget{app:prerequisites}{}

    \begin{itemize}
      \item [\ref{pre:dbms}]A full fledged database management system
        (DBMS), object oriented or relational, must be available.
      \item [\ref{pre:transactions}]The DBMS must be able to perform
        transaction based processing.
      \item [\ref{pre:table-inheritance}]The DBMS should support table
        inheritance.
      \item [\ref{pre:aips++}]A package for manipulation of
        measurement sets.
    \end{itemize}

  \dbappendix{requirements-list}
  \label{app:requirements-list}\hypertarget{app:requirements-list}{}%

    \begin{itemize}
      \item [\ref{req:parameter-distribution}]There must be a
        mechanism that can cleverly distribute parameters to any
        interested party upon request by the originator.
      \item [\ref{req:asynchronous}]The protocol dialogs, for the
        communications between BlackBoard components, should be
        asynchronous.
      \item [\ref{req:no-decision}]A simple watcher has to be able to
        make a tristate decision on which of two threads is leading to
        desirable results.
      \item [\ref{req:merge}]A watcher should be able to see a
        possibility to merge the results of two solution threads.
    \end{itemize}

  \dbappendix{revision log}
  \label{app:revision-log}\hypertarget{app:revision-log}{}%

    Hand copy log entries from the cvs log, or make up your own.

    \begin{itemize}

      \item 

        Revision 1.1 2003/06/18 12:06:25 daan

        initial version containing:
        \begin{itemize}

	  \item 

            storage requirements.

        \end{itemize}

    \end{itemize}

  \bibliography{}
  \begin{thebibliography}{WIDELABEL}

    \bibitem[LOFAR-ASTRON-MEM-035]{LOFAR-ASTRON-MEM-035}
      \emph{CEP Requirements Analysis, Architectural Design and
      Description} , Kjeld van der Schaaf, Copyright \copyright{} 2002
      ASTRON. \label{LOFAR-ASTRON-MEM-035}

    \bibitem[LOFAR-ASTRON-MEM-096]{LOFAR-ASTRON-MEM-096}
      \emph{The use of the Blackboard architectural pattern, in the LOFAR Central Processor, for the selfcal control system},
      D.\ Hoogland,
      Copyright \copyright{} 2003 ASTRON.
      \label{LOFAR-ASTRON-MEM-096}

  \end{thebibliography}

\end{document}
