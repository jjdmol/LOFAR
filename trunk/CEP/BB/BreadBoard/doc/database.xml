<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
 "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" 
 >

<!-- $Id$ -->
<!-- look at bottom for revision Log. -->

<article lang="en">
 <artheader>
  <title>nested transactions</title>
  <subtitle>an extreme database requirement for the use of the Blackboard
  architecture in the selfcal imaging application in LOFAR</subtitle>
  <author>
   <firstname>Daan</firstname>
   <surname>Hoogland</surname>
  </author>
  <releaseinfo>
   <para>
    $Id$
   </para>
  </releaseinfo>

  <!-- makes a summary from the content -->
  <abstract>
   <para>

    For the LOFAR project a self-calibration program shall be
    written. The idea is that this program will have the architectural
    structure of a "BlackBoard". The Blackboard itself will be
    distributed however. Therefor the database used must fulfill some
    special requirements.

   </para>
   <para>

    This document is no longer maintained. See
    &quot;LOFAR/CEP/BB/doc/selfcal-implementation.xml&quot;.

   </para>
  </abstract>
 </artheader>

 <section>
  <title>the design concept</title>
  <mediaobject>
   <imageobject>
    <imagedata fileref="local-_global-commit.png" format="PNG" />
    </imageobject>
   <caption>a simple topology for a distributed blackboard database</caption>
  </mediaobject>

  <para>

   In the distributed selfcal program, the available cluster will be
   partitioned as well as the data the be calibrated on. several
   sub-clusters will have responsibility over part of the data and hence
   part of the parameters  to be calibrated.

  </para>

  <para>

   A calibrating cluster is a set of programs running on a (set of)
   node(s), that is doing part of the calibration.
   A calibrating cluster might use more parameters then it has
   responsibility over. Therefor it must have all parameters to its
   disposal.

  </para>

  <para>

   A calibrating cluster is converging parameters from assumed values
   to corrected values. This converging might go in the wrong direction
   so a set of transactions might be leading to invalid results and
   must not be distributed. It might also lead to good results and be
   approved by a controlling program for distribution. The idea is that
   this program will then close a more global transaction, leading to
   the replication of the data.

  </para>

 </section>

 <section>
  <title>nested transactions</title>

  <para>

   One solution for this requirement is that transactions can be
   nested. The fact that they seem to be centered around separate
   engines does not seem to be important. We need only one level of
   nesting. However several processes with their own connections to
   the database must be able to participate in a single global level
   transaction.

  </para>

  <mediaobject>
   <imageobject>
    <imagedata fileref="database.png" format="PNG" />
    </imageobject>
   <caption>the action sequence that asks for nested transactions</caption>
  </mediaobject>

  <para>

   For this nesting to make sense, a database client must be able to
   start a transaction and get an transaction id to distribute among
   co-workers.

  </para>

  <para>

   These co-workers can then work on the global transaction, by
   &quot;"connecting to"&quot; or &quot;"joining"&quot; a transaction
   by id. Once joined, they can change data within the scope of global
   transaction. This can be as singular operations or as
   transactions. Any changes committed is valid an visible to any
   client joining in the transaction. Once the owner decides so he can
   close the global transaction. This closing can be a commit as well
   as a rollback, both with the expected result.

   <note>

    <para>

     Should participants be notified of the closing of the transaction?

    </para>

    <para>

     No, they will notice when trying to manipulate data.

    </para>

 ` </note>

  <mediaobject>
   <imageobject>
    <imagedata fileref="nestedTransaction.png" format="PNG" />
    </imageobject>
   <caption>sample sequence of a nested transaction</caption>
  </mediaobject>

  </para>

 </section>

 <section>
  <title>selective replication</title>

  <para>

   Another solution would be to use selective replication. This could
   mean that records will only be replicated after a specific
   trigger. It could also mean that only part of the datamodel will be
   replicated to other engines.

  </para>

 </section>

</article>