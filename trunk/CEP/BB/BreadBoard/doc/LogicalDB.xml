<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
 "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" 
 >

<!-- $Id$ -->
<!-- look at bottom for revision Log. -->
<article lang="en">
 <artheader>
  <title></title>
  <author>
   <firstname>Daan</firstname>
   <surname>Hoogland</surname>
  </author>
  <releaseinfo>
   <para>
    $Id$
   </para>
  </releaseinfo>

  <!-- makes a summary from the content -->
  <abstract>
   <para>

    Herein the logical database model is described, as it is to be
    used by the blackboard pattern for the SelfCal application of
    LOFAR.

   </para>
   <para>

    This document is no longer maintained. See
    &quot;LOFAR/CEP/BB/doc/selfcal-implementation.xml&quot;.

   </para>
  </abstract>
 </artheader>

 <bibliography>
  <title>References</title>

  <bibliodiv>
   <title>LOFAR documentation</title>

   <biblioentry id="LOFAR-ASTRON-MEM-035" >
    <title>CEP Requirements Analysis, Architectural Design and Description</title>
    <author>
     <surname>Schaaf</surname>
     <firstname>Kjeld</firstname>
     <othername>van der</othername>
    </author>
    <copyright>
     <year>2002</year>
     <holder>ASTRON</holder>
    </copyright>
   </biblioentry>

  </bibliodiv>

 </bibliography>

 <section>

  <title>Workload distribution</title>
  <para>

   The data, resulting from an observation will be several TB in
   volume <xref linkend="LOFAR-ASTRON-MEM-035" />. To
   conveniently handle this it will have to be partitioned. To handle
   part of the data a specialized sub-cluster will be defined. (see <link
   linkend="subcluster" >Figure 1</link>).

  </para>

   <mediaobject id="subcluster">
    <imageobject>
     <imagedata fileref="bb.subcluster.png" format="PNG" />
    </imageobject>
    <caption>Figure 1: an example subcluster</caption>
   </mediaobject>

  <para>

   As a result of this partitioning the Blackboard will be responsible
   for a subset of the data. This it will know:

  </para>
  <para>

   {self}1, {parent-id}1, {range}1

   <itemizedlist>
    <listitem>
     <para>

      "self" is the id of this blackboard.

     </para>
    </listitem>
    <listitem>
     <para>

      "parent_id" is the obvious.

     </para>
    </listitem>
    <listitem>
     <para>

      "range" is the set of values that defines the dataset used for
      solving parameters.

     </para>
    </listitem>
   </itemizedlist>

  </para>
  <para>

   the range can vary over several dimensions

  </para>
  <para>

   {time}1, {frequency}1, {interferometers}1, {direction}1
   <itemizedlist>
    <listitem>
     <para>

      "time" is a time range this blackboard is concerned
      with. <note>We'll assume no time-gaps for now.</note>

     </para>
    </listitem>
    <listitem>
     <para>

      "frequency" is the frequency range or band this blackboard is
      concerned with.  <note>We'll assume a single continuous band for
      now.</note>

     </para>
    </listitem>
    <listitem>
     <para>

      "interferometers" is the set of baselines that this BlackBoard is
      responsible for.

     </para>
    </listitem>
    <listitem>
     <para>

      "directions" is a range of points in the sky that function as
      field-centers.

     </para>
    </listitem>
   </itemizedlist>

  </para>
  <para>

   If for some reason it is considered that on one of the dimensions
   the range to evaluate is to large to do in one step, the Blackboard
   can ask it's BlackBoardController to spawn children. The Blackboard
   will have to know what children it has:

  </para>
  <para>

   {child-id}1, {self}1, {range}1

  </para>
  <para>

   For all of "time" through "objects" goes that they are a subset of
   the parents fields with the same name.

  </para>


 </section>

 <section>
  <title>Workload level</title>
  <para>

   The idea is that several analysis threads can exist
   simultaneously. In each of these threads several processes are
   active. In our blackboard model we have the following
   Knowledge-Sources

   <itemizedlist>
    <listitem>
     <para>

      A SelfCalEngine. Which contains processes at several
      nodes. There are a solve process and an array of predict
      processes.

     </para>
    </listitem>
    <listitem>
     <para>

      A SelfCalController starts engines and forks new child-threads
      if opportune.

     </para>
    </listitem>
    <listitem>
     <para>

      A SelfCalWatcher that monitors threads and decides on what is or
      is not a dead end.

     </para>
    </listitem>
   </itemizedlist>


   All three have their controlling BB tables.

   <section>
    <title>SelfcalEngine</title>
    <para>

     A SelfcalEngine solves for a set of parameters based on part of the data.

    </para>
    <para>

     A SelfcalEngine writes a record with globally the following
     structure.

    </para>
    <para>

     {meta-data}1, {next-action-type}1, {quality}1, {p-name, p-value, p-delta}1-*

    </para>
    <para>

     meta-data will contain:

    </para>
    <para>

     {workload-id}1, {engine-id}1, {controller-id}1, {parent-id}1, {range}1

     <itemizedlist>
      <listitem>
       <para>

        the id for the SelfcalEngine that produced the result.

       </para>
      </listitem>
      <listitem>
       <para>

        the id for the SelfcalController that created the workload.

       </para>
      </listitem>
      <listitem>
       <para>

        The parent id of this workload. This could be a thread-id or
        the id of another workload.

       </para>
      </listitem>
      <listitem>
       <para>

        The time that the data was captured.

       </para>
      </listitem>
      <listitem>
       <para>

        The frequency-range examined.

       </para>
      </listitem>
     </itemizedlist>

    </para>

   </section>

   <section>
    <title>SelfcalController</title>
    <para>

     A SelfcalController writes records of workloads like the
     SelfcalEngine, except the it does give a quality and it doesn't
     write the SelfcalEngine id. An engine writes its id in a record
     as it accepts it and starts the associated calculation. When it
     is finished it writes the deltas for all parameters and the
     quality.

    </para>
    <para>

     A SelfcalController decides what the next step in a anaysis path
     should be. The range might be smaller then that of the parent
     dataset.

    </para>
    <para>

     {controller-id}1, {strategy-description}1, {range}1, {child-id}0-*

    </para>
   </section>
   <section>
    <title>SelfcalWatcher</title>
    <para>

     A SelfcalWatcher has to have access to the records of the
     engines. It has a domain to watch containing several analysis
     threads.

    </para>
    <para>

     {watcher-id}1 {controller-id}2-*

    </para>
   </section>
  </para>
 </section>

</article>