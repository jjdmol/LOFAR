<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
 "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" 
 >

<!-- $Id$ -->
<!-- look at bottom for revision Log. -->
<article lang="nl">
 <artheader>
  <title></title>
  <author>
   <firstname>Daan</firstname>
   <surname>Hoogland</surname>
  </author>
  <releaseinfo>
   <para>
    $Id$
   </para>
  </releaseinfo>

  <!-- makes a summary from the content -->
  <abstract>
   <para>

    Herein the logical database model is described, as it is to be
    used by the blackboard pattern for the SelfCal application of
    LOFAR.

   </para>
  </abstract>
 </artheader>

 <bibliography>
  <title>References</title>

  <bibliodiv>
   <title>LOFAR documentation</title>

   <biblioentry id="LOFAR-ASTRON-MEM-035" >
    <title>CEP Requirements Analysis, Architectural Design and Description</title>
    <author>
     <surname>Schaaf</surname>
     <firstname>Kjeld</firstname>
     <othername>van der</othername>
    </author>
    <copyright>
     <year>2002</year>
     <holder>ASTRON</holder>
    </copyright>
   </biblioentry>

  </bibliodiv>

 </bibliography>

 <section>

  <title>Workload distribution</title>
  <para>

   The data, resulting from an observation will be several TB in
   volume <xref linkend="LOFAR-ASTRON-MEM-035" />. To
   conveniently handle this it will have to be partitioned. To handle
   part of the data a specialized sub-cluster will be defined. (see <link
   linkend="subcluster" >Figure 1</link>).

  </para>

   <mediaobject id="subcluster">
    <imageobject>
     <imagedata fileref="bb.subcluster.png" format="PNG" />
    </imageobject>
    <caption>Figure 1: an example subcluster</caption>
   </mediaobject>

  <para>

   As a result of this partitioning the Blackboard will be responsible
   for a subset of the data. This it will know:

  </para>
  <para>

   {self}1, {parent-id}1, {time}1, {frequency}1, {field}1, {beams}1

  </para>
  <para>

   If for some reason it is considered that on one of the dimensions
   the range to evaluate is to large to do in one step, the Blackboard
   can ask it's BlackBoardController to spawn children. The Blackboard
   will have to know what children it has:

  </para>
  <para>

   {child-id}1, {self}1, {time}1, {frequency}1, {field}1, {beams}1

  </para>

 </section>

 <section>
  <title>Workload level</title>
  <para>

   The idea is that several analysis threads can exist
   simultaneously. In each of these threads several processes are
   active. In our blackboard model we have the following
   Knowledge-Sources

   <itemizedlist>
    <listitem>
     <para>

      A SelfCalEngine. Which contains processes at several
      nodes. There are a solve process and an array of predict
      processes.

     </para>
    </listitem>
    <listitem>
     <para>

      A SelfCalController starts engines and forks new child-threads
      if opportune.

     </para>
    </listitem>
    <listitem>
     <para>

      A SelfCalWatcher that monitors threads and decides on what is or
      is not a dead end.

     </para>
    </listitem>
   </itemizedlist>


   All three have their controlling BB tables.

   <section>
    <title>SelfcalEngine</title>
    <para>

     A SelfcalEngine looks for a set of parameters on part of the data.

    </para>
    <para>

     A SelfcalEngine writes a record with globally the following
     structure.

    </para>
    <para>

     {meta-data}1, {next-action-type}1, {Quality}1, {p-name, p-value, p-delta}1-*

    </para>
    <para>

     meta-data will contain:

    </para>
    <para>

     {workload-id}1, {engine-id}1, {controller-id}1, {parent-id}1, {time}1, {frequency}1, {field}1, {beams}1

     <itemizedlist>
      <listitem>
       <para>

        the id for the SelfcalEngine that produced the result.

       </para>
      </listitem>
      <listitem>
       <para>

        the id for the SelfcalController that created the workload.

       </para>
      </listitem>
      <listitem>
       <para>

        The parent id of this workload. This could be a thread-id or
        the id of another workload.

       </para>
      </listitem>
      <listitem>
       <para>

        The time that the data was captured.

       </para>
      </listitem>
      <listitem>
       <para>

        The frequency-range examined.

       </para>
      </listitem>
     </itemizedlist>

    </para>

   </section>

   <section>
    <title>SelfcalController</title>
    <para>

     A SelfcalController writes records of workloads like the
     SelfcalEngine, except the it does give a quality and it doesn't
     write the SelfcalEngine id. An engine writes its id in a record
     as it accepts it and starts the associated calculation. When it
     is finished it writes the deltas for all parameters and the
     Quality.

    </para>
    <para>

     A SelfcalController decides what the next step in a anaysis path
     should be.

    </para>
    <para>

     {controller-id}1, {strategy-description}1, {child-id}0-*

    </para>
   </section>
   <section>
    <title>SelfcalWatcher</title>
    <para>

     A SelfcalWatcher has to have access to the records of the
     engines. It has a domain to watch containing several analysis
     threads.

    </para>
    <para>

     {watcher-id}1 {controller-id}2-*

    </para>
   </section>
  </para>
 </section>

</article>