# Include useful macros
include(LofarMacros)

# First check to see whether we need to update our CMakeLists.txt files.

# Generate version program source file
execute_process(COMMAND ${CMAKE_MODULE_PATH}/makeversion
  WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
  RESULT_VARIABLE result)
if(result)
  message(SEND_ERROR "makeversion failed!")
endif(result)

# Create FillPackage__VersionInc.h
file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/FillPackage__VersionInc.h"
  "/* Generated by CMake for project ${PROJECT_NAME} */\n\n")
foreach(dep ${${PROJECT_NAME}_DEPENDENCIES})
  file(APPEND "${CMAKE_CURRENT_BINARY_DIR}/FillPackage__VersionInc.h"
    "#include <${dep}/Package__Version.h>\n")
endforeach(dep ${${PROJECT_NAME}_DEPENDENCIES})

# Create FillPackage__VersionFunc.h
lofar_get_date(date)
lofar_get_hostname(hostname)
file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/FillPackage__VersionFunc.h"
  "/* Generated by CMake for project ${PROJECT_NAME} */\n\n"
  "namespace LOFAR {\n"
  "  std::string ${PROJECT_NAME}Version::getBuildTime()\n"
  "  { return \"${date}\"; }\n"
  "  std::string ${PROJECT_NAME}Version::getBuildUser()\n"
  "  { return \"$ENV{USER}\"; }\n"
  "  std::string ${PROJECT_NAME}Version::getBuildMachine()\n"
  "  { return \"${hostname}\"; }\n"
  "  void ${PROJECT_NAME}Version::fillInfo\n"
  "    (int level, std::vector<Version::PkgInfo>& vec)\n"
  "  {\n"
  "    // Add info of this package if needed.\n"
  "    vec.push_back (Version::PkgInfo(level, &getInfo));\n"
  "    // Add info of packages being used.\n")
foreach(dep ${${PROJECT_NAME}_DEPENDENCIES})
  file(APPEND "${CMAKE_CURRENT_BINARY_DIR}/FillPackage__VersionFunc.h"
    "    ${dep}Version::fillInfo (level+1, vec);\n")
endforeach(dep ${${PROJECT_NAME}_DEPENDENCIES})
file(APPEND "${CMAKE_CURRENT_BINARY_DIR}/FillPackage__VersionFunc.h"
  "  }\n"
  "}\n")

# Add current binary directory to compiler's include path, so that the
# generated header files can be found during compilation.
include_directories(${CMAKE_CURRENT_BINARY_DIR})
