\documentclass{article}

% opencl uitzoeken


% zoek parallelisme: onafhankelijke berekeningen
% voor de correlator geldt dat de berekiningen onafhankelijk zijn, maar IO niet!
% met many cores is de I/O vaak de bottleneck


%% pas je algorithmen aan op many-cores


%% 1) zoek parallelisme in je algorithme.
%%    vaak aanwezig. Zoek onafhankelijke operaties:
%%     voorbeelden:
%%    - correlator: kanalen, polatisaties, subbanden zijn onafhankelijk.
%%    - polyphase: stations zijn onafhankelijk
%%    - imaging: maak parallelisme: beeld elk kanaal af op een image, tel deze later op

  
%% 2) mem bw/ops neemt af met many cores
%%    optimaliseer.

%% dus optimaliseren: 
%%     - algo specifiek (reduceer mem loads)
%%     - architectuur-specifieke optimalisaties (cache gedrag, delays, floating point instructions)

%% manycores ondersteunen complex niet erg goed. Alleen BG/P wel.
%% Vaak de reals en de imags in aparte arrays stoppen.

\usepackage{spconf}
\usepackage{graphicx}
\usepackage{listings}

\title{How to Build a Correlator on Many-Core Hardware}

\name{Rob V. van Nieuwpoort and John W. Romein}
%\texttt{\{nieuwpoort,romein\}@astron.nl}}

\address{Stichting ASTRON (Netherlands Institute for Radio Astronomy) \\
Oude Hoogeveensedijk 4 \\
7991 PD\ \ Dwingeloo \\
The Netherlands}


\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}
% wat gaat de lezer leren van dit paper?

% we geven een leidraad voor het kiezen van de juiste architectuur voor het probleem van de lezer
% voor goede performance heb je nodig:
%  - kennis van algorithme
%  - kennis van de architecturen
%  - inzicht over hoe je de mapping van algorithme op architectuur het beste kunt doen
% dit paper geeft inzicht in de verschillen tussen architecturen, en inzicht over welke factoren belangrijk zijn om de mapping goed te doen.

Radio telescopes produce enormous amounts of data.
The Low Frequency Array (LOFAR) stations~\cite{Butcher:04,deVos:09}, for
instance, will produce some tens of petabits per day; the dishes from the
Australian SKA Pathfinder (ASKAP) will even produce over six exabits per day.
To extract the sky signal from the system noise, the \emph{correlator\/}
correlates the signals by multiplying the samples of each pair of receivers.
Additionally, the correlator integrates correlations over time, to reduce
the amount of data.

Typically, custom-built hardware is used to correlate the signals.
A recent development is to use a supercomputer~\cite{Romein:06,Romein:09b}.
Both approaches have important advantages and disadvantages.
Custom-built hardware is efficient and consumes modest amounts of power, but is
inflexible, expensive to design, and has a long development time.
Solutions that use a supercomputer are much more flexible, but are less
efficient, consume more power, and are expensive to purchase.
Future instruments, like the Square Kilometre Array (SKA), need several orders
of magnitude more computational resources.
It is likely that the requirements of the SKA cannot be met by using
current supercomputer technology.

During the past ten years, the high-performance computing community has
steadily adopted clusters of Graphics Processor Units (GPUs) as a viable
alternative to supercomputers, due to their unparalleled growth in
computational performance, increasing flexibility, increasing programmability,
relatively high power efficiency, and low purchase costs.
High-end GPUs are highly parallel and contain hundreds of processor cores.
However, their usefulness is often limited to applications that do not require
double-precision floating-point arithmetics, since there is no need for
double-precision calculations to play games.
Hence, the support for double-precision arithmetic is typically poor.
Fortunately, many signal-processing applications do not require double
precision.

In this article, we explain how modern multi-core architectures can be fully
exploited for signal-processing purposes.
Additionally, we give insights into their architectural limitations, and how
to best cope with them.
We treat five different, popular multi-core architectures: the IBM Cell
Broadband Engine, GPUs from Nvidia and ATI, the IBM Blue Gene/P, and
the Intel Core i7 processors.
We discuss their similarities and differences, and how the architectural
differences affect optimization choices and the eventual performance of a
correlator.
We strongly focus on correlators, but many of the findings, claims, and
optimizations hold for other signal-processing algorithms as well, both in the
area of radio astronomy and abroad.
We discuss the programmability of each of the architectures, but this paper
should be of special interest to those who are willing to put some extra
programming effort to obtain good performance, even if high-level programming
support is not available.


\section{Novel trends in modern radio astronomy}
    - LOFAR, SKA


\section{Correlating signals}

\begin{figure*}[t]
\begin{center}
\includegraphics[width=12cm]{figures/processing-overview.pdf}
\end{center}
\vspace{-0.5cm}
\caption{An extremely simplified view of LOFAR processing.}
\label{fig-processing-overview}
\end{figure*}

We call a set of receivers that are grouped closely
together a \emph{station}. The data streams from the different
stations must be filtered, delays in the signal path must be
compensated for, and the data streams from different stations must be
cross-correlated. The correlation process performs a data reduction by
integrating samples over time. In this paper, we use the LOFAR
telescope as an example, but the results apply equally well
to other instruments. An overview of the processing needed for the
standard imaging pipeline of LOFAR is shown in
Figure~\ref{fig-processing-overview}. The pipeline runs from left to right.
The thickness of the lines indicates the size of the data streams.
In this paper, we focus on the
correlator step (the gray box in
Figure~\ref{fig-processing-overview}), because its costs grow
quadratically with the number of stations. All other steps have a
lower time complexity. We choose 64 as the number of stations, since
that is a realistic number for LOFAR.  Future instruments will likely
have even more stations. We call the combination of two stations a
\emph{baseline}.  The total number of baselines is $(nrStations \times
(nrStations + 1)) / 2$, since we need each pair of correlations only
once. This includes the autocorrelations (the correlation of a station with itself),
since we need this later in the pipeline for calibration purposes.
Although the autocorrelations can be computed with fewer instructions, we 
ignore this here, since the number of autocorrelations is small, and grows
linearly with the number of stations, while the number of normal correlations
grows quadratically.
The correlator algorithm itself is straightforward, and can be
written in a single formula:
$C_{s_1,s_2\geq s_1,p_1\in\{X,Y\},p_2\in\{X,Y\}} = \displaystyle\sum_{t} Z_{s_1,t,p_1} * Z_{s_2,t,p_2}^\ast$ 


\begin{figure*}[t]
\lstset{language=C,basicstyle={\fontencoding{T1}\fontfamily{pcr}\fontseries{m}\fontshape{n}\fontsize{7}{10pt}\selectfont}} 
\begin{lstlisting}{}
for (ch=0; ch<nrChannels; ch++)
  for (station2=0; station2<nrStations; station2++)
    for (station1=0; station1<=station2; station1++)
      for (polarization1 = 0; polarization1 < nrPolarizations; polarization1++)
        for (polarization2 = 0; polarization2 < nrPolarizations; polarization2++) {
          complex float sum = 0 + i*0;
          for (time=0; time < integrationTime; time++)
            sum += samples[ch][station1][time][polarization1] * ~samples[ch][station2][time][polarization2];
          baseline = computeBaseline(station1, station2);
          correlation[baseline][ch][polarization1][polarization2] = sum;
        }
\end{lstlisting}
\vspace{-0.5cm}
\caption{Pseudo code for the correlation algorithm.}
\label{correlator-code}
\end{figure*}

Pseudo code for the algorithm is shown in Figure~\ref{correlator-code}.
A sample is a ($2 \times 32-bit$) complex number that represents the
amplitude and phase of a signal at a particular time. The receivers
are polarized; they take separate samples from orthogonal (X and Y)
directions. The received signals from sky sources are so weak, that the antennas 
mainly receive noise. To see if there is statistical coherence
in the noise, simultaneous samples of each pair of stations are correlated, 
by multiplying the sample of one station with the complex
conjugate (i.e., the imaginary part is negated) of the sample of the other station.
To reduce the output size, the products are integrated, by accumulating all products. 
Stations are also autocorrelated, i.e., with
themselves. Both polarizations of a station A are correlated with both polarizations 
of a station B, yielding correlations in XX, XY, YX, and YY
directions.
The correlator is mostly multiplying and adding complex numbers.

We can implement the correlation operation very efficiently, with only
four fma instructions, doing eight floating-point operations in
total. For each pair of stations, we have to do this four times, once
for each combination of polarizations. Thus, in total we need 32
operations and load 8 floats (32 bytes) from memory, resulting in \emph{exactly
  one FLOP/byte}.  The number of operations that is performed per byte
that has to be loaded from main memory is called the \emph{arithmetic
  intensity}~\cite{system-performance}. For the correlation algorithm,
the arithmetic intensity is extremely low.



\section{Many-core architectures}

In this section, we briefly explain key properties of six different
architectures with multiple cores.  We focus on the differences
between the systems that are relevant for signal processing
applications.

\subsection{General Purpose multi-core CPU}

As a reference, we implemented the correlator on a multi-core general
purpose architecture, a quad core Intel Core~i7 CPU.  There is 32~KB
of on-chip L1 data cache per core, 256~KB L2 cache per core, and 8~MB
of shared L3 cache.  The theoretical peak performance of the system is
85~gflops, in single precision.  The parallelism comes from four cores
with two-way hyperthreading, and a vector length of four floats,
provided by the SSE4 instruction set.

The architecture has several important drawbacks for our application.
First, there is no fused multiply-add instruction.  Since the
correlator performs mostly multiplies and adds, this can cause a
performance penalty. The processor does have multiple pipelines, and
the multiply and add instructions are executed in different pipelines,
allowing eight flops per cycle per core.

Another problem is that SSE's shuffle instructions to move data around
in vector registers are more limited than for instance on the
\mbox{Cell/B.E.} processor. This complicates an efficient
implementation.  For the future Intel Larrabee GPU, and for the next
generation of Intel processors, both a fused multiply-add instruction
and improved shuffle support has been announced.  The number of SSE
registers is small (sixteen 128-bit registers), allowing only little
data reuse.  This is a problem for the correlator, since the tile size
is limited by the number of registers.  A smaller tile size means less
opportunity for data reuse, increasing the memory bandwidth that is
required.


\subsection{IBM Blue Gene/P}

The IBM Blue Gene/P~(BG/P)~\cite{bgp} is the architecture that is
currently used for the LOFAR correlator~\cite{sc09}.  Four PowerPC
processors are integrated on each Blue Gene/P chip.  The BG/P is an
energy efficient supercomputer. This is accomplished by using many
small, low-power chips, at a low clock frequency.  The supercomputer
also has excellent I/O capabilities, there are five specialized
networks for communication.

We found that the BG/P is extremely suitable for our application,
since it is highly optimized for processing of complex numbers.  The
BG/P performs \emph{all} floating point operations in double
precision, which is overkill for our application.  In contrast to all
other architectures we evaluate, the problem is compute bound instead
of I/O bound, thanks to the BG/P's high memory bandwidth per
operation. It is 3--10 times higher than for the other architectures.
The BG/P has 32 vector registers of width 2.  Therefore, 64 floating
point numbers (with double precision) can be kept in registers
simultaneously. This is the same amount as on the general purpose
Intel chip, but an important difference is that the BG/P has 32
registers of width 2, compared to Intel's 16 of width 4.  The smaller
vector size reduces the amount of shuffle instructions needed.


\subsection{ATI GPU}

The most high-end GPU provided by ATI (recently acquired by AMD) is
the 4870~\cite{amd-manual}.  The 4870 chip contains 800 scalar 32-bit
streaming processors.  The theoretical peak performance is
1.2~teraflops. The board uses a PCI-express~2.0 interface
for communication with the host system.  Ten cores
share 16 KB of local memory and separate L1 texture cache.  The L2
cache is shared. The The application can specify if a read should be
cached or not.  The SIMD cores can exchange data using 16 KB of global
memory.

The ATI 4870 GPU has the largest number of cores of all architectures
we evaluate (800).  However, the architecture has several important
drawbacks for data-intensive applications.  First, there is no way to
synchronize threads. With other architectures, we can improve the
cache hit ratio significantly by letting threads that access the same
samples run in lock step, increasing data reuse.  Second, the
host-to-device bandwidth is too low. In practice, the achieved
PCI-express bandwidth is far from the theoretical limit. The achieved
bandwidth is not enough to keep all cores busy.  Third, we found that
overlapping communication with computation by performing asynchronous
data transfers between the host and the device has a large impact on
kernel performance. We observed kernel slowdowns of \emph{a factor of
  three} due to transfers in the background.  Fourth, the architecture
does not provide random write access to device memory, but only to
\emph{host} memory. However, for our application which is mostly
read-performance bound, this does not have a large impact.


\subsection{NVIDIA GPU}

NVIDIA's Tesla C1060 contains a GTX~280 GPU with 240 single precision
and 30 double precision ALUs.  Current NVIDIA GPUs thus have fewer
cores than ATI GPUs, but the individual cores are faster. The memory
architecture is also quite different. NVIDIA GPUs still use GDDR3
memory, while ATI already uses GDDR5 with the 4870~GPU.  The
theoretical peak performance is 933 gflops.

The number of registers is large: there are 16384 32-bit floating
point registers per multiprocessor. There also is 16~KB of shared
memory per multiprocessor.  This memory is shared between all threads
on a multiprocessor, but not globally.  There is a total amount of 64
KB of constant memory on the chip.  Finally, texture caching hardware
is available.  The application has some control over the caching
hardware.  It is possible to specify which area of device memory must
be cached, while the shared memory is completely managed by the
application.

On NVIDIA GPUs, it is possible to synchronize the threads within a
multiprocessor.  With our application, we exploit this to increase the
cache hit ratio. This improves performance considerably.  When
accessing device memory, it is important to make sure that
simultaneous memory accesses by different threads are \emph{coalesced}
into a single memory transaction.  In contrast to ATI hardware, NVIDIA
GPUs support random write access to device memory. This allows a
programming model that is much closer to traditional models, greatly
simplifying software development.  The NVIDIA GPUs suffer from a
similar problem as the ATI GPUs: the host-to-device bandwidth is
equally low.



\subsection{The Cell Broadband Engine}

The Cell Broadband Engine (\mbox{Cell/B.E.})~\cite{cell} is a
heterogeneous many-core processor, designed by Sony, Toshiba and IBM
(STI).  The \mbox{Cell/B.E.} has nine cores: the Power Processing
Element (PPE), acting as a main processor, and eight Synergistic
Processing Elements (SPEs) that provide the real processing power.
The cores, the main memory, and the external I/O are connected by a
high-bandwidth Element Interconnection Bus (EIB).  The main memory has
a high-bandwidth, and uses XDR (Rambus).  The PPE's main role is to
run the operating system and to coordinate the SPEs.  An SPE contains
a RISC-core (the Synergistic Processing Unit (SPU)), a 256KB Local
Store (LS), and a memory flow controller.

The LS is an extremely fast local memory (SRAM) for both code and data
and is managed entirely by the application with explicit DMA
transfers.  The LS can be considered the SPU's L1 cache.  The
\mbox{Cell/B.E.} has a large number of registers: each SPU has 128,
which are 128-bit (4 floats) wide.  The SPU can dispatch two
instructions in each clock cycle using the two pipelines designated
\emph{even} and \emph{odd}. Most of the arithmetic instructions
execute on the even pipe, while most of the memory instructions
execute on the odd pipe.  We use a QS21 Cell blade with two
\mbox{Cell/B.E.} processors.  The 8 SPEs of a single chip in the
system have a total theoretical single-precision peak performance of
205 gflops.

\subsection{Larrabee}

Intel's Larrabee~\cite{larrabee} (to be released) is another promising
architecture.  Larrabee will be a hybrid between a GPU and a
multi-core CPU.  It will be compatible with the x86 architecture, but
will have 4-way simultaneous multi-threading, 512-bit wide vector
units, shuffle and multiply-add instructions, and special texturing
hardware. Larrabee will use in-order execution, and will have coherent
caches.  Unlike current GPUs, but similar to the \mbox{Cell/B.E.},
Larrabee will have a ring bus for communication between cores and for 
memory transactions.

\subsection{Essential properties and differences}

\begin{table*}[t]
\begin{center}
{\small
\begin{tabular}{l|l|l}
feature                   & Cell/B.E.                      & GPUs \\
\hline
access times              & uniform                        & non-uniform \\
cache sharing level       & single thread (SPE)            & all threads in a multiprocessor \\
access to off-chip memory & only through DMA               & supported \\
memory access overlapping & asynchronous DMA               & hardware-managed thread preemption \\
communication             & DMA between SPEs               & independent thread blocks + \\
                          &                                & shared memory within a block \\
\end{tabular}
} %\small
\end{center}
\vspace{-0.5cm}
\caption{Differences between many-core memory architectures.}
\label{memory-properties}
\end{table*}


\section {optimizing the correlator algorithm}

%- optimaliseren van het algorithme: tiles, etc

% TODO add text about mapping from alg to arch

\begin{figure}[t]
\begin{center}
\includegraphics[width=4.2cm]{figures/correlation-triangle.pdf}
\end{center}
\vspace{-0.5cm}
\caption{An example correlation triangle.}
\label{fig-correlation}
\end{figure}

An important optimization that we implemented is the reduction
of memory loads by the correlator. 
A sample can be used multiple times by correlating it
with the samples from multiple other stations in the same loop iteration.
For example, a sample from station A in the X polarization
that is loaded into a register pair can be correlated with the X and
Y polarizations of stations B, C and D, using it six times. 
Figure~\ref{fig-correlation} shows how we correlate multiple
stations at the same time. Each square represents the XX, XY,
YX, and YY correlations of the stations as indicated by row and
column number. The figure is triangular, because we compute
the correlation of each pair of stations only once. The squares labeled \emph{A} are
autocorrelations, which could be treated specially since they require less
computations. The triangle is divided into larger tiles, in this case 
2x3 tiles (the dark gray boxes), but arbitrary sizes are possible.
A tile is correlated as a unit. For example, the lower
right-hand-side rectangle correlates stations 9 and 10 with stations
0, 1, and 2.

It is important to tune the tile size to the architecture. We want to
make the tile size as large as possible, while still fitting in the
register file. This offers the highest level of data reuse.  
If we have a $w \times h$ tile size, the number of operations is given by $flops = 32wh$.
The number of bytes that has to loaded from memory is $16(w+h)$.
The minimum number of registers that is required is $4 (1 + min(w,h)) + 8 w h$.
This is the total number of registers, including accumulators, while reusing
registers if a value is no longer needed (hence the $min$ operation). However,
this formula does not count additional registers that could be needed for data prefetching,
address calculations and loop counters.
The number of registers is expressed in single-precision float registers. If an architecture has vector
registers, the result can be divided by the vector length.
Table~\ref{tile-size-table} shows the properties of different tile sizes. 

Despite the division of the correlation triangle in tiles, there
still is opportunity for additional data reuse \emph{between} tiles. 
The tiles
within a row or column in the triangle still need the same samples.
In
addition to registers, caches can thus also be used to increase data
reuse.  Since we know exactly what data can be reused at what moment, we
found it is important to have direct influence on the caches and the thread scheduler.  This
way, we can make sure that tiles in same row or column are calculated
at the same time by different threads. 
Because the algorithm is
extremely data intensive, the resulting optimized implementation on
many-cores is typically limited by the architecture's memory
bandwidth. The memory aspects of the algorithm are twofold.
There is an algorithmic part, the tile size, which is limited
by the number of registers. The second aspect is architectural in nature: the cache
sizes, cache hierarchy and hit ratio. Together, these two aspects dictate the
memory bandwidth that is needed to keep the ALUs busy.

\begin{table}
\begin{center}
{\small
\begin{tabular}{l|r|r|r|r}
tile & floating point & memory loads & arithmetic     &  minimum nr.           \\
size & operations     & (bytes)      & intensity      &  registers (floats)    \\
\hline
1x1  &  32            &   32         &   1.00         &  16                    \\
1x2  &  64            &   48         &   1.33         &  24                    \\
2x2  & 128            &   64         &   2.00         &  44                    \\
3x2  & 192            &   80         &   2.40         &  60                    \\
3x3  & 288            &   96         &   3.00         &  88                    \\
4x3  & 384            &  112         &   3.43         & 112                    \\
4x4  & 512            &  128         &   4.00         & 148                    \\
\end{tabular}
} %\small
\end{center}
\vspace{-0.5cm}
\caption{Properties of different tile sizes.}
\label{tile-size-table}
\end{table}

It is important to realize that the
correlator itself is \emph{trivially parallel}, since tens of thousands of
frequency channels can be processed independently.  This allows us to
efficiently exploit many-core hardware.


\subsection{Intel}
\subsection{BG/P}
\subsection{NVIDIA}
\subsection{ATI}
\subsection{Cell}
\subsection{Larrabee}

 
\section{Programmability}


\section{Conclusions}


\bibliographystyle{IEEEbib}
\bibliography{spm}

\end{document}
