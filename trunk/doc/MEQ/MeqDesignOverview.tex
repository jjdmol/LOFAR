\documentclass[10pt]{article}

\oddsidemargin=-5mm
\oddsidemargin=-5mm
\topmargin=-5mm
\textwidth=170mm
\textheight=240mm

\pagestyle{myheadings}

\markboth{MeqTree Design Overview}{\small CVS path: LOFAR/doc/MEQ/MeqDesignOverview.tex $$Revision$$}


\title{MeqTree Design Overview (PSS4)}
\author{O.M. Smirnov}

\begin{document}
\sloppy

\newcommand{\url}[1]{{\tt #1}}

\maketitle

% \qq{text} used to quote code (in fixed font)
\newcommand{\qq}[1]{{\tt #1}}

\newcommand{\Request}{{\tt Request}}
\newcommand{\RequestId}{{\tt RequestId}}
\newcommand{\Result}{{\tt Result}}
\newcommand{\VellSet}{{\tt VellSet}}
\newcommand{\Cells}{{\tt Cells}}
\newcommand{\Vells}{{\tt Vells}}
\newcommand{\Domain}{{\tt Domain}}
\newcommand{\Node}{{\tt Node}}
\newcommand{\Parm}{{\tt Parm}}
\newcommand{\Polc}{{\tt Polc}}
\newcommand{\RES}[1]{{\tt RES\_#1}}




\section{Introduction}

The purpose of this document is to provide a C++ analogue of the MeqTree
handbook. I will try to keep it updated with design decisions we make in our
meetings. Un updated version of this document may be obtained via CVS at
\qq{LOFAR/doc/MEQ/MeqDesignOverview.tex}.

\section{Data structures} 

\subsection{Basic principles}

  All data structures used in the Meq {\em interface} must be mappable to data
  structures of the scripting language of choice. Currently, this is Glish, in
  the future this will be Python; we should in any case restrict ourself to
  common primitives which we can expect to be available in any mature scripting
  language. Thus, we'll define ``legal objects'' as:

  \begin{itemize}
  
  \item scalars (bool, integer, float, double, float or double complex);
  
  \item strings;
  
  \item multidimensional arrays of scalars;
  
  \item lists of legal objects (in Glish this is represented either  via a
  vector of scalars or strings, or via a record with fields indexed by number);

  \item records of legal objects (a.k.a. dictionaries/maps/hashes with a string
  key and a legal object value).

  \end{itemize}

  On the C++ side, data objects are based on the DMI \qq{DataRecord},
  \qq{DataField} and \qq{DataArray} classes. Most data classes are in fact
  derived from \qq{DataRecord}, and are essentially a record with some
  predefined structure, and some extra ``shortcut'' methods. 

\subsection{Naming conventions}

  \begin{itemize}

  \item In C++, standard data structures \& nodes reside in \qq{namespace Meq}.
    In Glish, corresponding object constructors are placed into the {\tt meq}
    ``namespace'' (actually just a record), and names are all-lowercase. The
    DMI dynamic type system uses a {\tt Meq} prefix. Thus, the
    \qq{Meq::\Request} class in C++ is registered as a ``\qq{MeqRequest}'' in
    the DMI type system, and  has a  \qq{meq.request()} counterpart in Glish.

  \item The C++ side uses DMI HIIDs (hierarchical IDs) extensively. When seen
    as a string, HIIDs take the form ``\qq{Request.ID}''. When used as record
    field names on the Glish side, the same HIID takes the form
    \qq{request\_id}. We will use both forms interchangably here. Note that
    HIIDs are not case-sensitive.
    
  \item Even though the languages we use are case-sensitive, we should not rely
    on character case to distinguish identifiers. Note that C++ and Glish have
    different capitalization conventions -- e.g., \qq{Meq::Request} as opposed
    to \qq{meq.request}. In general, we should avoid situations where different
    entities have names that differ only in character case.

  \end{itemize}

\subsection{Glish \qq{meq} objects: meqtypes.g}

  With a couple of exceptions, Meq objects are represented by Glish records of
  a [mostly] predefined layout. The Glish/C++ conversion layer uses a few
  ``magic'' attributes to distinguish these objects from ordinary records, so
  it is able to map them to specialized Meq C++ classes rather than generic
  \qq{DataRecord}s. 

  Specifically, the \qq{::dmi\_actual\_type} attribute is set to a string which
  gives the DMI object type. Thus, it is possible to construct a record in
  Glish, tag it with \qq{::dmi\_actual\_type}, pass it thorugh the Glish/C++
  layer, and have it auto-magically converted to an C++ object of the
  appropriate class. The only requirement is that the record contain the
  correct set of fields, which are mapped to class attributes (data members) in
  C++. The file \qq{meq/meqtypes.g} defines  some Glish ``constructor''
  functions which create properly formed records:

  \begin{description}
  
   \item[\qq{meq.domain()}] creates a Domain object (record).

  \item[\qq{meq.cells()}] creates a Cells object (record).

  \item[\qq{meq.requestid()}] creates a request ID from individual components
  (domain ID, config ID, iteration ID). A request ID is a \qq{HIID}.
  
  \item[\qq{meq.request()}] creates a Request object (record).
  
  \item[\qq{meq.polc()}] creates a Polc object (record).
  
  \end{description}
  
  Some Meq classes have Glish counterparts but no constructor functions, since
  these objects are passed from C++ to Glish but not vice versa (it is always
  possible to implement such constructors in the future, if necessary). These
  include \Vells, \VellSet{}s, and \Result{}s.

  In general, all data objects on the C++ side have counterparts on the Glish
  side. Within this document, we will describe data objects in terms of Glish
  records and record fields, with the understanding that there is a trivial
  mapping from that to C++ classes and data members.

  Several other functions in \qq{meqtypes.g} help to construct defrecs for
  nodes (see below). \qq{meq.node()} puts together a basic node defrec -- class
  name, node name, optional children specification, optional node group
  list. \qq{meq.parm()} is a specialization for constructing \Parm\ defrecs.
    
\section{MeqNode}

  The abstract base class \qq{Meq::Node} implements the basic node behaviour:

  \begin{itemize}

  \item A node may have a number of child nodes. Generally, a node has no
    knowledge of the types of its children. Subclasses may assign formal child
    labels (akin to argument names) to specify semantics, or may leave their
    children unlabeled. Child labels are assigned via the constructor of the
    subclass.

  \item To nail down directional terms: root nodes and parents are at the {\em
    bottom}, children and leaves are at the top. 

  \item Each node is assigned a unique index (integer$>$0) and an optional name. A
    MeqForest object acts as a repository of nodes, and maintains a map between
    names, indices and node objects.

  \item \Node\ has an \qq{execute()} method, taking a \Request\ parameter,
    and returning a \Result. Normally, a node is expected to call execute()
    with the same \Request\ on its children, and form its result based on the
    results of its children. Thus, requests propagate up the tree, and results
    percolate down the tree.

\begin{verbatim}
    virtual int execute (Result::Ref &result,const Request &request);
\end{verbatim}

    \Result{}s are returned by attaching them to the CountedRef. The return code
    of \qq{execute()} is significant; see details below.

  \end{itemize}

\subsection{Initialization and state}
  
  A node's full {\em state} should be mapped to a {\em state record}. State may
  be requested via \qq{getState()} and changed via \qq{setState()}. Note that
  the argument to \qq{setState()} does not have to be a complete new state
  record; instead, it should contains only those fields that actually need to
  be changed. 

  When a node is constructed, it is passed an {\em init-record} (via the
  \qq{init()} method), which is essentially a complete initial state record.
  This is the way that all run-time arguments to a node are specified! Later 
  in a node's lifetime, the \qq{setState()} method may the be called to
  reconfigure  it. Note that a node class is not obliged to be reconfigurable
  in every single aspect, but it's good design to make it so as much as
  possible. If some of the node state may only be set once via \qq{init()} and
  not changed later on via \qq{setState()} -- call this {\em static\/} state --
  it should be clearly documented as such. The assumed default is {\em
  dynamic\/} state, i.e., state that is freely reconfigurable via
  \qq{setState()}.

  The following methods are responsible for initializing and changing state:

\begin{verbatim}
  // public: Initializes node with init record
  //         Note that Ref::Xfer implies that ref to record will be taken over
virtual void init (DataRecord::Ref::Xfer &initrec);

  // public: Changes dynamic node state (note: non-virtual)
  //         Node can attach to/take over record contents as needed.
void setState (DataRecord &rec);

  // protected: Checks init record for missing fields, fills in defaults where needed
  //            (called from Node::init())
virtual void checkInitState (DataRecord &rec);

  // protected: Implementation for setting or changing internal dynamic state 
  //            (called from Node::setState())
  //            Node can attach to record contents as needed. If initializing,
  //            then record is the state record and should not be changed. If
  //            not initializing, node can take over contents as well.
virtual void setStateImpl (DataRecord &rec,bool initializing);
\end{verbatim}

\subsubsection{init()}

  The base \qq{Node::init()} does the following:

  \begin{enumerate}
  
  \item Takes over the init record,  sets it as the state record, ensures a
    private \& writable copy.
    
  \item Adds the node's classname (\qq{rec.class}) to the state record if not
    already present. If present, checks that the name actually matches the node
    class.

  \item Calls the virtual \qq{checkInitState()} method with the state record,
    to ensure that it's complete, and that any missing defaults are filled in.

  \item Calls \qq{setStateImpl(staterec,true)} to set up internal state from
    the state record (the \qq{true} argument indicates that the node is being
    initialized with the state record.)

  \item Looks at \qq{rec.children} to set up child nodes. Children may be
    specified via a either a list or a record, containing any mix of the
    following:

    \begin{itemize}
      \item integer node indices referring to existing nodes.

      \item string node names, referring to existing or yet-to-be-created
        nodes. In the latter case, \qq{Node::resolveChildren()} must be called
        later on; this will recursively resolve all children not found at
        \qq{init()} time.

      \item init-records, to recursively create child nodes on-the-fly (each of
        these records must have a field named \qq{class}, containing the child
        node classname).

    \end{itemize}

    If a list is specified, then the children are simply attached in the given
    order. If a record is specified, then the field names must match the child
    labels set up by the subclass (if no labels are set up, the record is
    processed just like a list, with no specific order ensured). The record
    form allows for a more formal child specification in the case where
    children are semantically different.
    
  \item Any errors will result in an exception being thrown at the caller. A
    node object that fails \qq{init()} is under no obligation to be usable; the
    only method that's not allowed to fail is the destructor.

  \end{enumerate}

  Derived classes need to reimplement \qq{init()} only if they have additional
  static state of their own. A derived \qq{init()} should do the following:

  \begin{enumerate}
  
  \item Call the parent class's \qq{init()} with the initrec. This should
    ultimately call \qq{Node::init()}, thus setting up the state record  and
    calling \qq{setStateImpl()} to set up dynamic state.

  \item Set up static state, as defined at the child class level, in accordance
    with the state record.

  \item Throw exceptions on any error. 

  \end{enumerate}
  
  Note the virtual \qq{checkInitState()} method is called from
  \qq{Node::init()}. This is meant to check the init record for required
  fields. The \qq{requiresInitField(record,field)} macro/inline (defined in
  \qq{Node}) is handy for this; it will throw a standard exception if the
  specified field is missing. 
  
  The base \qq{Node::checkInitState()} only fills in a default for \qq{.name}
  (empty). A derived \qq{checkInitState()} should call the parent version, then
  check for additional defaults and required fields as defined by the child
  class.
  
  Note that child classes can also ignore \qq{checkInitState()}, and instead use
  the \qq{initializing} parameter of \qq{setStateImpl()} to determine when
  the node is being initialized, and check for missing fields and/or fill in
  defaults as apporpriate.

\subsubsection{setState() and setStateImpl()}

  The non-virtual \qq{setState()} method defined in \qq{Node} provides the
  public interface for setting state. Basically, it defers parsing the record
  to \qq{setStateImpl()}, while providing a transaction mechanism of sorts:

\begin{enumerate}

  \item Calls \qq{setStateImpl(rec,false)} to process the record. The
    \qq{false} value indicates that state is being modified rather than
    [re]initialized. (Note that if the supplied record happens to be the node
    state record itself, \qq{true} will be passed in instead.)

  \item Catches \qq{Node::FailWithoutCleanup} exceptions and rethrows them at
    the caller with no additional action.

  \item Catches all other execeptions, and does a cleanup before rethrowing
    them. The cleanup consists of calling \qq{setStateImpl(staterec,true)}, so
    as to reset internal state from the current state record. This is meant to
    roll back from situations where an error midway through \qq{setStateImpl()}
    could cause internal object state to decohere from the state record.

  \item On success, merges the supplied record into the current state record.

\end{enumerate}

  This design ensures that if a \qq{setState()} call fails (i.e., with an
  exception), both the state record and the internal state of the object are
  rolled back to their values prior to the call. (Assuming they were mutually
  consistent to begin with.) In other words, the node object is guaranteed to
  remain usable.

  The virtual \qq{setNodeState()} method is responsible for changing dynamic
  state. It receives two arguments: a \qq{newst} record, and a boolean called
  \qq{initializing}. The latter is \qq{true}, the node is being initialized --
  in this case \qq{newst} is the complete initial state record. If it is
  \qq{false}, \qq{newst} contains only those state fields that are being
  changed. Normally, the method should do the following:

\begin{enumerate}

  \item If the \qq{initializing} is \qq{false}, check the record for
    ``forbidden'' fields, i.e., attempts to modify static state. Throw a
    \qq{FailWithoutCleanup} if any are present. The
    \qq{protectStateField(record,field)}  macro/inline is a convenient way to
    do this.
    
  \item Call the parent \qq{setStateImpl()}.

  \item As an alternative to overriding \qq{checkInitState()}, if
    \qq{initializing} is \qq{true}, check for missing fields and/or fill in
    defaults.

  \item Parse the record and modify internal state relevant to the child class.
    Note that the standard DMI hook method \qq{get()} is very handy for doing
    this operation, combined with the previous one:
    
    \begin{verbatim}
    if( newst[StateField].get(var,initializing) )
      // field is present, react if needed
    else
      // field is missing, react if needed
    \end{verbatim}
    
    The \qq{get()} method employed here does the following: if \qq{StateField}
    is present in the \qq{newst} record, assigns its value to \qq{var}
    (throwing an exception is the types are incompatible) and returns
    \qq{true}. If the field is missing, optionally (only if \qq{initializing}
    is \qq{true}) inits it from the value in \qq{var}, and returns \qq{false}.
    The standard \qq{setStateImpl()} methods make extended use of this
    mechanism.

  \item Throw exceptions on error. A \qq{Node::FailWithoutCleanup} should be
    thrown if and only if no internal state was modified. All other exceptions
    will invoke the ``rollback'' mechanism above. You can rely on
    \qq{DataRecord} (and other DMI classes) to throw an exception when
    datatypes mismatch or something else goes wrong; throw a
    \qq{Node::FailWithCleanup} if you want to indicate some other kind of
    failure.

\end{enumerate}

  The base \qq{Node::setStateImpl()} method is described in detail in a later
  section on basic node state.

\subsubsection{Unrecognized state fields}

  Note that these implementations of \qq{init()} and \qq{setState()} will
  ignore any unrecognized fields in the init and state record, all the while 
  diligently maintaining and changing them as requested. This allows for a few
  interesting possibilities:

  \begin{itemize}
  
  \item Nodes may be assigned arbitary additional attributes and data,
    meaningless to the node itself, but perhaps useful to the control layer.

  \item Things like the result cache (see below) -- which is stored directly in
    the state record -- may be accessed and changed externally (i.e. from the
    scripting level). This may be useful for debugging and testing.

  \end{itemize}

\subsection{Node serialization \& persistency}

  In the near future we will need persistent nodes (i.e. being able to
  save/load the nodes to a file or database), and further down the road, the
  possibly the capability to move a node across a network. This implies being
  able to serialize a node.
  
  Serialization is implemented through DMI mechanisms. A \qq{DataRecord} is
  inherently serializable. To serialize a node, the control code will simply
  serialize its state record. To unserialize a node, it will recover the
  record, create a node object (as specified by the \qq{class} field), and call
  \qq{init()} on it. 

  Thus, subclasses of \Node\ should take care to maintain their state record
  appropriately. Each node class should ensure that it is completely
  re-creatable (via \qq{init()}) from a snapshot of its state record at any
  point in time. Basically, this means that a 1-1 mapping should be maintained
  between the state record and internal object state. One possible exception to
  this are internal caches; if these are not maintained in the state record,
  then the worst than can happen from re-creating a node is a cleared cache.

\section{MeqRequest}

  A \Request\ is a {\em job description} containing a number of commands
  that a node executes to produce a \Result. A \Request\ is a record with a
  semi-fixed structure; commands are identified by the presence of specific 
  fields in this record. Additional fields can contain optional command
  arguments.

  A \Request\ always has a unique \RequestId\ (see below). Whenever a different
  request is generated, it must be assigned a different id (see discussion on
  caching and dependencies below).

  \Request\ is derived from \qq{DataRecord}. It has the following fields (of
  which only request\_id is obligatory).

  \noindent\begin{tabular}{lp{.8\textwidth}}
  \qq{.request\_id} & the request ID (a HIID)\\
  \qq{.cells}       & [opt] a \Cells\ object (see below)\\
  \qq{.calc\_deriv} & [opt] compute perturbed values (0, 1 or 2).
                      Default is 0.\\
  \qq{.next\_request} & [opt] a hint of what the next request is going to be.
                      This matters for caching decisions, and for ``rippling''
                      trees.\\
  \qq{.rider}       & [opt] rider record used for additional commands.
  \end{tabular}
  
  Note that only the \qq{cells} command (the \qq{cells} field can be considered
  a command to evaluate the node over the given \Cells) is present at the top
  level of the record. This is done for reasons of efficiency, as this command
  represents the bulk of the system's workload. All other commands are placed
  into the rider record, which will be described in detail below.

\subsection{Request IDs and the node cache}

  Request IDs (RqIDs) are first of all used to distinguish different \Request\
  objects. The originator (creator) of the request is responsible for assigning
  a unique request ID to each new, different request.

  RqIDs play a pivotal role in caching behaviour. When a node caches a result,
  it also caches the request ID. In the trivial case, if the next request has
  the same ID, the node can immediately return the cached result. In fact the
  cache is somewhat more intelligent. Each cached result has  a {\em dependency
  mask} (or {\em depmask} for short) that describes what properties of a
  request the result depends on. Typical dependencies include:

  \begin{itemize} 
  
  \item The request's \Cells\ (envelope domain and grid), obviously enough.
  Example nodes with this dependency: \qq{MeqParm} (with a non-zero degree
  polynomial), \qq{MeqTime}, \qq{MeqFrequency}. 

  \item The envelope domain of the \Cells. Example: the \qq{MeqSpigot},
  since it always returns data at the native resolution of the dataset, ignoring
  the resolution specified in the \Cells.
  
  \item Updated \qq{MeqParm} values sent up by a solver.
  
  \item The configuration of a \qq{MeqWSum} node.

  \item Any combination of the above. 

  \end{itemize}
  
  If a node has children, then its result's dependencies are almost always the
  union of the children dependencies, plus (in some cases) additional
  dependencies introduced by the node itself (e.g. the \qq{MeqUVW} node always
  adds a dependency on \Cells). In other words, the depmask of the result is 
  a bitwise-OR of the depmasks of the children's results, OR the node's own
  local depmask. Obviously, the set of dependencies grows as results propagate
  down the tree.

  Given a cached result and its depmask, a node can be somewhat more
  discriminating in choosing when to return a cached result. For example, if
  the depmask indicates that the result depends on \Cells\ only, then all
  further requests with the same \Cells\ can be served from the cache. The same
  applies to other dependencies. In global optimization terms, this means that
  when a tree is re-evaluated for a slightly different request, it recalculates
  only those sub-trees that need it. The problem is how to determine if a
  different request has the same \Cells, without doing a brute-force comparison
  (which can be quite expensive if done at every node). This is where the {\em
  hierarchical} part of request IDs come in.

  The RqID is a \qq{HIID} -- essentially, a string of integer indices. Each
  index corresponds to one bit in the depmask. For example, if the depmask is
  structured as follows:
  
  \begin{tabular}{l|l}
  \hline
  bit 0 & \qq{MeqParm} values from solver \\
  bit 1 & \qq{MeqWSum} configuration \\
  bit 2 & resolution of \Cells \\ 
  bit 3 & envelope domain of \Cells \\
  \hline\end{tabular}
  
  then the RqID is composed of four indices:
  
  {\tt\em  
  $<$domain index$>$.$<$resolution index$>$.$<$config\_index$>$.$<$value\_index$>$
  }
  
  The decision whether a new request can be served from the cache becomes quite
  simple: just compare all indices of the RqIDs for which the corresponding
  depmask bit is set, and use the cache only if none of them differ.

  In other words, the components of the RqID describe how a request is
  different from previous requests. The domain index must change whenever a new
  domain is requested, the config index must change whenever a \qq{MeqWSum} is
  reconfigured, the value index must change at each solve iteration, etc.

  Of course, this scheme only works if the depmasks returned by the nodes
  (generally, somewhere up the tree), and the request IDs generated by request
  originators (generally, down the tree) have the same semantics. The
  depmask/RqID correspondence represents an {\em agreement} between request
  generators and dependency generators to apply these semantics consistently.
  The \qq{Node} class provides a number of mechanisms for automatically setting
  up consistent semantics throughout the tree, see the discussion on {\em
  symdeps} below.

  Note also that the general scheme implemented at the \qq{Node} level does not
  assume any application-specific semantics at all. The depmask is a treated as
  set of $N$ bits, and the RqID as a corresponding set of $N$ indices.

\subsection{Next\_request and request sequences}

  The concept of a ``request sequence'' has been bandied about a lot (see the
  ``Making Waves'' document, plus various discussions). The reason for this is
  that a node needs some capability of ``looking ahead'' to future requests, in
  order to efficiently utilize cache, and to enable ``rippling'' trees that
  parallelize well.

  In fact, it is sufficient to be able to answer the more limited question:
  given request $X$, what is the next request likely to be? A node doesn't 
  need to know the full request sequence -- only the next step of it. The
  mechanism can be hidden behind a single method called, e.g.,
  \qq{getNextRequestHint()}, implemented at the \Node\ level. This neatly
  factors the issue into two independent ones:

  \begin{itemize}
  
  \item {\em Where does the base \qq{\em Node} class get knowledge of the
    next request?} Obviously, the originator of the \Request\ can have some
    idea.  For example, a Solver node would probably know if more iterations
    over the same domain/source are required, or if we're going to the next
    domain. A \qq{Sink} node may know what the next domain is going to be. Etc. It
    seems reasonable to place this information into the \Request\ record
    itself, hence the \qq{next\_request} field.

  \item {\em Given knowledge of the next request, how does that help us in
    caching and parallelization?} Parallelization was the subject of the
    ``Making Waves'' document, while caching issues are discussed below.

  \end{itemize}
  
  The next-request hint is just that, a hint, with no commitment implied. It is
  not necessary at all for correct operation of the system -- even the hint
  itself can even be wrong. The maximum penalty to pay for an incorrect hint is
  recalculation of the tree rooted at the node in question. Efficient
  operation, however, requires that the hint be correct most of the time.

  {\em Hints and sequences are probably outside of PSS-4 scope; the point of
  the present discussion is to run through mental models of the mechanism and
  convince ourselves that we're making the right decisions.}

\section{Results}

\subsection{MeqResult}

  A \Result\ contains the result of a \Request's execution. It is derived from
  a \qq{DataRecord}, and may contain the following fields:

  \noindent\begin{tabular}{lp{.8\textwidth}}
  \qq{.cells}  & [optional] the \Cells of the result, if any.\\
  \qq{.values} & [optional] a list of \VellSet\ objects for these \Cells.\\
  \qq.{.integrated} & flag indicating the result is integrated (default is false).\\
  etc.         & any optional flags \& attributes (e.g. solver may use these to
                  return the solution).
  \end{tabular}
  
  A \Result\ can represent both a sampling of some function at the cell
  centers, or an integration over each cell. The \qq{integrated} flag is used
  to indicate this, if missing, \qq{false} (i.e. a sampling) is assumed. Leaf
  nodes set this flag according to the type of value they return (for example,
  a \qq{Spigot} reading visibilities from a data set returns integrations; a
  \qq{Parm} representing gain returns samplings). Non-leaf nodes should take
  care to pass this flag from child to parent properly, this is dicsussed in
  more detail in the section on individual node classes below. This flag is
  also taken into account when performing resampling of results, see below.

\subsection{MeqVellSet}

  A \VellSet\ contains a value plus optional perturbed values for a \Cells. It
  is derived from a \qq{DataRecord}, and contains the following fields:

  \noindent\begin{tabular}{lp{.8\textwidth}}
  \qq{.value}  &  the value: a \Vells\ of the shape determined by \Cells, or 
                  scalar if constant in time/freq).\\
  \qq{.spids}  &  [opt] a list of spids\\
  \qq{.perturbations}  & [opt] a list of perturbations (same length as spids)\\
  \qq{.perturbed\_value} & [opt] perturbed values: a list (same length as spids); 
                    of array or scalar \Vells\\
  \qq{.fail}  & a list of one or more fail-records (see below)
                describing failures that have occurred\\
  etc. &        any optional flags \& attributes.
  \end{tabular}
                    
  The \qq{value} and \qq{fail} fields are mutually exclusive. A \VellSet\ with
  neither is an empty (uninitialized). A \VellSet\ with a \qq{fail} in it is
  called a fail-\VellSet\ (or simply a fail). The \qq{spids},
  \qq{perturbations} and \qq{perturbed\_value} fields are optional, but either
  none or all three must be present at the same time.
  
  Note also that this layout could be extended in the future to accomodate
  double derivatives and analytic derivatives.

\subsubsection{MeqVells}

  On the scripting side, a \Vells\ object is simply a scalar or an array. On
  the C++ side, it is also essentially an array, with some run-time type and
  size information. The current implementation supports double and
  double-precision complex types, in either scalar or 2D-array form, but this
  could be extended in the future.

  \Vells\ are covered in some more detail in the description of \qq{Function}
  nodes, below.

\subsection{Multiple values}

  The point of defining a \Result\ as a set of \VellSet{}s is to allow multiple
  return values for a single \Cells\ (a.k.a. "multiple planes"). For example, a
  \qq{Spigot} may return four values at a time (for the four correlations).
  Function nodes expect all child \Result{}s to either have the same number of
  planes, and will apply the function to each set of planes (cross-slice)
  independently; however, some children may have only one plane, in which case
  it is re-used in each cross-slice.

  The \qq{Selector} and \qq{Composer} nodes can be used to decompose and
  assemble \Result{}s.

\subsection{Fail propagation}

  Note that a set may contain a mix of failed and normal \VellSet{}s. Failed
  values should propagate down the tree in an orderly fashion. Normally, a
  fail-value from one of its children produces a fail at the same position in
  the output \Result\ (the contents of the fail -- origin \& description -- are
  preserved.)

  For example, if a \qq{Spigot} node is configured to return four correlations,
  and the data source only has XX and YY, then XY/YXs will be represented by
  fails. These fails would propagate all the way down the XY/YX trees, to a
  \qq{Sink} node, which can handle them benignly (by not writing XY/YX data,
  for example).

\section{Base Node state}

  The base \qq{Node} class maintains a number of state fields via its
  \qq{setStateImpl()} method. This section describes the state in detail.
  Unless explicitly specified, each state field can be changed dynamically at
  any time. Note that an end user will hardly ever need to change (or even see)
  node state directly; a tree developer, however, will be working with this
  stuff constantly. As will become apparent in this section, a node's internals
  are completely exposed to tweaking and experimentation. The C++ side imposes
  no policy and does very few sanity checks, so it is perfectly possible  to
  thoroughly confuse a node (or an entire tree) through misguided  manipulation
  of its state record from the outside. We assume that it is up to the
  scripting-side tools to shield the end users from ``dangerous'' capabilities.

\subsection{\qq{class}, \qq{nodeindex}, \qq{children}} 
  
  These fields represent static properties of the node. \qq{setStateImpl()}
  will throw an exception if an attempt is made to change them. \qq{class} is a
  string classname, \qq{nodeindex} is an integer node index, and \qq{children}
  is a list of child node indices (if any).

\subsection{\qq{name}}
  
  This is just the node name (a string). 
 
\subsection{\qq{node\_groups}}
  
  A node may be assigned to one or more node groups. The purpose of this is
  described in detail below (see the section on command processing). The
  \qq{node\_groups} field is a list of \qq{HIID} group names. Note that all
  nodes are implicitly members of the \qq{All} group; thus \qq{"All"} is not
  explicitly present in the list.

\subsection{\qq{auto\_resample}}
  
  This flag specifies if auto-resampling of child results is enabled. See
  detailed discussion later on.

\subsection{\qq{request\_id}, \qq{cache\_result}, \qq{cache\_result\_code}}
  
  These three fields compose the node result cache. The first field -- a
  \qq{HIID} -- is the ID of the most recent request. The second field is the
  cached \qq{Result} of that request, if any (stored by reference). The third
  field -- an integer -- is the cumulative result code (mainly its the depmask,
  with a few additional flags, described in \qq{execute()} later on) of the
  cached result.

  The node cache may be cleared by assigning a boolean \qq{false} to the
  \qq{cache\_result} field. It is also possible to modify the cache on the fly
  (for example, substituting in another result). This may be a useful feature
  for debugging and experimentation, though if used improperly, it can probably
  confuse the caching and dependency tracking mechanism.  
  
\subsection{\qq{request}}

  This is a (read-only) reference to the most recently processed \qq{Request}
  object. This field is maintained for information purposes only, \qq{Node}
  fills it whenever it executes a request, but does not use it for anything
  else (so modifying this field will have no effect).

\subsection{\qq{cache\_policy}}

  This is a placeholder for the caching policy (see discussion below). This is
  not yet implemented -- all current nodes always cache results.

\subsection{\qq{depend\_mask}, \qq{known\_symdeps}, \qq{active\_symdeps}, 
            \qq{symdep\_masks}, \qq{gen\_symdeps}, \qq{gen\_symdeps\_group}}
              
  These fields are responsible for maintenance of dependency masks. This is a
  somewhat complicated subject covered in a separate section below. Note that
  the default settings for these fields are practically always good enough, but
  they are exposed for purposes of experimentation and debugging.

\section{Symdeps and depmasks}

  As discussed in the section on requests above, a {\em depmask} is a bitwise
  mask that describes a result's dependencies on particular properties of the
  request, which are in turn indicated by individual indices of the request ID.
  To enable proper use of the cache, all nodes in the tree should interpret
  these bits and indices in a consistent way -- which is, by necessity,
  application-dependent. Several fields of the node state provide a mechanism
  for setting up these semantics and propagating them throughout trees. 

\subsection{The local depmask}
  
  The \qq{depend\_mask} field of the state record is the local depmask of the
  node. The local depmask indicates which dependencies a node introduces into
  its result. For most \qq{Function}-derived nodes, this mask is null,
  indicating that the result dependencies are fully determined by child
  dependencies. Leaf nodes, on the other hand, will have a non-null mask.

  The local depmask is automatically ORed into the result code by
  \qq{Node::execute()} (see below). Some nodes will set up the mask at init
  time and never worry about it again. For other nodes, it may change depending
  on node state.

  The depmask is just a set of $N$ bits with no specific semantics associated
  with them. The association between individual bits and specific result
  properties is set up via the mechanism of {\em symbolic dependencies}, or
  {\em symdeps} for short.
  
\subsection{Symdeps in a nutshell}
  
  A {\em symdep} is a \qq{HIID} (thus, symbolic -- since \qq{HIID}s have a
  symbolic representation) that identifies some application-specific dependency
  of the result. Node classes will typically define some standard symdeps, such
  as these -- used in the standard nodes:

  \begin{description}
  
  \item[``Domain'':] result depends on the requested domain (i.e., the envelope
    domain of the \Cells). Most non-trivial leaf nodes have this symdep.

  \item[``Resolution'':] result depends on the resolution of the \Cells. Most
    nodes with a time and/or frequency dependence have this symdep.
   
  \item[``Parm.Value'':] result depends on parameter values passed up from the
    solver. Solvable \Parm{}s have this symdep.
  
  \end{description}
  
  A node's set of symdeps is generally known to the node class at construction
  time. Then, when a tree is initialized, different symdeps are dynamically
  associated with different bits of the depmask, as described below.
  Essentially, this maps the abstract concepts (the symdeps) onto specific bits
  of the depmasks. In other words, this mechanism is what determines the
  bitmask semantics.

\subsubsection{Symdep masks}

  Note that certain nodes can be viewed as symdep {\em generators}. These are
  nodes that generate new requests. For example, the \qq{Sink} node generates
  requests with different domains and resolutions, thus we say that \qq{Sink}
  generates the \qq{"Domain"} and \qq{"Resolution"} symdep. The \qq{ModRes} node
  changes the resolution of requests, thus it generates the \qq{"Resolution"}
  symdep. The \qq{Solver} node generates the \qq{"Parm.Value"} symdep.
  
  These nodes are responsible for associating a particular bit of the depmask
  with each symdep that they generate. Typically, they will do this once when a
  tree is initialized. These associations (known as {\em symdep masks}) are
  then recursively sent up the tree, thus becoming known to all child nodes.
  Nodes up the tree can then compute their local depmasks by combining the
  symdep masks of their specific symdeps.

\subsection{Symdeps: the hairy details}

  This section describes the details of how symdeps and depmasks are set up and
  maintained. Note that all this is maintained in the node state record.

\subsubsection{Known and active symdeps} 
  
  The {\em known symdeps} of a node are just that, all the symdeps that a node
  class knows about. Typically, this is specified once and for all in the
  node class's constructor, by calling the \qq{setKnownSymDeps()} method.
  
  A subset of the known symdeps -- the {\em active symdeps} set -- determines
  what symdeps currently apply to the node's result. For some node classes,
  this is always the entire known set. Some classes, however, may change their
  active set depending on state. For example, if a \qq{Constant} node is
  configured to provide a constant value as a sampling, then it has no active
  symdeps at all, as the value will be the same for any domain or resolution.
  However, if it is (re)configured to provide the constant as an integration,
  then it begins to depend on resolution -- since the integrated value is the
  product of the sample value and cell size.

  The active symdeps set may be changed by calling the \qq{setActiveSymDeps()}
  method, or by changing the \qq{active\_symdeps} field (a list of \qq{HIID}s)
  of the state record. Whenever this is done, the local depmask is
  automatically recalculated using the known symdep masks, by calling the
  virtual \qq{resetDependMasks()} method.

  The known symdeps may also be changed at any time (though I can hardly see
  why anyone would want to do this), by calling the \qq{setKnownSymDeps()}
  method, or by changing the \qq{known\_symdeps}  field of the state record. 
  
\subsubsection{Propagating symdep masks}

  A node will automatically keep track of the symdep masks associated with its
  known symdep set. This is done via the rider command facility (see below),
  and implemented via \qq{Node::processCommands()}:

  \begin{itemize}
  
  \item The \qq{Add.Dep.Mask} command contains a map of symdeps to symdep
    masks. (This command usually originates at the symdep generator nodes, see
    ``Generated symdeps'' below). In response to this command, \qq{Node} adds
    all the masks it finds for its known symdeps to its internal map of symdep
    masks. After this, it calls \qq{resetDependMasks()} to recalculate its
    local depmask. 

  \item The \qq{Clear.Dep.Mask} command clears all known symdep masks.
  
  \end{itemize}
  
  One consequence of this design is that each node maintains its own local
  mapping of symdeps to depmasks. While at first glance this may seem redundant
  and even wasteful -- since the mapping would appear to be the same throughout
  a tree -- consider the following points:

  \begin{itemize}
  
  \item When a tree is distributed throughout a cluster, maintaining a single
    ``global'' map becomes difficult (and actually violates the principle of
    locality!) Keeping a copy of the map at each node avoids this problem.

  \item The map is not really global anyway. For example, consider a rippled
    tree with multiple solvers. The solvable parm set of solver 1 and the
    solvable parm set of solver 2 need to be represented by different bits in
    the depmask. Thus, the \qq{"Parm.Value"} symdep of different groups of
    parms will actually be mapped to different depmasks!
    
    Note that node group facility (see processing of rider commands, below)
    provides an elegant mechanism for distributing different symdep masks to
    different node groups.
    
  \item The map is small, and changes very infrequently (if at all -- usually,
    it will be set up only once when a tree is initialized). Thus there is no
    performance cost associated with keeping local copies.

  \end{itemize}
  
  The map of known symdep masks is maintained in the \qq{symdep\_masks} field of
  the node state record. It is possible to change this field on the fly, an
  automatic call to \qq{resetDependMasks()} always results.

\subsubsection{Generating symdep masks}

  Nodes that generate new requests also need to generate \qq{Add.Dep.Mask}
  commands containing their symdep masks assignments. \qq{Node} provides a
  simple facility for doing this automatically.
  
  A node class can specify its mapping of {\em generated symdeps} to masks
  by calling the \qq{setGenSymDeps()} method at construction time. The standard
  node classes specify some pre-assigned masks by default: bit 0 for
  \qq{"Parm.Value"}, bit 1 for \qq{"Resolution"}, bit 4 for \qq{"Domain"}. This
  allows for simple trees to be put together using just the defaults.
  
  For more elaborate trees -- e.g., rippled trees with multiple solvers --
  different \qq{Solver} nodes need to be assigned different masks for the same
  symdep. This can be done via the \qq{gen\_symdeps} field of the state record.
  This field has to contain a map (e.g. record) of symdeps to depmasks; if
  specified, it overrides any previously set mappings. 
  
  Additionally, a node may be configured to generate symdeps for a particular
  node group only. This useful for, e.g., multiple solvers. By default, the
  \qq{All} group is used, but this can be overridden via the
  \qq{gen\_symdeps\_group} field of the state record.

  Once the generated symdeps are configured, a node needs to be told to send
  them up to its children. This is done by passing it the \qq{Init.Dep.Masks}
  command via a request rider. In responce to this command,
  \qq{Node::processCommands} inserts the appropriate \qq{Add.Dep.Mask} commands
  into the request rider based on the current setting of \qq{gen\_symdeps} and
  \qq{gen\_symdeps\_group}.
  
  Operationally, all this is typically done only once at init time:
  
  \begin{itemize}
  
  \item Request generator nodes are created with an initial state record
    containing their generated symdep assignments (if the default assignments
    need to be overridden).
    
  \item Once all the nodes and trees have been created, a request containing
    two following two commands is given to all the root nodes:
    \qq{Resolve.Children} and \qq{Init.Dep.Masks}. (The first command is
    required to resolve named children).
    
  \item This initial request is propagated up the tree, acquiring symdep masks
    from generator nodes along the way. 
    
  \item All trees are now ready for use.
  
  \end{itemize}

\subsubsection{Order of state updates}

  Because it is possible to change everything about a node's symdeps and masks
  by modifying the state record, and a state update may contain multiple
  fields, the order in which it is updated becomes important.
  \qq{Node::setStateImpl()} employs the following order:

  \begin{enumerate}
  
  \item Updates the known symdep set from \qq{known\_symdeps}, if specified.
  
  \item If specified, reloads the symdep masks from \qq{symdep\_masks}, and
    calls \qq{resetDependMasks()}.
    
  \item If specified, sets the active symdeps from \qq{active\_symdeps}, and
    calls \qq{resetDependMasks()}.
    
  \item If specified, sets the local depmask from \qq{depend\_mask}.
  
  \end{enumerate}
  
  Basically, this order implies that if the local depmask is explicitly changed
  via \qq{depend\_mask}, the specified value overrides any implict value
  calculated from, e.g., an \qq{active\_symdeps}.
  
\subsubsection{Specialized node behaviour}  
  
  Note that all these facilities are provided at the basic \qq{Node} level, but
  special node classes are free to ignore them, or make use of only some
  subset. For example, the \qq{Parm} class\footnote{And currently, this is the
  only example.} needs to maintain separate predict symdeps and solve symdep
  sets. It deals with this in the following way:

  \begin{itemize}
  
  \item It ignores the \qq{Node}-level active symdeps, initially specifying an
    empty set of active symdeps. This implies that its \qq{Node}-level local
    depmask stays at zero.

  \item It maintains two of its own symdep sets: predict symdeps and solve
    symdeps, and two corresponding depmasks: the predict depmask and the solve
    depmask.
    
  \item It overrides the \qq{resetDependMasks()} method, to recompute the two
    depmasks whenever known symdep masks change.
    
  \item It returns either one or the other mask from \qq{getResult()}, depending
    on what sort of request is being serviced.

  \end{itemize}
  
\section{The details of Node::execute()}

  The virtual \qq{Node::execute()} method is responsible for processing a
  \Request. The default version decomposes the request and calls a number of
  virtual methods to handle it. All but the most exotic nodes should only need
  to implement the handlers -- but the possibility to reimplement
  \qq{execute()} itself is always there. \qq{Node::execute()} does the
  following:

  \begin{enumerate}
  
  \item Compares the request id to the id of the previous request, if any. If
    there's a cached \Result, and the request id ``matches'' the cached request
    id, then does nothing, immediately returning the cached \Result.  If IDs do
    not match, clears the cache. (Note that the matching is not a literal
    comparison -- instead, the depmask is taken into account. See the discussion
    on depmasks above).

  \item For new requests only: calls the virtual \qq{readyForRequest()} method,
    and if the return value is false, immediately returns \qq{RES\_WAIT}.

  \item For new requests only: if a rider record is present, parses it and 
    calls the virtual \qq{processCommands()} method if a command set for the
    node is found (see details below).

  \item If node has children, calls the virtual \qq{pollChildren()} method to
    collect results from its children. The default implementation of this
    method calls \qq{execute()} with the same \Request\ on all the child nodes,
    collecting their \Result{}s into a vector of \qq{Result::Ref}s, and
    computing the {\em cumulative result code} as a bitwise-OR of the child
    return values. If any child returns a \RES{FAIL}, it creates an output
    \Result\ containing a merge of all the fail-results. Otherwise, if
    auto-resampling is enabled (see below), it will compare the child results'
    resolutions, and resample them as appropriate.

    If the cumulative result code from \qq{pollChildren()} contains \RES{WAIT}
    or \RES{FAIL}, \qq{execute()} returns immediately with that result code.  

    Note that the default implementation of \qq{pollChildren()} is appropriate
    for most node classes, with the exception of specialized ``control'' nodes
    such as \qq{Sink} and \qq{Solver}.

  \item If a \Cells\ object is present, calls the virtual \qq{getResult()}
    method, passing in the vector of child \Result{}s returned by
    \qq{pollChildren()}. Bitwise-ORs the return value with the cumulative
    result code from the children, OR the local node depmask.

  \item If an exception is thrown at any stage of the process, \qq{execute()}
    will catch it, create an output \Result\ with a fail-result describing the
    exception, and return \RES{FAIL}. Thus, throwing an exception is a normal
    way for \qq{setState()} or \qq{processCommands()} or \qq{getResult()} to
    indicate failure.

  \item Upon exit, optionally stores the output \Result\ and result code in the
    cache (see caching issues, below).

  \end{enumerate}

  The return value of \qq{execute()} is simply the accumulated result code.
  
\subsection{Result codes}

  The return value of \qq{execute()} is meant to be a result code describing
  certain properties  of the returned \Result. It is a bitmask composed of a
  number of flags listed below. Each flag describes a certain property of the
  \Result. The property semantics are defined in such a way that, in most
  practical cases, a flagged property in any child result is inherited by the
  parent's result. This allows \qq{execute()} to accumulate the correct result
  code via a simple bitwise-OR. In other words, only a few classes (Parm, Time,
  Freq, Spigot, and perhaps some special nodes) have any specific logic for
  determining result codes. For all other classes, the correct result code is
  simply the bitwise-OR of their children's codes. The following bits are
  defined:
  
  \begin{description}
  
  \item[\RES{UPDATED}:] result has changed from that of previous \Request. This
    bit is usually automatically cleared when the node returns a result 
    from the cache, and set otherwise.
     
  \item[\RES{DEP(0)}, \RES{DEP(1)}, etc.:] result will change if the $i$-th
    index of the request ID changes. This is simply the {\em depmask\/} discussed
    in the section on Requests above.

  \item[\RES{DEP\_VOLATILE}:] result may change in response to external events,
    even without new requests. (This is not implemented for now, and only meant
    as a placeholder for future developments, such as dynamically growing
    domains, partial integration, etc.)

  \item[\RES{FAIL}:] result is a ``complete'' fail. Note that this is not the
    same thing as a result containing some mix of valid and failed VellSets;
    rather, this indicates a failure for the whole result overall. \RES{FAIL}s
    are usually generated when a node runs into some unrecoverable error.
    
    When this flag is returned, a \Result\ object is expected; it should
    contain one or more fails describing the error. Note that dependency flags
    can be meaningfully combined with \RES{FAIL}.

  \item[\RES{WAIT}:] no result available, wait for notification or try later.
    If this flag is raised, then no \Result\ should be returned. Note that
    dependency flags can and should be meaningfully combined with \RES{WAIT},
    since it usually possible to indicate the dependencies of a node in
    advance.

  \end{description}
  
  The return value of a node's \qq{getResult()} method should describe any {\bf
  additional} properties introduced by the \qq{getResult()} calculation.
  Most function nodes will
  return zero, indicating that a node does not introduce any additional
  dependencies into the result. 
  
\subsection{Caching issues}

  To avoid unnecessary recalculations, a node's result can be retained in a
  cache. Obviously, this trades off performance against memory footprint. Three
  broad caching policies have been identified so far:

  \begin{description}
  
  \item[Never:] no caching at all, values are always recalculated anew. 
   
  \item[Always:] result is always cached, until a different request comes in.
    (This is the policy implemented currently). While expensive in terms of
    memory, this can be very useful for debugging, since it allows one to pause
    the system and examine the most recent result of every node.

  \item[Smart:] result is cached according to memory availability, expected
    request sequence, etc.

  \end{description}
  
  Caching policy should be settable on a per-node basis, via the init record
  (and changed via \qq{setState()}). The cache itself is simply part of the
  node's state record (and thus can even be changed manually if needed.)
  
  The ``Smart'' policy is the really interesting one. The combination of result
  codes, hierarchical request IDs and next-request hints allows us to get
  pretty smart. 
  
  Let's call the individual components of a request ID {\em dependencies} --
  because the \RES{DEP} flags in the result code describe what the result
  depends on. Note that a parent result inherits dependencies from all its
  child results, thus the parent dependencies are always a superset of any
  child dependencies (i.e. equal to or larger.) The following simple rules seem
  reasonable:

  \begin{enumerate}
  
  \item If a dependency will change in the next request, then node can clear
    cache (since the next request will invalidate it anyway).

  \item If the parent dependencies are exactly equal to those of a child, then
    the parent does not need the child's cache (because any request requiring a
    recalculation of the parent result will also require a recalculation of the
    child result.)

  \item If the parent dependencies are larger than those of a child, then the 
    child should retain cache (unless [1] holds for the child.) 

  \item A child must retain cache unless [1] is true, or {\bf all} its parents
    have told it to release cache.

  \end{enumerate}
  
  Note also that when a node retains the result in a cache, it also retains the
  dependency mask and the request ID. When deciding whether to return the
  cached result or recalculate the request (see step [1] of \qq{execute()}),
  the request IDs are matched according to the dependency mask.
  
\subsection{Commands in request riders}

  The optional \qq{rider} sub-record of a \Request\ may be used to send
  additional commands to specific nodes. The Solver node, for example, makes
  heavy use of this feature to implement iterative solutions. Command sets are
  specified via records, with the field names being the commands per se, and
  the field values being the command arguments. If the record contains multiple
  commands, they are processed in a specific order. Some example commands are:

  \begin{description}
  
  \item[\qq{state}:] to change the state of a node (available for all nodes);
  
  \item[\qq{set\_value}:] to change the values of a polc in a MeqParm (see
  below);
  
  \item[\qq{save\_polc}:] to save the polc(s) in a MeqParm (see below).
  
  \end{description}
  
  The rider record is structured so that it is possible to associate a command
  with a specific node or a set of nodes. A node will check if the request
  contains any commands for itself. Note that in a very large tree, these
  repeated checks may become expensive. It is for this reason that we introduce
  the concept of {\em node groups}. 
  
  A node may be associated with one or more groups. Groups are specified via a
  list of HIIDs passed in the \qq{.node\_groups} field of the init record (they
  can subsequently be changed via \qq{setState()}). All nodes automatically
  belong to the \qq{all} group. A node's groups are used as a first-level index
  into the \qq{rider} record. If a node belongs to groups \qq{foo} and
  \qq{bar}, then \qq{Node::execute()} will check for the {\em command
  subrecords}\/ (CSRs) \qq{rider.foo}, \qq{rider.bar}, and \qq{rider.all}, in
  that order, and process any subrecords that it finds.

  Each CSRs contains a number of command sets. These command sets may be
  associated with specific nodes. There are three ways to specify these
  associations:
  
  \paragraph{All nodes in group:} The command sets specified via the field
  \qq{command\_all} is applied to all nodes in the group. For example:

\begin{verbatim}
  - req.rider.foo.command_all
  [ save_polc=T,state=[solvable=F] ]  
\end{verbatim}

  ...will call \qq{processCommands()} on all nodes in group \qq{foo} (saving
  polcs and setting their state to non-solvable.)

  \paragraph{Via node index:} Command sets may be associated with a specific
  node index. This is done via field \qq{command\_by\_nodeindex}, which is
  essentially a map from node index to command set. For example:

\begin{verbatim}
  - req.rider.foo.command_by_nodeindex
  [ #19 = [ value=1,save_polc=T ], #41 = [ value=2,save_polc=T ] ]
\end{verbatim}

  ...will cause a \qq{processCommands()} call on nodes 19 and 41. (Note that
  since Glish only supports strings for record field names, the \qq{'\#ddd'}
  form is used to specify a ``numeric'' node index.)

  \paragraph{Via lists:} The third way is to associate command sets with nodes
  listed by name or node index. This is specified via field
  \qq{command\_by\_list}. For example:

\begin{verbatim}
  - req.rider.foo.by_list
  [ *1 = [ name="RA DEC",nodeindex=[17,32],state=[solvable=T],command=[save_polc=T] ],
    *2 = [ state=[solvable=F] ]
\end{verbatim}

  ...will call \qq{processCommands()} with the first command set on nodes RA,
  DEC, \#17 and \#32, and with the second command set on all other nodes in
  group \qq{foo}. To be more specific, the \qq{command\_by\_list} field is
  treated as a list  of records. Each record in the list is a command set, with
  an additional \qq{name} field (string or vector of strings) and/or a
  \qq{nodeindex} field (integer or vector of integers). \qq{Node::execute()}
  will iterate through the records one by one; if the node's name is found in
  \qq{name}\footnote{In the future, pattern matching will be supported as
  well.}, or the node index is found in \qq{nodeindex}, then
  \qq{processCommands()} is called with the contents of that record. Once a
  match is found, list processing stops. As a special case, if neither
  \qq{name} nor \qq{index} is specified, then the entry is a ``wildcard''
  matching any node. Wilcards are only useful at the end of the list, to catch
  nodes not already matched by previous entries.
  
\subsubsection{Command evaluation order}

  In cases where a node finds more than one command set associated with it, the
  order of processing becomes important. The rider is parsed in the following
  order:

  \begin{itemize}
  
  \item The outer loop is over node groups, in the order in which they are
  specified in the node state record. The \qq{all} group is checked last.
  
  \item Within a group's command sub-record, the processing order is from least
  specific to most specific: \qq{command\_all}, \qq{command\_by\_list},
  \qq{command\_by\_nodeindex}.
  
  \item Once a command set is passed to a node's \qq{processCommands()} method,
  the order of processing is determined by the node class implementation.
  Generally, a subclass should call its parent's \qq{processCommands()} first,
  so general commands (such as \qq{state}) should be processed before
  more class-specific commands (such as \qq{save\_polc}).
  
  \end{itemize}
  
\section{Resolution \& Gridding}

  Resolution \& gridding is a complicated business. Some basic requirements
  are:

  \begin{itemize}
  
  \item In the first instance, the grid/resolution is determined by incoming
  data. We'll call this the {\em full resolution} grid.

  \item It may be prohibitively expensive to evaluate some subtrees (e.g.
  predict) at full resolution. Thus we should support going from full
  resolution to {\em reduced resolution} (integration) and back (upsampling). 
  
  \item Parent nodes will not always have sufficient information to determine
  what the best resolution for a child is. Thus, a child should be able to 
  return data at any resolution is deems fit, and let the parent deal with it.
  
  \end{itemize}
  
  To satisfy these requirements, the following behaviour w.r.t. resolution
  is implemented:
  
  \begin{enumerate}
  
  \item The resolution (and gridding) of a \Request\ is determined by the
  \Cells\ object within. The \Cells\ contains a vector of cell centers and cell
  sizes along each axis (time, frequency), plus the envelope domain. 

  \item The \Cells\ of a \Request\ are merely a hint! A node is not obligated
  to honor the requested grid -- only its envelope domain. The gridding of the
  result is indicated by the \Cells\ returned in the \Result\ object.

    \begin{itemize} 

    \item Some nodes (e.g. \qq{Parm}, \qq{Freq}, \qq{Time} -- generally, nodes
    meant to evaluate some analytic function of time and frequency -- are able
    to evaluate themselves over any given grid. These nodes will always return
    a \Result\ with the same \Cells\ as the \Request; the tree designer may
    rely on this behaviour.

    \item Data-driven nodes (e.g. \qq{Spigot}) completely ignore the \Cells\
    of the \Request. The gridding of their \Result\ is fully determined by
    incoming data.

    \end{itemize}
    
  \item A lot of node classes (e.g., all the \qq{Function}-derived ones)
  require child results to have the same resolution. In the event that this is
  not the case, a node can be configured to deal with it in one of four ways,
  as determined by the \qq{auto\_resample} field of the state record:

    \begin{description}
    
    \item[NONE $(=0)$:] do nothing, do not even check the child resolutions. This
    is the default setting initialized by the \qq{Node} class constructor.

    \item[FAIL $(=-2)$:] check resolutions and return a \qq{RES\_FAIL} if they do
    not match. This is the default setting  initialized by the \qq{Function}
    class constructor. Since this is somewhat slower that the NONE setting, 
    perhaps it should only be the default in debug mode?
    
    \item[INTEGRATE $(=-1)$:] evaluate and return a \Result\ at the lower
    resolution, by integrating higher-resolved child results.

    \item[UPSAMPLE $(=1)$:] evaluate and return a \Result\ at the higher
    resolution, by upsampling lower-resolved child results.

    \end{description}
    
  Auto-resampling is handled at the base \qq{Node} level (in
  \qq{Node::processChildren()}, and thus may be enabled for any individual node
  (although node classes that do their own polling of children -- e.g.,
  \qq{Solver} -- may ignore the flag.) In the rippled solvers tree (Fig. ??),
  nodes which enable auto-resampling are indicated by an "UPS" or "INT" label
  in the node box. 

  \item A few utility nodes may be used to change resolution mid-tree.
  Initially, two such nodes will be provided:

    \begin{description}
    
    \item[\qq{Resampler}:] this node guarantees a \Result\ at the requested
    resolution. A \qq{Resampler} has a single child. It passes the parent's
    \Request\ on to the child, and if the returned \Cells\ are different from
    the requested ones, then it resamples the result to the requested \Cells\
    before returning it to the parent.

    \item[\qq{ModRes}:] this node modifies a \Request's resolution up or down
    by a fixed factor (or to a fixed number of cells along either axis), as as
    determined by its state record (dynamic configuration). This node has a
    single child. The modified \Request\ is passed on to its child, and the
    child's \Result\ is returned.

    \end{description}
    
  In the future, we envision more nodes, such as an adaptive resolution
  reducer, which adaptively selects a minimum required resolution based on the
  results of the child. At the moment, the \qq{ModRes} node is a suitable
  proxy. 

  \item Data access nodes (\qq{Sink} and \qq{Spigot}) are coupled. For each
  snippet of data, the \qq{Sink} will issue a \Request\ with \Cells\
  corresponding to the data layout. The corresponding \qq{Spigot} will then be
  able to return a \Result\ with the same cells.
  
  \item For the time being, we'll only support integral resolutions -- i.e.,
  the full resolution cells must be tilings of the reduced resolution cells.
  This keeps things simple, and avoids interpolation errors. In the future, we
  may support arbitrary regridding.

  \end{enumerate}
  
  It is, of course, up to the tree designer to ensure that resolution is
  changed up and down appropriately within the tree, by strategically
  positioning \qq{Resampler} and \qq{ModRes} nodes, and enabling
  auto-resampling at a few specific nodes. The tree in Fig. ?? provides a good
  example of this.


\section{Description of specialized nodes}

\subsection{ReqSeq}

  \qq{ReqSeq} is the {\em request sequencer} node. It is used to sequence the
  execution of requests between subtrees.
  
  Normally, if a node has multiple children, they may recieve \& execute their
  requests in parallel, with no predefined order (note that in a
  single-threaded system, they will effectively execute in sequence, however,
  you cannot design a tree to rely on this behaviour). Some applications
  require that branches of the tree are evaluated in a specific order. For
  example, in the rippled solvers tree (Fig. ??), the Predict--Solver branch
  must be executed first, to determine values for the solvable parameters,
  followed by Predict--Subtract.
  
  The sequencer (\qq{ReqSeq}) node provides an easy way to sequence these
  requests. A sequencer may have any number of children. Upon receiving a
  request from its parent, the sequencer will pass it on to the first child,
  and wait for the first child to return a result. Then it will go on to the
  second child, etc. For its own result, the sequencer returns the result of
  one of the children, as determined by its state record (run-time
  configurable).

\subsection{Resampler}

\subsection{ModRes}

\subsection{MeqParm}

  The \Parm\ node implements a possibly solvable Measurement Equation
  parameter. The parameter is represented by one or more \Polc\ objects.

\subsubsection{MeqPolc}

  The \Polc\ class implements a 2D polynomial in time and frequency. The Glish
  equivalent is a \qq{meq.polc} record. This record will contain the following
  fields:
  
  \noindent\begin{tabular}{lp{.8\textwidth}}
  \qq{.coeff}  &  a 2D array of polynomial coefficients.\\
  \qq{.freq\_0}  &  \\
  \qq{.freq\_scale}  &  \\
  \qq{.time\_0}  &  \\
  \qq{.time\_scale}  & the scale of the polc (see below)\\
  \qq{.domain}  & (optional) the polc \Domain.\\
  \qq{.weight}  & weight\\
  \qq{.pert}  & perturbation to use for computing derivatives\\
  \qq{.dbid\_index}  & database ID (see below)\\
  \qq{.inf\_domain} &  optional flag: infinite domain (see below)\\
  \qq{.grow\_domain} &  optional flag: growing domain (see below)\\
  \end{tabular}
  
  The value of a polc for frequency $f$ and time $t$ is computed as follows:

  \begin{equation}
  p(f,t) = \sum_{i=0}^{N-1}\sum_{j=0}^{M-1} c_{ij}(\frac{f-f_0}{s_f})^i(\frac{t-t_0}{s_t})^j
  \end{equation}
  
  Here, $c_{ij}$ is an $N\times M$ array of coefficients (\qq{coeff}), and
  $f_0,s_f,t_0,s_t$ is the scale of the polc. The scale is only necessary to
  keep numbers small so as to avoid round-off errors.

\subsubsection{MeqParm state}

  Here's the layout for a \Parm\ state record. All of these attributes are
  dynamic state, that is, they may be changed at any time via \qq{setState()}:
  
  \begin{description}

  \item[\qq{solvable}] (bool, optional) is this \Parm\ solvable or not?
    Default is non-solvable.

  \item[\qq{polcs}] (list of \Polc{}s, optional) the parm's polc list (see below).

  \item[\qq{table\_name}] (string, optional) the name of a MEP table. Default is none.
    If no table is provided, then polcs must be specified via either the
    \qq{polcs} or the \qq{default} field.

  \item[\qq{parm\_name}] (string, optional) the name to use when working with a MEP
    table. Default is to use the node name itself.

  \item[\qq{default}] (\Polc, optional) a default \Polc, to be used as a last
    resort (i.e. if no polcs found in the MEP table).

  \item[\qq{auto\_save}] (bool, optional) If true, any updates to the parm's 
    polcs are immediately saved to the MEP table. If false, updates need to be
    explicitly saved (more on this below). Default is false.

  \end{description}
  
\subsubsection{Selecting polcs}

  The \qq{Parm::getResult()} method is responsible for evaluating a parm over a
  \Cells\ (specifically, over the domain of the \Cells). To do this, the parm
  needs to find an appropriate polc or polcs for the given domain. Most of the
  tricky logic of the \Parm\ class is dedicated to choosing the right set of
  polcs.  Currently, it will select polc(s) as follows:

  \begin{enumerate}
  
  \item If no MEP table and no default polc has been set in the state record,
    then the parm will blindly re-use the current polc list (i.e. the
    \qq{polcs} field of the state record), or fail if the list is empty.  No
    further error checking is done, and it is up to the user to ensure that the
    parm has been initialized with polcs that are meaningful w.r.t. the domain
    of the request.

  \item Otherwise, the parm will first see if it can re-use the current polc 
    anyway. The current list must contain a single polc, which is tested for
    re-usability as follows:

    \begin{enumerate}
    
    \item If the \qq{inf\_domain} flag is set, the polc has an infinite domain, 
      and can be re-used.
      
    \item If the \qq{grow\_domain} flag is set, and the requested domain is a
      superset of the polc's current domain, then the domain of the polc is
      expanded to match the requested domain, and the polc can be re-used. 

    \item If the requested domain is a subset of the polc's current domain, the
      polc is re-used.

    \end{enumerate}

  \item If no re-use is possible, the current polc list is cleared. The parm
    will then query its MEP table for polcs whose domain overlaps the requested
    domain. These polcs are loaded into the polc list.

  \item If no polcs are found in the MEP table, the table is checked for a
    default polc. Note that default polcs have no domain (generally, they will
    only have a $c_{00}$ coefficient). If a default polc is found, it is placed
    in the list, and its domain is set to the requested domain.

  \item If no default polc is found in the table, or if no table is available,
    then default polc from the state record is copied into the list, and its
    domain is set to the requested domain. Note that the case of no table and
    no default polc is covered by (1), above.

  \end{enumerate}
  
  Once the selection is complete, the parm will have at its disposal a list of
  one or more polcs. 

\subsubsection{Selecting a single solvable polc}
  
  If the parm is set to solvable, the polc list is then culled to a single polc
  (NB: future versions may support solving for multiple polcs). This polc is
  selected according to the following criteria (in descending order of
  importance):

  \begin{itemize}
  
  \item an exact match of the requested domain to the polc domain;
  
  \item weight (higher is better);
  
  \item database ID (higher, i.e. more recent, is better).
  
  \end{itemize}
  
  Once a single solvable polc is selected, its domain is set equal to the
  requested domain.
  
\subsubsection{Evaluating the polc list}

  A single polc is evaluated directly over the \Cells\ of the incoming
  \Request. The resulting \VellSet\ object (polc value, plus optional
  derivatives) is then returned to the caller. 
  
  If the parm contains multiple polcs, different evaluation schemes are
  possible:

  \begin{description}

  \item[Tiled polcs.] This is the only scheme implemented by \Parm\ at time of
  writing. For every polc in the list, \Parm\ computes the overlap between
  the polc's domain and the domain of the request. The polc is then evaluated
  over that part of the \Cells\ grid which falls within the overlapping area.
  This step is repeated for every polc. Sections of the grid with no polc
  domain coverage are assigned a zero value.

  Obviously, this scheme is most suitable when the polcs neatly tile
  the request domain. Note that the result is generally discontinuous across
  tile boundaries, which can be quite useful for representing things such as
  phase jumps. On the other  hand, if the request domain is not completely
  covered, or if the polc domains overlap, the results of this scheme are not
  very well defined. 

  \item[Weighted mean.] Each polc is associated with a set of weights, defined
  on the \Cells\ grid. Different weighting schemes may be employed. Presumably,
  grid points within the polc's domain are assigned a higher weight, while
  points outside the domain get a lower weight, further decreasing as we get
  further away from the domain. The value of the parm at each grid point is
  then simply a weighted mean of all the polcs' values.

  The advantage of this scheme is that it gracefully incorporates polcs with
  overlapping domains, while allowing for extrapolation to non-covered areas of
  the request domain. The result is always smooth and continous -- which, on the
  other hand, may not always be what you want. The downside is computational
  expense, as each polc needs to be evaluated at each grid point.

  \item[Reduction to single polc.] This scheme involves fitting a single polc
  (usually of a higher order) to multiple polcs. It can already be implemented
  externally (see \qq{fitpolcs\_wlc.g} for an example), as a ``preprocessing''
  stage of sorts. The scheme works by evaluating the polcs over some set of
  points within the request domain (not necessarily the \Cells\ grid at all),
  combining the results using some sort of weighted mean, then doing a
  least-squares fit of a new polc to the resulting values.

  \end{description}

\subsubsection{Updating and saving polcs}    

  In the course of a solution, the Solver node updates the values of solvable
  polcs by sending up new values in the request rider. This is done by
  including the \qq{Update.Values} command in the rider. The value of the
  command is expected to be a vector of new coefficients, in the same order in
  which spids were assigned. More specifically:

  \begin{itemize}
  
  \item When a \Parm\ that has been set solvable initializes a new polc for a
  domain, it associates a number of spids with its coefficients. Spids are
  assigned as $256*${\em nodeindex}$+i$, where $i$ is the number of the
  coefficient.
  
  \item These spids are included in the resulting \Vells; as results percolate
  down the tree, spid vectors and corresponding perturbed values from different
  solvable \Parm{}s are merged. The \Vells\ received by the solver contain the
  full set of spids from all the solvable \Parm{}s in its trees.

  \item The Solver computes a set of incremental updates. Note that the Solver
  knows nothing of \Polc{}s or \Parm{}s; instead, it only deals with abstract
  ``atomic parameters'' identified by spid.

  \item The solver inserts the updates into the rider of the next request, as
  a set of \qq{Update.Values} commands. This request is then used to recalculate
  the trees for the next iteration. If this is the last iteration, then a
  request without a \Cells\ is sent up -- this updates the values without
  recalculating anything.
  
  \end{itemize}
  
  Presumably, at some point the new polc values need to be stored into a MEP
  table. There are two ways to accomplish this:

  \begin{description}
  
  \item[Automatically:] if the \qq{auto\_save} flag is set in the \Parm\ state
  record, then each update via \qq{set\_value} is immediately committed to the
  MEP table.

  \item[With explicit command:] whenever the \Parm\ receives a request with a
  \qq{Save.Polcs} command in the rider, it commits all its polcs to the MEP
  table.

  \end{description}
  
  The \qq{dbid\_index} attribute of the \Polc\ is used to keep track of its
  location in the MEP table. When a polc is loaded from the table (whether on
  the C++ side, or via the Glish \qq{meptable()} object), \qq{dbid\_index} is
  set to its DB identifier.\footnote{As long as we use AIPS++ tables, this is
  simply the row number. If and when we employ other storage schemes, dbid  may
  become something different, but is in any case a key into the database.} 
  When a polc is subsequently saved, its dbid is used to locate the correct
  entry in the table. New polcs are created with a dbid of -1; when they are
  subsequently saved, a new entry is allocated in the MEP table, and the polc
  object is updated with the dbid. During normal operation, the user need not
  worry about this since everything happens automatically; some advanced
  scripting may require knowledge of the dbid.

\section{MeqServer interface}

Coming soon.

\end{document}
