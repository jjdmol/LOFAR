\chapter{Node Initialization \& State}

  The fundamental behaviour of \& interface to a node is provided by the C++
  class \qq{Meq::Node}. This is an abstract class; at least one pure virtual
  methods is declared (\qq{Node::getResult()}) that must be defined by
  subclasses to implement specific functionality.

  All nodes share the following basic traits:

  \begin{itemize}

  \item A node may have a number of child nodes. Generally, a node has no
    knowledge of the types of its children. Subclasses may assign formal child
    labels (akin to argument names) to specify semantics, or may leave their
    children unlabeled. Child labels are assigned via the constructor of the
    subclass.
    
    A node also has no direct knowledge of its parents, and is only allowed to
    infer things from the requests that it receives.

  \item Each node has a unique {\bf node index} (integer$>$0) and an optional
    unique {\bf node name}. A MeqForest object acts as a repository of nodes,
    and maintains a map between names, indices and node objects (see
    section~\ref{sec:meqserver}).

  \item A \Node\ maintains a {\bf node state record}, which should completely
    determine the behaviour of the node. 
    
  \item A \Node\ has an \qq{execute()} method, taking a \Request\ parameter,
    and returning a \Result. Normally, a node is expected to call
    \qq{execute()} with the same \Request\ on its children, and form its result
    based on the results of its children. Thus, requests propagate up the tree,
    and results percolate down the tree. This is discussed in
    Chapter~\ref{sec:execute}. 

  \end{itemize}
  
  The subject of handling requests will be dealt with later. This chapter deals
  with everything related to node initialization and state.
  
\section{Node state in C++ and Glish}
  
  Each node's state is mapped to a state record (\qq{DataRecord} in C++,
  standard record in Glish). The base \qq{Node} class defines this record and
  provides a number of tools for maintaining it. Note that the internal state
  of a C++ object, as determined by its data members, is physically different 
  form the state record, and it is up to the object itself to maintain {\bf
  coherency} between the two. Coherency is critically important, since the
  Glish layer only has access to the state record, and not to an object's
  internal data members. As will be seen below, the \qq{Node} class implements
  a number of facilities that simplify the task of maintaining coherency.
  
  Node state is almost always inherited from superclass to subclass. Subclasses
  define state in terms of {\em additions\/} to state defined by their
  superclass. State defined by the base \qq{Node} class is common to all nodes.

\subsection{Access to state}

  On the C++ side, state may be read via the \qq{Node::state()} method, and
  changed via the \qq{Node::setState()} method. On the Glish side, these are
  mapped to the \qq{getnodestate()} and \qq{setnodestate()} methods of the
  \qq{meqserver} proxy (see Chapter~\ref{sec:meqserver}). The argument to
  \qq{setState()} (or \qq{setnodestate()}) does not have to be a complete new
  state record; instead, it should only contain those fields that actually need
  to be changed. 
  
  Another mechanism of state changes is the {\em request rider}. A \qq{Request}
  can contain a command that changes the state of a node or a group of nodes
  (section~\ref{sec:request-set-state}).

  When a node is constructed, it is passed\footnote{ via the \qq{init()} method
  in C++, or via the \qq{createnode()} call in  Glish.} an {\bf init-record}
  (also called the {\bf defrec}, for {\em definition record\/}), which is
  nothing more and nothing less than the complete initial state record of the
  node. This is the mechanism via which all run-time arguments to a node are
  specified. Later in a node's lifetime, it may be reconfigured (via
  \qq{setState()} or request riders). A node is not obliged to be
  reconfigurable in every single aspect, although it's good design to make it
  so as much as possible. If some of the node state may only be set once via
  \qq{init()} and not changed later on via \qq{setState()} -- we'll call this
  {\bf static state} -- it should be clearly documented as such. The assumed
  default is {\bf  dynamic state}, i.e., state that may be reconfigured at any
  time via \qq{setState()}.
  
  The individual fields of the state record are known as {\bf state fields}.

\subsection{Categories of state fields}

  All state fields belong to one of the following categories:
  
  \begin{description}
  
  \item[Static state] can only be set up at construction time, via the
  init-record. Static state is protected: any attempts to modify it should
  return an error. By design, static state is kept to a minimum.

  \item[Dynamic state] can be specified at construction time, and freely
  changed later on via \qq{setState()} or request riders. Node classes are
  designed so that most of state is dynamic. This is the assumed default,
  unless clearly documented otherwise.

  \item[Informational state] does not affect the behaviour of a node. It is a
  one-way street: nodes maintain these fields to provide additional info to
  outsiders (thus improving transparency, i.e., monitoring and debugging), but
  any changes to these fields from the outside are simply ignored.
  
  Script code can monitor informational state, but should have any operational 
  dependencies on it. Due to performance concerns, the setting of informational
  state may be compiled out of optimized builds of the kernel. 

  \item[Other state] fields that a node class does not recognize are simply
  ignored. Outsiders may read and change these fields at will; this can be
  useful for tagging a node with additional informational attributes.
  
  \end{description}
  
\subsection{Clients}
  
  It is useful to introduce the term {\bf client}, referring a software
  component (or even the user himself) that initiates the creation of nodes,
  specifies state changes, issues initial requests, etc.

  From a node's point of view, the client is any external entity that accesses
  the node interface. From the \qq{meqserver}'s point of view, the client is the
  scripting layer, or perhaps another C++ component that interfaces with the
  \qq{meqserver}. From the scripting layer's point of view, the client is the
  user himself, or perhaps a batch script run by the user that uses standard
  functions in the scripting layer.

\subsection{The Node Contract}

  Even the base \qq{Node} class exhibits some non-trivial behaviour with
  regards to maintaining state and processing requests. This behaviour is not
  defined or constrained by the node interface as such. The node interface
  simply defines a collection of methods (\qq{init()}, \qq{setState()},
  \qq{execute()}) and data formats. Meanwhile, it's the implementations of
  these methods that provide additional semantics, such as tying node behaviour
  to node state.

  These additional semantics are known as the {\bf node contract}. For example,
  maintaining a state record that is coherent with internal C++ object state is
  part of the basic node contract. Responding to changes in dynamic state is
  another part of the contract. Other examples will be discussed below. In
  general, the contract is a set of obligations that a node can be trusted to
  follow.
  
  A conventional contract brings together at least two parties. In the case of
  the MeqTree kernel, the other party to the contract is the client  (scripting
  layer, tree builder, tree user, etc.). The obligations of the client are also
  specified in the contract. In particular, the \qq{setState()} interface to a
  node is an extremely powerful tool; node classes provide only minimal sanity
  checking, so it's always possible to configure a node into some sort of
  senseless state. Correct interaction of nodes within a tree requires nodes to
  be consistently configured. Thus, the contractual obligations of a node to
  behave correctly are only valid as long as the client meets its obligations
  of configuring the node(s) consistently. We will see specific examples of
  this later on.
  
  It is helpful to view the kernel in the context of a multi-layered software
  system. The lowest level is the MeqTree kernel itself; on top of that is the
  \qq{meqserver}, which provides an interface to a thin scripting layer. On top
  of that -- now completely in the scripting domain -- we have
  application-specific scripts to build trees, and still higher up, user-level
  tools to operate, manage and visualize trees. The interfaces grow more
  application-specific towards the upper layers, while contracts grow less
  specific. The overall design philosophy here relies on the fact that it is
  far easier to implement complex semantics in a scripting language; thus the
  higher layers in the scripting domain can ensure more and more elaborate
  aspects of the node contracts, until the user is completely protected from
  these complexities. 
  
  Note that an end user will hardly ever need to change (or even see) node
  state directly; a tree developer, however, will be working with this stuff
  constantly. As will become apparent in this chapter, a node's internals are
  completely exposed to tweaking and experimentation. The C++ kernel imposes no
  policy and does very few sanity checks, so it is perfectly possible  to
  thoroughly confuse a node (or an entire tree) through misguided  manipulation
  of its state record. Again, we assume that it is up to the scripting side
  tools to shield end-users from the more ``dangerous'' capabilities. Remember,
  prohibition is for policy-makers!

  When developing new node classes, it is very important to define and document
  their contracts in detail.
  
\section{Standard Node state fields}

  Table~\ref{table:nodestate} lists all the state fields defined and maintained
  by the \qq{Node} class. Here we will only discuss the basic fields; the more
  advanced ones will be documented in further chapters.

  \begin{table}[th]
  \begin{center}\begin{tabular}{|lccp{.55\textwidth}|}
%  \begin{center}\begin{tabular}{!{\color{tableheading}\vline}lllp{.55\textwidth}!{\color{tableheading}\vline}}
  \statetableheading
  \tablesubheading{4}{static state:}\\
%  
  \statetableentry{class}{string}{}{the node class }
  \statetableentry{nodeindex}{int}{0}{the node index }
  \statetableentry{children}{\rm ---}{\rm null}{children specification
    (see~\ref{sec:children})}
%  
  \tablesubheading{4}{dynamic state:}\\
%  
  \statetableentry{name}{string}{""}{node name}
  \statetableentry{node\_groups}{HIID[]}{[]}{list of groups that this node
    belongs to}
  \statetableentry{auto\_resample}{int}{0}{auto-resampling mode (see~\ref{sec:resampling})}
%  
  \tablesubheading{4}{cache-related dynamic state (see~\ref{sec:cache}):}\\
%
  \statetableentry{cache\_policy}{\rm ---}{\rm null}{caching policy {\em (placeholder; not currently
                                  implemented)}}
  \statetableentry{request\_id}{HIID}{\rm null}{rqid corresponding to cached result }
  \statetableentry{cache\_result}{Result}{\rm null}{cached result}
  \statetableentry{cache\_result\_code}{int}{0}{cached result code}
%                                  
  \tablesubheading{4}{depmask-related dynamic state (see
      Chapter~\ref{sec:depmasks}):} \\
%
  \statetableentry{depend\_mask}{int}{0}{current depmask }
  \statetableentry{known\_symdeps}{HIID[]}{[]}{list of known symdeps }
  \statetableentry{active\_symdeps}{HIID[]}{[]}{list of active symdeps }
  \statetableentry{symdep\_masks}{record}{[]}{current symdep masks}
  \statetableentry{gen\_symdeps}{HIID[]}{[]}{list of generated symdeps}
  \statetableentry{gen\_symdeps\_group}{HIID[]}{[]}{list of groups for generated symdeps}
%  
  \tablesubheading{4}{informational state:} \\
%      
  \statetableentry{children\_names}{string[]}{}{list of child names.
    Can't be used to specify child nodes: use the \qq{children} field instead.}
  \statetableentry{request}{Request}{}{last handled request}
  
  \hline
  \end{tabular}\end{center}
  \caption{\label{table:nodestate}Base state defined by the \qq{Node} class}
  \end{table}
  
\subsection{Constructing nodes: classes, names, indices}

  To construct a node, a client must provide the init record -- i.e., an
  initial state record. Note the ``default'' column in
  Table~\ref{table:nodestate} -- only a few state fields need to be specified,
  since the rest have reasonable defaults that will be filled in by the node at
  construction time (a default of ``null'' indicates that the field, if
  missing, will remain unfilled). Also, the cache-related and depmask-related
  state fields are not normally set at construction time, but rather are filled
  by the node itself during operation. The node state interface provides full
  access to them mostly for debugging and monitoring purposes.

  The class of a node is obviously an external, static property -- once a node
  object is instantiated, its class is defined ``for life''. The \qq{class}
  field is usually set by the client in the scripting layer, and used by the
  \qq{meqserver} component as a key into a {\em node constructor registry},
  when determining which node class to actually instantiate. The \qq{class}
  string is usually formed by concatenating the C++ namespace identifier with
  the C++ class name. Thus, a \qq{Meq::Parm} is specified as \qq{"MeqParm"}.
 
  The node index (field \qq{nodeindex}) is not normally specified by the client, but
  rather automatically assigned to the object at construction time, and placed
  into the \qq{nodeindex} field. The index is also a static property.

  The node name (field \qq{name}) is just a free-form identifier supplied by
  the client. The name is used to identify the object for subsequent
  operations. The \qq{meqserver} layer maintains a \qq{Forest}, which is
  essentially just a repository of node objects, with name$\rightarrow$node
  and  index$\rightarrow$node maps. A node may be created with an empty name
  (which is the default), such {\em anonymous} nodes are then only identifiable
  by their indices. Note that while the name of the node may be changed via a
  \qq{setState()} call, this is probably a bad idea, since the current
  \qq{Forest} implementation does not support node renaming (i.e. cannot update
  the name$\rightarrow$object map).

\subsection{Specifying children} 
  \label{sec:children}
  
  The \qq{children} field of the state record is used to specify a node's
  children. The children set is a static property\footnote{The ability to
  connect children dynamically may be implemented in future versions if
  necessary. In any case, it would be provided via a separate function rather
  than the generic \qq{setState()} mechanism, so the \qq{children} field would
  remain protected.}, and must be specified at construction time. The
  \qq{children} field takes the form of a list or record of {\bf child
  specifiers}. A child specifier can be:

  \begin{itemize}
  
  \item An integer node index referring to an already existing node.
  
  \item A string node name, which does not have to match an existing node. The
    child can be created later on; the \qq{meqserver} includes a mechanism 
    for {\em resolving} named children (see Chapter~\ref{sec:meqserver}).
    
  \item A record, which will be used as an init-record to create a child node on
    the fly. This option allows whole subtrees to be specified via one big
    nested record.
  
  \end{itemize}
  
  \subsubsection{Child labels}
  
  Certain node classes can predefine {\em labels} (\qq{HIID}s) to identify their
  children. Think of child labels as being the equivalent of named arguments in
  a programming language. Without labels, children can only be specified by
  their ordinal number (a-la positional arguments). Thus, labels help
  distinguish children with specific roles. For example, the \qq{UVW} node
  (used to compute $UVW$ coordinates) may label its children, e.g., ``Ra'',
  ``Dec'', ``X'', ``Y'', ``Z''. If the child roles are all the same (e.g.,
  the \qq{Sum} node, which sums the results of its children), or are obvious
  from position (e.g., binary function nodes, including non-commutative ones
  such as \qq{Sub} and \qq{Div}), then labels are not used.
  
  Labels have the following implications for the \qq{children} field:
  
  \begin{itemize}
  
  \item Given a node class that predefines child labels, \qq{children} may be
  specified as a record. Child labels are matched to field names (on a
  mismatch, node creation fails, and an error is reported.)

  \item If \qq{children} is a list rather than a record, then child nodes are
  simply matched by position, and any labels are ignored.
  
  \item If \qq{children} is a record but the node class does define any 
  labels, then child nodes are matched by their position in the record. This
  way of specifying children is discouraged, since the abstract record type
  does not provide for a fixed order of fields.

  \end{itemize}  
  
\subsubsection{Child information}
  
  After a node has been created and all children have been resolved, the
  \qq{children} field of the state record is replaced with either a list of
  child node indices if no labels are predefined, or a record of
  labels to indices otherwise. This field is treated as static state,
  so any attempts to modify it via the \qq{setState()} mechanism will fail. The
  (purely informational) \qq{children\_names} field is filled with a similar
  list or record of child names. 

\subsection{Node groups}

  A node may be assigned to one or more node groups. Node groups are used to
  restrict the commands of a \Request to a specific set of nodes. This
  mechanism is discussed in detail in section~\ref{sec:CSR}. Examples of its
  use may be found in the documentation for the \qq{Parm} and \qq{Solver}
  nodes.

\section{Creating init-records in Glish}

  The \qq{meq.node()} function (in \qq{meq/meqtypes.g}) can be used to put
  together a basic init-record. This record can then be extended with
  additional fields as required:

  \begin{verbatim}
    const meq.node := function (class,name,children=F,groups="")
  \end{verbatim}
  
  The mandatory \qq{class} and \qq{name} arguments are strings specifying the
  node class and node name. The optional \qq{children} argument is a list or
  record of child specifiers (see above). The \qq{groups} argument specifies
  the node groups, this can be a list of \qq{HIID}s or strings; in the latter
  case (as is usual for most \qq{meq} functions), \qq{meq.node()} will convert
  the strings to \qq{HIID}s automatically.
  
  Specialized node classes may define functions of their own to put together the
  corresponding init-records. An example of this is \qq{meq.parm()} (see Glish
  file for details).
  
  \subsection{The defrec map}
  
  The kernel build system includes a mechanism for automatically generating
  Glish scripts that define class-specialized init-records. This code -- known
  as the {\em defrec map} -- is generated based on comments found in each
  node's class header file, and may be used as an alternative to the
  \qq{meq.node()} function.
  
  The defrec map is made available by including \qq{meq/defrec.g}. This defines
  the following function:
  
  \begin{verbatim}
    const meqdefrec := function (class,name='',children=F,groups="")
  \end{verbatim}
  
  The function can be used exactly like \qq{meq.node()}, but with one important
  difference: it returns a complete init-record for the specified class,
  including any specialized fields defined by that class. These fields
  are initially populated with default values.
  
  In addition to this, the init-record returned by \qq{meqdefrec()} is also
  self-documenting. The record itself is tagged with a \qq{::description}
  attribute, containing a textual description of the node class. Record fields
  are also tagged with \qq{::description} attributes of their own.

\section{The C++ side}

  The rest of this chapter deals with implementation of node state on the C++
  side. You probably don't need to read this unless you're developing your own
  node classes.
  
  The following is a list of \Node\ methods responsible for initializing and
  changing state:

\begin{verbatim}
  // public: Initializes node with init record
  //         Note that Ref::Xfer implies that ref to record will be taken over
virtual void init (DataRecord::Ref::Xfer &initrec);

  // public: Reinitializes node with init record (called after de-serializing)
virtual void reinit (DataRecord::Ref::Xfer &initrec);

  // public: Changes dynamic node state (note: non-virtual)
  //         Node can attach to/take over record contents as needed.
void setState (DataRecord &rec);

  // protected: Checks init record for missing fields, fills in defaults where needed
  //            (called from Node::init())
virtual void checkInitState (DataRecord &rec);

  // protected: Implementation for setting or changing internal dynamic state 
  //            (called from Node::setState())
  //            Node can attach to record contents as needed. If initializing,
  //            then record is the state record and should not be changed. If
  //            not initializing, node can take over contents as well.
virtual void setStateImpl (DataRecord &rec,bool initializing);
\end{verbatim}

\subsection{Managing data objects via CountedRefs}

  Many of the methods described here (and in Chapter~\ref{sec:execute})
  take arguments of type {\sl Class}\qq{::Ref::Xfer} or \qq{Ref::Copy}.
  These arguments are known as {\bf counted refs}. Counted refs are properly
  documented in the DMI Programmer's Guide; this section provides a brief
  primer.
  
  Counted refs provide an efficient object management mechanism. Most DMI data
  objects can be accessed via a counted ref; this allows the same object to be
  shared by many ``owners'', and to be passed around efficiently. Refs may be
  copied (in which case a second ref to the same object is created) or
  transferred (xferred), in which case the new ref is attached to the object
  while the old one is detached. When the last ref to an object is detached, it
  is automatically destroyed. DMI containers (\qq{DataRecord}, \qq{DataFields})
  hold their contents via counted ref. 
  
  Counted refs may be read-only or read-write. Holders of a read-only ref
  cannot legally write to an object (without engaging in C++ \qq{const}
  violations, which are caugfht by the compiler). The holder of a ref may  {\em
  privatize} it: this operation ensures that a ``private'' copy of an object is
  made. The privatization operation is essential for avoiding unnecessary (and
  presumably expensive) copying of large data objects: refs are smart enough to
  figure out when actual copying is not required. For example, a
  singly-referenced object is already private to begin with. An object with no
  writable refs can also be considered ``private'' to each read-only ref holder,
  since there's no legal way to modify the object.
  
  For example, a \qq{Request} object is passed up the tree via read-only refs.
  This means that all nodes deal with the same object; if a node needs to
  modify a request, it must privatize its ref first. This ensures that
  \qq{Request}s are copied only when really necessary. A similar mechanism is
  employed for \qq{Result}s and the result cache: children returns refs to
  result objects, and retain refs in their cache. Because most nodes do not
  modify child results, but rather process them as read-only before discarding,
  only a single instance of that \qq{Result} object needs to exist.

  All counted ref types are instantiations of the \qq{CountedRef<T>} template
  defined in DMI. Most classes define the nested type {\sl Class}\qq{::Ref} as
  a shortcut for \qq{CountedRef<{\sl class}\/>}. The \qq{::Ref::Xfer} and
  \qq{::Ref::Copy} types are aliases for \qq{::Ref} itself, these are used in
  function declarations to document the function's behaviour, i.e., whether it
  can be expected to take a copy of the ref, or to transfer the ref.

\subsection{init()}

  The base \qq{Node::init()} method is called with an init-record, directly
  after a node has been constructed. The method is virtual, and thus can be
  redefined in subclasses if needed. It does the following:

  \begin{enumerate}
  
  \item Takes over the init record,  sets it as the state record, ensures a
    private \& writable copy.
    
  \item Adds the node's classname to the state record if not already present.
    If present, checks that the name actually matches the node class.

  \item Calls the virtual \qq{checkInitState()} method with the state record,
    to ensure that it's complete, and that any missing defaults are filled in.

  \item Calls \qq{setStateImpl(staterec,true)} to set up internal state from
    the state record (setting the second argument -- \qq{initializing} -- to
    \qq{true} indicates that the node is being initialized with a full
    state record.)

  \item Processes the \qq{children} field to set up connections to child nodes
    (see \ref{sec:children}).

  \item Any errors will result in an exception being thrown at the caller. A
    node object that fails \qq{init()} is under no obligation to be usable; the
    only method that's not allowed to fail is the destructor.

  \end{enumerate}

  Derived classes need to implement their own \qq{init()} only if they have 
  some special initialization needs that can't be taken care of via
  \qq{setStateImpl()}. The \qq{init()} method in a derived class should do the
  following:

  \begin{enumerate}
  
  \item Call the parent class's \qq{init()} with the init-record. This should
    ultimately call \qq{Node::init()}, thus setting up the state record, and
    calling \qq{setStateImpl()} to set up dynamic state.

  \item Set up static state defined at the child class level.

  \item Throw exceptions on any error. 

  \end{enumerate}
  
  Note that static state is easier handled in \qq{setStateImpl()} (when
  \qq{initializing} is \qq{true}), so there's little point in redefining
  \qq{init()} specifically for that purpose. In fact, most node classes find it
  sufficient to only redefine \qq{setStateImpl()}, and not bother with any of
  the other methods. 

\subsection{checkInitState()}
  
  Note the virtual \qq{checkInitState()} method called from \qq{Node::init()}.
  This is meant to check the init-record for mandatory fields, and insert
  missing defaults. Alternatively, this can be done in \qq{setStateImpl()} when
  the \qq{initializing} is \qq{true}. The second way is usually easier, since
  \qq{setStateImpl()} is almost always redefined by subclasses.

  A derived \qq{checkInitState()} should call the parent version, then check
  for defaults and mandatory fields defined by the child class, and throw an
  exception if any fields are missing.

  A couple of macros defined in \qq{Node.h} are meant to help implement this
  method. The \qq{requiresInitField(rec,field)} macro checks if the specified
  field is present, and throws an exception otherwise. The
  \qq{defaultInitField(rec,field,deflt)} macro inserts a default value for a
  field if it is missing.  
  
\subsection{setStateImpl()}

  The virtual \qq{setStateImpl()} method is responsible for setting up and/or
  modifying dynamic node state. Note that this method is protected -- the rest
  of the world must call it via through \qq{init()} or \qq{setState()}.

  \begin{verbatim}
  void Node::setStateImpl (DataRecord &rec,bool initializing);
  \end{verbatim}
  
  The first argument is a record, the second argument tells the method whether
  the node is being initialized (and \qq{rec} is a complete init-record), or
  simply updated (and \qq{rec} contains only a subset of state, i.e. only those
  fields that are actually being changed).
  
  Most node classes can get away with implementing their own
  \qq{setStateImpl()}, and not worrying about any of the other methods
  described in this section. A node's \qq{setStateImpl()} should follow this
  checklist:

  \begin{enumerate}

  \item If the \qq{initializing} is \qq{false}, check the record for protected
    fields (i.e. for attempts to modify static state). Throw a
    \qq{FailWithoutCleanup} exception if any are present. The
    \qq{protectStateField(record,field)} macro defined in \qq{Node.h} is a
    convenient way to do this.

  \item Call the parent class's \qq{setStateImpl()} to set up inherited state.
  
  \item If
    \qq{initializing} is \qq{true}, check for missing mandatory state fields,
    and/or fill in defaults (unless \qq{checkInitState()} has been already been
    redefined to
    do the same). 
    
    

  \item Parse the record and modify internal state relevant to the child class.
    Note that the standard DMI hook method \qq{get()} is very handy for doing
    this operation, combined with the previous one:
    
    \begin{verbatim}
    if( newst[StateField].get(var,initializing) )
      // field is present, react if needed
    else
      // field is missing, react if needed
    \end{verbatim}
    
    The \qq{get()} method employed here does the following: if \qq{StateField}
    is present in the \qq{newst} record, assigns its value to \qq{var}
    (throwing an exception is the types are incompatible) and returns
    \qq{true}. If the field is missing, optionally (only if \qq{initializing}
    is \qq{true}) inits it from the value in \qq{var}, and returns \qq{false}.
    The standard \qq{setStateImpl()} methods make extended use of this
    mechanism.

  \item Throw exceptions on error. A \qq{Node::FailWithoutCleanup} should be
    thrown if and only if no internal state was modified. All other exceptions
    will invoke the ``rollback'' mechanism above. You can rely on
    \qq{DataRecord} (and other DMI classes) to throw an exception when
    datatypes mismatch or something else goes wrong; throw a
    \qq{Node::FailWithCleanup} if you want to indicate some other kind of
    failure.

\end{enumerate}
  

\subsection{setState()}


  The non-virtual \qq{setState()} method defined in \qq{Node} provides the
  public interface for setting state. Basically, it defers parsing the record
  to \qq{setStateImpl()}, while providing a transaction mechanism of sorts:

\begin{enumerate}

  \item Calls \qq{setStateImpl(rec,false)} to process the record. The
    \qq{false} value indicates that state is being modified rather than
    [re]initialized. (Note that if the supplied record happens to be the node
    state record itself, \qq{true} will be passed in instead.)

  \item Catches \qq{Node::FailWithoutCleanup} exceptions and rethrows them at
    the caller with no additional action.

  \item Catches all other execeptions, and does a cleanup before rethrowing
    them. The cleanup consists of calling \qq{setStateImpl(staterec,true)}, so
    as to reset internal state from the current state record. This is meant to
    roll back from situations where an error midway through \qq{setStateImpl()}
    could cause internal object state to decohere from the state record.

  \item On success, merges the supplied record into the current state record.

  \end{enumerate}

  This design ensures that if a \qq{setState()} call fails (i.e., with an
  exception), both the state record and the internal state of the object are
  rolled back to their values prior to the call. (Assuming they were mutually
  consistent to begin with.) In other words, the node object is guaranteed to
  remain usable.

  The virtual \qq{setNodeState()} method is responsible for changing dynamic
  state. It receives two arguments: a \qq{newst} record, and a boolean called
  \qq{initializing}. The latter is \qq{true}, the node is being initialized --
  in this case \qq{newst} is the complete initial state record. If it is
  \qq{false}, \qq{newst} contains only those state fields that are being
  changed. Normally, the method should do the following:

\begin{enumerate}

  \item If the \qq{initializing} is \qq{false}, check the record for
    ``forbidden'' fields, i.e., attempts to modify static state. Throw a
    \qq{FailWithoutCleanup} if any are present. The
    \qq{protectStateField(record,field)}  macro/inline is a convenient way to
    do this.
    
  \item Call the parent \qq{setStateImpl()}.

  \item As an alternative to overriding \qq{checkInitState()}, if
    \qq{initializing} is \qq{true}, check for missing fields and/or fill in
    defaults.

  \item Parse the record and modify internal state relevant to the child class.
    Note that the standard DMI hook method \qq{get()} is very handy for doing
    this operation, combined with the previous one:
    
    \begin{verbatim}
    if( newst[StateField].get(var,initializing) )
      // field is present, react if needed
    else
      // field is missing, react if needed
    \end{verbatim}
    
    The \qq{get()} method employed here does the following: if \qq{StateField}
    is present in the \qq{newst} record, assigns its value to \qq{var}
    (throwing an exception is the types are incompatible) and returns
    \qq{true}. If the field is missing, optionally (only if \qq{initializing}
    is \qq{true}) inits it from the value in \qq{var}, and returns \qq{false}.
    The standard \qq{setStateImpl()} methods make extended use of this
    mechanism.

  \item Throw exceptions on error. A \qq{Node::FailWithoutCleanup} should be
    thrown if and only if no internal state was modified. All other exceptions
    will invoke the ``rollback'' mechanism above. You can rely on
    \qq{DataRecord} (and other DMI classes) to throw an exception when
    datatypes mismatch or something else goes wrong; throw a
    \qq{Node::FailWithCleanup} if you want to indicate some other kind of
    failure.

\end{enumerate}

  The base \qq{Node::setStateImpl()} method is described in detail in a later
  section on basic node state.

\subsection{Unrecognized state fields}

  Note that these implementations of \qq{init()} and \qq{setState()} will
  ignore any unrecognized fields in the init and state record, all the while 
  diligently maintaining and changing them as requested. This allows for a few
  interesting possibilities:

  \begin{itemize}
  
  \item Nodes may be assigned arbitary additional attributes and data,
    meaningless to the node itself, but perhaps useful to the control layer.

  \item Things like the result cache (see below) -- which is stored directly in
    the state record -- may be accessed and changed externally (i.e. from the
    scripting level). This may be useful for debugging and testing.

  \end{itemize}

\subsection{Serialization \& persistency}

  The \qq{meqserver} already supports persistent nodes (i.e. being able to
  save/load nodes and trees to a file). Further down the road, we plan for the
  possibly the capability to move a node across a network. Both functions hinge
  on being able to serialize a node.

  Serialization is implemented through DMI mechanisms. A \qq{DataRecord} is
  inherently serializable. To serialize a node, the control code will simply
  serialize its state record. To unserialize a node, it will recover the
  record, create a node object (as specified by the \qq{class} field), and call
  \qq{init()} on it. 

  Thus, subclasses of \Node\ should take care to maintain their state record
  appropriately. Each node class should ensure that it is completely
  re-creatable (via \qq{init()}) from a snapshot of its state record at any
  point in time. Basically, this means that a 1-1 mapping should be maintained
  between the state record and internal object state. One possible exception to
  this are internal caches; if these are not maintained in the state record,
  then the worst than can happen from re-creating a node is a cleared cache.
  
\chapter{Symdeps \& Depmasks}

  As discussed in the section on requests above, a {\em depmask} is a bitwise
  mask that describes a result's dependencies on particular properties of the
  request, which are in turn indicated by individual indices of the request ID.
  To enable proper use of the cache, all nodes in the tree should interpret
  these bits and indices in a consistent way -- which is, by necessity,
  application-dependent. Several fields of the node state provide a mechanism
  for setting up these semantics and propagating them throughout trees. 

\section{The local depmask}
  
  The \qq{depend\_mask} field of the state record is the local depmask of the
  node. The local depmask indicates which dependencies a node introduces into
  its result. For most \qq{Function}-derived nodes, this mask is null,
  indicating that the result dependencies are fully determined by child
  dependencies. Leaf nodes, on the other hand, will have a non-null mask.

  The local depmask is automatically ORed into the result code by
  \qq{Node::execute()} (see below). Some nodes will set up the mask at init
  time and never worry about it again. For other nodes, it may change depending
  on node state.

  The depmask is just a set of $N$ bits with no specific semantics associated
  with them. The association between individual bits and specific result
  properties is set up via the mechanism of {\em symbolic dependencies}, or
  {\em symdeps} for short.
  
\section{Symdeps in a nutshell}
  
  A {\em symdep} is a \qq{HIID} (thus, symbolic -- since \qq{HIID}s have a
  symbolic representation) that identifies some application-specific dependency
  of the result. Node classes will typically define some standard symdeps, such
  as these -- used in the standard nodes:

  \begin{description}
  
  \item[``Domain'':] result depends on the requested domain (i.e., the envelope
    domain of the \Cells). Most non-trivial leaf nodes have this symdep.

  \item[``Resolution'':] result depends on the resolution of the \Cells. Most
    nodes with a time and/or frequency dependence have this symdep.
   
  \item[``Parm.Value'':] result depends on parameter values passed up from the
    solver. Solvable \Parm{}s have this symdep.
  
  \end{description}
  
  A node's set of symdeps is generally known to the node class at construction
  time. Then, when a tree is initialized, different symdeps are dynamically
  associated with different bits of the depmask, as described below.
  Essentially, this maps the abstract concepts (the symdeps) onto specific bits
  of the depmasks. In other words, this mechanism is what determines the
  bitmask semantics.



**************************************************************    
  Rqids play a pivotal role in caching behaviour. 
  
  When a node caches a result,
  it also caches the rqid. In the trivial case, if the next request has the
  same ID, the node can immediately return the cached result. In fact the cache
  is somewhat more intelligent. Each cached result also has a {\em dependency
  mask} (or {\bf depmask} for short) that describes {\em what properties of a
  request the result depends on}. Typical dependencies include:

  \begin{itemize} 
  
  \item The request's \Cells\ (envelope domain and grid), obviously enough.
  Example nodes with this dependency: \qq{Parm} (with a non-zero degree
  polynomial), \qq{Time}, \qq{Freq}. 

  \item Only the envelope domain of the \Cells. Example: the \qq{Spigot}, since
  it always returns data at the native resolution of the dataset, ignoring the
  resolution specified in the \Cells.

  \item Updated \qq{Parm} values sent up by a solver.
  
  \item The configuration of a \qq{WSum} node.

  \item Any combination of the above. 

  \end{itemize}
  
  If a node has children, then its result's dependencies are almost always the
  union of the children dependencies, plus (in some cases) additional
  dependencies introduced by the node itself (e.g. the \qq{UVW} node always
  adds a dependency on \Cells). In other words, the depmask of the result is 
  a bitwise-OR of the depmasks of the children's results, OR the node's own
  local depmask. Obviously, the set of dependencies grows as results propagate
  down the tree.

  Given a cached result and its depmask, a node can be somewhat more
  discriminating in choosing when to return a cached result. For example, if
  the depmask indicates that the result depends on \Cells\ only, then all
  further requests with the same \Cells\ can be served from the cache. The same
  applies to other dependencies. In global optimization terms, this means that
  when a tree is re-evaluated for a slightly different request, it recalculates
  only those sub-trees that need it. The problem is how to determine if a
  different request has the same \Cells, without doing a brute-force comparison
  (which can be quite expensive if done at every node). This is where the {\em
  hierarchical} part of request IDs come in.

  An rqid is a \qq{HIID} -- essentially, a string of integer indices. Each
  index corresponds to one bit in the depmask. For example, if the depmask is
  structured as follows:
  
  \begin{center}\begin{tabular}{l|l}
  \hline
  bit 0 & \qq{Parm} values from solver \\
  bit 1 & \qq{WSum} configuration \\
  bit 2 & resolution of \Cells \\ 
  bit 3 & envelope domain of \Cells \\
  \hline\end{tabular}\end{center}
  
  then the rqid is composed of four indices:
  
  {\tt\em  
  $<$domain index$>$.$<$resolution index$>$.$<$config\_index$>$.$<$value\_index$>$
  }
  
  The decision whether a new request can be served from the cache becomes quite
  simple: just compare all indices of the rqid for which the corresponding
  depmask bit is set, and use the cache only if none of them differ.

  In other words, the components of the rqid describe how a request is
  different from previous requests. The domain index must change whenever a new
  domain is requested, the config index must change whenever a \qq{WSum} is
  reconfigured, the value index must change at each solve iteration, etc.

  Of course, this scheme only works if the depmasks returned by the nodes
  (generally, somewhere up the tree), and the request IDs generated by request
  originators (generally, down the tree) have the same semantics. The
  depmask/rqid correspondence represents a {\em contract} between request
  generators and dependency generators to apply these semantics consistently.
  The \qq{Node} class provides a number of mechanisms for automatically setting
  up consistent semantics throughout the tree, see the discussion on {\em
  symdeps} below.

  Note also that the general scheme implemented at the \qq{Node} level does not
  assume any application-specific semantics at all. The depmask is a treated as
  set of $N$ bits, and the rqid as a corresponding set of $N$ indices.

\subsection{Next\_request and request sequences}

  The concept of a ``request sequence'' has been bandied about a lot (see the
  ``Making Waves'' document, plus various discussions). The reason for this is
  that a node needs some capability of ``looking ahead'' to future requests, in
  order to efficiently utilize cache, and to enable ``rippling'' trees that
  parallelize well.

  In fact, it is sufficient to be able to answer the more limited question:
  given request $X$, what is the next request likely to be? A node doesn't 
  need to know the full request sequence -- only the next step of it. The
  mechanism can be hidden behind a single method called, e.g.,
  \qq{getNextRequestHint()}, implemented at the \Node\ level. This neatly
  factors the issue into two independent ones:

  \begin{itemize}
  
  \item {\em Where does the base \qq{\em Node} class get knowledge of the next
    request?} Obviously, the originator of the \Request\ can have some idea. 
    For example, a \qq{Solver} node would probably know if more iterations over
    the same domain/source are required, or if we're going to the next domain.
    A \qq{Sink} node may know what the next domain is going to be. Etc. It
    seems reasonable to place this information into the \Request\ record
    itself, hence the \qq{next\_request} field.

  \item {\em Given knowledge of the next request, how does that help us in
    caching and parallelization?} Parallelization was the subject of the
    ``Making Waves'' document, while caching issues are discussed below.

  \end{itemize}
  
  The next-request hint is just that, a hint, with no commitment implied. It is
  not necessary at all for correct operation of the system -- even the hint
  itself can even be wrong. The maximum penalty to pay for an incorrect hint is
  recalculation of the tree rooted at the node in question. Efficient
  operation, however, requires that the hint be correct most of the time.

  {\em Hints and sequences are not implemented at the moment; the point of
  the present discussion is to see where this fits into the data structure.}

\subsection{Symdep masks}

  Note that certain nodes can be viewed as symdep {\em generators}. These are
  nodes that generate new requests. For example, the \qq{Sink} node generates
  requests with different domains and resolutions, thus we say that \qq{Sink}
  generates the \qq{"Domain"} and \qq{"Resolution"} symdep. The \qq{ModRes} node
  changes the resolution of requests, thus it generates the \qq{"Resolution"}
  symdep. The \qq{Solver} node generates the \qq{"Parm.Value"} symdep.
  
  These nodes are responsible for associating a particular bit of the depmask
  with each symdep that they generate. Typically, they will do this once when a
  tree is initialized. These associations (known as {\em symdep masks}) are
  then recursively sent up the tree, thus becoming known to all child nodes.
  Nodes up the tree can then compute their local depmasks by combining the
  symdep masks of their specific symdeps.

\section{Symdeps: the hairy details}

  This section describes the details of how symdeps and depmasks are set up and
  maintained. Note that all this is maintained in the node state record.

\subsection{Known and active symdeps} 
  
  The {\em known symdeps} of a node are just that, all the symdeps that a node
  class knows about. Typically, this is specified once and for all in the
  node class's constructor, by calling the \qq{setKnownSymDeps()} method.
  
  A subset of the known symdeps -- the {\em active symdeps} set -- determines
  what symdeps currently apply to the node's result. For some node classes,
  this is always the entire known set. Some classes, however, may change their
  active set depending on state. For example, if a \qq{Constant} node is
  configured to provide a constant value as a sampling, then it has no active
  symdeps at all, as the value will be the same for any domain or resolution.
  However, if it is (re)configured to provide the constant as an integration,
  then it begins to depend on resolution -- since the integrated value is the
  product of the sample value and cell size.

  The active symdeps set may be changed by calling the \qq{setActiveSymDeps()}
  method, or by changing the \qq{active\_symdeps} field (a list of \qq{HIID}s)
  of the state record. Whenever this is done, the local depmask is
  automatically recalculated using the known symdep masks, by calling the
  virtual \qq{resetDependMasks()} method.

  The known symdeps may also be changed at any time (though I can hardly see
  why anyone would want to do this), by calling the \qq{setKnownSymDeps()}
  method, or by changing the \qq{known\_symdeps}  field of the state record. 
  
\subsection{Propagating symdep masks}

  A node will automatically keep track of the symdep masks associated with its
  known symdep set. This is done via the rider command facility (see below),
  and implemented via \qq{Node::processCommands()}:

  \begin{itemize}
  
  \item The \qq{Add.Dep.Mask} command contains a map of symdeps to symdep
    masks. (This command usually originates at the symdep generator nodes, see
    ``Generated symdeps'' below). In response to this command, \qq{Node} adds
    all the masks it finds for its known symdeps to its internal map of symdep
    masks. After this, it calls \qq{resetDependMasks()} to recalculate its
    local depmask. 

  \item The \qq{Clear.Dep.Mask} command clears all known symdep masks.
  
  \end{itemize}
  
  One consequence of this design is that each node maintains its own local
  mapping of symdeps to depmasks. While at first glance this may seem redundant
  and even wasteful -- since the mapping would appear to be the same throughout
  a tree -- consider the following points:

  \begin{itemize}
  
  \item When a tree is distributed throughout a cluster, maintaining a single
    ``global'' map becomes difficult (and actually violates the principle of
    locality!) Keeping a copy of the map at each node avoids this problem.

  \item The map is not really global anyway. For example, consider a rippled
    tree with multiple solvers. The solvable parm set of solver 1 and the
    solvable parm set of solver 2 need to be represented by different bits in
    the depmask. Thus, the \qq{"Parm.Value"} symdep of different groups of
    parms will actually be mapped to different depmasks!
    
    Note that node group facility (see processing of rider commands, below)
    provides an elegant mechanism for distributing different symdep masks to
    different node groups.
    
  \item The map is small, and changes very infrequently (if at all -- usually,
    it will be set up only once when a tree is initialized). Thus there is no
    performance cost associated with keeping local copies.

  \end{itemize}
  
  The map of known symdep masks is maintained in the \qq{symdep\_masks} field of
  the node state record. It is possible to change this field on the fly, an
  automatic call to \qq{resetDependMasks()} always results.

\subsection{Generating symdep masks}

  Nodes that generate new requests also need to generate \qq{Add.Dep.Mask}
  commands containing their symdep masks assignments. \qq{Node} provides a
  simple facility for doing this automatically.
  
  A node class can specify its mapping of {\em generated symdeps} to masks
  by calling the \qq{setGenSymDeps()} method at construction time. The standard
  node classes specify some pre-assigned masks by default: bit 0 for
  \qq{"Parm.Value"}, bit 1 for \qq{"Resolution"}, bit 4 for \qq{"Domain"}. This
  allows for simple trees to be put together using just the defaults.
  
  For more elaborate trees -- e.g., rippled trees with multiple solvers --
  different \qq{Solver} nodes need to be assigned different masks for the same
  symdep. This can be done via the \qq{gen\_symdeps} field of the state record.
  This field has to contain a map (e.g. record) of symdeps to depmasks; if
  specified, it overrides any previously set mappings. 
  
  Additionally, a node may be configured to generate symdeps for a particular
  node group only. This useful for, e.g., multiple solvers. By default, the
  \qq{All} group is used, but this can be overridden via the
  \qq{gen\_symdeps\_group} field of the state record.

  Once the generated symdeps are configured, a node needs to be told to send
  them up to its children. This is done by passing it the \qq{Init.Dep.Masks}
  command via a request rider. In responce to this command,
  \qq{Node::processCommands} inserts the appropriate \qq{Add.Dep.Mask} commands
  into the request rider based on the current setting of \qq{gen\_symdeps} and
  \qq{gen\_symdeps\_group}.
  
  Operationally, all this is typically done only once at init time:
  
  \begin{itemize}
  
  \item Request generator nodes are created with an initial state record
    containing their generated symdep assignments (if the default assignments
    need to be overridden).
    
  \item Once all the nodes and trees have been created, a request containing
    two following two commands is given to all the root nodes:
    \qq{Resolve.Children} and \qq{Init.Dep.Masks}. (The first command is
    required to resolve named children).
    
  \item This initial request is propagated up the tree, acquiring symdep masks
    from generator nodes along the way. 
    
  \item All trees are now ready for use.
  
  \end{itemize}

\subsection{Order of state updates}

  Because it is possible to change everything about a node's symdeps and masks
  by modifying the state record, and a state update may contain multiple
  fields, the order in which it is updated becomes important.
  \qq{Node::setStateImpl()} employs the following order:

  \begin{enumerate}
  
  \item Updates the known symdep set from \qq{known\_symdeps}, if specified.
  
  \item If specified, reloads the symdep masks from \qq{symdep\_masks}, and
    calls \qq{resetDependMasks()}.
    
  \item If specified, sets the active symdeps from \qq{active\_symdeps}, and
    calls \qq{resetDependMasks()}.
    
  \item If specified, sets the local depmask from \qq{depend\_mask}.
  
  \end{enumerate}
  
  Basically, this order implies that if the local depmask is explicitly changed
  via \qq{depend\_mask}, the specified value overrides any implict value
  calculated from, e.g., an \qq{active\_symdeps}.
  
\subsection{Specialized node behaviour}  
  
  Note that all these facilities are provided at the basic \qq{Node} level, but
  special node classes are free to ignore them, or make use of only some
  subset. For example, the \qq{Parm} class\footnote{And currently, this is the
  only example.} needs to maintain separate predict symdeps and solve symdep
  sets. It deals with this in the following way:

  \begin{itemize}
  
  \item It ignores the \qq{Node}-level active symdeps, initially specifying an
    empty set of active symdeps. This implies that its \qq{Node}-level local
    depmask stays at zero.

  \item It maintains two of its own symdep sets: predict symdeps and solve
    symdeps, and two corresponding depmasks: the predict depmask and the solve
    depmask.
    
  \item It overrides the \qq{resetDependMasks()} method, to recompute the two
    depmasks whenever known symdep masks change.
    
  \item It returns either one or the other mask from \qq{getResult()}, depending
    on what sort of request is being serviced.

  \end{itemize}
  
