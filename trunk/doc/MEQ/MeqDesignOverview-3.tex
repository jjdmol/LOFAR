\chapter{Executing Requests}
  \label{chap:execute}

  The virtual \qq{Node::execute()} method is responsible for processing a
  \Request:
  
  \begin{verbatim}
  virtual int execute (Result::Ref &resref,const Request &req);
  \end{verbatim}
  
  \noindent The node is supplied a \qq{Request} object, and it is expected to return a
  \qq{Result} by attaching it to the counted ref passed in as the first
  argument. The return value is called the {\bf result code}: this
  incorporates the depmask of the result, plus several additional flags such
  as \RES{WAIT} and \RES{FAIL} (see below).

  A parent node will generally call the \qq{execute()} methods of its
  children. In the current single-threaded implementation, the entire tree
  is evaluated via nested \qq{execute()} calls. In a multi-threaded or
  distributed implementation, the parent will probably call stub methods in
  the communication layer, which will in turn call \qq{execute()} on the
  child nodes.

  \highlightbox{The \qq{Node::execute()} method is the fulcrum of the entire
  MeqTree kernel. A solid understanding of how it works is vital for both tree
  design and node development, and also beneficial to advanced users that need
  to deal directly with trees.}

  
\section{Base Node::execute() steps}
   \label{sec:execute}
  
  
  The \qq{Node::execute()} method looks at the request, and calls a number
  of virtual {\em handler} methods for various aspects of processing. Most
  node classes will override one or more of these handler method(s) to
  implement their specific node behaviour. \qq{Node::execute()} also
  provides fundamental node functionality, such as cache management and
  exception handling.\footnote{You may have noted that \qq{execute()} is
  declared virtual. Most node classes will only redefine specific handler
  methods, not \qq{execute()} itself.  The possibility to reimplement
  \qq{execute()} is reserved for the exotic cases. This is not to be
  undertaken lightly, however, as the base \qq{Node::execute()} provides so
  much useful behaviour.}

  The base \qq{Node::execute()} performs a number of processing steps. These
  will now be described in detail, grouped by function.
  

\newcounter{execstep}
\setcounter{execstep}{0}
\newcommand{\ExecStepBox}[2]{\highlightbox{\mbox{#1. } #2}}
\newcommand{\ExecStep}[1]
{\addtocounter{execstep}{1}\ExecStepBox{Step \arabic{execstep}}{#1}}
  
\subsection{Checking the cache}

  \ExecStepBox{Init retunr code}{Set the current return code to 0. It will be
  accumulated in further steps (usually via a bitwise-OR).}

  \ExecStep{Compare the request id to the id of the previous request, if any.
  Sets a local ``new request'' flag that affects further logic below.}

  \ExecStep{If there's a cached \Result, and the request id matches the
  cached rqid/depmask (see \ref{sec:cache} for a discussion), immediately
  return the cached \Result\ and cached result code. On mismatch, clear the
  cache and proceed.}
  
  Note that the caching policy also determines how fail-results are dealt with.
  If the cache contains a fail-result, the node may choose to ignore it and
  attempt to recalculate the result to see if the fail conditions have gone
  away.

  \ExecStep{For new requests only: call the virtual \qq{readyForRequest()}
  handler, and if the return value of that is \qq{false}, immediately
  return the code \RES{WAIT} (result will be empty).}
  
\begin{verbatim}  
  virtual bool readyForRequest (const Request &req);
\end{verbatim}

  \noindent The handler is passed the current \Request, i.e., the \qq{req}
  argument to \qq{execute()} itself. The purpose of this handler is to
  support nodes that block on external events. None as such have been
  implemented, so this is currently just a placeholder. The default handler
  always returns \qq{true}.

  \medskip \ExecStep{For new requests only: if a rider subrecord is present,
  parse it and call the virtual \qq{processCommands()} handler to process
  commands targeted at the node (see details in~\ref{sec:CSR}).}

\subsection{Polling children}
    
  \ExecStep{If node has children, call the virtual \qq{pollChildren()}
    handler to pass the request on to the children and collect their
    results. Bitwise-OR the return value of \qq{pollChildren()} into the current
    return code.}

  \begin{verbatim}    
  virtual int pollChildren (std::vector<Result::Ref> &child_results,
                            Result::Ref &resref,
                            const Request &req);
  \end{verbatim}
    
  \noindent The handler is called with the same \qq{resref} and \qq{req}
  arguments  that were given to \qq{execute()} itself. The
  \qq{child\_results} vector where the child results are returned, it is
  pre-sized to the number of children prior to calling \qq{pollChildren()}.

  The default implementation of \qq{pollChildren()} is appropriate for most
  node classes that pass their requests on to the children unmodified. 
  ``Control'' nodes (e.g. \qq{Sink}, \qq{Solver}, \qq{ModRes},\qq{ReqSeq}) will
  define their own version. This is the default \qq{Node::pollChildren()}
  behaviour:

  \begin{itemize}

  \item Calls \qq{execute()} (with \qq{req}) on all the child nodes, collects
  their \Result{}s (by ref) into the \qq{child\_results} vector, and
  accumulates a return code as a bitwise-OR of the children's \qq{execute()}
  return values. Note that the refs to child \Result{}s are expected to
  be read-only. 

  \item If the accumulated return code has the \RES{FAIL} bit set, its is
  assumed that at least one of the children has returned a fail-result
  (see~\ref{sec:fail}). In this case, \qq{pollChildren()} creates a new
  fail-\Result\ object, attaches it to \qq{resref}, and fills it with 
  all the fail-records found in child results.

  \item The accumulated return code is the return value of the handler.

  \end{itemize}
  
  Note that \qq{resref} is passed to \qq{pollChildren()} only as a means of
  reporting possible fails. If the handler returns a code with \RES{FAIL} in
  it, it should attach a fail-result to \qq{resref}. If no \RES{FAIL} is
  reported, the handler should leave \qq{resref} alone (in fact, anything it
  does to it will be simply ignored when no \RES{FAIL} is returned.)

  If the \qq{pollChildren()} return value contains \RES{WAIT} or \RES{FAIL},
  \qq{execute()} returns (see section~\ref{sec:execute-return}). Otherwise,
  it proceeds to the next step:

  \ExecStep{If auto-resampling is enabled (see \ref{sec:resampling}), compare
  the resolutions of the child results, figure out a common resolution
  (\qq{Cells}) to resample them to, and perform the resampling. Throw an
  exception if this is not possible.}
  
  A result \Cells\ may be initialized based on how the resampling went (see
  \ref{sec:resampling}). 

\subsection{Evaluating \qq{cells}}

  \ExecStep{If the request contains a \qq{cells} command (with a \Cells\
  object), call the virtual \qq{getResult()} handler to process the command,
  passing in the vector of child \Result{}s returned by \qq{pollChildren()}.
  The return value of \qq{getResult()}, along with the node's current depmask
  (see~\ref{sec:depmask-node}), is bitwise-ORed into the current return code.}
  
\begin{verbatim}
  virtual int getResult (Result::Ref &resref,
                         const Cells::Ref &cells,
                         const std::vector<Result::Ref> &child_results,
                         const Request &req,bool newreq);
\end{verbatim}
  
  The \qq{resref} and \qq{req} arguments are the same as those passed to
  \qq{execute()}. The \qq{cells} argument is a ref to the result cells, if any
  were initialized during the resampling stage above, or otherwise to the
  \Cells\ in the request (see~\ref{sec:resampling} for details). The
  \qq{child\_results} vector is built up in \qq{pollChildren()}, it will be
  empty if the node has no children. Finally, the \qq{newreq} flag indicates if
  it is a new request, this flag is set in Step~1 above.
  
  The \qq{getResult()} handler is responsible for attaching a \Result\ object
  to \qq{resref}. In most cases, it will create a new object. Note, however,
  that certain nodes may pass on child results transparently (e.g.,
  \qq{ModRes}, \qq{ReqSeq}), they do this by simply copying a ref from the
  \qq{child\_results} vector. 
  
  If \qq{getResult()} returns a \RES{WAIT} code, it is allowed (and expected)
  to leave \qq{resref} unattached. Otherwise, a valid \Result\ must be
  provided! Any errors occurring inside \qq{getResult()} can be reported by
  throwing an exception.

\subsection{Handling exceptions}

  \ExecStepBox{Error handling}{If an exception is thrown at any stage of the
  process, \qq{execute()} will catch it, create an output \Result\ with a
  fail-result describing the exception, and add \RES{FAIL} to the current
  return code.}

  Thus, throwing an exception is the normal way for \qq{processCommands()},
  \qq{getResult()}, or any other handler to indicate a failure. Note that a
  node should remain in a usable state (i.e. should be able to process further
  \Request{}s) after most exceptions; methods that are liable to leave the node
  in a non-usable state should provide their own exception handling code that
  performs the necessary cleanups and re-throws the exceptions. See the
  \qq{setState()} rollback mechanism described in section
  \ref{sec:state-rollback} for one such example.

\subsection{Caching and returning a \Result}
\label{sec:execute-return}
 
  \ExecStepBox{Returning}{Whenever any kind of \Result\ is returned, it is
  stored in the cache according to the current policy, and returned via the
  \qq{resref} argument. The accumulated return code is returned along with the
  result. If the result is new (i.e. not returned from cache at step 2), the
  \RES{UPDATED} flag is added to the return value.}

  Note that if the accumulated return code contains \RES{WAIT}, then no
  \Result\ is expected (\qq{resref} remains unattached). In all other cases, a
  valid \Result\ object should be attached to \qq{resref} (in case of
  exceptions, this will be a fail-result).

\subsection{All Results are read-only!}

  Prior to returning a \Result, \qq{execute()} recursively changes \qq{resref}
  and all other refs found inside the result object to read-only. This implies
  that the caller of \qq{execute()} (i.e. the parent node, or \qq{MeqServer})
  cannot [legally] change the \Result\ contents. This is deliberate -- the node
  can now hold a ref to the \Result\ in the cache, and be assured that no-one
  can [legally] change the contents. 
  
  In most cases, parent nodes will process the \Result{}s of their children as
  read-only, and discard them afterwards (actually, only the parents' refs are
  discarded -- the \Result\ objects themselves persist if still referenced
  somewhere, e.g., in a child's cache). Some nodes may want to modify child
  \Result{}s ``in place''. To do this, they will need to privatize their refs
  for writing first (see \ref{sec:countedrefs}), thus ensuring that a private
  copy is made if the same object is still referenced somewhere. The same
  applies to individual components of the \Result{}s. Essentially, this is a
  robust copy-on-write mechanism that assures that data is duplicated only when
  needed, with very little effort required from the node developer.
  
  Note also that when a \Result\ is moved across to the scripting layer, some
  sort of copying is implicitly performed. Glish does not deal with \Result\
  objects directly, but rather with their Glish representations.

\section{Result codes}
\label{sec:execute-resultcode}

  As described above, the return value of \qq{execute()} is simply the
  accumulated result code. The result code describes certain properties of the
  returned \Result. Part of it is simply the result depmask (see
  \ref{sec:depmask-result}, the other part contains a number of bitflags listed
  below. Note that the property semantics are defined in such a way that, in
  most practical cases, a flagged property in any child result is inherited by
  the parent's result. This allows \qq{execute()} to accumulate the correct
  result code via a simple bitwise-OR. The following additional flags are
  defined:
 
  \begin{description}
  
  \item[\RES{UPDATED}:] result has changed from that of previous \Request. This
    bit is usually cleared when the node returns a result  from the cache, and
    set otherwise.

  \item[\RES{VOLATILE}:] result may change in response to external events,
    even without new requests. {\em (This is not implemented for now, and only meant
    as a placeholder for future developments, such as dynamically growing
    domains, partial integration, etc.)}

  \item[\RES{FAIL}:] result is a fail. Note that this is not the same thing as
    a result containing some mix of valid and failed VellSets; rather, this
    indicates a failure for the whole result overall. \RES{FAIL}s are usually
    generated in an exception handler. Note that the default implementation of
    \qq{pollChildren()} and \qq{execute()} causes fails to cascade down the
    tree.

    When this flag is returned, a \Result\ object is still expected; it should
    contain one or more fails describing the error. Note that depmasks can be
    meaningfully combined with \RES{FAIL}, to indicate that the fail depends on
    something (i.e. may go away if a particular dependency changes). The
    ``smart'' caching policy may make use of this. 

  \item[\RES{WAIT}:] no result available, wait for notification or try later.
    If this flag is raised, then no \Result\ should be returned. Note that
    dependency flags can be meaningfully combined with \RES{WAIT}, since it
    usually possible to indicate the dependencies of a node in advance. No
    current code uses this, however.

  \end{description}
  
  The return value of a node's \qq{getResult()} method should describe any {\bf
  additional} properties introduced by the \qq{getResult()} calculation
  (additional with respect to the node's current depmask -- see
  \ref{sec:depmask-node}). Most function nodes will return zero, indicating
  no additional dependencies.

\section{Commands in request riders}
  \label{sec:rider}
  \label{sec:CSR}
  \label{sec:rider-setstate}

  The optional \qq{rider} sub-record of a \Request\ may be used to send
  commands to specific nodes. The \qq{Solver} node, for example, makes heavy
  use of this feature to implement iterative solutions. Command sets are
  specified via records, with the field names being the commands per se, and
  the field values being the command arguments. If the record contains multiple
  commands, they are processed in a specific order. Some example commands are:

  \begin{description}
  
  \item[\qq{state}:] to change the state of a node (available for all nodes);
  
  \item[\qq{set\_value}:] to change the values of a polc in a MeqParm (see
  below);
  
  \item[\qq{save\_polc}:] to save the polc(s) in a MeqParm (see below).
  
  \end{description}
  
  The rider record is structured so that it is possible to associate a command
  with a specific node or a set of nodes. A node will check if the request
  contains any commands for itself. Note that in a very large tree, these
  repeated checks may become expensive. It is for this reason that we introduce
  the concept of {\em node groups}. 
  
  A node may be associated with one or more groups. Groups are specified via a
  list of HIIDs passed in the \qq{.node\_groups} field of the init record (they
  can subsequently be changed via \qq{setState()}). All nodes automatically
  belong to the \qq{all} group. A node's groups are used as a first-level index
  into the \qq{rider} record. If a node belongs to groups \qq{foo} and
  \qq{bar}, then \qq{Node::execute()} will check for the {\em command
  subrecords}\/ (CSRs) \qq{rider.foo}, \qq{rider.bar}, and \qq{rider.all}, in
  that order, and process any subrecords that it finds.

  Each CSRs contains a number of command sets. These command sets may be
  associated with specific nodes. There are three ways to specify these
  associations:
  
  \paragraph{All nodes in group:} The command sets specified via the field
  \qq{command\_all} is applied to all nodes in the group. For example:

\begin{verbatim}
  - req.rider.foo.command_all
  [ save_polc=T,state=[solvable=F] ]  
\end{verbatim}

  ...will call \qq{processCommands()} on all nodes in group \qq{foo} (saving
  polcs and setting their state to non-solvable.)

  \paragraph{Via node index:} Command sets may be associated with a specific
  node index. This is done via field \qq{command\_by\_nodeindex}, which is
  essentially a map from node index to command set. For example:

\begin{verbatim}
  - req.rider.foo.command_by_nodeindex
  [ #19 = [ value=1,save_polc=T ], #41 = [ value=2,save_polc=T ] ]
\end{verbatim}

  ...will cause a \qq{processCommands()} call on nodes 19 and 41. (Note that
  since Glish only supports strings for record field names, the \qq{'\#ddd'}
  form is used to specify a ``numeric'' node index.)

  \paragraph{Via lists:} The third way is to associate command sets with nodes
  listed by name or node index. This is specified via field
  \qq{command\_by\_list}. For example:

\begin{verbatim}
  - req.rider.foo.by_list
  [ *1 = [ name="RA DEC",nodeindex=[17,32],state=[solvable=T],command=[save_polc=T] ],
    *2 = [ state=[solvable=F] ]
\end{verbatim}

  ...will call \qq{processCommands()} with the first command set on nodes RA,
  DEC, \#17 and \#32, and with the second command set on all other nodes in
  group \qq{foo}. To be more specific, the \qq{command\_by\_list} field is
  treated as a list  of records. Each record in the list is a command set, with
  an additional \qq{name} field (string or vector of strings) and/or a
  \qq{nodeindex} field (integer or vector of integers). \qq{Node::execute()}
  will iterate through the records one by one; if the node's name is found in
  \qq{name}\footnote{In the future, pattern matching will be supported as
  well.}, or the node index is found in \qq{nodeindex}, then
  \qq{processCommands()} is called with the contents of that record. Once a
  match is found, list processing stops. As a special case, if neither
  \qq{name} nor \qq{index} is specified, then the entry is a ``wildcard''
  matching any node. Wilcards are only useful at the end of the list, to catch
  nodes not already matched by previous entries.
  
\subsection{Command evaluation order}

  In cases where a node finds more than one command set associated with it, the
  order of processing becomes important. The rider is parsed in the following
  order:

  \begin{itemize}
  
  \item The outer loop is over node groups, in the order in which they are
  specified in the node state record. The \qq{all} group is checked last.
  
  \item Within a group's command sub-record, the processing order is from least
  specific to most specific: \qq{command\_all}, \qq{command\_by\_list},
  \qq{command\_by\_nodeindex}.
  
  \item Once a command set is passed to a node's \qq{processCommands()} method,
  the order of processing is determined by the node class implementation.
  Generally, a subclass should call its parent's \qq{processCommands()} first,
  so general commands (such as \qq{state}) should be processed before
  more class-specific commands (such as \qq{save\_polc}).
  
  \end{itemize}
  
\subsection{Standard node commands}
  
\section{Resolution \& resampling}
\label{sec:resampling}

  Resolution \& gridding is a complicated business. Some basic requirements
  are:

  \begin{itemize}
  
  \item In the first instance, the grid/resolution is determined by incoming
  data. We'll call this the {\em full resolution} grid.

  \item It may be prohibitively expensive to evaluate some subtrees (e.g.
  predict) at full resolution. Thus we should support going from full
  resolution to {\em reduced resolution} (integration) and back (upsampling). 
  
  \item Parent nodes will not always have sufficient information to determine
  what the best resolution for a child is. Thus, a child should be able to 
  return data at any resolution is deems fit, and let the parent deal with it.
  
  \end{itemize}
  
  To satisfy these requirements, the following behaviour w.r.t. resolution
  is implemented:
  
  \begin{enumerate}
  
  \item The resolution (and gridding) of a \Request\ is determined by the
  \Cells\ object within. The \Cells\ contains a vector of cell centers and cell
  sizes along each axis (time, frequency), plus the envelope domain. 

  \item The \Cells\ of a \Request\ are merely a hint! A node is not obligated
  to honor the requested grid -- only its envelope domain. The gridding of the
  result is indicated by the \Cells\ returned in the \Result\ object.

    \begin{itemize} 

    \item Some nodes (e.g. \qq{Parm}, \qq{Freq}, \qq{Time} -- generally, nodes
    meant to evaluate some analytic function of time and frequency -- are able
    to evaluate themselves over any given grid. These nodes will always return
    a \Result\ with the same \Cells\ as the \Request; the tree designer may
    rely on this behaviour.

    \item Data-driven nodes (e.g. \qq{Spigot}) completely ignore the \Cells\
    of the \Request. The gridding of their \Result\ is fully determined by
    incoming data.

    \end{itemize}
    
  \item A lot of node classes (e.g., all the \qq{Function}-derived ones)
  require child results to have the same resolution. In the event that this is
  not the case, a node can be configured to deal with it in one of four ways,
  as determined by the \qq{auto\_resample} field of the state record:

    \begin{description}
    
    \item[NONE $(=0)$:] do nothing, do not even check the child resolutions. This
    is the default setting initialized by the \qq{Node} class constructor.

    \item[FAIL $(=-2)$:] check resolutions and return a \qq{RES\_FAIL} if they do
    not match. This is the default setting  initialized by the \qq{Function}
    class constructor. Since this is somewhat slower that the NONE setting, 
    perhaps it should only be the default in debug mode?
    
    \item[INTEGRATE $(=-1)$:] evaluate and return a \Result\ at the lower
    resolution, by integrating higher-resolved child results.

    \item[UPSAMPLE $(=1)$:] evaluate and return a \Result\ at the higher
    resolution, by upsampling lower-resolved child results.

    \end{description}
    
  Auto-resampling is handled at the base \qq{Node} level (in
  \qq{Node::processChildren()}, and thus may be enabled for any individual node
  (although node classes that do their own polling of children -- e.g.,
  \qq{Solver} -- may ignore the flag.) In the rippled solvers tree (Fig. ??),
  nodes which enable auto-resampling are indicated by an "UPS" or "INT" label
  in the node box. 

  \item A few utility nodes may be used to change resolution mid-tree.
  Initially, two such nodes will be provided:

    \begin{description}
    
    \item[\qq{Resampler}:] this node guarantees a \Result\ at the requested
    resolution. A \qq{Resampler} has a single child. It passes the parent's
    \Request\ on to the child, and if the returned \Cells\ are different from
    the requested ones, then it resamples the result to the requested \Cells\
    before returning it to the parent.

    \item[\qq{ModRes}:] this node modifies a \Request's resolution up or down
    by a fixed factor (or to a fixed number of cells along either axis), as as
    determined by its state record (dynamic configuration). This node has a
    single child. The modified \Request\ is passed on to its child, and the
    child's \Result\ is returned.

    \end{description}
    
  In the future, we envision more nodes, such as an adaptive resolution
  reducer, which adaptively selects a minimum required resolution based on the
  results of the child. At the moment, the \qq{ModRes} node is a suitable
  proxy. 

  \item Data access nodes (\qq{Sink} and \qq{Spigot}) are coupled. For each
  snippet of data, the \qq{Sink} will issue a \Request\ with \Cells\
  corresponding to the data layout. The corresponding \qq{Spigot} will then be
  able to return a \Result\ with the same cells.
  
  \item For the time being, we'll only support integral resolutions -- i.e.,
  the full resolution cells must be tilings of the reduced resolution cells.
  This keeps things simple, and avoids interpolation errors. In the future, we
  may support arbitrary regridding.

  \end{enumerate}
  
  It is, of course, up to the tree designer to ensure that resolution is
  changed up and down appropriately within the tree, by strategically
  positioning \qq{Resampler} and \qq{ModRes} nodes, and enabling
  auto-resampling at a few specific nodes. The tree in Fig. ?? provides a good
  example of this.

\chapter{The MeqServer Interface}
\label{chap:meqserver}
\label{sec:meqserver}
\label{sec:meqforest}

  Coming soon.

\chapter{Description of specialized nodes}

\section{Function nodes}
\label{sec:Function}

\section{ReqSeq}

  \qq{ReqSeq} is the {\em request sequencer} node. It is used to sequence the
  execution of requests between subtrees.
  
  Normally, if a node has multiple children, they may recieve \& execute their
  requests in parallel, with no predefined order (note that in a
  single-threaded system, they will effectively execute in sequence, however,
  you cannot design a tree to rely on this behaviour). Some applications
  require that branches of the tree are evaluated in a specific order. For
  example, in the rippled solvers tree (Fig. ??), the Predict--Solver branch
  must be executed first, to determine values for the solvable parameters,
  followed by Predict--Subtract.
  
  The sequencer (\qq{ReqSeq}) node provides an easy way to sequence these
  requests. A sequencer may have any number of children. Upon receiving a
  request from its parent, the sequencer will pass it on to the first child,
  and wait for the first child to return a result. Then it will go on to the
  second child, etc. For its own result, the sequencer returns the result of
  one of the children, as determined by its state record (run-time
  configurable).

\section{Resampler}

\section{ModRes}

\section{MeqParm}

  The \Parm\ node implements a possibly solvable Measurement Equation
  parameter. The parameter is represented by one or more \Polc\ objects.

\subsection{MeqPolc}

  The \Polc\ class implements a 2D polynomial in time and frequency. The Glish
  equivalent is a \qq{meq.polc} record. This record will contain the following
  fields:
  
  \noindent\begin{center}\begin{tabular}{lp{.8\textwidth}}
  \qq{.coeff}  &  a 2D array of polynomial coefficients.\\
  \qq{.freq\_0}  &  \\
  \qq{.freq\_scale}  &  \\
  \qq{.time\_0}  &  \\
  \qq{.time\_scale}  & the scale of the polc (see below)\\
  \qq{.domain}  & (optional) the polc \Domain.\\
  \qq{.weight}  & weight\\
  \qq{.pert}  & perturbation to use for computing derivatives\\
  \qq{.dbid\_index}  & database ID (see below)\\
  \qq{.inf\_domain} &  optional flag: infinite domain (see below)\\
  \qq{.grow\_domain} &  optional flag: growing domain (see below)\\
  \end{tabular}\end{center}
  
  The value of a polc for frequency $f$ and time $t$ is computed as follows:

  \begin{equation}
  p(f,t) = \sum_{i=0}^{N-1}\sum_{j=0}^{M-1} c_{ij}(\frac{f-f_0}{s_f})^i(\frac{t-t_0}{s_t})^j
  \end{equation}
  
  Here, $c_{ij}$ is an $N\times M$ array of coefficients (\qq{coeff}), and
  $f_0,s_f,t_0,s_t$ is the scale of the polc. The scale is only necessary to
  keep numbers small so as to avoid round-off errors.

\subsection{MeqParm state}

  Here's the layout for a \Parm\ state record. All of these attributes are
  dynamic state, that is, they may be changed at any time via \qq{setState()}:
  
  \begin{description}

  \item[\qq{solvable}] (bool, optional) is this \Parm\ solvable or not?
    Default is non-solvable.

  \item[\qq{polcs}] (list of \Polc{}s, optional) the parm's polc list (see below).

  \item[\qq{table\_name}] (string, optional) the name of a MEP table. Default is none.
    If no table is provided, then polcs must be specified via either the
    \qq{polcs} or the \qq{default} field.

  \item[\qq{parm\_name}] (string, optional) the name to use when working with a MEP
    table. Default is to use the node name itself.

  \item[\qq{default}] (\Polc, optional) a default \Polc, to be used as a last
    resort (i.e. if no polcs found in the MEP table).

  \item[\qq{auto\_save}] (bool, optional) If true, any updates to the parm's 
    polcs are immediately saved to the MEP table. If false, updates need to be
    explicitly saved (more on this below). Default is false.

  \end{description}
  
\subsection{Selecting polcs}

  The \qq{Parm::getResult()} method is responsible for evaluating a parm over a
  \Cells\ (specifically, over the domain of the \Cells). To do this, the parm
  needs to find an appropriate polc or polcs for the given domain. Most of the
  tricky logic of the \Parm\ class is dedicated to choosing the right set of
  polcs.  Currently, it will select polc(s) as follows:

  \begin{enumerate}
  
  \item If no MEP table and no default polc has been set in the state record,
    then the parm will blindly re-use the current polc list (i.e. the
    \qq{polcs} field of the state record), or fail if the list is empty.  No
    further error checking is done, and it is up to the user to ensure that the
    parm has been initialized with polcs that are meaningful w.r.t. the domain
    of the request.

  \item Otherwise, the parm will first see if it can re-use the current polc 
    anyway. The current list must contain a single polc, which is tested for
    re-usability as follows:

    \begin{enumerate}
    
    \item If the \qq{inf\_domain} flag is set, the polc has an infinite domain, 
      and can be re-used.
      
    \item If the \qq{grow\_domain} flag is set, and the requested domain is a
      superset of the polc's current domain, then the domain of the polc is
      expanded to match the requested domain, and the polc can be re-used. 

    \item If the requested domain is a subset of the polc's current domain, the
      polc is re-used.

    \end{enumerate}

  \item If no re-use is possible, the current polc list is cleared. The parm
    will then query its MEP table for polcs whose domain overlaps the requested
    domain. These polcs are loaded into the polc list.

  \item If no polcs are found in the MEP table, the table is checked for a
    default polc. Note that default polcs have no domain (generally, they will
    only have a $c_{00}$ coefficient). If a default polc is found, it is placed
    in the list, and its domain is set to the requested domain.

  \item If no default polc is found in the table, or if no table is available,
    then default polc from the state record is copied into the list, and its
    domain is set to the requested domain. Note that the case of no table and
    no default polc is covered by (1), above.

  \end{enumerate}
  
  Once the selection is complete, the parm will have at its disposal a list of
  one or more polcs. 

\subsection{Selecting a single solvable polc}
  
  If the parm is set to solvable, the polc list is then culled to a single polc
  (NB: future versions may support solving for multiple polcs). This polc is
  selected according to the following criteria (in descending order of
  importance):

  \begin{itemize}
  
  \item an exact match of the requested domain to the polc domain;
  
  \item weight (higher is better);
  
  \item database ID (higher, i.e. more recent, is better).
  
  \end{itemize}
  
  Once a single solvable polc is selected, its domain is set equal to the
  requested domain.
  
\subsection{Evaluating the polc list}

  A single polc is evaluated directly over the \Cells\ of the incoming
  \Request. The resulting \VellSet\ object (polc value, plus optional
  derivatives) is then returned to the caller. 
  
  If the parm contains multiple polcs, different evaluation schemes are
  possible:

  \begin{description}

  \item[Tiled polcs.] This is the only scheme implemented by \Parm\ at time of
  writing. For every polc in the list, \Parm\ computes the overlap between
  the polc's domain and the domain of the request. The polc is then evaluated
  over that part of the \Cells\ grid which falls within the overlapping area.
  This step is repeated for every polc. Sections of the grid with no polc
  domain coverage are assigned a zero value.

  Obviously, this scheme is most suitable when the polcs neatly tile
  the request domain. Note that the result is generally discontinuous across
  tile boundaries, which can be quite useful for representing things such as
  phase jumps. On the other  hand, if the request domain is not completely
  covered, or if the polc domains overlap, the results of this scheme are not
  very well defined. 

  \item[Weighted mean.] Each polc is associated with a set of weights, defined
  on the \Cells\ grid. Different weighting schemes may be employed. Presumably,
  grid points within the polc's domain are assigned a higher weight, while
  points outside the domain get a lower weight, further decreasing as we get
  further away from the domain. The value of the parm at each grid point is
  then simply a weighted mean of all the polcs' values.

  The advantage of this scheme is that it gracefully incorporates polcs with
  overlapping domains, while allowing for extrapolation to non-covered areas of
  the request domain. The result is always smooth and continous -- which, on the
  other hand, may not always be what you want. The downside is computational
  expense, as each polc needs to be evaluated at each grid point.

  \item[Reduction to single polc.] This scheme involves fitting a single polc
  (usually of a higher order) to multiple polcs. It can already be implemented
  externally (see \qq{fitpolcs\_wlc.g} for an example), as a ``preprocessing''
  stage of sorts. The scheme works by evaluating the polcs over some set of
  points within the request domain (not necessarily the \Cells\ grid at all),
  combining the results using some sort of weighted mean, then doing a
  least-squares fit of a new polc to the resulting values.

  \end{description}

\subsection{Updating and saving polcs}    

  In the course of a solution, the Solver node updates the values of solvable
  polcs by sending up new values in the request rider. This is done by
  including the \qq{Update.Values} command in the rider. The value of the
  command is expected to be a vector of new coefficients, in the same order in
  which spids were assigned. More specifically:

  \begin{itemize}
  
  \item When a \Parm\ that has been set solvable initializes a new polc for a
  domain, it associates a number of spids with its coefficients. Spids are
  assigned as $256*${\em nodeindex}$+i$, where $i$ is the number of the
  coefficient.
  
  \item These spids are included in the resulting \Vells; as results percolate
  down the tree, spid vectors and corresponding perturbed values from different
  solvable \Parm{}s are merged. The \Vells\ received by the solver contain the
  full set of spids from all the solvable \Parm{}s in its trees.

  \item The Solver computes a set of incremental updates. Note that the Solver
  knows nothing of \Polc{}s or \Parm{}s; instead, it only deals with abstract
  ``atomic parameters'' identified by spid.

  \item The solver inserts the updates into the rider of the next request, as
  a set of \qq{Update.Values} commands. This request is then used to recalculate
  the trees for the next iteration. If this is the last iteration, then a
  request without a \Cells\ is sent up -- this updates the values without
  recalculating anything.
  
  \end{itemize}
  
  Presumably, at some point the new polc values need to be stored into a MEP
  table. There are two ways to accomplish this:

  \begin{description}
  
  \item[Automatically:] if the \qq{auto\_save} flag is set in the \Parm\ state
  record, then each update via \qq{set\_value} is immediately committed to the
  MEP table.

  \item[With explicit command:] whenever the \Parm\ receives a request with a
  \qq{Save.Polcs} command in the rider, it commits all its polcs to the MEP
  table.

  \end{description}
  
  The \qq{dbid\_index} attribute of the \Polc\ is used to keep track of its
  location in the MEP table. When a polc is loaded from the table (whether on
  the C++ side, or via the Glish \qq{meptable()} object), \qq{dbid\_index} is
  set to its DB identifier.\footnote{As long as we use AIPS++ tables, this is
  simply the row number. If and when we employ other storage schemes, dbid  may
  become something different, but is in any case a key into the database.} 
  When a polc is subsequently saved, its dbid is used to locate the correct
  entry in the table. New polcs are created with a dbid of -1; when they are
  subsequently saved, a new entry is allocated in the MEP table, and the polc
  object is updated with the dbid. During normal operation, the user need not
  worry about this since everything happens automatically; some advanced
  scripting may require knowledge of the dbid.


