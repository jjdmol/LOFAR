//
//  DO NOT EDIT THIS FILE   (MY_Protocol.ph)
//  
//  It has been AutoGen-ed  Friday April 23, 2004 at 11:43:24 AM CEST
//  From the definitions    MY_Protocol.prot
//  and the template file   protocol
//
//  MY_Protocol.h: Protocol definition for the Test
//
//  Copyright (C) 2003
//  ASTRON (Netherlands Foundation for Research in Astronomy)
//  P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//  
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//  
//  You should have received a copy of the GNU Lesser General Public
//  License along with This program; if not, write to:
//             The Free Software Foundation, Inc.,
//             59 Temple Place - Suite 330,
//             Boston,  MA  02111-1307, USA.
//
//  $Id$
//

#ifndef MY_PROTOCOL_H
#define MY_PROTOCOL_H
#ifdef SWIG
%module pybind
%include GCF/GCF_Event.h
%include carrays.i
%include TransObject.h
%array_class(int, int_array)
%array_class(char, char_array)
%{
#include "pybind.ph"
#include <string.h> // needed for memcpy
#include <GCF/GCF_TMProtocols.h>
#include "TransObject.h"
#include <iostream>
#include <sstream>
%}
#endif
#include <string.h> // needed for memcpy
#include <GCF/GCF_TMProtocols.h>

#define STRLEN 1024

namespace MY_Protocol
{
  //
  // Define protocol ID
  //
  enum {
    MY_PROTOCOL = (F_GCF_PROTOCOL + 3)
  };

  //
  // Define protocol message types
  //
  enum { 
    ABS_BEAM_ALLOC_ID = 1
  };
 
#define ABS_BEAM_ALLOC F_SIGNAL(MY_PROTOCOL, ABS_BEAM_ALLOC_ID, F_IN)

  class ABSBeamAllocEvent : public GCFEvent
  {
    public:
      ABSBeamAllocEvent(
        int aParam1,
        int aParam2)
      : GCFEvent(ABS_BEAM_ALLOC),
        param1(aParam1),
        param2(aParam2)
      {
        length = sizeof(ABSBeamAllocEvent);
        
        
      }

      ABSBeamAllocEvent() : GCFEvent(ABS_BEAM_ALLOC)
      {
        length = sizeof(ABSBeamAllocEvent);
      }
      
      int param1;
      int param2;
  };
  
  class ABSBeamAllocEventExt : public GCFEventExt
  {
    public:
      ABSBeamAllocEventExt(ABSBeamAllocEvent& be, bool dounpack = false) 
      : base(be),
        ext1Dim(0),
        ext1(0),
        ext2Dim(0),
        ext2(0)
      {
        if (dounpack) unpack();
      }
      
      virtual ~ABSBeamAllocEventExt() { }
      
      int* ext1; unsigned int ext1Dim;
      char* ext2; unsigned int ext2Dim;
      TransObject* obj1;

#ifdef SWIG
    private:
#endif
      void* pack(unsigned int& packsize)
      {
        unsigned int requiredSize =
          sizeof(ext1Dim) + (ext1Dim * sizeof(int)) +
          sizeof(ext2Dim) + (ext2Dim * sizeof(char)) ;

        resizeBuf(requiredSize);
        unsigned int offset = 0;
        offset += packMember(ext1, ext1Dim,  sizeof(int), offset);
        offset += packMember(ext2, ext2Dim,  sizeof(char), offset);
        packsize = offset;
        base.length += offset;
        return _buffer;
      }

      void unpack()
      {
        unsigned int offset = sizeof(ABSBeamAllocEvent);
        if (offset < base.length)
        {
          char* data = (char*) &base;
          ext1 = (int*) unpackMember(data, ext1Dim,  sizeof(int), offset);
          ext2 = (char*) unpackMember(data, ext2Dim,  sizeof(char), offset);
        }
      }
      
      GCFEvent& getEvent() { return base; }

      ABSBeamAllocEvent& base;
      
    private:
      ABSBeamAllocEventExt();
  };

#ifdef SWIG
%extend ABSBeamAllocEventExt {
char* __str__()
{
  static char* str = 0;
  std::ostringstream ostr;

  ostr << "ABSBeamAllocEvent\n";

  ostr << "\text1 = " << self->ext1Dim << " [\n";
  for (int i=0; i < self->ext1Dim; i++) ostr << self->ext1[i] << " ";
  ostr << "\n]\n";

  ostr << "\text2 = " << self->ext2Dim << " [\n";
  for (int i=0; i < self->ext2Dim; i++) ostr << self->ext2[i] << " ";
  ostr << "\n]\n";

  if (str) delete [] str;
  str = new char[ostr.str().length()+1];
  memset(str, 0, ostr.str().length()+1);
  memcpy(str, ostr.str().c_str(), ostr.str().length()-1);
  
  return str;
}
};
#endif

} // namespace MY_Protocol

using namespace MY_Protocol;

#ifndef SWIG
#ifdef DECLARE_SIGNAL_NAMES

const char* MY_PROTOCOL_signalnames[] = {
  "MY_PROTOCOL: invalid signal",
  "ABS_BEAM_ALLOC"
};

#else

// extern declaration of protocol event names
extern const char* MY_PROTOCOL_signalnames[];

#endif
#endif

#endif
