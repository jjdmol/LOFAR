//
//  CCU_increment1.btsw: Testscript for increment 1 of the CCU software.
//
//  Copyright (C) 2005
//  ASTRON (Netherlands Foundation for Research in Astronomy)
//  P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
//
// ------------------------------------------------------------------------------
// Description:
//
//
//
// ------------------------------------------------------------------------------

[statemachines]

Statemachine_MACScheduler (ready, stopBeamServer, bs_alloc_ack, bs_pointto_ack, vbsd_scheduled) =
{
// ------------------------------------------------------------------------------
  s000  : F_SAS_SCHEDULE ( "VI1.ps" )                           ; s010.			// send schedule VI1
  s010  : E_SAS_RESPONSE ( 0x00000000 )                         ; s020.			// wait for response
  s010  : E_SAS_RESPONSE (  )                                   ; error.  	// invalid response received
  s020  : R_SIG ( bs_alloc_ack )                                ; s030.			// wait for beam allocation acknowledge; sync with BeamServer statemachine
  s020  : R_SIG ( vbsd_scheduled )                              ; s031.    	// or wait for VirtualBackend response; sync with VirtualBackend statemachine
  s020  : TIMER(30)																							; timeout.	// or timeout
  s030  : R_SIG ( vbsd_scheduled )                              ; s100.			// wait for VirtualBackend response; sync with VirtualBackend statemachine
  s030  : TIMER(30)																							; timeout.	// or timeout
  s031  : R_SIG ( bs_alloc_ack )                                ; s040.			// wait for beam allocation acknowledge; sync with BeamServer statemachine
  s031  : TIMER(30)																							; timeout.	// or timeout
  s040  : TIMER(30)                                             ; s100.     // wait for schedule to finish
// ------------------------------------------------------------------------------


// ------------------------------------------------------------------------------
  s100  : F_SAS_CANCELSCHEDULE ( "VI1.ps" )                     ; s110.			// cancel schedule VI1
  s110  : E_SAS_RESPONSE ( 0x00000000 )                         ; s200.			// wait for response
  s110  : E_SAS_RESPONSE (  )                                   ; error.  	// invalid response received
// ------------------------------------------------------------------------------

// ------------------------------------------------------------------------------
  s200  : F_SAS_SCHEDULE ( "VI1.ps" )                           ; s210.			// send schedule VI1
  s210  : E_SAS_RESPONSE ( 0x00000000 )                         ; s220.			// wait for response
  s210  : E_SAS_RESPONSE (  )                                   ; error.  	// invalid response received
  s220  : R_SIG ( bs_alloc_ack )                                ; s230.			// wait for beam allocation acknowledge; sync with BeamServer statemachine
  s220  : R_SIG ( vbsd_scheduled )                              ; s231.    	// or wait for VirtualBackend response; sync with VirtualBackend statemachine
  s220  : TIMER(30)																							; timeout.	// or timeout
  s230  : R_SIG ( vbsd_scheduled )                              ; s300.			// wait for VirtualBackend response; sync with VirtualBackend statemachine
  s230  : TIMER(30)																							; timeout.	// or timeout
  s231  : R_SIG ( bs_alloc_ack )                                ; s300.			// wait for beam allocation acknowledge; sync with BeamServer statemachine
  s231  : TIMER(30)																							; timeout.	// or timeout
// ------------------------------------------------------------------------------

// ------------------------------------------------------------------------------
  s300  : F_SAS_UPDATESCHEDULE ( "VI1.ps" )                     ; s310.			// send schedule update VI1
  s310  : E_SAS_RESPONSE ( 0x00000000 )                         ; s320.			// wait for response
  s310  : E_SAS_RESPONSE (  )                                   ; error.  	// invalid response received
  s320  : R_SIG ( bs_alloc_ack )                                ; s230.			// wait for beam allocation acknowledge; sync with BeamServer statemachine
  s320  : R_SIG ( vbsd_scheduled )                              ; s231.    	// or wait for VirtualBackend response; sync with VirtualBackend statemachine
  s320  : TIMER(30)																							; timeout.	// or timeout
  s330  : R_SIG ( vbsd_scheduled )                              ; s400.			// wait for VirtualBackend response; sync with VirtualBackend statemachine
  s330  : TIMER(30)																							; timeout.	// or timeout
  s331  : R_SIG ( bs_alloc_ack )                                ; s400.			// wait for beam allocation acknowledge; sync with BeamServer statemachine
  s331  : TIMER(30)																							; timeout.	// or timeout
// ------------------------------------------------------------------------------

  s400  : TIMER(1) 																							; finish.		// end of script
// ------------------------------------------------------------------------------
  finish : S_SIG ( ready )
           S_SIG ( stopBeamServer )                             ; OK.
  OK     : TIMER(60)																						; OK.

  timeout : TERMINATE ; timeout.
  error   : TERMINATE ; error.
}

Statemachine_BeamServer  ( stop, bs_alloc_ack, bs_pointto_ack ) =
{
VAR handle.

  s000   : E_ABS_BEAMALLOC (, ,,,,,,,,,, ,,,,,,,,,, 
           	                 ,,,,,,,,,, ,,,,,,,,,, 
            	                ,,,,,,,,,, ,,,,,,,,,, 
              	              ,,,,,,,,,, ,,,,,,,,,, 
                	            ,,,,,,,,,, ,,,,,,,,,, 
                  	          ,,,,,,,,,, ,,,,,,,,,, 
                    	        ,,,,,,,,)                           ; s010.
  s000   : E_ABS_BEAMFREE  ( handle )                             ; s020.
  s000   : E_ABS_BEAMPOINTTO (,,,,)                               ; s030.
  s000   : E_ABS_WGSETTINGS (,)                                   ; s040.
  s000   : E_ABS_WGENABLE ( )                                     ; s000.
  s000   : E_ABS_WGDISABLE ( )                                    ; s000.
  s000   : R_SIG( stop )                                        	; finish.
  
  s010   : S_SIG( bs_alloc_ack )
           F_ABS_BEAMALLOC_ACK ( 0x00000001, 0x00000000 )         ; s000.
  
  s020   : F_ABS_BEAMFREE_ACK ( handle, 0x00000000 )              ; s000.
  
  s030   : S_SIG( bs_pointto_ack )                              	; s000.

  s040   : F_ABS_WGSETTINGS_ACK ( 0x00000000 )                    ; s000.

  finish : TERMINATE ; finish.
}

Statemachine_VBStartDaemon ( stop, vbsd_scheduled, vbsd_connected ) =
{
  s000   : E_STARTDAEMON_SCHEDULE (,,,,,)                         ; s010.
  s000   : E_STARTDAEMON_STOP	( ) 	                              ; finish.
  s000   : R_SIG( stop )                                        	; finish.
  
  s010   : F_STARTDAEMON_SCHEDULED ( 0x00000000 )         				
           S_SIG( vbsd_scheduled )
           S_SIG( vbsd_connected )																; s000.
  
  finish : TERMINATE ; finish.
}

Statemachine_VirtualBackend  ( stop, vbsd_connected ) =
{
  s000   : R_SIG( vbsd_connected )																; s010.
  
  s010   : F_LOGICALDEVICE_CONNECT( "VB1" )												; s020.
  
  s020   : E_LOGICALDEVICE_CONNECTED (0x00000000)                 ; s030.
  s020   : E_LOGICALDEVICE_CONNECTED ( )                          ; error.
  
	s030   : E_LOGICALDEVICE_SCHEDULE ()                           	; s040.
	s030   : E_LOGICALDEVICE_CANCELSCHEDULE ( )                     ; s050.
	s030   : E_LOGICALDEVICE_CLAIM ( )                       				; s060.
	s030   : E_LOGICALDEVICE_PREPARE ( )														; s070.
	s030   : E_LOGICALDEVICE_RESUME ( )                       			; s080.
	s030   : E_LOGICALDEVICE_SUSPEND ( )                       			; s090.
	s030   : E_LOGICALDEVICE_RELEASE ( )                       			; s100.
  s030   : R_SIG( stop )                                        	; finish.
  
  s040   : F_LOGICALDEVICE_SCHEDULED ( 0x00000000 )         			; s030.
  s050   : F_LOGICALDEVICE_SCHEDULECANCELLED ( 0x00000000 )  			; s030.
  s060   : F_LOGICALDEVICE_CLAIMED ( 0x00000000 )  								; s030.
  s070   : F_LOGICALDEVICE_PREPARED ( 0x00000000 )								; s030.
  s080   : F_LOGICALDEVICE_RESUMED ( 0x00000000 )									; s030.
  s090   : F_LOGICALDEVICE_SUSPENDED ( 0x00000000 )								; s030.
  s100   : F_LOGICALDEVICE_RELEASED ( 0x00000000 )								; s030.
  
  finish : TERMINATE ; finish.
  error  : TERMINATE ; error.
}

WaitUntilTestEnd (SM1_ready) =
{
  s010   :   R_SIG (SM1_ready)                                  ; finish.
  finish : TERMINATE ; finish.
}

Statemachine_THPVSSBridge  ( stop ) =
{
VAR scope.

  s000   : F_PVSS_LOAD_EXT_PROPERTY_SET( "System1:PAC_LogicalDeviceScheduler","TLcuPacLogicalDeviceScheduler" )			 			; s010.
  s010   : E_PVSS_LOAD_EXT_PROPERTY_SET_RESPONSE( ,0x00000000,,"System1:PAC_LogicalDeviceScheduler" )				; s020.
  s010   : E_PVSS_LOAD_EXT_PROPERTY_SET_RESPONSE( ,,, )            			; error.
  
  s020   : F_PVSS_EXT_GET_VALUE ( "System1:PAC_LogicalDeviceScheduler","command" )														; s030.
  s030   : E_PVSS_VALUE_CHANGE_RESPONSE ( ,,"System1:PAC_LogicalDeviceScheduler",,"command",, )							; s040. // note: can only check one string in an event 
  s030   : E_PVSS_VALUE_CHANGE_RESPONSE( ,,,,,, )											; error.

  s040   : F_PVSS_SUBSCRIBE_EXT_PROPERTY ( "System1:PAC_LogicalDeviceScheduler","command" )									; s050.
  s050   : E_PVSS_SUBSCRIBE_EXT_PROPERTY_RESPONSE( ,0x00000000,,"System1:PAC_LogicalDeviceScheduler",,"command" ) 	; s060.
  s050   : E_PVSS_SUBSCRIBE_EXT_PROPERTY_RESPONSE( ,,,,, )							; error.

  s060   : F_PVSS_EXT_SET_VALUE ( "System1:PAC_LogicalDeviceScheduler","command","dummy1" )														; s070.
  s070   : E_PVSS_EXT_SET_VALUE_RESPONSE( , 0x00000000,,"System1:PAC_LogicalDeviceScheduler",,"command" ) 						; s080.
  s070   : E_PVSS_EXT_SET_VALUE_RESPONSE( ,,,,, )												; error.
  
  s080   : E_PVSS_VALUE_CHANGE_RESPONSE( ,,"System1:PAC_LogicalDeviceScheduler",,"command",,"dummy1" )								; s090. // note: can only check one string in an event
  s080   : E_PVSS_VALUE_CHANGE_RESPONSE( ,,,,,, ) 											; error.

  s090   : F_PVSS_UNSUBSCRIBE_EXT_PROPERTY ( "System1:PAC_LogicalDeviceScheduler","command" )								; s100.
  s100   : E_PVSS_UNSUBSCRIBE_EXT_PROPERTY_RESPONSE( , 0x00000000,,"System1:PAC_LogicalDeviceScheduler",,"command" )	; s110.
  s100   : E_PVSS_UNSUBSCRIBE_EXT_PROPERTY_RESPONSE( ,,,,, )						; error.

  s110   : F_PVSS_EXT_SET_VALUE ( "System1:PAC_LogicalDeviceScheduler","command","dummy2" )														; s120.
  s120   : E_PVSS_EXT_SET_VALUE_RESPONSE( , 0x00000000,,"System1:PAC_LogicalDeviceScheduler",,"command" ) 						; s130.
  s120   : E_PVSS_EXT_SET_VALUE_RESPONSE( ,,,,, )												; error.
 
  s130   : F_PVSS_EXT_GET_VALUE ( "System1:PAC_LogicalDeviceScheduler","command" )														; s140.
  s140   : E_PVSS_VALUE_CHANGE_RESPONSE ( ,,"System1:PAC_LogicalDeviceScheduler",,"command",,"dummy2" )							; s150. // note: can only check one string in an event 
  s140   : E_PVSS_VALUE_CHANGE_RESPONSE( ,,,,,, )											; error.

  s150   : F_PVSS_UNLOAD_EXT_PROPERTY_SET( "System1:PAC_LogicalDeviceScheduler" )			; s160.
  s160   : E_PVSS_UNLOAD_EXT_PROPERTY_SET_RESPONSE( ,0x00000000,,"System1:PAC_LogicalDeviceScheduler" ) 		; s500.
  s160   : E_PVSS_UNLOAD_EXT_PROPERTY_SET_RESPONSE( ,,, )            			; error.
  
  s500   : F_PVSS_LOAD_EXT_PROPERTY_SET( "System1:PAC_LogicalDeviceScheduler","TLcuPacLogicalDeviceScheduler" )			 			; s510.
  s510   : E_PVSS_LOAD_EXT_PROPERTY_SET_RESPONSE( ,0x00000000,,"System1:PAC_LogicalDeviceScheduler" )				; s520.
  s510   : E_PVSS_LOAD_EXT_PROPERTY_SET_RESPONSE( ,,, )            			; error.
  
  s520   : F_PVSS_SUBSCRIBE_EXT_PROPERTY ( "System1:PAC_LogicalDeviceScheduler","command" )									; s530.
  s530   : E_PVSS_SUBSCRIBE_EXT_PROPERTY_RESPONSE( ,0x00000000,,"System1:PAC_LogicalDeviceScheduler",,"command" ) 	; s540.
  s530   : E_PVSS_SUBSCRIBE_EXT_PROPERTY_RESPONSE( ,,,,, )							; error.

  s540   : F_PVSS_SUBSCRIBE_EXT_PROPERTY ( "System1:PAC_LogicalDeviceScheduler","status" )									; s550.
  s550   : E_PVSS_SUBSCRIBE_EXT_PROPERTY_RESPONSE( ,0x00000000,,"System1:PAC_LogicalDeviceScheduler",,"status" ) 	; s560.
  s550   : E_PVSS_SUBSCRIBE_EXT_PROPERTY_RESPONSE( ,,,,, )							; error.

  s560   : E_PVSS_VALUE_CHANGE_RESPONSE( ,,,,,, )												; s560.
  s560   : R_SIG( stop )                                       				 	; finish.

  s990   : R_SIG( stop )                                       				 	; finish.
	s990   : TERMINATE                                       				 	; s990.
    
  finish : TERMINATE ; finish.
  error  : TERMINATE ; error.
}



[testscript]
VAR     SM1_done, SM2_stop, SM3_stop, SM4_stop, SM5_stop, bs_alloc_ack, bs_pointto_ack, vbsd_scheduled, vbsd_connected.

COM1 :  Statemachine_MACScheduler (SM1_done, SM2_stop, bs_alloc_ack, bs_pointto_ack, vbsd_scheduled)
        WaitUntilTestEnd (SM1_done).

COM2 :  Statemachine_BeamServer   (SM2_stop, bs_alloc_ack, bs_pointto_ack).

COM3 :  Statemachine_VBStartDaemon (SM3_stop, vbsd_scheduled, vbsd_connected).

COM4 :  Statemachine_VirtualBackend (SM4_stop, vbsd_connected).

//COM5 :  Statemachine_THPVSSBridge (SM5_stop).

