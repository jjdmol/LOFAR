#!/bin/bash
#
# swlevel : bring software on node in certain runlevel
#
# Copyright (C) 2006
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Syntax: swlevel [ 0 | 1 | 2 | 3 | 4 | 5 | 6 ]
#
# $Id$
#
VERSION="v1.4 20071017"		# added possibility for custom scripts
BINDIR=/opt/lofar/bin
LOGDIR=/opt/lofar/log
LEVELTABLE=${BINDIR}/../etc/swlevel.conf

#
# SyntaxError msg
#
SyntaxError()
{
	Msg=$1

	[ -z "${Msg}" ] || echo "ERROR: ${Msg}"
	echo ""
	echo "Syntax: $(basename $0) [ 0 | 1 | 2 | 3 | 4 | 5 | 6 ]"
	echo "0: stop all lofar software"
	echo "1: Lofar daemons are running"
	echo "2: RSPDriver is running"
	echo "3: PVSS database is running"
	echo "4: Hardwaremonitor is running"
	echo "5: Servers are running"
	echo "6: Full MAC is running"
	echo ""
	exit 1
}

#
# Start the program when it exists
#
start_prog()
{
	# make arguments readable
	prog=$1
	asroot=${2:1}
	withmpi=${3:1}

	# check existance
	[ -x $BINDIR/$prog ] || [ -x $BINDIR/${prog}.sh ] || return
	
	# if it is a shell script call the script
	if [ -f $BINDIR/${prog}.sh ]; then
		$BINDIR/${prog}.sh start
		return
	fi

#	ps -ef | grep -v grep | grep -v ${prog}[^\ ] | grep $prog 2>&1 >/dev/null
	ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog} 2>&1 >/dev/null
	if [ $? -eq 0 ]; then
		# program is running, show it
#		ps -ef | grep -v grep | grep -v ${prog}[^\ ] | grep $prog
		ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog}
	else
		echo Starting $prog
		# PVSS needs special treatment
		if [ "$prog" = "PVSS00pmon" ]; then
			start_pvss2
			sleep 5
		else
			if [ -n "$asroot" ]; then
				sudo rm -f $LOGDIR/$prog.log*
				if [ "$prog" = "RSPDriver" ]; then
					echo "Starting RSPDriver with nice -20"
					sudo -b nohup nice -20 $BINDIR/$prog 1>&2 2>/dev/null
				else
					sudo -b nohup $BINDIR/$prog 1>&2 2>/dev/null
				fi
			else
				rm -f $LOGDIR/$prog.log*
				nohup $BINDIR/$prog 1>&2 2>/dev/null &
			fi
			sleep 1
		fi
#		ps -ef | grep -v grep | grep -v ${prog}[^\ ] | grep $prog
		ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog}
	fi
}

#
# Stop the program when it is running
#
stop_prog()
{
	# make arguments readable
	prog=$1
	asroot=${2:1}
	withmpi=${3:1}
	[ ! -z "$asroot" ] && asroot=sudo	

	# check existance
	[ -x $BINDIR/$prog ] || [ -x $BINDIR/${prog}.sh ] || return
	
	# if it is a shell script call the script
	if [ -f $BINDIR/${prog}.sh ]; then
		$BINDIR/${prog}.sh stop
		return
	fi

	# get processlist
#	ps -ef | grep -v grep | grep -v ${prog}[^\ ] | grep $prog 2>&1 >/dev/null
	ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog} 2>&1 >/dev/null
	if [ $? -ne 0 ]; then
		return
	fi

	# PVSS needs special treatment
	if [ "$prog" = "PVSS00pmon" ]; then
		echo "Stopping PVSS database"
		start_pvss2 -stopWait
		return
	fi

	# first handle mpi programs
	if [ ! -z "$withmpi" ]; then
		$asroot cexec :0-11 killall -9 ${prog}
		return
	fi

	# first try normal kill
#	ps -ef | grep -v grep | grep -v ${prog}[^\ ] | grep $prog | awk '{ print $2 }' | while read pid
	ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog} | awk '{ print $2 }' | while read pid
	do 
		echo "Softly killing ${prog}(${pid})"
		$asroot kill $pid
		sleep 1
	done

	# when normal kill did not work, kill is with -9
#	ps -ef | grep -v grep | grep -v ${prog}[^\ ] | grep $prog | awk '{ print $2 }' | while read pid
	ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog} | awk '{ print $2 }' | while read pid
	do 
		sleep 2
		echo "Hard killing ${prog}(${pid})"
		$asroot kill -9 $pid 1>&2 2>/dev/null
	done
}

#
# show status of program
#
status_prog()
{
	echo
	echo Status of all software level:

	prevlevel=1
	cat $LEVELTABLE | cut -d"#" -f1 | awk '{ if (NF>0) print $0 }' | while read line
	do
		levelnr=`echo $line | cut -d":" -f1`
		prog=`echo $line | cut -d":" -f6`

		# check existance
		[ -x $BINDIR/$prog ] || [ -x $BINDIR/${prog}.sh ] || continue
	
		if [ $prevlevel -ne $levelnr ]; then
			echo "---"
			prevlevel=$levelnr
		fi

		# if it is a shell script call the script
		if [ -f $BINDIR/${prog}.sh ]; then
			$BINDIR/${prog}.sh status $levelnr
			continue
		fi

#		ps -ef | grep -v grep | grep -v ${prog}[^\ ] | grep ${prog} 2>&1 >/dev/null
		ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog} 2>&1 >/dev/null
		if [ $? -eq 0 ]; then
			# program is running, show it
#			pid=""
#			ps -ef | grep -v grep | grep -v ${prog}[^\ ] | grep ${prog} | awk '{ print $2 }' | while read somepid
#			do
#				pid=${pid}" "${somepid}
#			done
#			pid=`ps -ef | grep -v grep | grep -v ${prog}[^\ ] | grep ${prog} | awk '{ print $2 }'`
			pid=`ps -ef | grep -v grep | egrep '[0-9][0-9] [a-zA-Z0-9/_.]*/'${prog} | awk '{ print $2 }'`
		else
			pid="DOWN"
		fi
		echo ${levelnr} ${prog} ${pid} | awk '{ printf "%s : %-25s %s\n", $1, $2, $3 }'
	done
}

#
# goto_level levelnr
#
goto_level()
{
	#first power down to new level
	newlevel=$1
	for (( l=6 ; l>newlevel ; l-- ))
	do
		tac $LEVELTABLE | cut -d"#" -f1 | awk '{ if (NF>0) print $0 }' | \
		grep "^${l}:" | grep ":d:" |  while read line
		do
			asroot=`echo $line | cut -d":" -f4`
			withmpi=`echo $line | cut -d":" -f5`
			program=`echo $line | cut -d":" -f6`
			stop_prog $program x$asroot x$withmpi
		done
	done

	# then power up to new level
	for (( l=1 ; l<=newlevel ; l++ ))
	do
		cat $LEVELTABLE | cut -d"#" -f1 | awk '{ if (NF>0) print $0 }' | \
		grep "^${l}:" | grep ":u:" |  while read line
		do
			asroot=`echo $line | cut -d":" -f4`
			withmpi=`echo $line | cut -d":" -f5`
			program=`echo $line | cut -d":" -f6`
			start_prog $program x$asroot x$withmpi
		done
	done
}

#
# MAIN
#

# when no argument is given show current level
if [ -z "$1" ]; then
	level=`cat /tmp/level.admin`
	echo "Current level is $level"
	status_prog
	exit
fi

# don't allow root to run swlevel because all logfile get root access.
uid=`id | cut -d'=' -f2 | cut -d'(' -f1`
if [ $uid -eq 0 ]; then
	echo "swlevel may NOT be run as root!"
	exit
fi

# first power down to this level
case $1 in
	0|1|2|3|4|5|6)	let level=$1
			;;
	*) SyntaxError
esac
echo Going to level $level
cwd=`pwd`
cd ${BINDIR}
goto_level $level
cd ${cwd}
status_prog

# save for later
echo $level >/tmp/level.admin
