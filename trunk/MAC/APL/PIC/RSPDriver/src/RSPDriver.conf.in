#
# Configuration of the RSPDriver
#

#
# If SYNC_MODE=1 then sync will be generated by a software timer (rate controlled by SYNC_INTERVAL)
# If SYNC_MODE=2 then RSPDriver will run as fast as possible (to determine maximum update rate).
# If SYNC_MODE=3 then sync will be generated by PPS API on /dev/pps0
#
RSPDriver.SYNC_MODE=3

#
# SYNC_INTERVAL is only used when SYNC_MODE=1 to set the interval
# time of the timer.
#
RSPDriver.SYNC_INTERVAL=1.0

#
# PPS_DEVICE is only used when SYNC_MODE=3 to designate the PPS device
#
RSPDriver.PPS_DEVICE=/dev/oncore.pps.0

#
# Send signal to the RSP boards to simulate the arrival of
# a SYNC pulse (which normally comes with a frequency of 1Hz).
#
RSPDriver.SOFTPPS=0

#
# Specify the base index of the RSP board ethernet MAC address
# The RSP boards addresses will be numbered consecutively.
#
# Start from address: 00:00:00:00:00:MAC_BASE
# RSPDriver.MAC_BASE=1

#
# Instead of specifying MAC_BASE, one can specify all MAC
# addresses explicitly as MAC_ADDR0..MAC_ADDR23
# In this case you must leave RSPDriver.MAC_BASE unspecified
#
#RSPDriver.MAC_ADDR_0=00:00:00:00:00:08
# lofar27:eth2:00:50:04:32:B8:5C
#RSPDriver.MAC_ADDR_0=00:30:48:2D:82:F6
RSPDriver.MAC_ADDR_0=10:FA:00:00:13:00
RSPDriver.MAC_ADDR_1=10:FA:00:00:12:00
RSPDriver.MAC_ADDR_2=00:00:00:00:00:03
RSPDriver.MAC_ADDR_3=00:00:00:00:00:04
RSPDriver.MAC_ADDR_4=00:00:00:00:00:05
RSPDriver.MAC_ADDR_5=00:00:00:00:00:06
RSPDriver.MAC_ADDR_6=00:00:00:00:00:07
RSPDriver.MAC_ADDR_7=00:00:00:00:00:08
RSPDriver.MAC_ADDR_8=00:00:00:00:00:09
RSPDriver.MAC_ADDR_9=00:00:00:00:00:10
RSPDriver.MAC_ADDR_10=00:00:00:00:00:0A
RSPDriver.MAC_ADDR_11=00:00:00:00:00:0B
RSPDriver.MAC_ADDR_12=00:00:00:00:00:0C
RSPDriver.MAC_ADDR_13=00:00:00:00:00:0D
RSPDriver.MAC_ADDR_14=00:00:00:00:00:0E
RSPDriver.MAC_ADDR_15=00:00:00:00:00:0F
RSPDriver.MAC_ADDR_16=00:00:00:00:00:10
RSPDriver.MAC_ADDR_17=00:00:00:00:00:11
RSPDriver.MAC_ADDR_18=00:00:00:00:00:12
RSPDriver.MAC_ADDR_19=00:00:00:00:00:13
RSPDriver.MAC_ADDR_20=00:00:00:00:00:14
RSPDriver.MAC_ADDR_21=00:00:00:00:00:15
RSPDriver.MAC_ADDR_22=00:00:00:00:00:16
RSPDriver.MAC_ADDR_23=00:00:00:00:00:17

#
# Data output payload size.
# Should eventually be computed dynamically
# based on settings.
#
# Data output payload size.
# Should eventually be computed dynamically
# based on settings.
# c_frame_size  = g_hdr_sz + c_epa_hdr_size + nof_blocks * (c_block_size)
#               =    16    +      8         +      16    * (   2*2*54   ) = 3480 words (16 bit)
# OUTPUT_PAYLOAD_SIZE = (3480 - 16) * 2 = 6928 octets
#
# Ethernet frame size: 3480*2 + 14 = 6974
#
RSPDriver.OUTPUT_PAYLOAD_SIZE=6928

#
# Destination IP and MAC address for data packets
# leaving the RSP board with the given index
#

#
# Output to CEP inputnode 1
#
RSPDriver.SRC_IP_ADDR_0=10.1.0.1
RSPDriver.DST_IP_ADDR_0=192.168.2.111
RSPDriver.DST_MAC_ADDR_0=00:E0:81:31:DE:8A

#
# Output to CEP inputnode 3
#
RSPDriver.SRC_IP_ADDR_1=10.1.0.2
RSPDriver.DST_IP_ADDR_1=192.168.2.112
RSPDriver.DST_MAC_ADDR_1=00:E0:81:31:DF:D4

#
# Output to lofar11
#
# RSPDriver.SRC_IP_ADDR_0=10.1.0.1
# RSPDriver.DST_IP_ADDR_0=192.168.2.111
# RSPDriver.DST_MAC_ADDR_0=00:04:23:B5:C4:6A
#
# Output to lofar12
#
# RSPDriver.SRC_IP_ADDR_1=10.1.0.2
# RSPDriver.DST_IP_ADDR_1=192.168.2.112
# RSPDriver.DST_MAC_ADDR_1=00:04:23:B5:C5:CA

RSPDriver.SRC_IP_ADDR_2=10.1.0.3
RSPDriver.DST_IP_ADDR_2=10.2.0.3
RSPDriver.DST_MAC_ADDR_2=
RSPDriver.SRC_IP_ADDR_3=10.1.0.4
RSPDriver.DST_IP_ADDR_3=10.2.0.4
RSPDriver.DST_MAC_ADDR_3=
RSPDriver.SRC_IP_ADDR_4=10.1.0.5
RSPDriver.DST_IP_ADDR_4=10.2.0.5
RSPDriver.DST_MAC_ADDR_4=
RSPDriver.SRC_IP_ADDR_5=10.1.0.6
RSPDriver.DST_IP_ADDR_5=10.2.0.6
RSPDriver.DST_MAC_ADDR_5=
RSPDriver.SRC_IP_ADDR_6=10.1.0.7
RSPDriver.DST_IP_ADDR_6=10.2.0.7
RSPDriver.DST_MAC_ADDR_6=
RSPDriver.SRC_IP_ADDR_7=10.1.0.8
RSPDriver.DST_IP_ADDR_7=10.2.0.8
RSPDriver.DST_MAC_ADDR_7=
RSPDriver.SRC_IP_ADDR_8=10.1.0.9
RSPDriver.DST_IP_ADDR_8=10.2.0.9
RSPDriver.DST_MAC_ADDR_8=
RSPDriver.SRC_IP_ADDR_9=10.1.0.10
RSPDriver.DST_IP_ADDR_9=10.2.0.10
RSPDriver.DST_MAC_ADDR_9=
RSPDriver.SRC_IP_ADDR_10=10.1.0.11
RSPDriver.DST_IP_ADDR_10=10.2.0.11
RSPDriver.DST_MAC_ADDR_10=
RSPDriver.SRC_IP_ADDR_11=10.1.0.12
RSPDriver.DST_IP_ADDR_11=10.2.0.12
RSPDriver.DST_MAC_ADDR_11=
RSPDriver.SRC_IP_ADDR_12=10.1.0.13
RSPDriver.DST_IP_ADDR_12=10.2.0.13
RSPDriver.DST_MAC_ADDR_12=
RSPDriver.SRC_IP_ADDR_13=10.1.0.14
RSPDriver.DST_IP_ADDR_13=10.2.0.14
RSPDriver.DST_MAC_ADDR_13=
RSPDriver.SRC_IP_ADDR_14=10.1.0.15
RSPDriver.DST_IP_ADDR_14=10.2.0.15
RSPDriver.DST_MAC_ADDR_14=
RSPDriver.SRC_IP_ADDR_15=10.1.0.16
RSPDriver.DST_IP_ADDR_15=10.2.0.16
RSPDriver.DST_MAC_ADDR_15=
RSPDriver.SRC_IP_ADDR_16=10.1.0.17
RSPDriver.DST_IP_ADDR_16=10.2.0.17
RSPDriver.DST_MAC_ADDR_16=
RSPDriver.SRC_IP_ADDR_17=10.1.0.18
RSPDriver.DST_IP_ADDR_17=10.2.0.18
RSPDriver.DST_MAC_ADDR_17=
RSPDriver.SRC_IP_ADDR_18=10.1.0.19
RSPDriver.DST_IP_ADDR_18=10.2.0.19
RSPDriver.DST_MAC_ADDR_18=
RSPDriver.SRC_IP_ADDR_19=10.1.0.20
RSPDriver.DST_IP_ADDR_19=10.2.0.20
RSPDriver.DST_MAC_ADDR_19=
RSPDriver.SRC_IP_ADDR_20=10.1.0.21
RSPDriver.DST_IP_ADDR_20=10.2.0.21
RSPDriver.DST_MAC_ADDR_20=
RSPDriver.SRC_IP_ADDR_21=10.1.0.22
RSPDriver.DST_IP_ADDR_21=10.2.0.22
RSPDriver.DST_MAC_ADDR_21=
RSPDriver.SRC_IP_ADDR_22=10.1.0.23
RSPDriver.DST_IP_ADDR_22=10.2.0.23
RSPDriver.DST_MAC_ADDR_22=
RSPDriver.SRC_IP_ADDR_23=10.1.0.24
RSPDriver.DST_IP_ADDR_23=10.2.0.24
RSPDriver.DST_MAC_ADDR_23=

#
# Ethernet interface on which to contact the RSP boards.
# This interface would normally be connected to the switch.
#
RSPDriver.IF_NAME=eth1

#
# Make sure that initially the
# beamlet statistics match the subband statistics
#
RSPDriver.IDENTITY_WEIGHTS=1
RSPDriver.FIRST_SUBBAND=384

#
# Select LOOPBACK_MODE mode
#
# If LOOPBACK_MODE == 0, the WRITE is done first.
# In this mode the RSPDriver checks that what was
# written is correctly read back from the board. This can
# be used to check that the RSP board or the EPAStub
# functions correctly. Read results are not stored in
# the RSPDriver cache.
#
# If LOOPBACK_MODE == 1, the READ is done first.
# In this mode you can check with Ethereal that what was
# read from the RSP board or EPAStub is written back in
# the same way. This is used to check whether the RSPDriver
# stores the information at the correct location in its cache.
# Of course in this mode reads results are stored in the
# RSPDriver cache.
#
RSPDriver.LOOPBACK_MODE=0

#
# Enable/disable certain parts of the update cycle.
# The order of these config variables does not
# alter the order the update actions are performed.
#
RSPDriver.WRITE_RSU=1
RSPDriver.WRITE_BS=1
RSPDriver.WRITE_CDO=1
# WRITE_CDO_ONCE, if set to 1 only write CDO register once at startup
# otherwise rewrite same data every update (= second)
RSPDriver.WRITE_CDO_ONCE=0
# READ_CDO, if set to 1 reads back contents of pid=CDO, regid=0x01
# This can be used to verify that the UDP/IP header is correctly
# written to the register.
RSPDriver.READ_CDO=0
RSPDriver.READ_STATUS=1
RSPDriver.WRITE_BF=1
RSPDriver.WRITE_SS=1
RSPDriver.WRITE_RCU=1
RSPDriver.WRITE_RCU_PROTOCOL=1
RSPDriver.WRITE_HBA_PROTOCOL=0
RSPDriver.WRITE_TDS_PROTOCOL=1
RSPDriver.READ_SST=1
RSPDriver.READ_BST=1
RSPDriver.WRITE_WG=1
RSPDriver.WRITE_WG_WAVE=0
RSPDriver.READ_RCU_RESULT=1
RSPDriver.READ_HBA_RESULT=0
RSPDriver.READ_TDS_RESULT=1
RSPDriver.READ_VERSION=1
RSPDriver.READ_XST=1

#
# Optionally read RW-registers.
#
RSPDriver.READ_BF=0
RSPDriver.READ_SS=0
RSPDriver.READ_RCU=0
RSPDriver.READ_WG=0

#
# Specify which RSP board is first for cross correlation (indexing from 0)
#
# MAC address of first RSP board is 10:FA:00:00:13:00
# therefor the index of the first RSP board = 0x13 = 19 (decimal)
#
RSPDriver.XST_FIRST_RSP_BOARD=19

#
# Specify the default sampling frequency that should be programmed
# into the hardware when the driver starts.
# Currently allowed values are: 0 (off), 160 (MHz) and 200 (MHz)
#
RSPDriver.DEFAULT_SAMPLING_FREQUENCY=160

#
# Specify how the rspdriver should operate:
# 0: one RSP driver active --> control all boards
# 1: many RSP drivers active --> control boards -I<n> only
#
RSPDriver.OPERATION_MODE=0

