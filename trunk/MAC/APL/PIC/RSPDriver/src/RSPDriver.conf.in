#
# Configuration of the RSPDriver
#

#
# If SYNC_MODE=1 then sync will be generated by a software timer (rate controlled by SYNC_INTERVAL)
# If SYNC_MODE=2 then RSPDriver will run as fast as possible (to determine maximum update rate).
# If SYNC_MODE=3 then sync will be generated by PPS API on /dev/pps0
#
RSPDriver.SYNC_MODE=3

#
# SYNC_INTERVAL is only used when SYNC_MODE=1 to set the interval
# time of the timer.
#
RSPDriver.SYNC_INTERVAL=1.0

#
# PPS_DEVICE is only used when SYNC_MODE=3 to designate the PPS device
#
RSPDriver.PPS_DEVICE=/dev/oncore.pps.0

#
# Send signal to the RSP boards to simulate the arrival of
# a SYNC pulse (which normally comes with a frequency of 1Hz).
#
RSPDriver.SOFTPPS=0

#
# Delay the driver some number of microseconds after it receives the PPS tick
# this may be needed to synchronized the driver properly to the hardware
#
RSPDriver.PPS_DELAY=0

#
# PPS trigger is on ASSERT (1) or CLEAR (0)
#
RSPDriver.PPS_TRIGGER=1

#
# Specify MAC addresses of the RSP boards explicitly
#
RSPDriver.MAC_ADDR_0=10:FA:00:00:11:00
RSPDriver.MAC_ADDR_1=10:FA:00:00:12:00
RSPDriver.MAC_ADDR_2=10:FA:00:00:02:00
RSPDriver.MAC_ADDR_3=10:FA:00:00:03:00
RSPDriver.MAC_ADDR_4=10:FA:00:00:04:00
RSPDriver.MAC_ADDR_5=10:FA:00:00:05:00
RSPDriver.MAC_ADDR_6=10:FA:00:00:06:00
RSPDriver.MAC_ADDR_7=10:FA:00:00:07:00
RSPDriver.MAC_ADDR_8=10:FA:00:00:08:00
RSPDriver.MAC_ADDR_9=10:FA:00:00:09:00
RSPDriver.MAC_ADDR_10=10:FA:00:00:0A:00
RSPDriver.MAC_ADDR_11=10:FA:00:00:0B:00
RSPDriver.MAC_ADDR_12=10:FA:00:00:0C:00
RSPDriver.MAC_ADDR_13=10:FA:00:00:0D:00
RSPDriver.MAC_ADDR_14=10:FA:00:00:0E:00
RSPDriver.MAC_ADDR_15=10:FA:00:00:0F:00
RSPDriver.MAC_ADDR_16=10:FA:00:00:10:00
RSPDriver.MAC_ADDR_17=10:FA:00:00:11:00
RSPDriver.MAC_ADDR_18=10:FA:00:00:12:00
RSPDriver.MAC_ADDR_19=10:FA:00:00:13:00
RSPDriver.MAC_ADDR_20=10:FA:00:00:14:00
RSPDriver.MAC_ADDR_21=10:FA:00:00:15:00
RSPDriver.MAC_ADDR_22=10:FA:00:00:16:00
RSPDriver.MAC_ADDR_23=10:FA:00:00:17:00

#
# Serdes lane settings.
#
# Define the end of the four SERDES rings. The boards
# not defined as end of the lane will pass on their
# cross-correlation or beamlet data to the neighbour board.
#
# This also defines which RSP board will output data from which
# lane on its CDO port (CDO = CEP Data Output).
#
# Complete beamforming and cross-correlation data and statistics
# will be available on the last RSP board in a ring.
# All other boards in the ring will produce partial 
# data and statistics.
#
# Assuming the index of the last RSP board is N, then
# the ring starts at RSP board (N - 1) % N_RSPBOARDS
#
# Note: the specified RSP board index will be taken
# modulo N_RSPBOARDS to prevent out of range indices.
#
# Setting IGNORE_REMOTE_DATA to 1 will force all boards
# to ignore remote data. This can be used to check
# for difference between operation with data from SERDES
# ring and without.
#
RSPDriver.LANE_0_BLET_OUT=0
RSPDriver.LANE_1_BLET_OUT=1
RSPDriver.LANE_2_BLET_OUT=2
RSPDriver.LANE_3_BLET_OUT=3
RSPDriver.LANE_0_XLET_OUT=0
RSPDriver.LANE_1_XLET_OUT=1
RSPDriver.LANE_2_XLET_OUT=2
RSPDriver.LANE_3_XLET_OUT=3
RSPDriver.IGNORE_REMOTE_DATA=0

#
# CDO Control
# This controls the format of CEP output data from the serdes lane specified in
# the previous section.
#
# CDO_ENABLE=(0|1)   : when 0 disable output on all RSP boards
# CDO_N_BLOCKS=(N)   : Set number of blocks of N_BEAMLETS beamlets per output Ethernet frame
# CDO_N_BEAMLETS=(N) : Set number of beamlets to output in each block
# CDO_SRCMAC_FORMAT  : Template for the src mac address of the boards that output data to CEP
#   First %02x will be replaced by station id, second by RSP board index,
#   e.g. Station 14, RSP board 3 will be: 10:FA:00:0E:03:01
#
RSPDriver.CDO_ENABLE=1
RSPDriver.CDO_N_BLOCKS=16
RSPDriver.CDO_N_BEAMLETS=40
RSPDriver.CDO_SRCMAC_FORMAT=10:FA:00:%02x:01:%02x

# FTS-1
# RSPDriver.DST_MAC_ADDR_0=00:E0:81:31:DE:8A
# RSPDriver.DST_MAC_ADDR_1=00:E0:81:31:DF:D4
# CS-1
RSPDriver.DST_MAC_ADDR_0=00:E0:81:34:93:3B
RSPDriver.DST_MAC_ADDR_1=00:E0:81:34:93:3B
RSPDriver.DST_MAC_ADDR_2=00:E0:81:31:B0:E1
RSPDriver.DST_MAC_ADDR_3=00:E0:81:31:B2:F5
RSPDriver.DST_MAC_ADDR_4=00:E0:81:31:B2:F5
RSPDriver.DST_MAC_ADDR_5=00:E0:81:31:B2:F5
RSPDriver.DST_MAC_ADDR_6=00:E0:81:34:93:3B
RSPDriver.DST_MAC_ADDR_7=00:E0:81:34:93:3B
RSPDriver.DST_MAC_ADDR_8=00:E0:81:31:B0:E1
RSPDriver.DST_MAC_ADDR_9=00:E0:81:31:B0:E1
RSPDriver.DST_MAC_ADDR_10=00:E0:81:31:B2:F5
RSPDriver.DST_MAC_ADDR_11=00:E0:81:31:B2:F5

RSPDriver.SRC_IP_ADDR_0=10.10.0.1
RSPDriver.SRC_IP_ADDR_1=10.10.0.2
RSPDriver.SRC_IP_ADDR_2=10.10.0.3
RSPDriver.SRC_IP_ADDR_3=10.10.0.4
RSPDriver.SRC_IP_ADDR_4=10.10.0.5
RSPDriver.SRC_IP_ADDR_5=10.10.0.6
RSPDriver.SRC_IP_ADDR_6=10.10.0.7
RSPDriver.SRC_IP_ADDR_7=10.10.0.8
RSPDriver.SRC_IP_ADDR_8=10.10.0.9
RSPDriver.SRC_IP_ADDR_9=10.10.0.10
RSPDriver.SRC_IP_ADDR_10=10.10.0.11
RSPDriver.SRC_IP_ADDR_11=10.10.0.12

RSPDriver.DST_IP_ADDR_0=10.170.0.1
RSPDriver.DST_IP_ADDR_1=10.170.0.2
RSPDriver.DST_IP_ADDR_2=10.170.0.3
RSPDriver.DST_IP_ADDR_3=10.170.0.4
RSPDriver.DST_IP_ADDR_4=10.170.0.5
RSPDriver.DST_IP_ADDR_5=10.170.0.6
RSPDriver.DST_IP_ADDR_6=10.170.0.7
RSPDriver.DST_IP_ADDR_7=10.170.0.8
RSPDriver.DST_IP_ADDR_8=10.170.0.9
RSPDriver.DST_IP_ADDR_9=10.170.0.10
RSPDriver.DST_IP_ADDR_10=10.170.0.11
RSPDriver.DST_IP_ADDR_11=10.170.0.12

#
# Specify the absolute backplane index of the first
# RSP board in hexadecimal
#
# MAC address is equal to : 10:FA:00:00:XX:00
#
RSPDriver.XST_FIRST_RSP_BOARD=0x00

#
# Ethernet interface on which to contact the RSP boards.
# This interface would normally be connected to the switch.
#
RSPDriver.IF_NAME=eth1

#
# Make sure that initially the
# beamlet statistics match the subband statistics
#
RSPDriver.IDENTITY_WEIGHTS=1
RSPDriver.FIRST_SUBBAND=0

#
# Select LOOPBACK_MODE mode
#
# If LOOPBACK_MODE == 0, the WRITE is done first.
# In this mode the RSPDriver checks that what was
# written is correctly read back from the board. This can
# be used to check that the RSP board or the EPAStub
# functions correctly. Read results are not stored in
# the RSPDriver cache.
#
# If LOOPBACK_MODE == 1, the READ is done first.
# In this mode you can check with Ethereal that what was
# read from the RSP board or EPAStub is written back in
# the same way. This is used to check whether the RSPDriver
# stores the information at the correct location in its cache.
# Of course in this mode reads results are stored in the
# RSPDriver cache.
#
RSPDriver.LOOPBACK_MODE=0

#
# Enable/disable certain parts of the update cycle.
# The order of these config variables does not
# alter the order the update actions are performed.
#
RSPDriver.WRITE_RSU=1
RSPDriver.WRITE_BS=1
RSPDriver.WRITE_CDO=1
# READ_CDO, if set to 1 reads back contents of pid=CDO, regid=0x01
# This can be used to verify that the UDP/IP header is correctly
# written to the register.
RSPDriver.READ_CDO=0
RSPDriver.WRITE_RAD=1
RSPDriver.READ_STATUS=1
RSPDriver.WRITE_XBF=1
RSPDriver.WRITE_BF=1
RSPDriver.WRITE_SS=1
RSPDriver.WRITE_RCU=1
RSPDriver.WRITE_RCU_PROTOCOL=1
RSPDriver.WRITE_HBA_PROTOCOL=0
RSPDriver.READWRITE_TDS_PROTOCOL=1
RSPDriver.READ_SST=1
RSPDriver.READ_BST=1
RSPDriver.WRITE_WG=1
RSPDriver.WRITE_WG_WAVE=0
RSPDriver.READ_RCU_RESULT=1
RSPDriver.READ_HBA_RESULT=0
RSPDriver.READ_VERSION=1
RSPDriver.READ_XST=1
RSPDriver.WRITE_TIMESTAMP=1

#
# TDS_CONTROL
#
# 0x00111111 : Only first RSP board in each rack of the six racks
#              controls the TD-oard
#
RSPDriver.TDS_CONTROL=0x00111111

#
# Optionally read RW-registers.
#
RSPDriver.READ_BF=0
RSPDriver.READ_SS=0
RSPDriver.READ_RCU=0
RSPDriver.READ_WG=0

#
# Specify the default sampling frequency that should be programmed
# into the hardware when the driver starts.
# Currently allowed values are: 0 (off), 160 (MHz) and 200 (MHz)
#
RSPDriver.DEFAULT_SAMPLING_FREQUENCY=200

#
# Specify how the rspdriver should operate:
# 0: one RSP driver active --> control all boards
# 1: many RSP drivers active --> control boards -I<n> only
#
RSPDriver.OPERATION_MODE=0

#
# Set initial gain for beamforming and cross-correlation
#
RSPDriver.BF_GAIN=8000
RSPDriver.XC_GAIN=8000

#
# If set to 1 (true), then the cross-correlation array will
# be filled completely by copying the conjugate of a cross-correlation
# across the diagonal if a value equals zero.
#
RSPDriver.XC_FILL=1

#
# Disable initialization to enable testing on a system without hardware
#
RSPDriver.DISABLE_INIT=0
