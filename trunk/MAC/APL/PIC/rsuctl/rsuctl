#!/usr/bin/perl

#
# rsuctl # Remote System Update - program firmware in FPGA flash
#
# Usage: rsuctl [options] command
#
#   options
#     [-i ifname]      # Ethernet interface name on which to communicate (default is eth1)
#     [-m mac-address] # IP-address of the target board
#                      # (default is broadcast address FF:FF:FF:FF:FF:FF)
#
#   command (specify at least one of the following)
#     [-l] # List the images currently stored in all pages of the flash
#
#     [-b in.ttf -f out.bin]           # Convert a ttf file to a binary file
#     [-e -p page [-F]]                # Erase flash page, use -1 for all pages; 0 <= page < 16
#     [-x -p page                      # Start (load & reset) new firmware from the specified page
#     [-w -p page -f image[.ttf] [-F]] # Write img.bin into specified page (-F forces write to page 0)
#     [-v -p page -f image[.ttf]]      # Compare flash page with img.bin
#     [-d -p page -f dumpfile.bin]     # Dump flash page to dmp.bin
#
#     [-r] # Reset all FPGA's (load factory image)
#     [-c] # Clear all FPGA's (restart current image)
#     [-s] # Send SYNC pulse to all FPGA's
#     [-V] # Read RSU status and RSR versions
#     [-h] # This help text
#

use Net::RawIP;
use Getopt::Std;
use File::stat;
use Switch;
use POSIX; # for geteuid()

$g_debug  = 0;  # set to 1 to enable debug output
$g_packet = ''; # global packet string
$g_error  = 0;  # global error status 

#
# Definitions
#
$PID_RSR      = 0x01;
$PID_RSU      = 0x02;

$REG_STATUS       = 0x00;
$REG_STATUS_SIZE  = 200;
$REG_VERSION      = 0x01;
$REG_VERSION_SIZE = 2;

$REG_RW       = 0x01;
$REG_ERASE    = 0x02;
$REG_RECONFIG = 0x03;
$REG_CLEAR    = 0x04;

$CMD_ERASE = 0x01;

$CMD_SYNC  = 0x01;
$CMD_CLEAR = 0x02;
$CMD_RESET = 0x04;

$MEPHDRSIZE = 16;

$TYPE_READ     = 0x01;
$TYPE_WRITE    = 0x02;
$TYPE_READACK  = 0x03;
$TYPE_WRITEACK = 0x04;

$ADDR_BLP_NONE = 0x00;
$ADDR_RSP      = 0x01;

$FLASHSIZE         = 64 * 1024 * 1024; # 64MB
$BLOCKSIZE         = 1024; # block  = 1024 bytes
$BLOCKS_PER_SECTOR = 128;  # sector = 128 blocks
$SECTORS_PER_PAGE  = 32;   # page   = 32 sectors
$BLOCKS_PER_PAGE   = $BLOCKS_PER_SECTOR * $SECTORS_PER_PAGE;
$PAGES             = 16;
$PROGRESS_SIZE     = 32;

#
# pack format for the MEP message
# 
# C 0x10 Ethernet Type byte 0
# C 0xFA Ethernet Type byte 1
# C TYPE
# C STATUS
# S FRAMELENGTH
# C BLPID
# C RSP
# C PID
# C REGID
# S OFFSET
# S PAYLOAD_LENGTH
# S SEQ_NR
# S RESERVED
#
$MEPSENDFORMAT="CCCCSCCCCSSSS";
$MEPRECVFORMAT="H28CCSCCCCSSSS";

# ETHLEN = max length of Ethernet payload
$ETHLEN = 1500;

#
# Error code
#
%STATUS = ( 0 => "=== OK",
	    1 => "=== ERR unknown MEP message type",
	    2 => "=== ERR illegal BLP address",
	    3 => "=== ERR invalid PID",
	    4 => "=== ERR register does not exist",
	    5 => "=== ERR offset too large",
	    6 => "=== ERR message is too large",
	    7 => "=== ERR message corruption during RSP processing",
	    8 => "=== ERR message lost during RSP processing"
	    );

#
# usage
#
sub usage
{
    print STDERR <<END;

rsuctl # Remote System Update - program firmware in FPGA flash

Usage: rsuctl [options] command

  options
    [-i ifname]      # Ethernet interface name on which to communicate (default is eth1)
    [-m mac-address] # IP-address of the target board
                     # (default is broadcast address FF:FF:FF:FF:FF:FF)

  command (specify at least one of the following)
    [-l] # List the images currently stored in all pages of the flash

    [-b in.ttf -f out.bin]           # Convert a ttf file to a binary file
    [-e -p page [-F]]                # Erase flash page, use -1 for all pages; 0 <= page < 16
    [-x -p page                      # Start (load & reset) new firmware from the specified page
    [-w -p page -f image[.ttf] [-F]] # Write img.bin into specified page (-F forces write to page 0)
    [-v -p page -f image[.ttf]]      # Compare flash page with img.bin
    [-d -p page -f dumpfile.bin]     # Dump flash page to dmp.bin

    [-r] # Reset all FPGA's (load factory image)
    [-c] # Clear all FPGA's (restart current image)
    [-s] # Send SYNC pulse to all FPGA's
    [-V] # Read RSU status and RSR versions
    [-h] # This help text

END

    exit;
}

#
# pack_rsu($type, $regid, $size, $offset)
#
# Pack an RSU message
#
sub pack_rsu
{
    my ($type, $regid, $size, $offset) = @_;

    return pack($MEPSENDFORMAT,
		0x10, 0xFA, $type, 0x00, $MEPHDRSIZE + $size,
		$ADDR_BLP_NONE, $ADDR_RSP, $PID_RSU, $regid, $offset, $size, 0, 0);
}

#
# pcapcallback, save packet in $g_packet
#
# savepacket($handle, $hdr, $packet)
#
sub savepacket
{
    my ($handle, $hdr, $packet) = @_;
    $g_packet = $packet;
}

#
# ($payload,$error) = readresponse($pcap)
#
sub readresponse
{
    my ($pcap) = @_;

    my $error = 0;

    eval {
	use POSIX qw(SIGALRM);
	POSIX::sigaction(SIGALRM,
			 POSIX::SigAction->new(sub { die }))
	    || die "=== ERR error setting SIGALRM handler: $!\n";
	
	alarm 5;
	(0 == loop ($pcap, 1, \&savepacket, ''))
	    || die "=== ERR Failed to receive response";
	alarm 0;
    };
    if ($@) {
	$error = 1;
 	print STDERR "=== ERR timeout waiting for response, is the RSP board connected?\n";
	return ('', $error);
    }
    
    my ($ethdr, $type, $status, $framesize, $blp, $rsp, $pid, $regid, $offset, $size, $seqnr, $reserved) =
	unpack($MEPRECVFORMAT, $g_packet);

    if ($TYPE_WRITEACK != $type && $TYPE_READACK != $type) {
	$error = 1;
	print STDERR "=== ERR invalid message type: ", $type, "\n";
    }
    if ($PID_RSU != $pid && $PID_RSR != $pid) {
	$error = 1;
	print STDERR "=== ERR invalid pid: ", $pid, "\n";
    }

    printf STDERR "0x%s 0x%02x 0x%02x %5d 0x%02x 0x%02x 0x%02x 0x%02x %5d %5d %5d %5d\n",
    $ethdr, $type, $status, $framesize, $blp, $rsp, $pid, $regid, $offset, $size, $seqnr, $reserved if ($g_debug);

    if (0 != $status) {
	$error = 1;
	print STDERR "=== FATAL protocol error: status=", $STATUS{$status}, "\n";
	print STDERR "=== Are you using the correct Ethernet interface? Use -i argument to change, e.g. -i eth1\n";
	exit;
    }
    
    return (substr($g_packet, 14 + $MEPHDRSIZE), $error);
}

#
# flash($sock, $pcap, $flashpage, $blockinc, $msg, $cmd, $size, $writecb, $readcb, $image)
# page = -1 means all pages
#
sub flash
{
    my ($sock, $pcap, $flashpage, $blockinc, $msg, $cmd, $size, $writecb, $readcb, $image) = @_;

    if ($flashpage < 0) {
	$startpage = 0;
	$count = $PAGES;
    } else {
	$startpage = $flashpage;
	$count = 1;
    }
    
    # process pages
    my ($page);
    for ($page = $startpage; $page < $startpage + $count; $page++) {

	printf STDERR "=== %s page %02d\n", $msg, $page;
	print  STDERR "=== |" . ("-" x $SECTORS_PER_PAGE) . "|\n===  ";

	my ($success) = 1;
	# leave last block for directory entry
	my ($block);
	for ($block = 0; $block < $BLOCKS_PER_PAGE - 1; $block += $blockinc) {
	    
	    if ($writecb) {
		$packet  = pack_rsu($TYPE_WRITE, $cmd, $size,
				    ($page * $BLOCKS_PER_PAGE) + $block);
		$packet .= &$writecb($page, $block, $image);
	    
		$sock->send_eth_frame($packet);
		($payload, $error) = readresponse($pcap);
		return $error if $error;
	    }

	    if ($readcb) {
		$packet  = pack_rsu($TYPE_READ, $cmd, $size,
				    ($page * $BLOCKS_PER_PAGE) + $block);

		$sock->send_eth_frame($packet);
		($payload, $error) = readresponse($pcap);
		return $error if $error;

		$success = &$readcb($page, $block, $payload, $image) && $success;
	    }

	    if (0 == $block % $BLOCKS_PER_SECTOR) {
		if ($success) { print STDERR "."; }
		else          { print STDERR "X"; }
		$success = 1;
	    }
	}
	print STDERR "\n";
    }

    return 0;
}

#
# writedir($sock, $pcap, $page, $entry)
# Write the entry to the last block of page $page
#
sub writedir
{
    my ($sock, $pcap, $page, $entry) = @_;

    die "=== ERR internal error: size of direntry > $BLOCKSIZE" if (length($entry) > $BLOCKSIZE);

    print STDERR "writing dir @", (($page + 1) * $BLOCKS_PER_PAGE) - 1, "\n" if ($g_debug);

    # add zero padding if needed
    $entry .= pack("C", 0) x ($BLOCKSIZE - length($entry)) if (length($entry) < $BLOCKSIZE);

    # write last block with dir entry
    $packet  = pack_rsu($TYPE_WRITE, $REG_RW, $BLOCKSIZE,
			(($page + 1) * $BLOCKS_PER_PAGE) - 1);
    $packet .= $entry;

    my $error = 0;
    $sock->send_eth_frame($packet);
    ($result, $error) = readresponse($pcap);

    return $error;
}

#
# readdir($sock, $pcap, $page)
# Read the directory entry from the specified page
#
sub readdirentry
{
    my ($sock, $pcap, $page) = @_;

    my ($packet)  = pack_rsu($TYPE_READ, $REG_RW, $BLOCKSIZE,
			     (($page + 1) * $BLOCKS_PER_PAGE) -1);

    $sock->send_eth_frame($packet);

    my $error = 0;
    ($entry, $error) = readresponse($pcap);
    return ('', $error) if $error;

    $entry = '' if (substr($entry,0,1) eq pack("C", 0xff));

    return ($entry, $error);
}

#
# erasecb($page, $block, $image)
#
sub erasecb
{
    my ($page, $block, $image) = @_;

    print STDERR "erasecb: $page, $block\n" if ($g_debug);

    return pack("C", $CMD_ERASE);
}

#
# erase($sock, $pcap, $page)
# page = -1 means all pages
#
sub erase
{
    my ($sock, $pcap, $page) = @_;

    return flash($sock, $pcap, $page, $BLOCKS_PER_SECTOR,
		 "erasing", $REG_ERASE, 1,
		 \&erasecb, 0, '');
}

#
# Verify the data
#
sub verifycb
{
    my ($page, $block, $payload, $image) = @_;

    print STDERR "verifycb: page=$page, block=$block, length(payload)=", length($payload), "\n" if ($g_debug);

    my ($refblock) = substr($image, $block * $BLOCKSIZE, $BLOCKSIZE);

    # append zeroes to fill buffer to $BLOCKSIZE
    $refblock .= pack("C", 0) x ($BLOCKSIZE - length($refblock));

    if ($payload ne $refblock) {
	print STDERR "=== ERR failed to verify block $block in page $page\n" if ($g_debug);
	$g_error = 1;
	return 0;
    }

    return 1;
}

#
# verify($sock, $pcap, $page, $image)
#
sub verify
{
    my ($sock, $pcap, $page, $image) = @_;

    return flash($sock, $pcap, $page, 1,
		 "verifying", $REG_RW, $BLOCKSIZE,
		 0, \&verifycb, $image);
}

#
# Dump the data to file
#
sub dumpcb
{
    my ($page, $block, $payload, $image) = @_;

    print STDERR "dumpcb: page=$page, block=$block, length(payload)=", length($payload), "\n" if ($g_debug);

    print DUMPFILE $payload;

    return 1;
}

#
# dump($sock, $pcap, $page)
#
sub dump($$$)
{
    my ($sock, $pcap, $page) = @_;

    return flash($sock, $pcap, $page, 1,
		 "dumping", $REG_RW, $BLOCKSIZE,
		 0, \&dumpcb, '');
}

#
# Write the data
#
sub writepagecb
{
    my ($page, $block, $image) = @_;

    print STDERR "writepagecb: page=$page, block=$block\n" if ($g_debug);

    my ($data) = substr($image, $block * $BLOCKSIZE, $BLOCKSIZE);

    # append zeroes to fill buffer to $BLOCKSIZE
    $data .= pack("C", 0) x ($BLOCKSIZE - length($data));

    return $data;
}

#
# Read and verify the data
#
sub readpagecb
{
    my ($page, $block, $payload, $image) = @_;

    print STDERR "readpagecb: page=$page, block=$block, length(payload)=", length($payload), "\n" if ($g_debug);

    my ($refblock) = substr($image, $block * $BLOCKSIZE, $BLOCKSIZE);

    # append zeroes to fill buffer to $BLOCKSIZE
    $refblock .= pack("C", 0) x ($BLOCKSIZE - length($refblock));

    if ($payload ne $refblock) {
	print STDERR "=== ERR failed to verify block $block in page $page\n" if ($g_debug);
	$g_error = 1;
	return 0;
    }

    return 1;
}

#
# Create a direntry string based on filename
# direntry($filename)
#
sub formatentry
{
    my ($filename) = @_;

    $stat = stat($filename) || die "=== ERR failed to stat file '$filename'";
    $datetime = ctime($stat->mtime);
    chop($datetime);

    # return 'size YYYY mm dd hh:mm filename'
    return sprintf("%10d %s %s", $stat->size, $datetime, $filename);
}

#
# writepage($sock, $pcap, $page, $filename, $image)
#
sub writepage
{
    my ($sock, $pcap, $page, $filename, $image) = @_;

    $error = flash($sock, $pcap, $page, 1,
		   "writing and verifying", $REG_RW, $BLOCKSIZE,
		   \&writepagecb, \&readpagecb, $image);

    if (!$error) {
	$error = writedir($sock, $pcap, $page, formatentry($filename));
    } else {
	# clear entry, an error has occured
	writedir($sock, $pcap, $page, '');
    }

    return $error;
}

#
# Read entire ttffile into a string
# convert it to a binary string and
# return than string
#
# ttfread($filename)
#
sub fread
{
    my ($filename) = @_;
    local $/;
    
    # open input and output files
    open(TTFFILE, $filename) || die "=== ERR failed to open file '$filename'";
    $ttf = <TTFFILE>;
    close(TTFFILE);

    # replace \r\n, by spaces
    $ttf =~ tr/\r\n/ /;

    @bytes = split(/,/, $ttf);
    $result = '';
    foreach $byte (@bytes) {
	$result .= pack("C", $byte);
    }

    # return the binary string
    return $result;
}

#
# Read image from ttf or bin file. If filename ends in .ttf
# then the file is converted from ttf to bin format first.
#
# readimage($filename)
#
sub readimage
{
    my ($filename) = @_;
    local $/ = undef; # read entire file
    
    # open input and output files
    die "=== ERR no image file specified" if (!defined($filename));
    open(IMAGEFILE, $filename) || die "=== ERR failed to open file '$filename'";
    print STDERR "=== Reading '$filename'\n";
    $data = <IMAGEFILE>; # read entire file
    close(IMAGEFILE);

    @parts = split(/\./, $filename);
    if (@parts[-1] eq "ttf") {
	# replace \r\n, by spaces
	$data =~ tr/\r\n/ /;

	@bytes = split(/,/, $data);

	print STDERR "=== Converting '$filename' to binary\n";
	print STDERR "=== |" . ("-" x $PROGRESS_SIZE) . "|\n===  ";

	$i = 0;
	$interval = $#bytes / $PROGRESS_SIZE;
	$interval = 1 if ($interval < .5);

	$bindata = '';
	foreach $byte (@bytes) {
	    $bindata .= pack("C", $byte);

	    $i++;
	    print STDERR "." if (0 == $i % $interval);
	}

	print STDERR "\n";
	return $bindata;
    }

    return $data;
}

#
# Read RSU status from RSR status register
# readrsustatus($sock, $pcap)
#
sub readrsustatus
{
    my ($sock, $pcap) = @_;

    $size = $REG_STATUS_SIZE;
    $packet = pack($MEPSENDFORMAT,
		   0x10, 0xFA, $TYPE_READ, 0x00, $MEPHDRSIZE + $size,
		   $ADDR_BLP_NONE, $ADDR_RSP, $PID_RSR, $REG_STATUS, 0, $size, 0, 0);
    $sock->send_eth_frame($packet);
    my $error = 0;
    ($result, $error) = readresponse($pcap);
    return $error if $error;

    $rsustatus = unpack("C", substr($result, 164, 1));

    print STDERR sprintf("\nRSU Status:\n  rdy  : %s\n  err  : %s\n  fpga : %s\n  image: %s\n  trig : %s\n\n",
			 ('Configuration ongoing', 'Configuration done')[$rsustatus & 1],
			 ('Configuration successfull', 'Configuration error')[($rsustatus & 2) >> 1],
			 ('BP was reconfigured', 'AP was reconfigured')[($rsustatus & 4) >> 2],
			 ('Factory image', 'Application image')[($rsustatus & 8) >> 3],
			 ('Board reset', 'User reconfig', 'User reset', 'Watchdog')[($rsustatus >> 4) & 7]);

    return $error;
}

#
# Read versions of all FPGA's (handy after reconfig, reset, clear, etc)
# readversions($sock, $pcap)
#
sub readversions
{
    my ($sock, $pcap) = @_;

    # read BP version
    $size = $REG_VERSION_SIZE;
    $packet = pack($MEPSENDFORMAT,
		   0x10, 0xFA, $TYPE_READ, 0x00, $MEPHDRSIZE + $size,
		   $ADDR_BLP_NONE, $ADDR_RSP, $PID_RSR, $REG_VERSION, 0, $size, 0, 0);
    $sock->send_eth_frame($packet);
    my $error = 0;
    ($result, $error) = readresponse($pcap);
    return $error if $error;

    ($id, $version) = unpack("CC", $result);
    $maj = $version >> 4;
    $min = $version & 15;
    print STDERR "RSP   version: $id\nBP    version: $maj.$min\n";

    # read AP versions
    for ($ap = 0; $ap < 4; $ap++) {
	$packet = pack($MEPSENDFORMAT,
		       0x10, 0xFA, $TYPE_READ, 0x00, $MEPHDRSIZE + $size,
		       1 << $ap, 0, $PID_RSR, $REG_VERSION, 0, $size, 0, 0);
	$sock->send_eth_frame($packet);
	($result, $error) = readresponse($pcap);
	return $error if $error;

	($id, $version) = unpack("CC", $result);
	$maj = $version >> 4;
	$min = $version & 15;
	print STDERR "AP[$id] version: $maj.$min\n";
    }

    return 0;
}

#
# Reconfigure. Load new firmware from flash into FPGA's. After loading
# has finished, the FPGA will be reset and restart with new firmware.
#
# reconfig($sock, $pcap, $page)
#
sub reconfig
{
    my ($sock, $pcap, $page) = @_;

    $subpage = $page & 7;
    $fpga    = 1 - ($page >> 3);

    $cmd = ($fpga << 7) | $subpage;

    $packet  = pack_rsu($TYPE_WRITE, $REG_RECONFIG, 1, 0);
    $packet .= pack("C", $cmd);
	
    $sock->send_eth_frame($packet);
    ($response, $error) = readresponse($pcap);
    return $error if $error;
	
    print STDERR "=== waiting 5 seconds after reconfig\n";
    sleep 5;

    $error = readrsustatus($sock, $pcap);
    return $error if $error;
    $error = readversions($sock, $pcap);
    return $error if $error;
}

#
# Reset control for all FPGA's
#
# clearctl($sock, $pcap, $cmd)
# valid values for $cmd:  $CMD_SYNC, $CMD_CLEAR, $CMD_RESET
#
sub clearctl
{
    my ($sock, $pcap, $cmd) = @_;

    $packet  = pack_rsu($TYPE_WRITE, $REG_CLEAR, 1, 0);
    $packet .= pack("C", $cmd);
    
    $sock->send_eth_frame($packet);
    ($response, $error) = readresponse($pcap);

    return $error;
}

#
# Report result
# report($error)
#
sub report
{
    my ($error) = @_;

    if ($error || $g_error) { print STDERR "=== FAILED\n"; }
    else                    { print STDERR "=== OK\n";     }
}

#
# Change range of the page parameter
# chkpage($page)
#
sub chkpage
{
    my ($page) = @_;

    die "=== ERR no flash page specified, use -p" if (!defined($page));
    if ($page < 0 || $page >= $PAGES) {
	die "=== ERR invalid page index $page, should be >= 0 and < $PAGES";
    }
}

sub main
{
    my $sock = 0;

    Getopt::Std::getopts("i:m:lb:exwvdp:f:FrcsVh");

    # check that at least one argument is present
    usage() if ($opt_h);
    usage() unless ($opt_l || $opt_b || $opt_e || $opt_x || $opt_w || $opt_v ||
		    $opt_d || $opt_r || $opt_c || $opt_s || $opt_V || $opt_h);
    
    # assign default values
    $opt_i = 'eth1'              if !defined($opt_i);
    $opt_m = 'FF:FF:FF:FF:FF:FF' if !defined($opt_m);
    
    # Create socket to the boards
    if (!defined($opt_b)) {

	die "=== ERR this program needs to run as root to send/recv raw Ethernet frames" if (0 != geteuid());

	$sock = new Net::RawIP;
	$sock->ethnew($opt_i);
	$sock->ethset(dest => $opt_m);

	$TIMEOUT=5;
	$pcap = $sock->pcapinit($opt_i, "not ether dst $opt_m", $ETHLEN, $TIMEOUT);

	die "=== ERR could not open raw socket to RSP board(s) on $opt_i:$opt_m: $!\n" unless $sock;
	  
	print STDERR "=== connected to RSP board(s) on $opt_i:$opt_m\n";
    }

    if (defined($opt_l)) {

	($entry, $error) = readdirentry($sock, $pcap, 0);
	if (!$error) {
	    print STDERR sprintf("\nBP Factory: ", 0) . $entry . "\n";;
	    for ($page = 1; $page < $PAGES; $page++) {
		($entry, $error) = readdirentry($sock, $pcap, $page);
		break if $error;
		print STDERR sprintf("%s Page %2d: %s\n",
				     ($page < 8 ?'BP':'AP'), $page, $entry) if ($entry ne '');
	    }
	}
	report($error);
	
	return;
    }

    if (defined($opt_b)) {

	$image = readimage($opt_b);
	die "=== ERR no output file specified" if (!defined($opt_f));

	open(DUMPFILE, ">$opt_f") || die "=== ERR failed to open file '$opt_f' for writing\n";
	print DUMPFILE $image;
	close(DUMPFILE);
	report($error);

	return;
    }

    if (defined($opt_e)) {

	die "=== ERR erasing factory image (page 0) prohibited, use -F to force erase of factory image" if (!$opt_F && (0 == $opt_p));
	chkpage($opt_p);

	$error = erase($sock, $pcap, $opt_p);
	report($error);

	return;
    }
    if (defined($opt_x)) {

	chkpage($opt_p);
	$error = reconfig($sock, $pcap, $opt_p);
	report($error);

	return;
    }
    if (defined($opt_w)) {

	die "=== ERR writing to factory image (page 0) prohibited, use -F to force write to factory image" if (!$opt_F && (0 == $opt_p));
	chkpage($opt_p);

	$image = readimage($opt_f);
	$error = erase($sock, $pcap, $opt_p);
	$error = writepage($sock, $pcap, $opt_p, $opt_f, $image) if (!$error);
	report($error);

	return;
    }
    if (defined($opt_v)) {

	chkpage($opt_p);
	$image = readimage($opt_f);
	$error = verify($sock, $pcap, $opt_p, $image);
	report($error);

	return;
    }
    if (defined($opt_d)) {

	chkpage($opt_p);
	die "=== ERR no image file specified" if (!defined($opt_f));

	open(DUMPFILE, ">$opt_f") || die "=== ERR failed to open file '$opt_f' for writing\n";
	$error = dump($sock, $pcap, $opt_p);
	close(DUMPFILE);
	report($error);

	return;
    }
    if (defined($opt_r)) {

	clearctl($sock, $pcap, $CMD_RESET);
	print STDERR "=== waiting 5 seconds after reset\n";
	sleep 5;
	$error = readrsustatus($sock, $pcap);
	$error = readversions($sock, $pcap) if (!$error);
	report($error);

	return;
    }
    if (defined($opt_c)) {

	clearctl($sock, $pcap, $CMD_CLEAR);
	print STDERR "=== waiting 5 seconds after clear\n";
	sleep 5;
	$error = readrsustatus($sock, $pcap);
	$error = readversions($sock, $pcap) if (!$error);
	report($error);

	return;
    }
    if (defined($opt_s)) {

	$error = clearctl($sock, $pcap, $CMD_SYNC);
	report($error);

	return;
    }
    if (defined($opt_V)) {

	print STDERR "\n";
	$error = readrsustatus($sock, $pcap);
	$error = readversions($sock, $pcap) if (!$error);
	report($error);

	return;
    }

}

main();
