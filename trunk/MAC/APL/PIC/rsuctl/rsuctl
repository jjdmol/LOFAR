#!/usr/bin/perl

#
# rsuctl # Remote System Update - program firmware in FPGA flash
#
# Usage: rsuctl [options] command
#
#   options
#     [-i ifname]      # Ethernet interface name on which to communicate (default is eth1)
#     [-m mac-address] # IP-address of the target board
#                      # (default is broadcast address FF:FF:FF:FF:FF:FF)
#
#   command (specify at least one of the following)
#     [-l] # List the images currently stored in all pages of the flash
#
#     [-b -f in.ttf -o out.bin]        # Convert a ttf file to a binary file
#     [-e -p page [-F]]                # Erase flash page,  0 <= page < 16 (-F forces erase of page 0)
#     [-x -p page                      # Start (load & reset) new firmware from the specified page
#     [-w -p page -f image[.ttf] [-F]] # Write img.bin into specified page (-F forces write to page 0)
#     [-v -p page -f image[.ttf]]      # Compare flash page with img.bin
#     [-d -p page -f dumpfile.bin]     # Dump flash page to dmp.bin
#
#     [-r] # Reset all FPGA's (load factory image)
#     [-c] # Clear all FPGA's (restart current image)
#     [-s] # Send SYNC pulse to all FPGA's
#     [-V] # Read RSU status and RSR versions
#     [-h] # This help text
#

use Net::RawIP;
use Getopt::Std;
use File::stat;
use Switch;
use POSIX; # for geteuid()

$g_debug  = 0;  # set to 1 to enable debug output
$g_packet = ''; # global packet string
$g_error  = 0;  # global error status 

#
# Definitions
#
$PID_RSR      = 0x01;
$PID_RSU      = 0x02;

$REG_STATUS       = 0x00;
$REG_STATUS_SIZE  = 200;
$REG_VERSION      = 0x01;
$REG_VERSION_SIZE = 2;

$REG_RW       = 0x01;
$REG_ERASE    = 0x02;
$REG_RECONFIG = 0x03;
$REG_CLEAR    = 0x04;

$CMD_ERASE = 0x01;

$CMD_SYNC  = 0x01;
$CMD_CLEAR = 0x02;
$CMD_RESET = 0x04;

$MEPHDRSIZE = 16;

$TYPE_READ     = 0x01;
$TYPE_WRITE    = 0x02;
$TYPE_READACK  = 0x03;
$TYPE_WRITEACK = 0x04;

$ADDR_BLP_NONE = 0x00;
$ADDR_RSP      = 0x01;

$FLASHSIZE         = 64 * 1024 * 1024; # 64MB
$BLOCKSIZE         = 1024; # block  = 1024 bytes
$BLOCKS_PER_SECTOR = 128;  # sector = 128 blocks
$SECTORS_PER_PAGE  = 32;   # page   = 32 sectors
$BLOCKS_PER_PAGE   = $BLOCKS_PER_SECTOR * $SECTORS_PER_PAGE;
$PAGES             = 16;
$PROGRESS_SIZE     = 32;

$RESPONSETIMEOUT = 2;
$TO = 3;

#
# pack format for the MEP message
# 
# C 0x10 Ethernet Type byte 0
# C 0xFA Ethernet Type byte 1
# C TYPE
# C STATUS
# S FRAMELENGTH
# C BLPID
# C RSP
# C PID
# C REGID
# S OFFSET
# S PAYLOAD_LENGTH
# S SEQ_NR
# S RESERVED
#
$MEPSENDFORMAT="CCCCSCCCCSSSS";
$MEPRECVFORMAT="H28CCSCCCCSSSS";

# ETHLEN = max length of Ethernet payload
$ETHLEN = 1500;

#
# Error code
#
%STATUS = ( 0 => "=== OK",
	    1 => "=== ERR unknown MEP message type",
	    2 => "=== ERR illegal BLP address",
	    3 => "=== ERR invalid PID",
	    4 => "=== ERR register does not exist",
	    5 => "=== ERR offset too large",
	    6 => "=== ERR message is too large",
	    7 => "=== ERR message corruption during RSP processing",
	    8 => "=== ERR message lost during RSP processing"
	    );

#
# usage
#
sub usage
{
    print STDERR <<END;

rsuctl # Remote System Update - program firmware in FPGA flash

Usage: rsuctl [options] command

  options
    [-i ifname]      # Ethernet interface name on which to communicate (default is eth1)
    [-m mac-address] # IP-address of the target board
                     # (default is broadcast address FF:FF:FF:FF:FF:FF)

  command (specify at least one of the following)
    [-l] # List the images currently stored in all pages of the flash

    [-b -f in.ttf -o out.bin]        # Convert a ttf file to a binary file
    [-e -p page [-F]]                # Erase flash page, 0 <= page < 16 (-F forces erase of page 0)
    [-x -p page                      # Start (load & reset) new firmware from the specified page
    [-w -p page -f image[.ttf] [-F]] # Write img.bin into specified page (-F forces write to page 0)
    [-v -p page -f image[.ttf]]      # Compare flash page with img.bin
    [-d -p page -f dumpfile.bin]     # Dump flash page to dmp.bin

    [-r] # Reset all FPGA's (load factory image)
    [-c] # Clear all FPGA's (restart current image)
    [-s] # Send SYNC pulse to all FPGA's
    [-V] # Read RSU status and RSR versions
    [-h] # This help text

END

    exit;
}

#
# pack_rsu($type, $regid, $size, $offset)
#
# Pack an RSU message
#
sub pack_rsu
{
    my ($type, $regid, $size, $offset) = @_;

    return pack($MEPSENDFORMAT,
		0x10, 0xFA, $type, 0x00, $MEPHDRSIZE + $size,
		$ADDR_BLP_NONE, $ADDR_RSP, $PID_RSU, $regid, $offset, $size, 0, 0);
}

#
# pcapcallback, save packet in $g_packet
#
# savepacket($handle, $hdr, $packet)
#
sub savepacket
{
    my ($handle, $hdr, $packet) = @_;
    $g_packet = $packet;
}

#
# ($payload,$error) = readresponse($pcap)
#
sub readresponse
{
    my ($pcap) = @_;

    my $error = 0;

    eval {
	use POSIX qw(SIGALRM);
	POSIX::sigaction(SIGALRM,
			 POSIX::SigAction->new(sub { die }))
	    || die "=== ERR error setting SIGALRM handler: $!\n";
	
	alarm $RESPONSETIMEOUT;
	(0 == loop ($pcap, 1, \&savepacket, ''))
	    || die "=== ERR Failed to receive response";
	alarm 0;
    };
    if ($@) {
	$error = 1;
	return ('', $error);
    }
    
    my ($ethdr, $type, $status, $framesize, $blp, $rsp, $pid, $regid, $offset, $size, $seqnr, $reserved) =
	unpack($MEPRECVFORMAT, $g_packet);

    if ($TYPE_WRITEACK != $type && $TYPE_READACK != $type) {
	$error = 1;
	print STDERR "=== ERR invalid message type: ", $type, "\n";
    }
    if ($PID_RSU != $pid && $PID_RSR != $pid) {
	$error = 1;
	print STDERR "=== ERR invalid pid: ", $pid, "\n";
    }

    printf STDERR "0x%s 0x%02x 0x%02x %5d 0x%02x 0x%02x 0x%02x 0x%02x %5d %5d %5d %5d\n",
    $ethdr, $type, $status, $framesize, $blp, $rsp, $pid, $regid, $offset, $size, $seqnr, $reserved if ($g_debug);

    if (0 != $status) {
	$error = 1;
	print STDERR "=== FATAL protocol error: status=", $STATUS{$status}, "\n";
	print STDERR "=== Are you using the correct Ethernet interface? Use -i argument to change, e.g. -i eth1\n";
	exit;
    }
    
    return (substr($g_packet, 14 + $MEPHDRSIZE), $error);
}

#
# flash($sock, $pcap, $page, $blockinc, $msg, $cmd, $size, $writecb, $readcb, $image)
#
sub flash
{
    my ($sock, $pcap, $page, $blockinc, $msg, $cmd, $size, $writecb, $readcb, $image) = @_;
    
    printf STDERR "=== %s page %02d\n", $msg, $page;
    print  STDERR "=== |" . ("-" x $SECTORS_PER_PAGE) . "|\n===  ";
    
    my ($success) = 1;
    # leave last block for directory entry
    my ($block);
    for ($block = 0; $block < $BLOCKS_PER_PAGE - 1; $block += $blockinc) {
	
	if ($writecb) {
	    $packet  = pack_rsu($TYPE_WRITE, $cmd, $size,
				($page * $BLOCKS_PER_PAGE) + $block);
	    $packet .= &$writecb($page, $block, $image);
	    
	    $sock->send_eth_frame($packet);
	    ($payload, $error) = readresponse($pcap);
	    return $error if $error;
	}
	
	if ($readcb) {
	    $packet  = pack_rsu($TYPE_READ, $cmd, $size,
				($page * $BLOCKS_PER_PAGE) + $block);
	    
	    $sock->send_eth_frame($packet);
	    ($payload, $error) = readresponse($pcap);
	    return $error if $error;
	    
	    $success = &$readcb($page, $block, $payload, $image) && $success;
	}
	
	if (0 == $block % $BLOCKS_PER_SECTOR) {
	    if ($success) { print STDERR "."; }
	    else          { print STDERR "X"; }
	    $success = 1;
	}
    }
    print STDERR "\n";

    return 0;
}

#
# writedir($sock, $pcap, $page, $entry)
# Write the entry to the last block of page $page
#
sub writedir
{
    my ($sock, $pcap, $page, $entry) = @_;

    die "=== ERR internal error: size of direntry > $BLOCKSIZE" if (length($entry) > $BLOCKSIZE);

    print STDERR "writing dir @", (($page + 1) * $BLOCKS_PER_PAGE) - 1, "\n" if ($g_debug);

    # add zero padding if needed
    $entry .= pack("C", 0) x ($BLOCKSIZE - length($entry)) if (length($entry) < $BLOCKSIZE);

    # write last block with dir entry
    $packet  = pack_rsu($TYPE_WRITE, $REG_RW, $BLOCKSIZE,
			(($page + 1) * $BLOCKS_PER_PAGE) - 1);
    $packet .= $entry;

    my $error = 0;
    $sock->send_eth_frame($packet);
    ($result, $error) = readresponse($pcap);

    return $error;
}

#
# readdir($sock, $pcap, $page)
# Read the directory entry from the specified page
#
sub readdirentry
{
    my ($sock, $pcap, $page) = @_;

    my ($packet)  = pack_rsu($TYPE_READ, $REG_RW, $BLOCKSIZE,
			     (($page + 1) * $BLOCKS_PER_PAGE) -1);

    $sock->send_eth_frame($packet);

    my $error = 0;
    ($entry, $error) = readresponse($pcap);
    return ('', $error) if $error;

    $entry = '' if (substr($entry,0,1) eq pack("C", 0xff));

    return ($entry, $error);
}

#
# erasecb($page, $block, $image)
#
sub erasecb
{
    my ($page, $block, $image) = @_;

    print STDERR "erasecb: $page, $block\n" if ($g_debug);

    return pack("C", $CMD_ERASE);
}

#
# erase($sock, $pcap, $page)
# page = -1 means all pages
#
sub erase
{
    my ($sock, $pcap, $page) = @_;

    return flash($sock, $pcap, $page, $BLOCKS_PER_SECTOR,
		 "erasing", $REG_ERASE, 1,
		 \&erasecb, 0, '');
}

#
# Verify the data
#
sub verifycb
{
    my ($page, $block, $payload, $image) = @_;

    print STDERR "verifycb: page=$page, block=$block, length(payload)=", length($payload), "\n" if ($g_debug);

    my ($refblock) = substr($image, $block * $BLOCKSIZE, $BLOCKSIZE);

    # append zeroes to fill buffer to $BLOCKSIZE
    $refblock .= pack("C", 0) x ($BLOCKSIZE - length($refblock));

    if ($payload ne $refblock) {
	print STDERR "=== ERR failed to verify block $block in page $page\n" if ($g_debug);
	$g_error = 1;
	return 0;
    }

    return 1;
}

#
# verify($sock, $pcap, $page, $image)
#
sub verify
{
    my ($sock, $pcap, $page, $image) = @_;

    return flash($sock, $pcap, $page, 1,
		 "verifying", $REG_RW, $BLOCKSIZE,
		 0, \&verifycb, $image);
}

#
# Dump the data to file
#
sub dumpcb
{
    my ($page, $block, $payload, $image) = @_;

    print STDERR "dumpcb: page=$page, block=$block, length(payload)=", length($payload), "\n" if ($g_debug);

    print DUMPFILE $payload;

    return 1;
}

#
# dump($sock, $pcap, $page)
#
sub dump($$$)
{
    my ($sock, $pcap, $page) = @_;

    return flash($sock, $pcap, $page, 1,
		 "dumping", $REG_RW, $BLOCKSIZE,
		 0, \&dumpcb, '');
}

#
# Write the data
#
sub writepagecb
{
    my ($page, $block, $image) = @_;

    print STDERR "writepagecb: page=$page, block=$block\n" if ($g_debug);

    my ($data) = substr($image, $block * $BLOCKSIZE, $BLOCKSIZE);

    # append zeroes to fill buffer to $BLOCKSIZE
    $data .= pack("C", 0) x ($BLOCKSIZE - length($data));

    return $data;
}

#
# Read and verify the data
#
sub readpagecb
{
    my ($page, $block, $payload, $image) = @_;

    print STDERR "readpagecb: page=$page, block=$block, length(payload)=", length($payload), "\n" if ($g_debug);

    my ($refblock) = substr($image, $block * $BLOCKSIZE, $BLOCKSIZE);

    # append zeroes to fill buffer to $BLOCKSIZE
    $refblock .= pack("C", 0) x ($BLOCKSIZE - length($refblock));

    if ($payload ne $refblock) {
	print STDERR "=== ERR failed to verify block $block in page $page\n" if ($g_debug);
	$g_error = 1;
	return 0;
    }

    return 1;
}

#
# Create a direntry string based on filename
# direntry($filename)
#
sub formatentry
{
    my ($filename) = @_;

    $stat = stat($filename) || die "=== ERR failed to stat file '$filename'";
    $datetime = ctime($stat->mtime);
    chop($datetime);

    # return 'size YYYY mm dd hh:mm filename'
    return sprintf("%10d %s %s", $stat->size, $datetime, $filename);
}

#
# writepage($sock, $pcap, $page, $filename, $image)
#
sub writepage
{
    my ($sock, $pcap, $page, $filename, $image) = @_;

    $error = flash($sock, $pcap, $page, 1,
		   "writing and verifying", $REG_RW, $BLOCKSIZE,
		   \&writepagecb, \&readpagecb, $image);

    if (!$error) {
	$error = writedir($sock, $pcap, $page, formatentry($filename));
    } else {
	# clear entry, an error has occured
	writedir($sock, $pcap, $page, '');
    }

    return $error;
}

#
# Read entire ttffile into a string
# convert it to a binary string and
# return than string
#
# ttfread($filename)
#
sub fread
{
    my ($filename) = @_;
    local $/;
    
    # open input and output files
    open(TTFFILE, $filename) || die "=== ERR failed to open file '$filename'";
    $ttf = <TTFFILE>;
    close(TTFFILE);

    # replace \r\n, by spaces
    $ttf =~ tr/\r\n/ /;

    @bytes = split(/,/, $ttf);
    $result = '';
    foreach $byte (@bytes) {
	$result .= pack("C", $byte);
    }

    # return the binary string
    return $result;
}

#
# Read image from ttf or bin file. If filename ends in .ttf
# then the file is converted from ttf to bin format first.
#
# readimage($filename)
#
sub readimage
{
    my ($filename) = @_;
    local $/ = undef; # read entire file
    
    # open input and output files
    die "=== ERR no image file specified" if (!defined($filename));
    open(IMAGEFILE, $filename) || die "=== ERR failed to open file '$filename'";
    print STDERR "=== Reading '$filename'\n";
    $data = <IMAGEFILE>; # read entire file
    close(IMAGEFILE);

    @parts = split(/\./, $filename);
    if (@parts[-1] eq "ttf") {
	# replace \r\n, by spaces
	$data =~ tr/\r\n/ /;

	@bytes = split(/,/, $data);

	print STDERR "=== Converting '$filename' to binary\n";
	print STDERR "=== |" . ("-" x $PROGRESS_SIZE) . "|\n===  ";

	$i = 0;
	$interval = $#bytes / $PROGRESS_SIZE;
	$interval = 1 if ($interval < .5);

	$bindata = '';
	foreach $byte (@bytes) {
	    $bindata .= pack("C", $byte);

	    $i++;
	    print STDERR "." if (0 == $i % $interval);
	}

	print STDERR "\n";
	return $bindata;
    }

    return $data;
}

#
# Read RSU status from RSR status register
# readrsustatus($sock, $pcap)
#
sub readrsustatus
{
    my ($sock, $pcap) = @_;

    $size = $REG_STATUS_SIZE;
    $packet = pack($MEPSENDFORMAT,
		   0x10, 0xFA, $TYPE_READ, 0x00, $MEPHDRSIZE + $size,
		   $ADDR_BLP_NONE, $ADDR_RSP, $PID_RSR, $REG_STATUS, 0, $size, 0, 0);
    $sock->send_eth_frame($packet);
    my $error = 0;
    ($result, $error) = readresponse($pcap);
    return $error if $error;

    $rsustatus = unpack("C", substr($result, 164, 1));

    print STDERR sprintf("\nRSU Status:\n  rdy  : %s\n  err  : %s\n  fpga : %s\n  image: %s\n  trig : %s\n\n",
			 ('Configuration ongoing', 'Configuration done')[$rsustatus & 1],
			 ('Configuration successfull', 'Configuration error')[($rsustatus & 2) >> 1],
			 ('BP was reconfigured', 'AP was reconfigured')[($rsustatus & 4) >> 2],
			 ('Factory image', 'Application image')[($rsustatus & 8) >> 3],
			 ('Board reset', 'User reconfig', 'User reset', 'Watchdog')[($rsustatus >> 4) & 7]);

    return $error;
}

#
# Read versions of all FPGA's (handy after reconfig, reset, clear, etc)
# readversions($sock, $pcap)
#
sub readversions
{
    my ($sock, $pcap) = @_;

    # read BP version
    $size = $REG_VERSION_SIZE;
    $packet = pack($MEPSENDFORMAT,
		   0x10, 0xFA, $TYPE_READ, 0x00, $MEPHDRSIZE + $size,
		   $ADDR_BLP_NONE, $ADDR_RSP, $PID_RSR, $REG_VERSION, 0, $size, 0, 0);
    $sock->send_eth_frame($packet);
    my $error = 0;
    ($result, $error) = readresponse($pcap);
    return $error if $error;

    ($id, $version) = unpack("CC", $result);
    $maj = $version >> 4;
    $min = $version & 15;
    print STDERR "RSP   version: $id\nBP    version: $maj.$min\n";

    # read AP versions
    for ($ap = 0; $ap < 4; $ap++) {
	$packet = pack($MEPSENDFORMAT,
		       0x10, 0xFA, $TYPE_READ, 0x00, $MEPHDRSIZE + $size,
		       1 << $ap, 0, $PID_RSR, $REG_VERSION, 0, $size, 0, 0);
	$sock->send_eth_frame($packet);
	($result, $error) = readresponse($pcap);
	return $error if $error;

	($id, $version) = unpack("CC", $result);
	$maj = $version >> 4;
	$min = $version & 15;
	print STDERR "AP[$id] version: $maj.$min\n";
    }

    return 0;
}

#
# Reconfigure. Load new firmware from flash into FPGA's. After loading
# has finished, the FPGA will be reset and restart with new firmware.
#
# reconfig($sock, $pcap, $page)
#
sub reconfig
{
    my ($sock, $pcap, $page) = @_;

    $subpage = $page & 7;
    $fpga    = 1 - ($page >> 3);

    $cmd = ($fpga << 7) | $subpage;

    $packet  = pack_rsu($TYPE_WRITE, $REG_RECONFIG, 1, 0);
    $packet .= pack("C", $cmd);
	
    $sock->send_eth_frame($packet);
    ($response, $error) = readresponse($pcap);
    return $error;
}

#
# Reset control for all FPGA's
#
# clearctl($sock, $pcap, $cmd)
# valid values for $cmd:  $CMD_SYNC, $CMD_CLEAR, $CMD_RESET
#
sub clearctl
{
    my ($sock, $pcap, $cmd) = @_;

    $packet  = pack_rsu($TYPE_WRITE, $REG_CLEAR, 1, 0);
    $packet .= pack("C", $cmd);
    
    $sock->send_eth_frame($packet);
    ($response, $error) = readresponse($pcap);

    return $error;
}

#
# Report result
# report($error, $report_ok = false)
#
sub report
{
    my ($error, $report_ok) = @_;

    if ($error || $g_error) {
	print STDERR "=== FAILED\n";
	exit 1;
    }
    else {
	print STDERR "=== OK\n" if ($report_ok);
    }
}

#
# Change range of the page parameter
# chkpage($page)
#
sub chkpage
{
    my ($page) = @_;

    die "=== ERR no flash page specified, use -p" if (!defined($page));
    if ($page < 0 || $page >= $PAGES) {
	die "=== ERR invalid page index $page, should be >= 0 and < $PAGES";
    }
}

#
# Get rsu status and versions
# version_cmd($sock, $pcap)
#
sub version_cmd
{
    my ($sock, $pcap) = @_;

    $error = readrsustatus($sock, $pcap);
    $error = readversions($sock, $pcap) && $error;
    return $error;
}

sub main
{
    my $sock = 0;

    Getopt::Std::getopts("i:m:lbf:o:exwvdp:FrcsVh");

    # check that at least one argument is present
    usage() if ($opt_h);
    usage() unless ($opt_l || $opt_b || $opt_e || $opt_x || $opt_w || $opt_v ||
		    $opt_d || $opt_r || $opt_c || $opt_s || $opt_V || $opt_h);
    
    # assign default values
    $opt_i = 'eth1'              if !defined($opt_i);
    $opt_m = 'FF:FF:FF:FF:FF:FF' if !defined($opt_m);
    
    # Create socket to the boards
    if (!defined($opt_b)) {

	die "=== ERR this program needs to run as root to send/recv raw Ethernet frames" if (0 != geteuid());

	$sock = new Net::RawIP;
	$sock->ethnew($opt_i);
	$sock->ethset(dest => $opt_m);

	$TIMEOUT=5;
	$pcap = $sock->pcapinit($opt_i, "not ether dst $opt_m", $ETHLEN, $TIMEOUT);

	die "=== ERR could not open raw socket to RSP board(s) on $opt_i:$opt_m: $!\n" unless $sock;
	  
	print STDERR "=== connected to RSP board(s) on $opt_i:$opt_m\n";

	print STDERR "=== checking for running RSPDriver\n";
	($payload, $error) = readresponse($pcap);
	die "=== RSPDriver appears to be running, stop it first\n" if ($payload ne '');
    }

    if (defined($opt_l)) {

	# LIST IMAGES IN FLASH
	#
	# readdirentry for all pages

	print STDERR "\n";
	for ($page = 0; $page < $PAGES; $page++) {
	    ($entry, $error) = readdirentry($sock, $pcap, $page);
	    break if $error;
	    print STDERR sprintf("%s %s %2d: %s\n", ($page < 8 ?'BP':'AP'),
				 (0 == $page % 8 ? 'Factory':'Image  '),
				 $page, $entry) if ((0 == $page % 8) || $entry ne '');
	}
	print STDERR "\n";
	report($error, true);
	
	return;
    }

    if (defined($opt_b)) {
	
	# CONVERT TO BINARY
	#
	# readimage

	die "=== ERR no input file specified"  if (!defined($opt_f) || ($opt_f eq ""));
	die "=== ERR no output file specified" if (!defined($opt_o) || ($opt_o eq ""));
	$image = readimage($opt_f);

	open(DUMPFILE, ">$opt_o") || die "=== ERR failed to open file '$opt_o' for writing\n";
	print DUMPFILE $image;
	close(DUMPFILE);
	report($error, true);

	return;
    }

    if (defined($opt_e)) {

	# ERASE
	#
	# erase flash page

	die "=== ERR erasing factory image (page 0) prohibited, use -F to force erase of factory image" if (!$opt_F && (0 == $opt_p));
	chkpage($opt_p);

	report(erase($sock, $pcap, $opt_p), true);

	return;
    }
    if (defined($opt_x)) {

	# RECONFIG
	#
	# reconfig BP or AP
	# if BP wait $TO seconds
	# clear
	# wait $TO seconds
	# read rsustatus & version

	chkpage($opt_p);
	report(reconfig($sock, $pcap, $opt_p));
	if ($opt_p < 8) {
	    print STDERR "=== waiting $TO seconds after BP reconfig\n"; sleep $TO;
	}
	report(clearctl($sock, $pcap, $CMD_CLEAR));
	report($error) if $error;
	print STDERR "=== waiting $TO seconds after clear\n"; sleep $TO;
	$error = readrsustatus($sock, $pcap);
	$error = readversions($sock, $pcap) && $error;
	report($error, true);

	return;
    }
    if (defined($opt_w)) {

	# WRITE
	#
	# readimage
	# erase page
	# write & verify page

	die "=== ERR writing to factory image (page 0) prohibited, use -F to force write to factory image" if (!$opt_F && (0 == $opt_p));
	chkpage($opt_p);

	$image = readimage($opt_f);
	report(erase($sock, $pcap, $opt_p));
	report(writepage($sock, $pcap, $opt_p, $opt_f, $image), true);

	return;
    }
    if (defined($opt_v)) {

	# VERIFY
	#
	# readimage reference
	# verify flash page against reference

	chkpage($opt_p);
	$image = readimage($opt_f);
	report(verify($sock, $pcap, $opt_p, $image), true);

	return;
    }
    if (defined($opt_d)) {

	# DUMP
	#
	# dump flash page to file

	chkpage($opt_p);
	die "=== ERR no image file specified" if (!defined($opt_f));

	open(DUMPFILE, ">$opt_f") || die "=== ERR failed to open file '$opt_f' for writing\n";
	print STDERR "=== Dumping to file '$opt_f'\n";
	$error = dump($sock, $pcap, $opt_p);
	close(DUMPFILE);
	report($error, true);

	return;
    }
    if (defined($opt_r)) {
	
	# RESET
	#
	# send reset
	# wait $TO seconds
	# reconfigure AP's with page 8 (factory default for AP's)
	# if reconfig failed (this can happen when an invalid AP image was loaded previously)
	#   clear
	#   wait $TO second
	#   reconfig again
	# wait $TO second
	# send clear
	# wait $TO seconds
	# read rsustatus and versions

	report(clearctl($sock, $pcap, $CMD_RESET));
	print STDERR "=== waiting $TO seconds after reset\n"; sleep $TO;
	print STDERR "=== reconfiguring AP's with factory image (page 8)\n";
	$error = reconfig($sock, $pcap, 8);
	if ($error) {
	    print STDERR "=== reconfig failed, clearing and waiting $TO seconds\n"; sleep $TO;
	    report(clearctl($sock, $pcap, $CMD_CLEAR));
	    print STDERR "=== waiting $TO seconds after clear\n"; sleep $TO;
	    print STDERR "=== retry reconfig\n";
	    report(reconfig($sock, $pcap, 8));
	}
	print STDERR "=== waiting $TO second after AP reconfig\n"; sleep $TO;
	report(clearctl($sock, $pcap, $CMD_CLEAR));
	print STDERR "=== waiting $TO seconds after clear\n"; sleep $TO;
	report(version_cmd($sock, $pcap) && $error, true);

	return;
    }
    if (defined($opt_c)) {

	# CLEAR
	#
	# send clear
	# wait $TO seconds
	# read rsustatus and versions
	
	report(clearctl($sock, $pcap, $CMD_CLEAR));
	print STDERR "=== waiting $TO seconds after clear\n"; sleep $TO;
	report(version_cmd($sock, $pcap), true);

	return;
    }
    if (defined($opt_s)) {

	# SYNC
	#
	# send sync

	report(clearctl($sock, $pcap, $CMD_SYNC), true);

	return;
    }
    if (defined($opt_V)) {

	# VERSIONS
	#
	# read rsustatus and versions

	report(version_cmd($sock, $pcap), true);

	return;
    }

}

main();
