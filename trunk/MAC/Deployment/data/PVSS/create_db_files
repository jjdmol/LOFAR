#
# create_db_file : Creates files for generating the PVSS and OTDB contents
#
# Copyright (C) 2006
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Syntax: genDBbase modulename precompiled_headerfiles
#
# The generated files must be manually adjusted before they
# can be used by genDBcode.
#
# $Id$
#
VERSION="v1.0"

#
# SyntaxError msg
#
SyntaxError()
{
	Msg=$1

	[ -z "${Msg}" ] || echo "ERROR: ${Msg}"
	echo ""
	echo "Syntax: $(basename $0) [-d destdir] [-o observation] [-s station]"
	echo "Syntax: $(basename $0) [-d destdir] [-o observation] [-S]"
	echo "    destdir      Relative directory where the resultfiles are placed."
	echo "    observation  Name of an observation. When omitted the datapoints"
	echo "                 for the permanent software are generated."
	echo "    station      Name of the station. When omitted the datapoints"
	echo "                 for the main database are generated."
	echo ""
	exit 1
}

#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
cleanlist()
{
	cut -d"#" -f1 $1 | awk '{ if (NF > 0) print $0 }'
}

#
# concatfile filename
#
# concatinates all lines of the file
concatfile()
{
	cleanlist $1 | while read line rest
	do
		result=$result":"$line
		echo $result
	done | tail -1 | sed "s/^://"
}

#
# create_ring_station_list
#
create_ring_station_list()
{
	cleanlist ${RINGFILE} | while read ring
	do 
		cleanlist ${ring}Stations.list | awk -v RING=${ring} \
		'{ 
			print RING"_"$1 
		}'
	done	>>/tmp/rslist
	concatfile /tmp/rslist
	rm -f /tmp/rslist
}

#
# labelize somename
#
# Capitalizes the name preceding initial capitals with an _
labelize()
{
	echo $1 | sed "s/[A-Z][a-z]/_&/g" | sed "s/^_//" | sed "s/\./_/g" | \
		awk '{ print toupper($1) }'
}

#
# substitute_arm
#
# replaces all lines containing the marker @arm@ with the arm names
#
# syntax of the lines must be: dp dpt
#
substitute_arm()
{
	awk -v ARMLIST=${ARMLIST} '
	BEGIN {
		nrArms=split(ARMLIST, armname, ":");
	};
	{
		hasArm=index($1,"@arm@");
		if (hasArm > 0) {
			for (arm in armname) {
				dpname=$1;
				sub("@arm@", armname[arm], dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_cluster
#
# syntax of the lines must be: dp dpt
#
substitute_cluster()
{
	awk -v CLUSTERLIST=${CLUSTERLIST} '
	BEGIN {
		nrClusters=split(CLUSTERLIST, clustername, ":");
	};
	{
		hasCluster=index($1,"@cluster@");
		if (hasCluster > 0) {
			for (cluster in clustername) {
				dpname=$1;
				sub("@cluster@", clustername[cluster], dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_cluster_node
#
# syntax of the lines must be: dp dpt
#
substitute_cluster_node()
{
	while read dp dpt
	do
		echo $dp | grep -s '@cluster@_@node@' >/dev/null
		if [ $? -eq 0 ]; then
			cleanlist $CLUSTERFILE | while read cluster nodename count
			do
				echo "$cluster	$nodename	$count" | awk -v dp=$dp -v dpt=$dpt '{
				for (nodenr = 1; nodenr <= $3; nodenr++) {
					dpcopy=dp;
					replacename=sprintf("%s_%s%03d", $1,  $2, nodenr);
					sub("@cluster@_@node@", replacename, dpcopy);
					print dpcopy"	"dpt;
				}
			}'
			done
		else
			echo "$dp	$dpt"
		fi
	done
}

#
# substitute_Cabinet_SubRack_RSPBoard
#
# syntax of the lines must be: dp dpt
#
substitute_Cabinet_SubRack_RSPBoard()
{
	awk -v nrBoards=${NRRSPBOARDS} '
	{
		hasCabSubBoard=index($1,"@cabinet@_@subrack@_@RSPBoard@");
		if (hasCabSubBoard > 0) {
			for (board=0; board<nrBoards; board++) {
				dpname=$1;
				cabinet=int(board/8)
				subrack=int(board/4)
				sub("@cabinet@_@subrack@_@RSPBoard@", "Cabinet"cabinet"_Subrack"subrack"_RSPBoard"board, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_Cabinet_SubRack
#
# syntax of the lines must be: dp dpt
#
substitute_Cabinet_SubRack()
{
	awk -v nrBoards=${NRRSPBOARDS} '
	{
		hasCabSub=index($1,"@cabinet@_@subrack@");
		if (hasCabSub > 0) {
			for (subrack=0; subrack<int(nrBoards/4); subrack++) {
				dpname=$1;
				cabinet=int(subrack/2)
				sub("@cabinet@_@subrack@", "Cabinet"cabinet"_Subrack"subrack, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_Cabinet
#
# syntax of the lines must be: dp dpt
#
substitute_Cabinet()
{
	awk -v nrBoards=${NRRSPBOARDS} '
	{
		hasCabinet=index($1,"@cabinet@");
		if (hasCabinet > 0) {
			for (cabinet=0; cabinet<int(nrBoards/8); cabinet++) {
				dpname=$1;
				sub("@cabinet@", "Cabinet"cabinet, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_ring_station
#
# replaces all lines containing the marker @ring@_@station@ with the ring_names
# and stationnames
#
# syntax of the lines must be: dp dpt
#
substitute_ring_station()
{
	awk -v RINGSTATIONLIST=${RINGSTATIONLIST} '
	BEGIN {
		nrRings=split(RINGSTATIONLIST, ringname, ":");
	};
	{
		hasRing=index($1,"@ring@_@station@");
		if (hasRing > 0) {
			for (ring in ringname) {
				dpname=$1;
				sub("@ring@_@station@", ringname[ring], dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_ring
#
# replaces all lines containing the marker @ring@ with the ring_names
#
# syntax of the lines must be: dp dpt
#
substitute_ring()
{
	awk -v RINGLIST=${RINGLIST} '
	BEGIN {
		nrRings=split(RINGLIST, ringname, ":");
	};
	{
		hasRing=index($1,"@ring@");
		if (hasRing > 0) {
			for (ring in ringname) {
				dpname=$1;
				sub("@ring@", ringname[ring], dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_observation
#
# syntax of the lines must be: dp dpt
#
substitute_observation()
{
	while read dp dpt
	do
		if [ -n "$OBSNAME" ]; then
			echo $dp"	"$dpt | awk -v obsname=$OBSNAME '{
				hasObs=index($1,"@observation@");
				if (hasObs > 0) {
					dpname=$1;
					sub("@observation@", obsname, dpname)
					print dpname"	"$2;
				}
				else {
					print $1"	"$2;
				}
			} '
		else
			echo $dp"	"$dpt
		fi
	done
}

#
# substitute_instancenr
#
# replaces all lines containing the marker @instancenr@ with the instancenr
#
# syntax of the lines must be: dp dpt
#
substitute_instancenr()
{
	awk '
	{
		sub("@instance@", "", $1);
		print $1"	"$2;
	} '
}

#
# number_dps
#
# add datapoint number to dplines
#
number_dps()
{
	awk '
	BEGIN {
		count = 1000;
	};
	{
		print $1"	"$2"	"count;
		count+=1;
	} '
}

#
# create_dpt_file inputfile dbtype dptype
#
create_dpt_file()
{
	rm -f ${ERRORFILE}

	(
		echo -n "# This file was generated by $(basename $0) ${VERSION} on " ; date
		echo	""
	) >${DESTDIR}/${DPT_FILE}

	cleanlist $1 | while read dpt prefix dbtype dptype dp
	do
		if [ "${dbtype}" != "$2" -o "${dptype}" != "$3" ]; then
			continue
		fi

		if [ ! -f ${dpt}.dpdef ]; then
			echo "TypeName"
			echo "${dpt}.${dpt}	1#1"
			echo "	state	25#2"
			if [ ${prefix} != "-" ]; then
				echo "No definition file for ${dpt}" >> ${ERRORFILE}
				echo "	error	25#3"
			fi
		else
			echo "TypeName"
			echo "${dpt}.${dpt}	1#1"
			echo "	state	25#2"
			echo "	error	25#3"
			let count=4
			let depth=1
			oldnode=""
			cleanlist ${dpt}.dpdef | awk -v elemNr=$count ' 
				BEGIN {  
					PVSStype["string"]	 = "25"
					PVSStype["bool"]	 = "23"
					PVSStype["uint"]	 = "20"
					PVSStype["int"]		 = "21"
					PVSStype["float"]	 = "22"
					PVSStype["double"]	 = "22"
					PVSStype["stringArr"]= "9"
					PVSStype["boolArr"]	 = "7"
					PVSStype["uintArr"]	 = "4"
					PVSStype["intArr"]	 = "5"
					PVSStype["floatArr"] = "6"
					PVSStype["doubleArr"]= "6"
					tabs="										"
					oldnode[1]=""
					prevlevel=0
				} 
				{
					nodename = $1
					level = 0
					do {
						dotpos=index(nodename,".");
						if (dotpos > 0) {
							level++;
							newnode[level]=substr(nodename,0,dotpos-1);
							nodename = substr(nodename,dotpos+1);
							dotpos   = index(nodename,".");
						}
					} while (dotpos > 0);
					
					if (newnode[level] != oldnode[level]) {
						print substr(tabs, 0, level) newnode[level]"	1#"elemNr;
						elemNr++;
						oldnode[level] = newnode[level];
					}
					print substr(tabs, 0, level+1) nodename"	"PVSStype[$2]"#"elemNr
					elemNr++;

					if (level < prevlevel) {
						for (l = prevlevel; l > level; l--) {
							oldnode[l]=""
						}
					}
					prevlevel = level;
				}'
		fi
		echo ""
	done >>${DESTDIR}/${DPT_FILE}
	echo "created: ${DESTDIR}/${DPT_FILE}"

	if [ -f ${ERRORFILE} ]; then
		echo "ERRORS During creation:"
		cat ${ERRORFILE}
		rm -f ${ERRORFILE}
	fi
}

#
# create_dp_file inputfile dbtype dptype
#
create_dp_file()
{
	(
		echo -n "# This file was generated by $(basename $0) ${VERSION} on " ; date
		echo	""
		echo    "DpName	TypeName	ID"
	) >${DESTDIR}/${DP_FILE}

	cleanlist $1 | awk -v dbtype=$2 -v dptype=$3 '{ 
		if ($3 == dbtype && $4 == dptype) {
			print $5"	"$1	
		} }' | \
				substitute_ring_station  | \
				substitute_ring | \
				substitute_arm | \
				substitute_Cabinet_SubRack_RSPBoard | \
				substitute_Cabinet_SubRack | \
				substitute_Cabinet | \
				substitute_cluster_node | \
				substitute_cluster | \
				substitute_observation | \
				substitute_instancenr | \
				sort -k1,1 |\
				number_dps >>${DESTDIR}/${DP_FILE}

	echo "created: ${DESTDIR}/${DP_FILE}"
}

#
# create_cpp_headerfile inputfile dbtype dptype
#
create_cpp_headerfile()
{
	cleanlist $1 | while read dpt prefix dbtype dptype dp
	do
		if [ "${dbtype}" != "$2" -o "${dptype}" != "$3" ]; then
			continue
		fi

		if [ $prefix != "-" ]; then
			label=`labelize ${dpt}`
			echo "// $dpt"
			echo "#define PSN_${label}	\"${dp}\""
			echo "#define PST_${label}	\"${dpt}\""
			if [ -f ${dpt}.dpdef ]; then
				cleanlist ${dpt}.dpdef | while read varname vartype
				do
					varlabel=`labelize ${varname}`
					echo "#define PN_${prefix}_${varlabel}	\"${varname}\""
				done
			fi
			echo ""
		fi
	done >>${DESTDIR}/${CPP_HEADERFILE}
}


#------------------------------ MAIN program ------------------------------
#
# Syntax: create_db_files [-d destdir] [-o observation] [-s station]
#

# setup defaults
DESTDIR="."
DPTYPENAME=Perm
DPTYPE=P
OBSNAME=""
DBTYPENAME=Main
DBTYPE=C
STNNAME="Station"

eval set argv=`getopt "d:o:s:Sh" $*`		# reformat arguments
shift
while [ "$1" != "--" ]
do
	case "$1" in
		-d)	DESTDIR=$2
			[ -d ${DESTDIR} ] ||
				SyntaxError "Destination directory >${DESTDIR}< does not exist"
			shift 2
			;;
		-o) OBSNAME=$2
			DPTYPENAME=Obs
			DPTYPE=O
			shift 2
			;;
		-s) STNNAME=$2
			DBTYPENAME=$2
			DBTYPE=S
			shift 2
			;;
		-S) DBTYPENAME=Station
			DBTYPE=S
			shift 1
			;;
		-h) SyntaxError
			;;
	esac
done
shift				# remove '--'


# define the input files
ARMFILE=Arms.list
BOARDFILE=RSPBoards.list
CLUSTERFILE=Clusters.list
RINGFILE=Rings.list
ERRORFILE=/tmp/Crea.Error
INPUTFILE=./PVSSDataPoints.base

# define the output files
CPP_HEADERFILE=${DBTYPENAME}${DPTYPENAME}DatapointDefs.h
DP_FILE=${DBTYPENAME}${DPTYPENAME}Datapoints.dpl
DPT_FILE=${DBTYPENAME}${DPTYPENAME}Datapointtypes.dpl

# construct some lists
ARMLIST=`concatfile $ARMFILE`
CLUSTERLIST=`concatfile $CLUSTERFILE`
RINGLIST=`concatfile $RINGFILE`
RINGSTATIONLIST=`create_ring_station_list`
NRRSPBOARDS=`grep -s ${STNNAME} ${BOARDFILE} | awk '{ print $2 }'`

# create the desired files
create_dpt_file ${INPUTFILE} ${DBTYPE} ${DPTYPE}
create_dp_file  ${INPUTFILE} ${DBTYPE} ${DPTYPE}
(
	echo -n "// This file was generated by $(basename $0) ${VERSION} on " ; date
	echo	""
) >${DESTDIR}/${CPP_HEADERFILE}
create_cpp_headerfile ${INPUTFILE} ${DBTYPE} ${DPTYPE}
echo "created: ${DESTDIR}/${CPP_HEADERFILE}"
mkdir -p ../../../../installed/gnu_debug/include/Deployment/
cp ${DESTDIR}/${CPP_HEADERFILE} ../../../../installed/gnu_debug/include/Deployment/


