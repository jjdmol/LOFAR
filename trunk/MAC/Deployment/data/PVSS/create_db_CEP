#
# create_db_file : Creates files for generating the PVSS and OTDB contents
#
# Copyright (C) 2006
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Syntax: genDBbase modulename precompiled_headerfiles
#
# The generated files must be manually adjusted before they
# can be used by genDBcode.
#
# $Id: create_db_files 12424 2009-01-12 13:29:18Z coolen $
#
VERSION="v1.0"

#
# SyntaxError msg
#
SyntaxError()
{
	Msg=$1

	[ -z "${Msg}" ] || echo "ERROR: ${Msg}"
	echo ""
	echo "Syntax: $(basename $0) [-d destdir] [-o observation] [-s station]"
	echo "Syntax: $(basename $0) [-d destdir] [-o observation] [-S]"
	echo "    destdir      Relative directory where the resultfiles are placed."
	echo "    observation  Name of an observation. When omitted the datapoints"
	echo "                 for the permanent software are generated."
	echo "    station      Name of the station. When omitted the datapoints"
	echo "                 for the main & CEP database are generated."
	echo ""
	exit 1
}

#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
cleanlist()
{
	cut -d"#" -f1 $1 | awk '{ if (NF > 0) print $0 }'
}

#
# concatfile filename
#
# concatinates all lines of the file
concatfile()
{
	cleanlist $1 | while read line rest
	do
		result=$result":"$line
		echo $result
	done | tail -1 | sed "s/^://"
}

#
# create_ring_station_list
#
create_ring_station_list()
{
	# stationname ID stationType ...
	cleanlist ${STATIONINFOFILE} | awk '{ 
		if ($3 == "C") {
			print "Core_"$1
		}
		else if ($3 == "R") {
			print "Remote_"$1
		}
		else {
			print "Europe_"$1
		}
	} ' >>/tmp/rslist
	concatfile /tmp/rslist
	rm -f /tmp/rslist
}

#
# create_wan_switch_list
#
create_wan_switch_list()
{
	cleanlist ${WANFILE} | while read wan
	do 
		cleanlist ${wan}Wan.list | awk -v WAN=${wan} \
		'{ 
			print WAN"_"$1 
		}'
	done	>>/tmp/wslist
	concatfile /tmp/wslist
	rm -f /tmp/wslist
}

#
# labelize somename
#
# Capitalizes the name preceding initial capitals with an _
labelize()
{
	echo $1 | sed "s/[A-Z][a-z]/_&/g" | sed "s/^_//" | sed "s/\./_/g" | \
		awk '{ print toupper($1) }'
}

#
# substitute_adder
#
# syntax of the lines must be: dp dpt
#
substitute_adder()
{
	awk '
	{
		hasAdder=index($1,"@adder@");
		if (hasAdder > 0) {
			for (adNr = 0; adNr < 128; adNr++) {  
				printf "Adder%d	%s\n", adNr, $2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

substitute_inputbuffer()
{
	awk '
	{
		hasInputBuffer=index($1,"@inputbuffer@");
		if (hasInputBuffer > 0) {
			for (ibNr = 0; ibNr < 128; ibNr++) {  
				printf "InputBuffer%d	%s\n", ibNr, $2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_BGP
#
# syntax of the lines must be: dp dpt
#
substitute_BGP()
{
	awk '
	{
		hasBGP=index($1,"@bgp@");
		if (hasBGP > 0) {
			for (bgp=0; bgp<2; bgp++) {
				dpname=$1;
				sub("@bgp@", "BGP"bgp, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}


#
# substitute_BGP_midplane
#
# syntax of the lines must be: dp dpt
#
substitute_BGP_midplane()
{
	awk '
	{
		hasBGPMid=index($1,"@bgp@_@midplane@");
		if (hasBGPMid > 0) {
			for (midplane=0; midplane<4; midplane++) {
				dpname=$1;
				bgp=int(midplane/2)
				sub("@bgp@_@midplane@", "BGP"bgp"_Midplane"midplane, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}


#
# substitute_BGP_midplane_ionode
#
# syntax of the lines must be: dp dpt
#
substitute_BGP_midplane_ionode()
{
	awk  '
	{
		hasBGPMidIONode=index($1,"@bgp@_@midplane@_@ionode@");
		if (hasBGPMidIONode > 0) {
			for (ionode=0; ionode<128; ionode++) {
				dpname=$1;
				bgp=int(ionode/64)
				midplane=int(ionode/32)
				sub("@bgp@_@midplane@_@ionode@", "BGP"bgp"_Midplane"midplane"_IONode"ionode, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_osrack
#
# syntax of the lines must be: dp dpt
#
substitute_osrack()
{
	awk '
	{
		hasOSRack=index($1,"@osrack@");
		if (hasOSRack > 0) {
			for (osr=0; osr<4; osr++) {
				dpname=$1;
				sub("@osrack@", "OSRack"osr, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_osrack_ossubcluster
#
# syntax of the lines must be: dp dpt
#
substitute_osrack_ossubcluster()
{
	awk '
	{
		hasOSRSub=index($1,"@osrack@_@ossubcluster@");
		if (hasOSRSub > 0) {
			for (osrsub=0; osrsub<8; osrsub++) {
				dpname=$1;
				osrack=int(osrsub/2)
				sub("@osrack@_@ossubcluster@", "OSRack"osrack"_OSSubcluster"osrsub, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_osrack_ossubcluster_offlinenode
#
# syntax of the lines must be: dp dpt
#
substitute_osrack_ossubcluster_offlinenode()
{
	awk  '
	{
		hasOSRSubOff=index($1,"@osrack@_@ossubcluster@_@offlinenode@");
		if (hasOSRSubOff > 0) {
			for (offnode=0; offnode<128; offnode++) {
				dpname=$1;
				osrack=int(offnode/18)
				ossub=int(offnode/9)
				sub("@osrack@_@ossubcluster@_@offlinenode@", "OSRack"osrack"_OSSubcluster"ossub"_OfflineNode"offnode, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# substitute_osrack_ossubcluster_storagenode
#
# syntax of the lines must be: dp dpt
#
substitute_osrack_ossubcluster_storagenode()
{
	awk  '
	{
		hasOSRSubStor=index($1,"@osrack@_@ossubcluster@_@storagenode@");
		if (hasOSRSubStor > 0) {
			for (stornode=0; stornode<128; stornode++) {
				dpname=$1;
				osrack=int(stornode/6)
				ossub=int(stornode/3)
				sub("@osrack@_@ossubcluster@_@storagenode@", "OSRack"osrack"_OSSubcluster"ossub"_StorageNode"stornode, dpname)
				print dpname"	"$2;
			}
		}
		else {
			print $1"	"$2;
		}
	} '
}

#
# number_dps
#
# add action & datapoint number to dplines
# 
number_dps()
{
	awk '
	BEGIN {
		count = 1000;
	};
	{
		print $1"	"$2"	"count;
		count+=1;
	} '
}

#
# create_dpt_file inputfile dbtype
#
create_dpt_file()
{
	rm -f ${ERRORFILE}

	(
		echo -n "# This file was generated by $(basename $0) ${VERSION} on " ; date
		echo	""
		cat PVSSbase.dpdef
	) >${DESTDIR}/${DPT_FILE}

	prevdpt="abc"
	cleanlist $1 | sort | while read dpt prefix dbtype dptype leaf dp
	do
		if [ "${dbtype}" != "$2" ]; then
			continue
		fi

		if [ "${prevdpt}" == "${dpt}" ]; then
			continue
		fi
		prevdpt=${dpt}

		# create PVSStypes
		echo "TypeName"
		echo "${dpt}.${dpt}	1#1"
		let count=2
		# DPs in the LOFAR tree need an ObjectStatus element
		if [ "LOFAR${dp#LOFAR}" == "${dp}" ];then
			echo "	status	41#2:ObjectStatus"
			let count=count+1
		fi
		# Adder and InputBuffer need an ObjectStatus && ProcessStatus element
		if [ "${dpt}" == "Adder" ];then
			echo "	status	41#2:ObjectStatus"
		  	echo "	process	41#3:ProcessStatus"
			let count=count+2
		fi

		if [ "${dpt}" == "InputBuffer" ];then
			echo "	status	41#2:ObjectStatus"
		  	echo "	process	41#3:ProcessStatus"
			let count=count+2
		fi


		echo $dp | grep 'SW_' 2>&1 1>/dev/null
		if [ $? = 0 ]; then
			if [ ! -f ${dpt}.dpdef ]; then
				echo "No definition file for ${dpt}" >> ${ERRORFILE}
			fi
			if [ "${dpt}" != "CEPObservation" ]; then
			  echo "	process	41#3:ProcessStatus"
			  let count=count+1
			fi
		fi

		if [ -f ${dpt}.dpdef ]; then
			let depth=1
			oldnode=""
			cleanlist ${dpt}.dpdef | awk -v elemNr=$count ' 
				BEGIN {  
					PVSStype["string"]	 = "25"
					PVSStype["bool"]	 = "23"
					PVSStype["uint"]	 = "20"
					PVSStype["int"]		 = "21"
					PVSStype["float"]	 = "22"
					PVSStype["double"]	 = "22"
					PVSStype["stringArr"]= "9"
					PVSStype["boolArr"]	 = "7"
					PVSStype["uintArr"]	 = "4"
					PVSStype["intArr"]	 = "5"
					PVSStype["floatArr"] = "6"
					PVSStype["doubleArr"]= "6"
					tabs="										"
					oldnode[1]=""
					prevlevel=0
				} 
				{
					nodename = $1
					level = 0
					do {
						dotpos=index(nodename,".");
						if (dotpos > 0) {
							level++;
							newnode[level]=substr(nodename,0,dotpos-1);
							nodename = substr(nodename,dotpos+1);
							dotpos   = index(nodename,".");
						}
					} while (dotpos > 0);
					
					if (newnode[level] != oldnode[level]) {
						print substr(tabs, 0, level) newnode[level]"	1#"elemNr;
						elemNr++;
						oldnode[level] = newnode[level];
					}
					if (substr($2,0,1) == ":") {
						print substr(tabs, 0, level+1) nodename"	41#"elemNr$2
					}
					else {
						print substr(tabs, 0, level+1) nodename"	"PVSStype[$2]"#"elemNr
					}
					elemNr++;

					if (level < prevlevel) {
						for (l = prevlevel; l > level; l--) {
							oldnode[l]=""
						}
					}
					prevlevel = level;
				}'
		fi
		echo ""

	done >>${DESTDIR}/${DPT_FILE}
	echo "created: ${DESTDIR}/${DPT_FILE}"

	# Modify 'leaf' value for some datapoints.
	(
		echo	"# Modify the default value for the leaf-field"
		echo    "ElementName	TypeName	_original.._value	_original.._status"
	) >${TMP_FILE}

	cleanlist $1 | awk -v dbtype=$2 -v dptype=$3 '{ 
		if ($3 == dbtype && $4 == dptype && $5 == "Y") {
			print "_mp_"$1".status.leaf	"$1"	1	0x101"
		} }' >>${TMP_FILE}

	if [ -f ${ERRORFILE} ]; then
		echo "ERRORS During creation:"
		cat ${ERRORFILE}
		rm -f ${ERRORFILE}
	fi
}

#
# create_dp_file inputfile dbtype dptype
#
create_dp_file()
{
	(
		echo	"#"
		echo -n "# This file was generated by $(basename $0) ${VERSION} on " ; date
		echo	"#"
		echo    "DpName	TypeName	ID"
	) >${DESTDIR}/${DP_FILE}

	# Note: ignore the PermSW_@... lines because they are there only for SAS
	cleanlist $1 | grep -v "PermSW_@" | awk -v dbtype=$2 -v dptype=$3 '{ 
		if ($3 == dbtype && $4 == dptype) {
			print $6"	"$1	
		} }' | \
				substitute_adder | \
				substitute_inputbuffer | \
				substitute_BGP_midplane_ionode | \
				substitute_BGP_midplane | \
				substitute_BGP | \
				substitute_osrack_ossubcluster_storagenode | \
				substitute_osrack_ossubcluster_offlinenode | \
				substitute_osrack_ossubcluster | \
				substitute_osrack | \
				sort -k1,1 |\
				number_dps >>${DESTDIR}/${DP_FILE}


	# setup master point and archives 
	# NOTE: THIS IS ADDED TO THE DataPointTYPES file!
	prevdpt="abc"
	cleanlist $1 | sort | while read dpt prefix dbtype dptype leaf dp
	do
		if [ "${dbtype}" != "$2" ]; then
			continue
		fi

		if [ "${prevdpt}" == "${dpt}" ]; then
			continue
		fi
		prevdpt=${dpt}

		# Create MasterDataPoint for LOFAR tree elements
		if [ "LOFAR${dp#LOFAR}" == "${dp}" ];then
			echo "DpName	TypeName	ID"
			echo "_mp_${dpt}	${dpt}	0"
			echo "_dt_${dpt}	_DynamicDatapoints	0"
			echo ""
		fi

		# if software then create an hourarchive for the logMsg in the MasterDataPoint
		echo $dp | grep 'SW_' 2>&1 1>/dev/null
		if [ $? = 0 ]; then
			if [ "${dpt}" != "CEPObservation" ]; then
			   echo "ElementName	TypeName	_original.._value	_original.._status"
			   echo "_dt_${dpt}.Leaf	_DynamicDatapoints	"'"'_mp_${dpt}.logMsg:_archive'"'"	0x101"
			   echo "_dt_${dpt}.DynamicAttribute	_DynamicDatapoints	"'"'_da_none'"'"	0x101"
			   echo ""

			   echo "StampSec	StampMSec	ElementName	TypeName	DetailNr	_archive.._type	_archive.._archive	_archive.._class"
			   echo "0	0	_mp_${dpt}.process.logMsg	${dpt}		45	1"
			   echo "0	0	_mp_${dpt}.process.logMsg	${dpt}	1	15		_ValueArchive_2"
			   echo ""
			fi
		fi

		# Adder and InputBuffer need an _mp and _dt also, and logMsg set
		if [ "${dpt}" == "Adder" ];then
			echo "DpName	TypeName	ID"
			echo "_mp_${dpt}	${dpt}	0"
			echo "_dt_${dpt}	_DynamicDatapoints	0"
			echo ""
			echo "ElementName	TypeName	_original.._value	_original.._status"
			echo "_dt_${dpt}.Leaf	_DynamicDatapoints	"'"'_mp_${dpt}.logMsg:_archive'"'"	0x101"
			echo "_dt_${dpt}.DynamicAttribute	_DynamicDatapoints	"'"'_da_none'"'"	0x101"
			echo ""

			echo "StampSec	StampMSec	ElementName	TypeName	DetailNr	_archive.._type	_archive.._archive	_archive.._class"
			echo "0	0	_mp_${dpt}.process.logMsg	${dpt}		45	1"
			echo "0	0	_mp_${dpt}.process.logMsg	${dpt}	1	15		_ValueArchive_2"
			echo ""
		fi

		if [ "${dpt}" == "InputBuffer" ];then
			echo "DpName	TypeName	ID"
			echo "_mp_${dpt}	${dpt}	0"
			echo "_dt_${dpt}	_DynamicDatapoints	0"
			echo ""
		   	echo "ElementName	TypeName	_original.._value	_original.._status"
			echo "_dt_${dpt}.Leaf	_DynamicDatapoints	"'"'_mp_${dpt}.logMsg:_archive'"'"	0x101"
			echo "_dt_${dpt}.DynamicAttribute	_DynamicDatapoints	"'"'_da_none'"'"	0x101"
			echo ""

			echo "StampSec	StampMSec	ElementName	TypeName	DetailNr	_archive.._type	_archive.._archive	_archive.._class"
			echo "0	0	_mp_${dpt}.process.logMsg	${dpt}		45	1"
			echo "0	0	_mp_${dpt}.process.logMsg	${dpt}	1	15		_ValueArchive_2"
			echo ""
		fi



	done >>${DESTDIR}/${DPT_FILE}

	echo "created: ${DESTDIR}/${DP_FILE}"
}

#
# expand_component compname labelprefix DPprefix
#
# format COMPONENT_FILE:
#	comp.comp 1#1
#		field1	??#2
#		field2	??#3
#		...
expand_component()
{
	expanding=false
	cleanlist $COMPONENT_FILE | while read field fldtype
	do
		if [ $expanding == false ]; then
			if [ $field == $1.$1 ]; then
				expanding=true
			fi
			continue
		fi

		if [ -z "${fldtype}" ] || [ "${fldtype:0:8}" == "TypeName" ]; then 
			expanding=false
			continue
		fi
		
		varlabel=`labelize $2_$field`
		echo "#define	PN_${varlabel}	\"$3.${field}\""
	done	
}

#
# create_cpp_headerfile inputfile dbtype dptype
#
create_cpp_headerfile()
{
	# write out the fields of the components
	(
		echo "#ifndef LOFAR_DEPLOYMENT_PVSSDATAPOINTS_H"
		echo "#define LOFAR_DEPLOYMENT_PVSSDATAPOINTS_H"
		echo "// process"
		expand_component ProcessStatus "FSM" "process" 
		echo "// object"
		expand_component ObjectStatus  "OBJ" "object"
		echo ""
	)  >>${DESTDIR}/${CPP_HEADERFILE}

	cleanlist $1 | while read dpt prefix dbtype dptype leaf dp
	do
#		if [ "${dbtype}" != "$2" -o "${dptype}" != "$3" ]; then
#			continue
#		fi

		if [ $prefix != "-" ]; then
			label=`labelize ${dpt}`
			echo "// $dpt"
			echo "#define PSN_${label}	\"${dp}\""
			echo "#define PST_${label}	\"${dpt}\""
			if [ -f ${dpt}.dpdef ]; then
				cleanlist ${dpt}.dpdef | while read varname vartype
				do
					if [ ${vartype:0:1} == ":" ]; then
						expand_component ${vartype:1} ${prefix}_${varname} ${varname}
					else
						varlabel=`labelize ${varname}`
						echo "#define PN_${prefix}_${varlabel}	\"${varname}\""
					fi
				done
			fi
			echo ""
		fi
	done >>${DESTDIR}/${CPP_HEADERFILE}

	echo "#endif"  >>${DESTDIR}/${CPP_HEADERFILE}
}

#------------------------------ MAIN program ------------------------------
#
# Syntax: create_db_files [-d destdir] [-o observation] 
#

# setup defaults
DESTDIR="."
DPTYPENAME=Perm
DPTYPE=P
OBSNAME=""
DBTYPENAME=CEP
DBTYPE=C
STNNAME="CEP"

argv=`getopt "d:o:s:Sh" $*`		# reformat arguments
#eval set argv=`getopt "d:o:s:Sh" $*`		# reformat arguments
#shift
while [ -n "$1" -a "$1" != "--" ]
do
	case "$1" in
		-d)	DESTDIR=$2
			[ -d ${DESTDIR} ] ||
				SyntaxError "Destination directory >${DESTDIR}< does not exist"
			shift 2
			;;
		-o) OBSNAME=$2
			DPTYPENAME=Obs
			DPTYPE=O
			shift 2
			;;
		-h) SyntaxError
			;;
		*) SyntaxError
			;;
	esac
done
shift				# remove '--'


# define the input files
STATIONINFOFILE=../StaticMetaData/StationInfo.dat
COMPONENT_FILE=PVSSbase.dpdef
CLUSTERFILE=Clusters.list
RINGFILE=Rings.list
WANFILE=Wan.list
ERRORFILE=/tmp/Crea.Error
INPUTFILE=./PVSSDataPoints.base

# define the output files
CPP_HEADERFILE=PVSSDatapointDefs.h
DP_FILE=${DBTYPENAME}${DPTYPENAME}Datapoints.dpl
DPT_FILE=${DBTYPENAME}Datapointtypes.dpl
TMP_FILE=/tmp/dpts$$.dpl

# construct some lists
CLUSTERLIST=`concatfile $CLUSTERFILE`
RINGLIST=`concatfile $RINGFILE`
RINGSTATIONLIST=`create_ring_station_list`
WANLIST=`concatfile $WANFILE`
WANSWITCHLIST=`create_wan_switch_list`

# create the desired files
create_dpt_file ${INPUTFILE} ${DBTYPE} ${DPTYPE}
create_dp_file  ${INPUTFILE} ${DBTYPE} ${DPTYPE}


#cat ${TMP_FILE} >>${DESTDIR}/${DPT_FILE}
#rm -f ${TMP_FILE}
#(
#	echo -n "// This file was generated by $(basename $0) ${VERSION} on " ; date
#	echo	""
#) >${DESTDIR}/${CPP_HEADERFILE}
#create_cpp_headerfile ${INPUTFILE} ${DBTYPE} ${DPTYPE}
#echo "created: ${DESTDIR}/${CPP_HEADERFILE}"
#mkdir -p ../../../../installed/gnu_debug/include/Deployment/
#cp ${DESTDIR}/${CPP_HEADERFILE} ../../../../installed/gnu_debug/include/Deployment/


