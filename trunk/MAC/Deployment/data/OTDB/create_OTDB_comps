#!/usr/bin/ksh
#
# create_OTDB_comps : Expand all base-file to gcomp files.
#
# Copyright (C) 2006
# ASTRON (Netherlands Foundation for Research in Astronomy)
# P.O.Box 2, 7990 AA Dwingeloo, The Netherlands, seg@astron.nl
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Syntax: create_OTDB_comps
#
# $Id$
#
VERSION="v1.0"

#
# SyntaxError msg
#
SyntaxError()
{
	Msg=$1

	[ -z "${Msg}" ] || echo "ERROR: ${Msg}"
	echo ""
	echo "Syntax: $(basename $0) [-d destdir] target(s)"
	echo "        destdir    Relative directory where the resultfiles are placed"
	echo "        targets	 PVSS | C++ | OTDB"
	echo ""
	exit 1
}


#
# cleanlist filename
#
# Removes all (partial) comment lines from the file
cleanlist()
{
	cut -d"#" -f1 $1 | awk '{ if (NF > 0) print $0 }'
}


#
# concatfile filename
#
# concatinates all lines of the file
concatfile()
{
	cleanlist $1 | while read line
	do
		result=$result":"$line
		echo $result
	done | tail -1 | sed "s/^://"
}


#
# substitute_marker objectname marker
#
# replaces all lines containing the marker with the contents of the markerfile
#
substitute_marker()
{
	echo "#"
	VALUELIST=`concatfile $1.list`
	awk -v VALUELIST=${VALUELIST} -v MARKER=$2 '
	BEGIN {
		nrMarkers=split(VALUELIST, valueName, ":");
	};
	{
		hasMarker=index($0, MARKER);
		if (hasMarker > 0) {
			for (someValue in valueName) {
				inputCopy = $0;
				sub(MARKER, valueName[someValue], inputCopy);
				sub(MARKER, valueName[someValue], inputCopy);
				sub(MARKER, valueName[someValue], inputCopy);
				print inputCopy;
			}
		}
		else {
			print $0;
		}
	} '
}


#
# expand_marker objectname marker ip-prefix
#
expand_marker()
{
	# expand the nodes
	echo -n "# This file was generated by $(basename $0) ${VERSION} on " ; date
	cleanlist $1.list | while read nodename
	do
		number=`echo ${nodename} | sed -e "s/[A-Za-z]//g"`
		ipaddr=`echo $3 | sed -e "s/@/${number}/"`
		(
		echo ""
		echo "#"
		cleanlist $1.base 
		) | sed -e "s/$2/${nodename}/g" -e "s/@IPaddress@/${ipaddr}/g"
	done

	substitute_marker $1 $2
}


#
# substitute_station stationType marker ip-prefix
#
substitute_station()
{
	# expand the nodes
	cleanlist ../StaticMetaData/StationInfo | while read nodename ID stnType rest
	do
		if [ "${stnType}" != $1 ]; then
			continue
		fi
		number=`echo ${nodename} | sed -e "s/[A-Za-z]//g"`
		arm=`echo ${number} | awk '{ print substr($1,1,1) }'`
		ring=`echo ${number} | awk '{ print substr($1,3,1) }'`
		if [ "${stnType}" -eq "C" ]; then
			number=`echo "${number} 7 / 16 * ${number} 7 % 1 - + p q" | dc`
		fi
		ipaddr=`echo $3 | sed -e "s/@@@/${number}/" | sed -e "s/@@/${arm}${ring}/"`
		(
		echo ""
		echo "#"
		cleanlist StationNode.base 
		) | sed -e "s/@Station@/${nodename}/g" -e "s/@IPaddress@/${ipaddr}/g"
	done

	> /tmp/foo.list
	cleanlist ../StaticMetaData/StationInfo | while read nodename ID stnType rest
	do
		if [ "${stnType}" != $1 ]; then
			continue
		fi
		echo ${nodename} >> /tmp/foo.list
	done

	substitute_marker /tmp/foo $2
}


#
# expand_connection filename 
#
expand_connection()
{
	# expand the connections
	echo -n "# This file was generated by $(basename $0) ${VERSION} on " ; date
	cleanlist $1.list | while read connectionName
	do
		sourceNode=`echo ${connectionName} | cut -d'-' -f1`
		destNode=`echo ${connectionName} | cut -d'-' -f2`
		(
		echo ""
		echo "#"
		cleanlist ConnectionNode.base 
		) | sed -e "s/@sourceNode@/${sourceNode}/g" -e "s/@destNode@/${destNode}/g" \
				-e "s/@connection@/${connectionName}/g"
	done

	substitute_marker $1 $2
}




#------------------------------ MAIN program ------------------------------
#
# Syntax: create_db_files [-d destdir] 
#
# where target is pvss / c++ / otdb
#
DESTDIR="."
eval set argv=`getopt "d:h" $*`		# reformat arguments
shift
while [ "$1" != "--" ]
do
	case "$1" in
		-d)	DESTDIR=$2
			[ -d ${DESTDIR} ] ||
				SyntaxError "Destination directory >${DESTDIR}< does not exist"
			shift 2
			;;
		-h) SyntaxError
			;;
	esac
done
shift								# remove --

rm -f ${DESTDIR}/*.gcomp

for file in `ls -1 *.base | grep -v Node`
do
	rawname=`echo $file | cut -d'.' -f1`
	outputname=`echo ${DESTDIR}/$(basename $rawname)".gcomp"`
	echo "Creating ${outputname}..."

	grep @BGLNode@ $file >/dev/null 2>&1
	if [ $? -eq 0 ]; then
		cleanlist $file | \
		expand_marker "BGLNode" "@BGLNode@" "10.20.100.@" >${outputname}
	fi

	grep @StorageNode@ $file >/dev/null 2>&1
	if [ $? -eq 0 ]; then
		cleanlist $file | \
		expand_marker "StorageNode" "@StorageNode@" "10.20.170.@" >${outputname}
	fi

	grep @ImagingNode@ $file >/dev/null 2>&1
	if [ $? -eq 0 ]; then
		cleanlist $file | \
		expand_marker "ImagingNode" "@ImagingNode@" "10.20.160.@" >${outputname}
	fi

	grep @CoreStation@ $file >/dev/null 2>&1
	if [ $? -eq 0 ]; then
		(
		echo -n "# This file was generated by $(basename $0) ${VERSION} on " ; date
		cleanlist $file | \
		substitute_station "C" "@CoreStation@"     "10.151.@@@.1" |\
		substitute_station "R" "@RemoteStation@"   "10.151.1@@.1" |\
		substitute_station "E" "@EuropeanStation@" "10.151.@@@.1"
		) >${outputname}
	fi

	grep @ring@ $file >/dev/null 2>&1
	if [ $? -eq 0 ]; then
		cat $file | \
		substitute_marker "../PVSS/Rings" "@ring@" >${outputname}
	fi

#	grep @BGL-Storage@ $file >/dev/null 2>&1
#	if [ $? -eq 0 ]; then
#		cleanlist $file | \
#		expand_connection "BGL-Storage" "@BGL-Storage@" >>${outputname}
#	fi

	grep @Storage-Imaging@ $file >/dev/null 2>&1
	if [ $? -eq 0 ]; then
		cleanlist $file | \
		expand_connection "Storage-Imaging" "@Storage-Imaging@" >>${outputname}
	fi

done

