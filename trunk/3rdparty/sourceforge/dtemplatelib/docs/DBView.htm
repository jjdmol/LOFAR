<html>


<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>DBView&lt;DataObj, ParamObj&gt;</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p>
<h1>DBView&lt;DataObj, ParamObj&gt;</h1>



















<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td><img src="containers.gif" width="194" height="38"></td>
        <td align="right"><img src="type.gif" width="194"
        height="39"></td>
    </tr>
    <tr>
        <td valign="top"><b>Category</b>: containers</td>
        <td align="right" valign="top"><b>Component type</b>:
        type</td>
    </tr>
</table>
<h3>Description</h3>

<p>The <font size="2" face="Courier New">DBView </font>Container is a semi-<a
href="http://www.sgi.com/tech/stl/Container.html">Container</a> with the property 
  that elements are bound to an underlying database. We say that<font size="2" face="Courier New"> 
  DBView </font>is a semi-<a href="http://www.sgi.com/tech/stl/Container.html">Container</a> 
  because it implements all properties and methods of an STL container except 
  for the <font size="2" face="Courier New">empty(), size() </font><font size="3">and</font><font size="2"
face="Courier New"> max_size()</font> methods. We do not implement <font size="2" face="Courier New">empty(), 
  size()</font> or <font size="2" face="Courier New">max_size()</font> for this 
  container because we cannot guarantee invariance for these functions; e.g. after 
  a programmer calls the<font size="2"
face="Courier New"> size() </font>function a second user may insert more records 
  into the database on the back-end, therby invalidating the fixed count the programmer 
  might expect. Internally the <font size="2" face="Courier New, Courier, mono">DBView</font> 
  also manages a key mode and list of key fields so that it can properly work 
  with the underlying DBMS's autokey mechanism for updates and deletes (see <a href="select_update_iterator.htm"><font size="2" face="Courier New, Courier, mono">select_update_iterator</font></a> 
  for more details).</p>

<h3>Definition</h3>

<p>Defined in the <font size="2" face="Courier New">DBView.h</font>
header file.</p>

<h3>Refinement of</h3>

<p>semi-<a
href="http://www.sgi.com/tech/stl/Container.html">Container</a>
</p>

<h3>Associated types</h3>

<p>The types defined by <a
href="http://www.sgi.com/tech/stl/Container.html">Container</a>
and the additional iterator types listed below.</p>

<h3>Example 1 :</h3>
<h3><i>Mapping a Table to a User Defined Object in Four Easy Steps:</i></h3>
<p><font face="Times Roman">1. Define an object to hold the rows from your query.</font></p>

<p><font face="Times Roman">2. Define an association
between fields in your query and fields in your object. This is
what we call a 'BCA', which is short for Bind Column Addresses.
In the example below, this is done via the functor &quot;BCAExample&quot;.
The job of the BCA is to equate SQL fields with object fields via
the '==' operator which will then establish ODBC bindings to move
data to or from a user query.</font></p>

<p><font face="Times Roman">3. Create a view to select
records from. This view is built from the template DBView and
establishes which table(s) you want to access, what fields you
want to look at (via the BCA), and an optional where clause to
further limit the set of records that you are working with.</font></p>

<p><font face="Times Roman">4. Use the DBView container
to obtain an iterator to SELECT, INSERT, UPDATE or DELETE records
from your view. These iterators may be used to either populate
STL containers or apply algorithms from the Standard Template
library.<br></p>

<pre><code><strong>
In all the examples that follow we will assume that our database contains a table called DB_EXAMPLE of the form

SQL&gt; desc db_example;
Name                            Type
------------------------------- --------
INT_VALUE                       INTEGER
STRING_VALUE                    VARCHAR
DOUBLE_VALUE                    FLOAT
EXAMPLE_LONG                    INTEGER
EXAMPLE_DATE                    DATE

<span class="codeComment">// STEP 1 ////
// &quot;Example&quot; structure to hold rows from our database table</span>
struct Example
{
                                        <span class="codeComment">// tablename.columnname:</span>
	int exampleInt;                 <span class="codeComment">// DB_EXAMPLE.INT_VALUE</span>
	string exampleStr;              <span class="codeComment">// DB_EXAMPLE.STRING_VALUE</span>
	double exampleDouble;           <span class="codeComment">// DB_EXAMPLE.DOUBLE_VALUE</span>
	long exampleLong;               <span class="codeComment">// DB_EXAMPLE.EXAMPLE_LONG</span>
	TIMESTAMP_STRUCT exampleDate;   <span class="codeComment">// DB_EXAMPLE.EXAMPLE_DATE</span>
};

<span class="codeComment">// STEP 2 ////</span>
<span class="codeComment">// Create an association between table columns and fields in our object</span>
template&lt;&gt; class dtl::DefaultBCA&lt;Example&gt;
{
public:
	void operator()(BoundIOs &amp;cols, Example &amp;rowbuf)
    	{
	   cols[&quot;INT_VALUE&quot;] == rowbuf.exampleInt;
	   cols[&quot;STRING_VALUE&quot;] == rowbuf.exampleStr;
	   cols[&quot;DOUBLE_VALUE&quot;] == rowbuf.exampleDouble;
	   cols[&quot;EXAMPLE_LONG&quot;] == rowbuf.exampleLong;
	   cols[&quot;EXAMPLE_DATE&quot;] == rowbuf.exampleDate;
	}
};

<span class="codeComment">// STEP 3 &amp; 4
// Read the contents of the DB_EXAMPLE table and return a vector of the
// resulting rows</span>
vector&lt;Example&gt; ReadData() {
	// Read the data
	vector&lt;Example&gt; results;
	DBView&lt;Example&gt; view(&quot;DB_EXAMPLE&quot;);

	DBView&lt;Example&gt;::select_iterator read_it = view.begin();
	for ( ; read_it != view.end();  ++read_it)
	{
		results.push_back(*read_it);
	}
	return results;
}
</code></pre></strong>

<h3>Example 2:</h3>
<pre><code><span class="codeComment">//BPA Functor to bind SQL parameters to a data object</span>

<span class="codeComment">// &quot;Example&quot; class to hold rows from our database table</span>
class Example
{
  public:                                <span class="codeComment">// tablename.columnname:</span>
	int exampleInt;                 <span class="codeComment">// DB_EXAMPLE.INT_VALUE</span>
	string exampleStr;              <span class="codeComment">// DB_EXAMPLE.STRING_VALUE</span>
	double exampleDouble;           <span class="codeComment">// DB_EXAMPLE.DOUBLE_VALUE</span>
	long exampleLong;               <span class="codeComment">// DB_EXAMPLE.EXAMPLE_LONG</span>
	TIMESTAMP_STRUCT exampleDate;   <span class="codeComment">// DB_EXAMPLE.EXAMPLE_DATE</span>

	Example(int exInt, const string &amp;exStr, double exDouble, long exLong,
		const TIMESTAMP_STRUCT &amp;exDate) :
	   exampleInt(exInt), exampleStr(exStr), exampleDouble(exDouble), exampleLong(exLong),
	   exampleDate(exDate)
	{ }

};

<span class="codeComment">// Create an association between table columns and fields in our object</span>
class BCAExampleObj
{
public:
	void operator()(BoundIOs &amp;cols, Example &amp;rowbuf)
    	{
	   cols[&quot;INT_VALUE&quot;] &gt;&gt; rowbuf.exampleInt;
	   cols[&quot;STRING_VALUE&quot;] &gt;&gt; rowbuf.exampleStr;
	   cols[&quot;DOUBLE_VALUE&quot;] &gt;&gt; rowbuf.exampleDouble;
	   cols[&quot;EXAMPLE_LONG&quot;] &gt;&gt; rowbuf.exampleLong;
	   cols[&quot;EXAMPLE_DATE&quot;] &gt;&gt; rowbuf.exampleDate;
	}
}

class ExampleParamObj
{
    public:
       	int lowIntValue;
	int highIntValue;
	string strValue;
	TIMESTAMP_STRUCT dateValue;
};

class BPAParamObj
{
public:
	void operator()(BoundIOs &amp;boundIOs, ExampleParamObj &amp;paramObj)
	{
	  boundIOs[0] &lt;&lt; paramObj.lowIntValue;
	  boundIOs[1] &lt;&lt; paramObj.highIntValue;
	  boundIOs[2] &lt;&lt; paramObj.strValue;
	  boundIOs[3] &lt;&lt; paramObj.dateValue;
	}

};

<span class="codeComment">// read some Example objects from the database and return a vector of</span>
<span class="codeComment">// the results, use BPA to set join parameters</span>
vector&lt;Example&gt; ReadData()
{
	vector&lt;Example&gt; results;

	<span class="codeComment">// construct view</span>
	
	DBView&lt;Example, ExampleParamObj&gt;
		view(&quot;DB_EXAMPLE&quot;, BCAExampleObj(),
		&quot;WHERE INT_VALUE BETWEEN (?) AND (?) AND &quot;
		&quot;STRING_VALUE = (?) OR EXAMPLE_DATE &lt; (?) ORDER BY EXAMPLE_LONG&quot;,
		BPAParamObj());

	<span class="codeComment">// loop through query results and add them to our vector</span>
	<span class="codeComment">// in this loop, read_it.GetLastCount() records read from DB</span>

	DBView&lt;Example, ExampleParamObj&gt;::select_iterator read_it = view.begin();

	<span class="codeComment">// set parameter values for the WHERE clause in our SQL query</span>
	read_it.Params().lowIntValue = 2;
	read_it.Params().highIntValue = 8;
	read_it.Params().strValue = &quot;Example&quot;;
	
	TIMESTAMP_STRUCT paramDate = {2000, 1, 1, 0, 0, 0, 0};
	read_it.Params().dateValue = paramDate;

	for ( ; read_it != view.end();  read_it++)
	{
		cout &lt;&lt; &quot;Reading element #&quot; &lt;&lt; read_it.GetLastCount() &lt;&lt; endl;
		results.push_back(*read_it);

		cout &lt;&lt; &quot;read_it-&gt;exampleInt = &quot; &lt;&lt; read_it-&gt;exampleInt &lt;&lt; endl;
		cout &lt;&lt; &quot;read_it-&gt;exampleStr = &quot; &lt;&lt; read_it-&gt;exampleStr &lt;&lt; endl;
		
	}
	
	return results;
}
</code></pre>
<h3>Example 3:</h3>

<pre><code><span class="codeComment">// Using a DBView to insert rows into a database</span>


<span class="codeComment">// ... Class definitions for Example and BCAExample as per our </span><a
href="DBViewReadData.htm">ReadData</a> <span class="codeComment">example .....

// Specialization of DefaultInsValidate for Example
// This defines a business rule we wish to enforce for all 
// Example objects before they are allowed to be inserted into the database</span>
template&lt;&gt; class dtl::DefaultInsValidate&lt;Example&gt; 
{
public:

	bool operator()(BoundIOs &amp;boundIOs, Example &amp;rowbuf) {	
		<span class="codeComment">// data is valid if rowbuf.exampleStr is nonempty and
		// rowbuf.exampleDouble is 
		// between 0 and 100 (like a percentage)</span>
		return (rowbuf.exampleStr.length() &gt; 0 &amp;&amp;  rowbuf.exampleDouble &gt;= 0.0 
			&amp;&amp; rowbuf.exampleLong  &lt;= 100.0);
	}
};


<span class="codeComment">// Insert rows from the vector&lt;Example&gt; parameter into the database</span>
void WriteData(const vector&lt;Example&gt; &amp;examples)
{
	DBView&lt;Example&gt; view(&quot;DB_EXAMPLE&quot;);
	DBView&lt;Example&gt;::insert_iterator write_it = view;

	<span class="codeComment">// loop through vector and write Example objects to DB</span>
	copy(examples.begin(), examples.end(), write_it);
}
</code></pre>


<h3>Public Base Classes</h3>

<p>None.</p>

<h3>Template parameters</h3>

<table border="1">
    <tr>
        <th>Parameter </th>
        <th>Description </th>
        <th>Default </th>
    </tr>
    <tr>
        <td valign="top"><tt>DataObj</tt> </td>
        <td valign="top">The type of object that will be written
        to the <font size="2" face="Courier New">DBView</font>.
        This object will be bound through use of the <font
        size="1" face="Courier New">BCA</font><font size="2"> </font>to
        the appropriate columns in the database. The set of value
        types of an <tt>DBView::insert_iterator</tt> consists of
        a single type, <font size="2" face="Courier New">DataObj</font>.
        </td>
        <td valign="top">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top"><tt>ParamObj</tt> </td>
        <td valign="top">The type of object that will be used to
        specify the postfix parameters to the <font size="2"
        face="Courier New">DBView</font>.</td>
        <td valign="top"><font size="2" face="Courier New">DefaultParamObj&lt;DataObj&gt;</font>&nbsp;
        </td>
    </tr>
</table>

<p>&nbsp;</p>

<h3>Notation</h3>

<table border="0">
    <tr>
        <td valign="top"><tt>X</tt> </td>
        <td valign="top">A type that is a model of DBView </td>
    </tr>
    <tr>
        <td valign="top"><tt>a</tt> </td>
        <td valign="top">Object of type <tt>X</tt> </td>
    </tr>
    <tr>
        <td valign="top"><tt>t</tt> </td>
        <td valign="top">Object of type <tt>X::value_type</tt> </td>
    </tr>
    <tr>
        <td valign="top"><tt>p</tt>, <tt>q</tt> </td>
        <td valign="top">Object of type <tt>X::iterator</tt> </td>
    </tr>
</table>

<p>&nbsp;</p>

<h3>Associated types</h3>

<p>In addition to the types defined in a semi-<a
href="http://www.sgi.com/tech/stl/Container.html">Container</a>
, the following types are defined.:</p>

<table border="1">
  <tr> 
    <td valign="top" width="75">Iterator type </td>
    <td valign="top" width="110">X::<a href="select_iterator.htm">select_iterator</a></td>
    <td valign="top" width="781">An input iterator to read records from the view</td>
  </tr>
  <tr> 
    <td valign="top" width="75">Iterator type </td>
    <td valign="top" width="110">X::<a href="insert_iterator.htm">insert_iterator</a></td>
    <td valign="top" width="781">An output iterator to insert records into the 
      view</td>
  </tr>
  <tr> 
    <td valign="top" width="75">Iterator type </td>
    <td valign="top" width="110">X::<a href="update_iterator.htm">update_iterator</a></td>
    <td valign="top" width="781">An output iterator to update records in the view</td>
  </tr>
  <tr> 
    <td valign="top" width="75">Iterator type </td>
    <td valign="top" width="110">X::<a href="delete_iterator.htm">delete_iterator</a></td>
    <td valign="top" width="781">An ouput iterator to delete records from the 
      view</td>
  </tr>
  <a name="Args">
  <tr>
    <td valign="top" width="75">Argument object type</td>
    <td valign="top" width="110">X::Args</td>
    <td valign="top" width="781"> 
      <p>Nested class for arguments object used to pass parameters to the <font face="Courier New, Courier, mono" size="2">DBView</font> 
        constructor.</p>
      <p>Accessors to set arguments in an <font face="Courier New, Courier, mono" size="2">Args</font> 
        object (all return <font size="2" face="Courier New, Courier, mono">*this</font> 
        as an <font size="2" face="Courier New, Courier, mono">Args &amp;</font>):</p>
      <ul>
        <li><font face="Courier New, Courier, mono" size="2">tables(const string 
          &amp;tableList) - corresponds to tableList parameter in main DBView 
          constructor - must be set for constructed DBView to be valid</font></li>
        <li><font face="Courier New, Courier, mono" size="2">bca(const BCA bca_functor) 
          - corresponds to bca_functor parameter in main DBView constructor - 
          default value: DefaultBCA&lt;DataObj&gt;()</font></li>
        <li><font face="Courier New, Courier, mono" size="2">postfix(const string 
          &amp;postfixClause) - corresponds to postfix parameter in main constructor 
          - default value: &quot;&quot;</font></li>
        <li><font face="Courier New, Courier, mono" size="2">bpa(const BPA bpa_functor) 
          - corresponds to bpa_functor parameter in main constructor - default 
          value: DefaultBPA&lt;ParamObj&gt;()</font></li>
        <li><font face="Courier New, Courier, mono" size="2">SelValidate(const 
          SelVal sel_val) - corresponds to sel_val parameter in main constructor 
          - default value: DefaultSelValidate&lt;DataObj&gt;()</font></li>
        <li><font face="Courier New, Courier, mono" size="2">InsValidate(const 
          InsVal ins_val) - corresponds to ins_val parameter in main constructor 
          - default value: DefaultInsValidate&lt;ParamObj&gt;()</font></li>
        <li><font face="Courier New, Courier, mono" size="2">handler(const IOHandler&lt;DataObj, 
          ParamObj&gt; io_hand) - corresponds to io_hand parameter in main constructor 
          - default value: DEFAULT_IO_HANDLER&lt;DataObj, ParamObj&gt;()</font></li>
        <li><font face="Courier New, Courier, mono" size="2">conn(DBConnection 
          &amp;connection) - corresponds to connection parameter in main constructor 
          - default value: DBConnection::GetDefaultConnection()</font></li>
        <li><font face="Courier New, Courier, mono" size="2">fields(const string 
          &amp;fieldList) - corresponds to fieldList parameter in DynamicDBView 
          main constructor -- ONLY FOR USE WITH A DynamicDBView, NOT DBView - 
          default value: &quot;&quot;</font></li>
        <li><font face="Courier New, Courier, mono" size="2">key_mode(KeyMode 
          km) - corresponds to km parameter in DynamicDBView main constructor 
          -- ONLY FOR USE WITH A DynamicDBView, NOT DBView - default value: USE_AUTO_KEY</font></li>
        <li><font face="Courier New, Courier, mono" size="2">keys(const string 
          &amp;keyList) - corresponds to keyList parameter in DBView constructor 
          - default value: &quot;&quot;</font></li>
      </ul>
      <p>To set the arguments, default construct an<font size="2" face="Courier New, Courier, mono"> 
        Args</font> object and then successively apply accessors to this object. 
        The parameters you reference will be set to the passed in values, all 
        others will receive their default values. For example, to construct a 
        view of <font face="Courier New, Courier, mono" size="2">Example</font> 
        objects that references the <font face="Courier New, Courier, mono" size="2">DB_EXAMPLE</font> 
        table and uses a connection named <font face="Courier New, Courier, mono" size="2">myConn</font>, 
        you would say:</p>
      <p><font size="2" face="Courier New, Courier, mono">DBView&lt;Example&gt; 
        view(DBView&lt;Example&gt;::Args().tables(&quot;DB_EXAMPLE&quot;).conn(myConn))</font>;</p>
      <p>The <font face="Courier New, Courier, mono" size="2">Args</font> class 
        is designed to emulate named arguments so you don't have to pass arguments 
        around that just use their default values. The constructor call above 
        would have to explicitly pass 6 arguments with their corresponding default 
        values, which is tedious, hard to read, and very error prone.</p>
      </td>
  </tr></a>
</table>

<p>&nbsp;</p>

<h3>Expression semantics</h3>

<table border="1">
  <tr> 
    <th>Name </th>
    <th>Expression </th>
    <th>Precondition </th>
    <th>Semantics </th>
    <th>Postcondition </th>
  </tr>
  <tr> 
    <td valign="top">Main constructor </td>
    <td valign="top" width="110"> 
      <pre>DBView(const string &amp;tableList, 
const <a href="BCA.htm">BCA</a> bca_functor = DefaultBCA&lt;DataObj&gt;(),
const string &amp;postfix = &quot;&quot;, 
const <a href="BPA.htm">BPA</a> bpa_functor = DefaultBPA&lt;ParamObj&gt;(),
const <a href="SelVal.htm">SelVal</a> sel_val = DefaultSelVal&lt;DataObj&gt;(),
const <a href="InsVal.htm">InsVal</a> ins_val = DefaultInsVal&lt;DataObj&gt;(),
<a href="IOHandler.htm">IOHandler&lt;DataObj, ParamObj&gt;</a> io_hand = DEFAULT_IO_HANDLER&lt;DataObj, ParamObj&gt;(),
<a href="DBConnection.htm">DBConnection</a> &amp;connection = DBConnection::GetDefaultConnection(),
const string &amp;keyList = &quot;&quot;)</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top" width="781">Creates an empty container bound to a table, using the database 
      connection specified in the connection object. The actual queries run againt 
      this table are built by the select, insert, update and delete iterators 
      (see these iterators for details) but essentially follow the following format: 
      <p><font size="2"
        face="Courier New">&quot;SELECT &quot; + &lt;columns listed in bca_fn()&gt; 
        + &quot; FROM &quot; + tableList + postfix</font></p>
      <p>In the SQL clause, users may also specify dynamic parameters through 
        the use of SQL <font size="2"
        face="Courier New">'(?)'</font> syntax. In this case <a
        href="BPA.htm"><font size="2" face="Courier New">BPA</font></a> is a class 
        that is used to hold these runtime parameters and <font size="2" face="Courier New">bpa_functor 
        </font>is a functor used to associate fields in the parameters class with 
        parameter fields in the query.</p>
      <p>A raw SQL query can be passed for the first parameter instead of the 
        table names along with an empty postfix clause. Use this technique when 
        you want to (and only when you want to) create a sql_iterator later over 
        the view.</p>
      <p>The user can customize the query building mechanism for his <font size="2" face="Courier New, Courier, mono">DBView</font> 
        by specializing the <font size="2" face="Courier New, Courier, mono"><a href="#BuildSpecialQry">BuildSpecialQry</a></font> 
        template functor.</p>
      <p>The user can pass in a comma separated list of fields indicating the 
        key for the view. This will get used by <a href="select_update_iterator.htm"><font size="2" face="Courier New, Courier, mono">select_update_iterator</font></a> 
        to determine which objects to update if the view's key mode is<font size="2" face="Courier New, Courier, mono"> 
        USE_ALL_FIELDS</font>.</p>
    </td>
    <td valign="top">The size of the container is <font
        size="3" face="Times New Roman"><tt>0. </tt></font> <font size="3" face="Times New Roman">Rows 
      are operated on by obtaining the appropriate iterator from the container.</font></td>
  </tr>
  <tr>
    <td valign="top">Main constructor (accepting Args object)</td>
    <td valign="top" width="110"><font size="2" face="Courier New, Courier, mono">DBView(const 
      Args &amp;args)</font></td>
    <td valign="top"><font face="Courier New, Courier, mono" size="2">!args.tableList.empty() 
      </font></td>
    <td valign="top" width="781">
      <p>Same as above, with the parameters specified in an <font size="2" face="Courier New, Courier, mono">Args 
        </font>object.</p>
      <p>See description of Args nested type above for use.</p>
    </td>
    <td valign="top">&nbsp;</td>
  </tr>
</table>

<p>&nbsp;</p>

<h3>Members</h3>

<table border="1">
  <tr> 
    <th>Member </th>
    <th>Where defined </th>
    <th>Description </th>
  </tr>
  <tr> 
    <td valign="top"><tt>value_type</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">The type of object, <tt>T</tt>, stored in the <font size="2" face="Courier New">DBView</font>. 
      In this case<font size="2" face="Courier New"> T = DataObj</font></td>
  </tr>
  <tr> 
    <td valign="top"><tt>pointer</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Pointer to <tt>T</tt>. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>reference</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Reference to <tt>T</tt> </td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_reference</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Const reference to <tt>T</tt> </td>
  </tr>
  <tr> 
    <td valign="top"><tt>size_type</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">An unsigned integral type. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>difference_type</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">A signed integral type. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>iterator</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Iterator used to iterate through a <font
        size="2" face="Courier New">DBView</font>. The default iterator for<font size="2" face="Courier New"> 
      DBView</font> is the <font size="2" face="Courier New">select_iterator</font>.</td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_iterator</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Const iterator used to iterate through a <font size="2" face="Courier New">DBView</font>. 
      (<tt>iterator</tt> and <tt>const_iterator</tt> are the same type.) </td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_iterator begin() const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Returns a <tt>const_iterator</tt> pointing to the beginning 
      of the DBView. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>const_iterator end() const</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Returns a <tt>const_iterator</tt> pointing to the end of 
      the DBView. </td>
  </tr>
  <tr> 
    <td valign="top"> 
      <pre><tt>DBView(const string &amp;tableList, 
const </tt><a href="BCA.htm"><tt>BCA</tt></a><tt> bca_functor = DefaultBCA&lt;DataObj&gt;(),
const string &amp;postfix = &quot;&quot;, 
const </tt><a href="BPA.htm"><tt>BPA</tt></a><tt> bpa_functor = DefaultBPA&lt;ParamObj&gt;(),
const </tt><a href="SelVal.htm"><tt>SelVal</tt></a><tt> sel_val = DefaultSelVal&lt;DataObj&gt;(),
const </tt><a href="InsVal.htm"><tt>InsVal</tt></a><tt> ins_val = DefaultInsVal&lt;DataObj&gt;(),
const <a href="IOHandler.htm">IOHandler&lt;DataObj, ParamObj&gt;</a> io_hand = DEFAULT_IO_HANDLER&lt;DataObj, ParamObj&gt;(),
</tt><a href="DBConnection.htm"><tt>DBConnection</tt></a><tt> &amp;connection = DBConnection::GetDefaultConnection(),
const string &amp;keyList = &quot;&quot;)</tt></pre>
    </td>
    <td valign="top"><font size="2" face="Courier New">DBView</font></td>
    <td valign="top">Creates a <font size="2"
        face="Courier New">DBView</font>. </td>
  </tr>
  <tr> 
    <td valign="top"><font face="Courier New, Courier, mono" size="2">DBView&lt;const 
      Args &amp;args)</font></td>
    <td valign="top"><font size="2" face="Courier New">DBView</font></td>
    <td valign="top">Creates a <font size="2"
        face="Courier New">DBView</font> using an arguments object.</td>
  </tr>
  <tr> 
    <td valign="top"><tt>DBView(const DBView&amp;)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">The copy constructor. </td>
  </tr>
  <tr> 
    <td valign="top"><tt>DBView&amp; operator=(const DBView&amp;)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">The assignment operator </td>
  </tr>
  <tr> 
    <td valign="top"><font size="2" face="Courier New">void set_io_handler(IOHandler&lt;DataObj, 
      ParamObj&gt;)</font></td>
    <td valign="top"><font size="2" face="Courier New">DBView</font></td>
    <td valign="top">Sets the <font size="2"
        face="Courier New">IOHandler</font> for this view. Iterators created from 
      this view will then use this handler by default until set by the iterator's 
      version of this method. The <font size="2" face="Courier New">IOHandler 
      </font>will try to handle exceptions thrown by such iterators and tell the 
      code which caught the exception whether to suppress the error or still throw.</td>
  </tr>
  <tr> 
    <td valign="top"><font size="2" face="Courier New">template&lt;class UserHandler&gt; 
      const UserHandler &amp; get_io_handler(UserHandler *dummy) const</font></td>
    <td valign="top"><font size="2" face="Courier New">DBView</font></td>
    <td valign="top">Returns the current<font size="2"
        face="Courier New"> IOHandler</font> for this object cast to the actual 
      type of the handler based on the dummy pointer passed in. If the dynamic 
      cast of the <font
        size="2" face="Courier New">IOHandler</font> object fails, an exception 
      will be thrown.</td>
  </tr>
  <tr> 
    <td valign="top"><font size="2" face="Courier New">IOHandler&lt;DataObj, ParamObj&gt; 
      &amp;get_io_handler() const</font></td>
    <td valign="top"><font size="2" face="Courier New">DBView</font></td>
    <td valign="top">Returns the current<font size="2"
        face="Courier New"> IOHandler</font> for this object as a raw <font size="2" face="Courier New">IOHandler</font> 
      object. You must cast to the actual type of the handler to be able to access 
      any of your handler's public members.</td>
  </tr>
  <tr> 
    <td valign="top"><tt>void swap(DBView&amp;)</tt> </td>
    <td valign="top"><a
        href="http://www.sgi.com/tech/stl/Container.html">Container</a> </td>
    <td valign="top">Swaps the contents of two <font size="2"
        face="Courier New">DBView's</font>. </td>
  </tr>
  <tr> 
    <td valign="top"><font size="2" face="Courier New, Courier, mono">DataObj 
      GetDataObj() const</font></td>
    <td valign="top"><font size="2" face="Courier New">DBView</font></td>
    <td valign="top">Returns a prototype <font size="2" face="Courier New, Courier, mono">DataObj</font> 
      with its structure built if necessary (needed in the case of <font size="2" face="Courier New, Courier, mono">variant_row</font>).</td>
  </tr>
  <tr>
    <td valign="top"><font size="2" face="Courier New, Courier, mono">void SetKey(const 
      string &amp;keyList)</font></td>
    <td valign="top"><font face="Courier New, Courier, mono" size="2">DBView</font></td>
    <td valign="top">Set the list of key fields for the view.<font face="Courier New, Courier, mono" size="2"> 
      keyList</font> is a comma separated list of those key fields.</td>
  </tr>
</table>

<a name="BuildSpecialQry">
<h3>BuildSpecialQry: Customizing the query generated by your DBView</h3>
</a>
<p>In most cases, the SQL query generated by your <font face="Courier New, Courier, mono" size="2">DBView</font> 
  will do just fine. However, there are times you may wish to do something special, 
  such as fetching distinct values or some other custom SQL statement which cannot 
  be expressed through a postfix clause (and for which a <font face="Courier New, Courier, mono" size="2">sql_iterator</font> 
  will not do). The primary use of <font face="Courier New, Courier, mono" size="2">BuildSpecialQry</font> 
  is actually to control the SQL statements used by an <font face="Courier New, Courier, mono" size="2">IndexedDBView</font>. 
  Since an<font size="2" face="Courier New, Courier, mono"> IndexedDBView</font> 
  uses a view to do its work we can create a <font size="2" face="Courier New, Courier, mono">BuildSpecialQry</font> 
  function to control exactly what SQL statements are generated to select, insert, 
  update or delete records by the<font size="2" face="Courier New, Courier, mono"> 
  IndexedDBView</font>. DTL provides a <font size="2" face="Courier New, Courier, mono">BuildSpecialQry</font> 
  template functor to allow you to customize the query that gets built for any 
  of the iterators generated by a <font face="Courier New, Courier, mono" size="2">DBView</font>. 
  The generic version of this functor simply forwards the call to the <font size="2" face="Courier New, Courier, mono">BuildDefaultQry()</font> 
  template function, which serves as the default query building mechanism for 
  <font face="Courier New, Courier, mono"> <font size="2">DBView</font></font>s. 
  To override the default query building mechanism, for a given <font size="2" face="Courier New, Courier, mono">DBView&lt;DataObj, 
  ParamObj&gt;</font>, define a corresponding specialization: <font size="2" face="Courier New, Courier, mono">BuildSpecialQry&lt;DataObj, 
  ParamObj&gt;</font>. Put your special behavior in <font size="2" face="Courier New, Courier, mono">BuildSpecialQry::operator()()</font>. 
  You can provide special behavior based on the<font size="2" face="Courier New, Courier, mono"> 
  SQLQueryType</font> value passed in. Also, if you have field names in your query 
  with spaces, you will need to use the <font face="Courier New, Courier, mono" size="2">QuoteChar</font> 
  parameter which specifies the character that is used to indicate the beginning 
  and ending of field names (such as double quote in Oracle yielding a query like 
  <font size="2"> <font face="Courier New, Courier, mono">SELECT &quot;FIRST NAME&quot;, 
  &quot;LAST NAME&quot; FROM EMPLOYEE</font></font>). If you wish to leave the 
  behavior unchanged for a particular query type, simply forward the <font size="2" face="Courier New, Courier, mono">operator()()</font> 
  call to <font size="2" face="Courier New, Courier, mono">BuildDefaultQry()</font>. 
  The example below will grab only distinct <font size="2" face="Courier New, Courier, mono">DistinctExample</font> 
  objects from the database when the records are fetched by a <font size="2" face="Courier New, Courier, mono">DBView::select_iterator</font>. 
  Note the use of various helper functions and <font size="2" face="Courier New, Courier, mono">DBView</font> 
  accessors used to build key parts of the query (such as <font size="2" face="Courier New, Courier, mono">MakeDelimitedList()</font>) 
  based on the view's attributes. Also notice that if we were to use <font size="2" face="Courier New, Courier, mono">DBView&lt;DistinctExample&gt;</font> 
  as an argument to an <font face="Courier New, Courier, mono" size="2">IndexedDBView</font> 
  then the fetch for the <font face="Courier New, Courier, mono" size="2">IndexedDBView</font> 
  (which uses a <font face="Courier New, Courier, mono" size="2">select_iterator</font>) 
  would also be built as <font size="2" face="Courier New, Courier, mono">"SELECT 
  DISTINCT ..."</font></p>

<pre><code><span class="codeComment">
// special query builder for DBView<distinctexample></span>
template&lt;&gt; class BuildSpecialQry<distinctexample>&lt;DistinctExample&gt;
{
public:
  <span class="codeComment">// build the special query</span>
  string operator()(const DBView<distinctexample>&lt;DistinctExample&gt; &amp;view, SQLQueryType qryType,
					const string &amp;QuoteChar)
  {
	switch (qryType)
	{
		case SELECT:
		{
		  string Query;

		  <span class="codeComment">// get the necessary info. we need from the view</span>
		  string postfixClause = view.GetPostfixClause();
		  string rawSQL = view.GetRawSQL();
		  set&lt;string&gt; tableNames = view.GetTableNames();
		  set&lt;string&gt; colNames = view.GetColNames();
		 
		  <span class="codeComment">// SELECT DISTINCT colNames FROM tableNames postfixClause</span>
		  if (tableNames.empty())
			throw DBException("DBView::BuildQry()",
				   "SELECT : must select from at least one table", NULL, NULL);

		  <span class="codeComment">// Catch this error in MakeBindings()
		  // Need to leave this test out so that sql_iterator can work
		  //
		  //if (colNames.empty())
		  //	throw DBException("DBView::BuildQry()",
		  //		   "SELECT : must select from at least one column", NULL, NULL);

		  // ***** Special behavior right here *******
		  // build SELECT stmt into Query ... only select DISTINCT records !!!!!</span>
		  Query += "SELECT DISTINCT ";

		  <span class="codeComment">// build comma-separated list of columns and tack on to the query</span>
		  Query += MakeDelimitedList(colNames);

		  Query += " FROM ";

		  <span class="codeComment">// now add a comma-separated list of the tables</span>
		  Query += MakeDelimitedList(tableNames);

		  <span class="codeComment">// tack on postfix clause</span>
		  if (postfixClause.length() &gt; 0)
		  {
		      Query += " ";
		      Query += postfixClause;
		  }
		  
		  return Query;

		}
		default:
		  return BuildDefaultQry(view, qryType, QuoteChar);
	} <span class="codeComment">// end switch</span>
  } <span class="codeComment">// end operator()</span>

}; <span class="codeComment">// end BuildSpecialQry&lt;DistinctExample&gt;</span>

</code></pre>
<h3>See also</h3>

<p><a
href="http://www.sgi.com/tech/stl/MultipleAssociativeContainer.html">Multiple 
  Associative Container</a>, <a href="BCA.htm"><font size="2"
face="Courier New">BCA</font></a><font size="2"
face="Courier New">, </font><a href="BPA.htm"><font size="2"
face="Courier New">BPA</font></a><font size="2"
face="Courier New">, </font><a href="InsVal.htm"><font size="2"
face="Courier New">InsVal</font></a><font size="2"
face="Courier New">, </font><a href="SelVal.htm"><font size="2"
face="Courier New">SelVal</font></a><font size="2"
face="Courier New">, <a href="select_update_iterator.htm">select_update_iterator</a>, 
  </font><a href="db_iterator.htm"><font
size="2" face="Courier New">DB_iterator</font><font size="2"><!--start footer--></font></a> 
</p>


<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright © 2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body>
</html>
