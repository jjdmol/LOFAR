<html>

<p> 
<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>Introduction to the Database Template Library</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p> </p>

<p align="center"><a href="#_Toc500425981"><font
face="Times Roman">Introduction to the Database Template Library</font></a><br>
<a href="#_Toc500425982"><font face="Times Roman">Abstract</font></a><br>
<a href="#_Toc500425983"><font face="Times Roman">Background</font></a><br>
<a href="#_Toc500425984"><font face="Times Roman">A First
Example, Reading and Writing Records in a Table</font></a><br>
<a href="#usermap"><font face="Times Roman">Mapping a Table to a User Defined Object</font></a></br>
<a href="#quickmap"><font face="Times Roman">Quickly Mapping a Table to a Default Structure</font></a></br>
<a href="#itertypes"><font face="Times Roman">Iterator Types</font></a></br>
<a href="#_Toc500425985"><font face="Times Roman">A Second
Example, Parameterized Queries</font></a><br>
<a href="#_Toc500425986"><font face="Times Roman">Tables R Us,
The IndexedDBView</font></a><br>
<a href="#_Toc500425987"><font face="Times Roman">When you don't
know column names or types until runtime, dynamic queries</font></a><br>
<a href="#_Toc500425988"><font face="Times Roman">Using
STL Algorithms, the Table Difference Function</font></a><br>
<a href="#_Toc500425989"><font face="Times Roman">Conclusion</font></a><br>
</p>

<p align="center"><a name="_Toc500425981"></a></p>

<p><font size="4" face="Arial"><br>
<br>
</font></p>

<p align="center"><font size="4" face="Arial"><b>Introduction to
the Database Template Library</b></font></p>

<p><font size="4" face="Arial"><br>
</font></p>

<p align="center"><font face="Times Roman">Corwin Joy * Michael
Gradman</font></p>

<p align="center"><a href="mailto:cjoy@houston.rr.com"><font
color="#0000FF" face="Times Roman"><u>cjoy@houston.rr.com</u></font></a></p>

<p align="center"><a href="mailto:Michael.Gradman@caminus.com"><font
face="Times Roman">Michael.Gradman@caminus.com</font></a></p>

<br>
<br>
</font><a name="_Toc500425982"></a><font size="4" face="Arial"><b><i>Abstract:<br>
</i></b></font><font face="Times Roman">The goal of this library
is to make ODBC recordsets look just like an STL container. As a
user, you can move through our containers using standard STL
iterators; and if you insert(), erase() or replace() records in
our containers changes can be automatically committed to the
database for you. The library's compliance with the STL iterator
and container standards means you can plug our abstractions into
a wide variety of STL algorithms for data storage, searching and
manipulation. In addition, the C++ reflection mechanism used by
our library to bind to database tables allows us to add generic
indexing and lookup properties to our containers with no special
code required from the end-user. Because our code takes full
advantage of the template mechanism, it adds minimal overhead
compared with using raw ODBC calls to access a database.<br>
<br>
<br>
</font><a name="_Toc500425983"></a><font face="Arial"><b><i>Background:<br>
</i></b></font><font face="Times Roman">Introduced in 1990, STL
and templates represent one of the most significant advances in
the C++ language in the last decade. The guiding force behind the
power of the standard template library is the notion of Generic
Programming. At the heart of Generic Programming is the idea of
abstracting operations across as broad a set of data types as
possible to create algorithms that are as generic as possible.
This kind of design leads to abstractions that are centered
around a set of requirements on the data types themselves.
Examples in STL include notions such as iterators, containers and
set operations. We have taken these abstractions and applied them
to the problem of representing tables in a database. In what
follows, we will show how this simplifies the task of
manipulating data and provides instant access to a broad range of
algorithms that come with the standard template library.<br>
<br>
<br>
</font><a name="_Toc500425984"></a><font face="Arial"><b><i>A
First Example, Reading and Writing Records in a Table:<br>
</i></b></font><font face="Times Roman">As our first example, we
show what a complete program would look like to open a table and print a set
of rows from the database.</font></p>

<strong><pre><code>
<span class="codeComment">//////////////////////////////////////////////////////////////////////////////////////</span>
#include "DTL.h"
#include &lt;iostream&gt;
using namespace dtl;
using namespace std;

int main() 
{
	try 
	{
		<span class="codeComment">// Connect to the database </span>
		DBConnection::GetDefaultConnection().Connect(&quot;UID=example;PWD=example;DSN=example;&quot;);

		<span class="codeComment">// Create a container to hold records from a query.
		// In this case, the query will be &quot;SELECT * FROM DB_EXAMPLE&quot;.</span>
		DynamicDBView&lt;&gt; view(&quot;DB_EXAMPLE&quot;, &quot;*&quot;); 

		<span class="codeComment">// Read all rows from the database and send to cout</span>
		copy(view.begin(), view.end(), ostream_iterator&lt;variant_row&gt;(cout, &quot;\n&quot;));
	}

	catch (std::exception &ex) 
	{
		<span class="codeComment">// Show any database or other standard errors</span>
		cerr << ex.what() << endl;
	}

	return 0;
}
<span class="codeComment">//////////////////////////////////////////////////////////////////////////////////////</span>
</code></pre></strong>

<p> The three steps shown above are: <br>
<ol>
    <li>Connect to the database.</li>
    <li>Create a DynamicDBView called 'view' which analyzes the
        database structure at runtime and binds the query
        fields to a class called 'variant_row'.</li>
    <li>Send all rows from the view to the standard output
        stream 'cout' using the STL copy algorithm.<br>
        </li>
</ol>
<p>In addition to dynamic queries which examine the database at runtime, we also provide templates that allow
the user to bind database tables directly to their own objects. </p>
<br><a name="usermap"></a>
<p><h3><i>Mapping a Table to a User Defined Object in Four Easy Steps:</i></h3>
<p><font face="Times Roman">1. Define an object to hold the rows from your query.</font></p>

<p><font face="Times Roman">2. Define an association
between fields in your query and fields in your object. This is
what we call a 'BCA', which is short for Bind Column Addresses.
In the example below, this is done via the functor &quot;BCAExample&quot;.
The job of the BCA is to equate SQL fields with object fields via
the '==' operator which will then establish ODBC bindings to move
data to or from a user query.</font></p>

<p><font face="Times Roman">3. Create a view to select
records from. This view is built from the template DBView and
establishes which table(s) you want to access, what fields you
want to look at (via the BCA), and an optional where clause to
further limit the set of records that you are working with.</font></p>

<p><font face="Times Roman">4. Use the DBView container
to obtain an iterator to SELECT, INSERT, UPDATE or DELETE records
from your view. These iterators may be used to either populate
STL containers or apply algorithms from the Standard Template
library.<br></p>

<pre><code><strong>
In all the examples that follow we will assume that our database contains a table called DB_EXAMPLE of the form

SQL&gt; desc db_example;
Name                            Type
------------------------------- --------
INT_VALUE                       INTEGER
STRING_VALUE                    VARCHAR
DOUBLE_VALUE                    FLOAT
EXAMPLE_LONG                    INTEGER
EXAMPLE_DATE                    DATE

<span class="codeComment">// STEP 1 ////
// &quot;Example&quot; structure to hold rows from our database table</span>
struct Example
{
                                        <span class="codeComment">// tablename.columnname:</span>
	int exampleInt;                 <span class="codeComment">// DB_EXAMPLE.INT_VALUE</span>
	string exampleStr;              <span class="codeComment">// DB_EXAMPLE.STRING_VALUE</span>
	double exampleDouble;           <span class="codeComment">// DB_EXAMPLE.DOUBLE_VALUE</span>
	long exampleLong;               <span class="codeComment">// DB_EXAMPLE.EXAMPLE_LONG</span>
	TIMESTAMP_STRUCT exampleDate;   <span class="codeComment">// DB_EXAMPLE.EXAMPLE_DATE</span>
};

<span class="codeComment">// STEP 2 ////</span>
<span class="codeComment">// Create an association between table columns and fields in our object</span>
template&lt;&gt; class dtl::DefaultBCA&lt;Example&gt;
{
public:
	void operator()(BoundIOs &amp;cols, Example &amp;rowbuf)
    	{
	   cols[&quot;INT_VALUE&quot;] == rowbuf.exampleInt;
	   cols[&quot;STRING_VALUE&quot;] == rowbuf.exampleStr;
	   cols[&quot;DOUBLE_VALUE&quot;] == rowbuf.exampleDouble;
	   cols[&quot;EXAMPLE_LONG&quot;] == rowbuf.exampleLong;
	   cols[&quot;EXAMPLE_DATE&quot;] == rowbuf.exampleDate;
	}
};

<span class="codeComment">// STEP 3 &amp; 4
// Read the contents of the DB_EXAMPLE table and return a vector of the
// resulting rows</span>
vector&lt;Example&gt; ReadData() {
	// Read the data
	vector&lt;Example&gt; results;
	DBView&lt;Example&gt; view(&quot;DB_EXAMPLE&quot;);

	DBView&lt;Example&gt;::select_iterator read_it = view.begin();
	for ( ; read_it != view.end();  ++read_it)
	{
		results.push_back(*read_it);
	}
	return results;
}
</code></pre></strong>
<br></p>

<h3><a name="quickmap"></a><i>Quickly Mapping a Table to a Default Structure:</i></h3>
<p>The above process is a bit long-winded.  Sometimes you just want DTL to create a simple struct for you and
map it to a specified database table.  We have macros to do this.  The above ReadData() example can be done in a more abbreviated
fashion as follows: (here we also print the records to cout)</p>
<p><strong><pre><code><span class="codeComment">// Generate a simple structure to read data from a table called 'db_example' 
// with three fields called 'int_value', 'double_value' and 'string_value'.
// Note: the macro must be invoked at namespace scope because templates are 
// not allowed  to take locally declared classes as template parameters.  
// See [temp.arg.type] 14.3.1  in the C++ standard for details.</span>

<a href="table.htm">DTL_TABLE5</a>(db_example,
   int, int_value,
   std::string, string_value,
   double, double_value,
   long, example_long,
   jtime_c, example_date
);

<span class="codeComment">//Note that the field names in the table are the same as the member names in the structure</span>
vector&lt;db_example_row&gt; ReadData()
{
   cout &lt;&lt; &quot;Read rows from the database: &quot; &lt;&lt; endl;
   vector&lt;db_example_row&gt; results;

   for (db_example_view::select_iterator read_it = db_example.begin();
          read_it  != db_example.end(); ++read_it)
   {
       cout &lt;&lt; read_it-&gt;int_value &lt;&lt; &quot; &quot; 
                 &lt;&lt; read_it-&gt;string_value &lt;&lt; &quot; &quot; 
                 &lt;&lt; read_it-&gt;double_value &lt;&lt; &quot; &quot;
                 &lt;&lt; read_it-&gt;example_long &lt;&lt; &quot; &quot; 
                 &lt;&lt; read_it-&gt;example_date   
                 &lt;&lt; endl;

       results.push_back(*read_it);
   }

   return results;
}
</pre></code>
 </strong><br></p>

<br>
<a name="itertypes"></a><h3><i>Iterator Types:</i></h3>

  <font face="Times Roman">At this point, it is worth discussing the types of 
  iterators exposed by DBView. The iterators that DBView provides are either Input 
  iterators or Output iterators. In simple terms, an Input iterator can read elements, 
  but not write them. An Output iterator can write elements, but not read them. 
  These notions were first envisaged for working with C++ input and output streams 
  but they apply equally well to reading and writing table data. Input and Output 
  iterators are also minimal types of iterators in that they don't guarantee that 
  table records will be read in any kind of specific or consistent order and they 
  don't provide for random access in the sense that users cannot ask them to 'skip' 
  ahead a given number of records or go to a particular record number in the table. 
  An exact description of the functionality provided by Input and Output iterators 
  may be found at </font><a
href="http://www.sgi.com/tech/stl/InputIterator.html"><font
color="#0000FF" face="Times Roman"><u>http://www.sgi.com/tech/stl/InputIterator.html</u></font></a><font
color="#0000FF" face="Times Roman"> </font><font
face="Times Roman">and </font><a
href="http://www.sgi.com/tech/stl/OutputIterator.html"><font
color="#0000FF" face="Times Roman"><u>http://www.sgi.com/tech/stl/OutputIterator.html</u></font></a><font
color="#0000FF" face="Times Roman"> </font><font
face="Times Roman">.<br>
  By restricting the iterators from DBView to be either input or output iterators, 
  we are able to provide database access with a minimum amount of code overhead; 
  thereby ensuring that read and write operations remain efficient as compared 
  with raw ODBC calls. The iterators provided by DBView are as follows:<br>
  <br>
  <b>Input Iterators:<br>
  </b>select_iterator<br>
  select_update_iterator<br<
  sql_iterator</font></p>
<p><font
face="Times Roman"> <b>Output Iterators:<br>
  </b>insert_iterator<br>
  update_iterator<br>
  delete_iterator<br>
  select_update_iterator<br>
  sql_iterator</font></p>
<p><font
face="Times Roman"> To illustrate the use of an output iterator we show how a 
  vector of rows would be inserted into a table.<br>
  <br>
  <strong>
<pre><code><span class="codeComment">// Using a DBView to insert rows into a database</span>


<span class="codeComment">// ... Class definitions for Example and BCAExample as per our </span><a
href="DBViewReadData.htm">ReadData</a> <span class="codeComment">example .....

// Specialization of DefaultInsValidate for Example
// This defines a business rule we wish to enforce for all 
// Example objects before they are allowed to be inserted into the database</span>
template&lt;&gt; class dtl::DefaultInsValidate&lt;Example&gt; 
{
public:

	bool operator()(BoundIOs &amp;boundIOs, Example &amp;rowbuf) {	
		<span class="codeComment">// data is valid if rowbuf.exampleStr is nonempty and
		// rowbuf.exampleDouble is 
		// between 0 and 100 (like a percentage)</span>
		return (rowbuf.exampleStr.length() &gt; 0 &amp;&amp;  rowbuf.exampleDouble &gt;= 0.0 
			&amp;&amp; rowbuf.exampleLong  &lt;= 100.0);
	}
};


<span class="codeComment">// Insert rows from the vector&lt;Example&gt; parameter into the database</span>
void WriteData(const vector&lt;Example&gt; &amp;examples)
{
	DBView&lt;Example&gt; view(&quot;DB_EXAMPLE&quot;);
	DBView&lt;Example&gt;::insert_iterator write_it = view;

	<span class="codeComment">// loop through vector and write Example objects to DB</span>
	copy(examples.begin(), examples.end(), write_it);
}
</code></pre>

 </strong><br>
  <br>
  In WriteData() we have used an output iterator to insert records into our table 
  in much the same way that we used a read iterator to read records from a table. 
  In addition, this example introduces notion of client-side validation. Often, 
  when reading or writing records from a table we want to do client side validation 
  to make sure that the fields in a record are not null or lie within an acceptable 
  range of values. DBView supports this through SelValidate and InsValidate functions. 
  The SelValidate function validates records as they are selected from the database. 
  The InsValidate function validates records as they are inserted into the database. 
  In the example above, we define a DefaultInsValidate function which validates 
  records before insertion to make sure the exampleStr, exampleDouble and exampleLong 
  fields contain acceptable values before allowing them to be inserted into the 
  database. <br>
  <br>
  In general, the constructor for DBView&lt;class DataObj, class ParamObj = DefaultParamObj&lt;DataObj&gt&gt; 
  takes the form<br>
  <br>
  <b>DBView(const string &amp;tableList, const BCA &amp;bca_functor = DefaultBCA&lt;DataObj&gt;(),<br>
  const string &amp;postfix = &quot;&quot;, const BPA &amp;bpa_functor = DefaultBPA&lt;ParamObj&gt;(),<br>
  const SelVal sel_val = DefaultSelValidate&lt;DataObj&gt;(),<br>
  const InsVal ins_val = DefaultInsValidate&lt;DataObj&gt;(),<br>
  DBConnection &amp;connection = DBConnection::GetDefaultConnection())<br>
  </b><br>
  which allows the user to define table names, field names, a where clause, query 
  parameters, a selection validation function, an insert validation function and 
  a database connection to use when processing queries. If the user does not supply 
  a validation function then the default functions named DefaultSelValidate and 
  DefaultInsValidate will be called. To see how the postfix clause and parameters 
  work we will next examine a more complex case.<br>
  <br>
  <br>
  </font><a name="_Toc500425985"></a><font face="Arial"><b><i>A Second Example, 
  Parameterized Queries:<br>
  </i></b></font><font face="Times Roman">We now turn to a more general class 
  of queries; the case where we may be joining across multiple tables and/or have 
  join conditions that restrict the set of records to be retrieved.</font> <br>
  <strong><pre><code><span class="codeComment">// Using dynamic parameters to join two tables


// For purposes of illustration we introduce a table called DB_SAMPLE </span>

SQL&gt; desc db_sample;
Name				Type
------------------------------- -------- 
SAMPLE_LONG			LONG INTEGER
SAMPLE_INT			INTEGER
SAMPLE_STR			STRING
EXTRA_FLOAT			FLOAT

class JoinExample
{
private:
	                                <span class="codeComment">//tablename.columnname:</span>
	int exampleInt;                 <span class="codeComment">//DB_EXAMPLE.INT_VALUE</span>
	string exampleStr;              <span class="codeComment">//DB_EXAMPLE.STRING_VALUE</span>
	double exampleDouble;           <span class="codeComment">//DB_EXAMPLE.DOUBLE_VALUE</span>
	unsigned long sampleLong;       <span class="codeComment">//DB_SAMPLE.SAMPLE_LONG</span>
	double extraDouble;             <span class="codeComment">//DB_SAMPLE.EXTRA_FLOAT</span>

friend class BCAJoinExample;
friend class BPAJoinParamObj;
};

<span class="codeComment">// Here we define a custom parameter object for use with our JoinExample</span> 
class JoinParamObj
{
public:
	int intValue;
	string strValue;
	int sampleInt;
	string sampleStr;
};

<span class="codeComment">// BCA for JoinExample ... needed to store bindings between
// query fields and members in JoinExample objects</span>
class BCAJoinExample
{
public:
	void operator()(BoundIOs &amp;cols, JoinExample &amp;row)
	{
		cols[&quot;INT_VALUE&quot;] == row.exampleInt;
		cols[&quot;STRING_VALUE&quot;] == row.exampleStr;
		cols[&quot;DOUBLE_VALUE&quot;] == row.exampleDouble;
		cols[&quot;SAMPLE_LONG&quot;] == row.sampleLong;
		cols[&quot;EXTRA_FLOAT&quot;] ==row.extraDouble;
	}
};

<span class="codeComment">// BPA for JoinParamObj ... set SQL Query parameters from object</span>
class BPAJoinParamObj
{
public:
	void operator()(BoundIOs &amp;boundIOs, JoinParamObj &amp;paramObj)
	{
		params[0] == paramObj.intValue;
		params[1] == paramObj.strValue;
		params[2] == paramObj.sampleInt;
		params[3] == paramObj.sampleStr;
	}
};


<span class="codeComment">// Read JoinExample objects from the database using a query that
// joins the DB_EXAMPLE and DB_SAMPLE tables</span>
vector&lt;JoinExample&gt; ReadJoinedData()
{
	vector&lt;JoinExample&gt; results;

	<span class="codeComment">// construct view
	// note here that we use a custom parameter class for JoinExample
	// rather than DefaultParamObj&lt;JoinExample&gt;</span>

	DBView&lt;JoinExample, JoinParamObj&gt;
	view(&quot;DB_EXAMPLE, DB_SAMPLE&quot;,	BCAJoinExample(),
	&quot;WHERE (INT_VALUE = (?) AND STRING_VALUE = (?)) AND &quot;
	&quot;(SAMPLE_INT = (?) OR SAMPLE_STR = (?)) &quot;
	&quot;ORDER BY SAMPLE_LONG&quot;, BPAJoinParamObj());

	<span class="codeComment">// loop through query results and add them to our vector</span>
	DBView&lt;JoinExample, JoinParamObj&gt;::select_iterator read_it = view.begin();

	<span class="codeComment">// assign paramteter values as represented by the (?) placeholders
	// in the where clause for our view</span>
	read_it.Params().intValue = 3;
	read_it.Params().strValue = &quot;Join Example&quot;;
	read_it.Params().sampleInt = 1;
	read_it.Params().sampleStr = &quot;Joined Tables&quot;;

	for ( ; read_it != view.end(); read_it++)
	{ 
		results.push_back(*read_it);
	}

	return results;
}
</code></pre> </strong><br>
  <font face="Times Roman">This works in exactly the same way as the select iterator 
  shown previously. The only new elements here are that instead of a single table 
  name we provide a list of tables, we set a where clause, and we bind parameters 
  to fill in values for the clause. To bind parameters we first create what we 
  call a BPA, or Bind Parameter Addresses, functor. A BPA functor establishes 
  a correspondence between parameters that are identified in a postfix clause 
  by &quot;(?)&quot; and fields in a parameter object. If you examine the function 
  BPAJoinParamObj you will notice that unlike our BCA functor the parameter fields 
  are bound by number. This is partly because parameter fields do not have distinct 
  names the way that table fields do, and it is partly due to the fact that using 
  a number here allows the binding operator to distinguish between binding output 
  columns and input parameters. Observant readers will also note that our postfix 
  clause contains instructions to sort the retrieved objects in a particular manner 
  ( </font><font face="Fixedsys">&quot;ORDER BY SAMPLE_LONG&quot; </font><font face="Times Roman">). 
  In fact, the postfix clause need not contain a WHERE command at all. In practical 
  applications this might be simply a sorting statement or a GROUP BY clause, 
  and our 'field' names in the BCA functor may be SQL functions like </font><font face="Fixedsys">&quot;SUM(INT_VALUE)&quot; 
  </font><font face="Times Roman">instead of simple column names. The BCA and 
  BPA are specified as function objects, i.e. functors.<br>
  <br>
  <br>
  </font><a name="_Toc500425986"></a><font face="Arial"><b><i>Tables R Us, The 
  IndexedDBView:<br>
  </i></b></font><font face="Times Roman">In practice, the most common operations 
  performed on a set of table records are: read the records into a container, 
  search the records by different key fields (i.e. indexes), and delete, insert 
  or update records in the container. For this reason, we have developed a more 
  advanced container for holding database tables. This IndexedDBView container 
  is a specialization of a Unique Associative Container as defined by the standard 
  template library </font><a
href="http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html"><font
color="#0000FF" face="Times Roman"><u>http://www.sgi.com/tech/stl/UniqueAssociativeContainer.html</u></font></a><font
color="#0000FF" face="Times Roman"> </font><font
face="Times Roman">.<br>
  In addition to the base methods defined by the STL standard we have coded features 
  to make the container more copesetic with the underlying rows that it contains. 
  The main new features are the easy creation of indexes into rows and synchronization 
  capabilities that can automatically propagate any changes back to the database. 
  This container comes at a price. It incurs more overhead than the simple DBView 
  and because it works at a higher level you lose a bit of the fine-grained control 
  that you get with simple iterators. To explain, we begin with an example:<br>
  <br>
  </font></p>
<p></p>

<p><br>
<strong><pre><code><span class="codeComment">// &quot;Example&quot; class to hold rows from our database table</span>
class Example
{
  public:                                        <span class="codeComment">// tablename.columnname:</span>
	int exampleInt;                         <span class="codeComment">// DB_EXAMPLE.INT_VALUE</span>
	string exampleStr;                      <span class="codeComment">// DB_EXAMPLE.STRING_VALUE</span>
	double exampleDouble;                   <span class="codeComment">// DB_EXAMPLE.DOUBLE_VALUE</span>
	long exampleLong;                       <span class="codeComment">// DB_EXAMPLE.EXAMPLE_LONG</span>
	TIMESTAMP_STRUCT exampleDate;           <span class="codeComment">// DB_EXAMPLE.EXAMPLE_DATE</span>

	Example(int exInt, const string &amp;exStr, double exDouble, long exLong,
		const TIMESTAMP_STRUCT &amp;exDate) :
	   exampleInt(exInt), exampleStr(exStr), exampleDouble(exDouble), exampleLong(exLong),
	   exampleDate(exDate)
	{ }

};

<span class="codeComment">// Parameter object to hold parameters for dynamic SQL query below </span>
class ParamObjExample
{
    public:
	int lowIntValue;
	int highIntValue;
	string strValue;
	TIMESTAMP_STRUCT dateValue;
};

<span class="codeComment">// Create an association between table columns and fields in our object</span>
class BCAExampleObj
{
public:
	void operator()(BoundIOs &amp;boundIOs, Example &amp;rowbuf)
    	{
	   boundIOs[&quot;INT_VALUE&quot;]	== rowbuf.exampleInt;
	   boundIOs[&quot;STRING_VALUE&quot;]	== rowbuf.exampleStr;
	   boundIOs[&quot;DOUBLE_VALUE&quot;]	== rowbuf.exampleDouble;
	   boundIOs[&quot;EXAMPLE_LONG&quot;]	== rowbuf.exampleLong;
	   boundIOs[&quot;EXAMPLE_DATE&quot;]	== rowbuf.exampleDate;
	}
};

<span class="codeComment">// Create an association between query parameters and fields in our parameters object</span>
class BPAExampleObj
{
public:
	void operator()(BoundIOs &amp;boundIOs, ParamObjExample &amp;paramObj)
	{
	  boundIOs[0] == paramObj.lowIntValue;
	  boundIOs[1] == paramObj.highIntValue;
	  boundIOs[2] == paramObj.strValue;
	  boundIOs[3] == paramObj.dateValue;
	}

};

<span class="codeComment">// Set parameters function for Example ... used by IndexedDBView&lt;Example&gt; to set dynamic query parameters
// Dynamic query parameters are indicated by (?) in our query string for the IndexedDBView</span>
void SetParamsExample(ParamObjExample &amp;params)
{
	<span class="codeComment">// set parameter values</span>
	params.lowIntValue = 2;
	params.highIntValue = 8;
	params.strValue = &quot;Example&quot;;
	
	TIMESTAMP_STRUCT paramDate = {2000, 1, 1, 0, 0, 0, 0};
	params.dateValue = paramDate;
}


<span class="codeComment">// Example of using an IndexDBView to read, insert and update records in a container / database</span>
void IndexedViewExample()
{
	typedef DBView&lt;Example, ParamObjExample&gt; DBV;

	DBV view(&quot;DB_EXAMPLE&quot;,   BCAExampleObj(), 
	  &quot;WHERE INT_VALUE BETWEEN (?) AND (?) OR &quot;
	  &quot;STRING_VALUE = (?) OR EXAMPLE_DATE &lt;= (?) ORDER BY EXAMPLE_LONG&quot;,
	  BPAExampleObj());

	IndexedDBView&lt;DBV&gt; indexed_view(view, &quot;UNIQUE PrimaryIndex; STRING_VALUE; AlternateIndex; EXAMPLE_LONG, EXAMPLE_DATE&quot;, 
	  BOUND, USE_ALL_FIELDS, cb_ptr_fun(SetParamsExample));
   		

	<span class="codeComment">// Find the item where the STRING_VALUE matches the string &quot;Foozle&quot;</span>
	IndexedDBView&lt;DBV&gt;::iterator idxview_it = indexed_view.find(string(&quot;Foozle&quot;));
		

	<span class="codeComment">// Update the item with the key of &quot;Foozle&quot;, to read &quot;Fizzle&quot; instead</span>
	if (idxview_it != indexed_view.end()) {
		Example replacement;
		replacement = *idxview_it;
		replacement.exampleStr = &quot;Fizzle&quot;;
		indexed_view.replace(idxview_it, replacement);
	}

	<span class="codeComment">// Now find a second set of items using AlternateIndex
	// The STL convention for equal_range is to return a pair consisting of:  
	// 1. an iterator referring to the beginning of the list of found items
	// 2. an iterator pointing to the end of the list of found items. 
	// We will remove all items in this range.</span>
	const TIMESTAMP_STRUCT date_criteria = {2000, 1, 1, 0, 0, 0, 0};
	long long_criteria = 33;
	pair&lt;IndexedDBView&lt;DBV&gt;::iterator, IndexedDBView&lt;DBV&gt;::iterator&gt; pr = 
		indexed_view.equal_range_AK (&quot;AlternateIndex&quot;, long_criteria, date_criteria);

	idxview_it = pr.first;

	cout &lt;&lt; &quot;*** Size before erase calls: &quot; &lt;&lt; indexed_view.size() &lt;&lt; &quot; ***&quot;
	     &lt;&lt; endl;
		
	<span class="codeComment">// Remove all items that match the criteria in our equal_range_AK lookup</span>
	while (idxview_it != pr.second)
	{
		<span class="codeComment">// As iterator is invalidated upon an erase(), use a
		// temporary iterator to point to DataObj to erase.
		// Increment idxview_it before we erase so it will still be valid
		// when we erase the DataObj.</span>
		IndexedDBView&lt;DBV&gt;::iterator deleteMe = idxview_it;

		idxview_it++;

		indexed_view.erase(deleteMe);

	}

	cout &lt;&lt; &quot;*** Size after erase calls: &quot; &lt;&lt; indexed_view.size() &lt;&lt; &quot; ***&quot;
	     &lt;&lt; endl;


	<span class="codeComment">// Finally, insert a new item into the container</span>
	pair&lt;IndexedDBView&lt;DBV&gt;::iterator, bool&gt; ins_pr;

	ins_pr = indexed_view.insert(Example(459, &quot;Unique String #1&quot;, 3.4, 1, date_criteria));

	cout &lt;&lt; &quot;insertion succeded = &quot; &lt;&lt; (ins_pr.second == true ? &quot;true&quot;: &quot;false&quot;) &lt;&lt; endl;

}
</code></pre> </strong></p>

<p><font face="Times Roman"><br>
  To understand how IndexedDBView works we begin with the constructor definition<br>
  <br>
  </font><font face="Fixedsys">IndexedDBView(DBView&lt;DataObj, ParamObj&gt; &amp;view, 
  <br>
  const string &amp;IndexNamesAndFields,<br>
  BoundMode bm = UNBOUND, KeyMode km = USE_ALL_FIELDS, <br>
  SetParamsFn SetParams = NULL);<br>
  </font><font face="Times Roman"><br>
  <br>
  The first parameter here is a view object; this defines the SQL Query that will 
  be used to read and write records as described in the previous two examples. 
  The second parameter is IndexNamesAndFields; this defines indexes on the rows 
  in the container and we will examine it in more detail shortly. The BoundMode 
  and KeyMode control whether or not changes to the container data are synchronized 
  with the database, and if so what key fields are used for the synchronization. 
  If BoundMode = BOUND, then any changes to the container are sent to the database. 
  If BoundMode = UNBOUND then any changes to the container will only apply locally. 
  Finally, the SetParams function allows the user to pass in an explicit function 
  for setting parameters in the where clause for the view if they so desire.<br>
  <br>
  The IndexNamesAndFields parameter is interesting. IndexNamesAndFields is used 
  to automatically create named indexes into our rows. In the above example we 
  have <br>
  <br>
  </font><font face="Fixedsys">IndexNamesAndFields = &quot;UNIQUE PrimaryIndex; 
  STRING_VALUE; AlternateIndex; EXAMPLE_LONG, EXAMPLE_DATE&quot;;<br>
  </font><font face="Times Roman"><br>
  What this does is create two indexes on the data that is read into the container. 
  The first index is designated to be a UNIQUE with the name &quot;PrimaryIndex&quot; 
  and is based on the field called STRING_VALUE. Because this key is designated 
  as unique this forms a constraint on the container whereby every entry for (STRING_VALUE) 
  must be unique in order for the associated row to be added to the table. The 
  second index is created with the name &quot;AlternateIndex&quot; and is based 
  on the fields EXAMPLE_LONG and EXAMPLE_DATE. AlternateIndex is not designated 
  to be unique here and is created only to provide a way to quickly look up rows 
  based on the values in the EXAMPLE_LONG and EXAMPLE_DATE fields.<br>
  <br>
  Why do we care about this? Doesn't the normal STL associative container already 
  provide lookup and retrieval using keys? Well, the normal associative containers 
  in STL have two limitations that we found quite tedious to work with in practice. 
  The first limitation is that if you want an STL container to provide lookup 
  capabilities then you need to manually write comparison functions for each class 
  and index that you want to use. As the number of tables and indexes grow, manually 
  maintaining these comparison functions gets to be a bit tedious. The IndexNamesAndFields 
  syntax can automatically create indexes given a list of field names. The internal 
  comparison functions that are created are slightly slower than using hand made 
  comparison operators, but, the performance difference is not that great and 
  we feel that the loss is more than made up for by the increased ease of use 
  and maintainability. The second limitation is that the STL containers only support 
  a single index on the data. We found this rather confining since we often want 
  to be able to search the same set of rows quickly using various subsets of the 
  row fields. For this reason, IndexNamesAndFields allows you to create multiple 
  indexes on the rows in your container. To see how these features are used to 
  search based on the PrimaryIndex and AlternateIndex we examine the following 
  lines from the above example:<br>
  <br>
  </font><font face="Fixedsys">idxview_it = indexed_view.find(string(&quot;Foozle&quot;));<br>
  <br>
  pr = indexed_view.equal_range_AK(&quot;IndexLongDate&quot;, long_criteria, date_criteria);<br>
  <br>
  </font><font face="Times Roman">Standard STL containers provide a find method 
  to locate objects in the container. This method is typically defined as follows:<br>
  <br>
  <i>container&lt; DataObj &gt;::find<br>
  </i></font><font face="Courier"><i><tt>const_iterator </tt></i><b><i><tt>find</tt></i></b><i><tt>(const 
  </tt></i></font><font face="Times Roman"><i>DataObj </i></font><font
face="Courier"><i><tt>&amp; key) const;<br>
  </tt></i></font><font face="Times Roman"><i>The find member function returns 
  an iterator that designates the earliest element in the controlled sequence 
  whose sort key equals </i></font><font
face="Courier"><i><tt>key</tt></i> </font><font
face="Times Roman"><i>. If no such element exists, the iterator equals end().<br>
  </i><br>
  In the IndexedDBView container, we overload the find() function with multiple 
  versions :<br>
  <br>
  template&lt;class DataField&gt; indexed_iterator find(const DataField &amp;df1); 
  // One field find<br>
  template&lt;class DataField1, class DataField2&gt; indexed_iterator find(const 
  DataField1 &amp;df1, const DataField2 &amp;df2); // Two field find<br>
  template&lt;class DataField1, class DataField2, class DataField3&gt; 
  indexed_iterator find(const DataField1 &amp;df1, const DataField2 &amp;df2, 
  const DataField &amp;df3);<br>
  <br>
  // Four field find, five field find, etc.<br>
  <br>
  indexed_iterator find(const DataObj &amp;key) // Standard find <br>
  <br>
  As per the standard, we provide a find(DataObj) method to locate elements in 
  the container. Our default find method uses the first index passed into the 
  IndexDBView constructor to locate objects, and will return a match based only 
  on the fields in that index. In addition to the default find method, we have 
  added overloaded versions of the find method to perform a find using only the 
  fields needed by the index. For example, in the case of </font><font
face="Fixedsys">indexed_view.find(string(&quot;Foozle&quot;)) </font><font
face="Times Roman">, the find() function resolves to find&lt;DataField&gt; (const 
  DataField &amp;df1). This is useful, because it allows us to execute a find 
  by directly supplying the criteria fields that we care about rather than having 
  to manually initialize an entire data object just to perform a find operation.<br>
  <br>
  In addition to find() operations using the primary index, we can also find an 
  object based upon any of the indexes named in the constructor for IndexDBView. 
  This is done via the find_AK function. For example, we could say </font><font face="Fixedsys">indexed_view.find_AK(&quot;AlternateIndex&quot;, 
  long_criteria, date_criteria) </font><font face="Times Roman">, which would 
  find the first element that matches the criteria provided by long_criteria and 
  date_criteria using the fields named in the &quot;AlternateIndex&quot; to determine 
  if we have a match.<br>
  <br>
  Finally, you will notice that the above code has calls to insert(), replace() 
  and erase() methods for IndexedDBView. One major difference between the IndexedDBView 
  container and a standard container is that any changes made to the items in 
  our container can be automatically propagated back to the database. If we construct 
  the container to initialize in what we call &quot;Bound&quot; mode then any 
  changes made to the container are also sent to the database. In our example, 
  when we call the erase() method, this removes the item in the container and 
  also deletes the underlying record in the database. Similarly, insert() and 
  replace() will modify both container and the database.<br>
  <br>
  <br>
  </font><a name="_Toc500425987"></a><font face="Arial"><b><i>When you don't know 
  column names or types until runtime, dynamic queries:<br>
  </i></b></font><font face="Times Roman">The queries shown above assume that 
  you know exactly what your target table looks like and are able to define static 
  objects to go against known fields in these tables. In practice, you often end 
  up in the situation where you have a query with an unknown number of columns 
  with unknown types and you want to bind a dynamic object to this query. To solve 
  this problem, our library has two additional containers called DynamicDBView 
  and DynamicIndexedDBView which perform binding to a variant row class. This 
  variant row class allows for an arbitrary number of fields, with each field 
  being of an arbitrary type</font><a href="#FNT1"><font size="2"
face="Times Roman"><sup>[1]</sup></font></a><font
face="Times Roman">. The type and number of fields in variant row are determined 
  at run-time by querying the underlying database to find the number of fields 
  in the query and the type of each field that is to be returned. To illustrate, 
  we present an example:<br>
  <br>
  <strong>
<pre><code><span class="codeComment">// Using a DynamicDBView to read rows from the database.

// Read the contents of a table and print the resulting rows</span>
void SimpleDynamicRead() {

	<span class="codeComment">// Our query will be &quot;SELECT * FROM DB_EXAMPLE&quot;</span>
	DynamicDBView&lt;&gt; view(&quot;DB_EXAMPLE&quot;, &quot;*&quot;);

	<span class="codeComment">// NOTE: We need to construct r from the view itself since we
	// don't know what fields the table will contain.
	// We therefore make a call to the DataObj() function to have the
	// table return us a template row with the correct number of fields
	// and field types.
	// We use this construction since we can't be guaranteed that the table
	// is non-empty &amp; we want to still display column names in this case.</span>
	variant_row s(view.GetDataObj());

	<span class="codeComment">// Print out the column names</span>
	vector&lt;string&gt; colNames = s.GetNames();
	for (vector&lt;string&gt;::iterator name_it = colNames.begin(); name_it != colNames.end(); name_it++)
	{
		cout &lt;&lt; (*name_it) &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;

	<span class="codeComment">// Print out all rows and columns from our query</span>
	DynamicDBView&lt;&gt;::select_iterator print_it = view.begin();
	for (print_it = view.begin(); print_it != view.end(); print_it++)
	{
		variant_row r = *print_it;
		for (size_t i = 0; i &lt; r.size(); i++)
		{
			cout &lt;&lt; r[i] &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
	}
}</code></pre>
 </strong><br>
  <br>
  Unlike the DBView code presented above, in DynamicDBView there is no notion 
  of a BCA to bind records to a particular class since the assumption is that 
  DynamicDBView will always bind to a variant_row object. Therefore, the DynamicDBView 
  is constructed by specifying a table name and a list of fields to select from 
  the table (in this case we use &quot;*&quot; to specify all fields in the table). 
  When we go to retrieve rows from our table, the row iterator returns </font><font face="Fixedsys">variant_row 
  </font><font face="Times Roman">objects. Essentially, </font><font
face="Fixedsys">variant_row </font><font face="Times Roman">is an array of varying 
  types designed to hold the fields from our query. </font><font face="Fixedsys">variant_row 
  </font><font
face="Times Roman">is constructed when the query is first executed, at which time 
  the view interrogates the database in order to find out the number and types 
  of fields that will be returned. Here we use three methods from </font><font
face="Fixedsys">variant_row </font><font face="Times Roman">in order to display 
  our results.<br>
  First, we call </font><font face="Fixedsys">GetNames() </font><font
face="Times Roman">in order to obtain a vector of the field names in our query. 
  To retrieve the field names, we must first initialize a </font><font face="Fixedsys">variant_row 
  </font><font
face="Times Roman">object from the view:<br>
  <br>
  </font><font face="Fixedsys">variant_row s(view.GetDataObj());<br>
  <br>
  </font><font face="Times Roman">It is crucial that we initialize all </font><font face="Fixedsys">variant_row 
  </font><font
face="Times Roman">objects that we want to use from our view class. This is because 
  a single </font><font face="Fixedsys">variant_row </font><font face="Times Roman">object 
  is shared by all dynamic views and therefore they have to initialize their particular 
  version at runtime to tell </font><font face="Fixedsys">variant_row </font><font face="Times Roman">what 
  fields it will need to hold from the query. The second method that we use from 
  </font><font
face="Fixedsys">variant_row </font><font face="Times Roman">is the </font><font face="Fixedsys">size() 
  </font><font
face="Times Roman">method. This returns the number of fields in our row. Finally, 
  we access individual fields within a row via the </font><font face="Fixedsys">[] 
  </font><font
face="Times Roman">operator. The </font><font face="Fixedsys">[] </font><font
face="Times Roman">operator returns a </font><font
face="Fixedsys">variant_field </font><font face="Times Roman">object that we can 
  use to read, write or print individual fields. Individual fields may be specified 
  by either field name or field number. To illustrate, we continue with a second 
  example that uses DynamicIndexedDBView. What this example does is to repeat 
  the IndexedViewExample code shown above; but it uses a </font><font
face="Fixedsys">variant_row </font><font face="Times Roman">object to do all its 
  work rather than a specialized Example class.<br>
  <br>
  <strong>
<pre><code><span class="codeComment">// Using a DynamicIndexedDBView to read, update and insert records in a database.

// Dynamic IndexedDBView example

// ... classes as in </span></code><span class="codeComment"><a href="IndexedDBViewExample.htm"><code>IndexedDBView example</code></a> <code> ....</code></span><code>

void DynamicIndexedViewExample()
{
 DynamicDBView&lt;ParamObjExample&gt; dynamic_view(&quot;DB_EXAMPLE&quot;,
	 &quot;INT_VALUE, STRING_VALUE, DOUBLE_VALUE, EXAMPLE_LONG,  EXAMPLE_DATE&quot;,
	 &quot;WHERE INT_VALUE BETWEEN (?) AND (?) OR &quot;
	  &quot;STRING_VALUE = (?) OR EXAMPLE_DATE &lt;= (?) ORDER BY EXAMPLE_LONG&quot;,
	  BPAExampleObj());

 DynamicIndexedDBView&lt; DynamicDBView&lt;ParamObjExample&gt; &gt;  
	 indexed_view(dynamic_view, 
         &quot;UNIQUE PrimaryIndex; STRING_VALUE;&quot;
         &quot;IndexLongDate; EXAMPLE_LONG, EXAMPLE_DATE&quot;,
	 BOUND, USE_ALL_FIELDS, cb_ptr_fun(SetParamsExample));

 <span class="codeComment">// Find the item where the STRING_VALUE matches the string  &quot;Foozle&quot;</span>
 DynamicIndexedDBView&lt; DynamicDBView&lt;ParamObjExample&gt; &gt;::iterator idxview_it =  indexed_view.find(string(&quot;Foozle&quot;));


 <span class="codeComment">// Update the item with the key of &quot;Foozle&quot;, to read  &quot;Fizzle&quot; instead</span>
 if (idxview_it != indexed_view.end()) {
  variant_row replacement;
  replacement = *idxview_it;
  replacement[&quot;STRING_VALUE&quot;] =   string(&quot;Fizzle&quot;);
  indexed_view.replace(idxview_it, replacement);
 }

 <span class="codeComment">// Now find a second set of items using AlternateIndex
 // The STL convention for equal_range is to return a pair  consisting of: 
 // 1. an iterator referring to the beginning of the list of found  items
 // 2. an iterator pointing to the end of the list of found items. 
 // We will remove all items in this range.</span>
 const TIMESTAMP_STRUCT date_criteria = {2000, 1, 1, 0, 0, 0, 0};
 long long_criteria = 33;
 pair&lt;DynamicIndexedDBView&lt;DynamicDBView&lt;ParamObjExample&gt; &gt;::iterator,
	 DynamicIndexedDBView&lt;DynamicDBView&lt;ParamObjExample&gt; &gt;::iterator&gt;
   	 pr = indexed_view.equal_range_AK(&quot;IndexLongDate&quot;, long_criteria, date_criteria);

 idxview_it = pr.first;

 cout << "*** Size before erase calls: " &lt;&lt; indexed_view.size() &lt;&lt; " ***" &lt;&lt; endl; 

 <span class="codeComment">// Remove all rows that matched the criteria in our equal_range_AK lookup </span>
 while (idxview_it !="pr.second)" { 
   <span class="codeComment">// as iterator is invalidated upon an erase(), use a temporary iterator 
   // to point to DataObj to erase 
   // increment idxview_it before we erase so it will still be valid 
   // when we erase the DataObj </span>
   DynamicIndexedDBView&lt; DynamicDBView&lt;ParamObjExample&gt; &gt;::iterator deleteMe = idxview_it; 
   idxview_it++; 
   indexed_view.erase(deleteMe); 
 } 
 cout &lt;&lt; "*** Size after erase calls: " &lt;&lt; indexed_view.size() &lt;&lt; " ***" &lt;&lt; endl; 
 
 <span class="codeComment">// Finally, insert a new item into the container </span>
 pair&lt;DynamicIndexedDBView&lt; DynamicDBView&lt;ParamObjExample&gt; &gt;::iterator, bool&gt; ins_pr; 
 
 variant_row r(indexed_view.GetDataObj()); 
 r["INT_VALUE"]=459; 
 r["STRING_VALUE"]=string(&quot;Unique String #1&quot;); 
 r["DOUBLE_VALUE"]=3.5; 
 r["EXAMPLE_LONG"]=1; 
 r["EXAMPLE_DATE"]=date_criteria; 
 ins_pr=indexed_view.insert(r);
 cout &lt;&lt; "insertion succeded=" &lt;&lt;  (ins_pr.second == true ? " true": " false") &lt;&lt; endl; 
}</code></pre>

 </strong><br>
  </font><a name="_Toc500425988"></a><font face="Arial"><em><strong>Using STL 
  Algorithms, the Table Difference Function:</strong></em><b><i><br>
  </i></b></font><font face="Times Roman">As a final example, we show how our 
  library's compliance with the STL standards allows us to take easy advantage 
  of native STL algorithms. If we pass two table containers to the function below, 
  it can use the standard STL algorithms to easily perform a 'difference' operation 
  showing any changed records in the tables.</font></p>

<pre><font face="Times Roman"><code><strong>
<span class="codeComment">// Table difference function.
// Takes two containers and prints out the differences (via set difference) between the containers.
// container 1 = &quot;original&quot; values, container 2 = &quot;new&quot; values</span>
template&lt;class Container&gt; void TableDiff(ostream &amp;o, const Container &amp;cont1, const Container &amp;cont2)
{
   typedef Container::value_type value_type;

   <span class="codeComment">// copy container data into sets as set_symmetric_difference needs a sorted list to do its work</span>
   multiset&lt;value_type&gt; set1;
   multiset&lt;value_type&gt; set2;

   <span class="codeComment">// Slight workaround here, M$ compiler 6.0 STL library can only work with pointers not iterators
   // Therefore, cannot do this at set construction time as recommended by the standard</span>
   copy(cont1.begin(), cont1.end(), inserter(set1, set1.begin()));
   copy(cont2.begin(), cont2.end(), inserter(set2, set2.begin()));

   <span class="codeComment">// Show set1 - set2 = deleted / changed items</span>
   o &lt;&lt; &quot;deleted / changed items:&quot; &lt;&lt; endl;
   set_difference(set1.begin(), set1.end(), set2.begin(), set2.end(),
				  ostream_iterator&lt;value_type&gt;(o, &quot;\n&quot;));
  
   <span class="codeComment">// Show set2 - set1 = inserted / changed items</span>
   o &lt;&lt; &quot;inserted / changed items:&quot; &lt;&lt; endl;
   set_difference(set2.begin(), set2.end(), set1.begin(), set1.end(),
				  ostream_iterator&lt;value_type&gt;(o, &quot;\n&quot;));

#if 0
   <span class="codeComment">// Show all differences as single set</span>
   set_symmetric_difference(set1.begin(), set1.end(), set2.begin(), set2.end(),
				  ostream_iterator&lt;value_type&gt;(o, &quot;\n&quot;));
#endif
}
</strong></code></font></pre>

<pre><font face="Times Roman"><code><strong>
<span class="codeComment">// Show the difference between the rows in two tables</span>
void TestTableDiff()
{
  <span class="codeComment">// Use two DBViews to directly difference the contents of two tables</span>
  DBView&lt;Example&gt; new_table(&quot;DB_EXAMPLE&quot;);
  DBView&lt;Example&gt; old_table(&quot;DB_EXAMPLE_BACKUP&quot;);
  TableDiff(cout, old_table, new_table);

  cout &lt;&lt; &quot;--- should be same for IndexedDBViews --- &quot; &lt;&lt; endl;

  <span class="codeComment">// now do the same thing for an IndexedDBView</span>
  IndexedDBView&lt;DBView&lt;Example&gt; &gt; new_idx_table(new_table, &quot;PrimaryIndex; STRING_VALUE&quot;);
  IndexedDBView&lt;DBView&lt;Example&gt; &gt; old_idx_table(old_table, &quot;PrimaryIndex; STRING_VALUE&quot;);
  TableDiff(cout, old_idx_table, new_idx_table);

}
</strong></code></font></pre>

<p><font face="Times Roman"><br>
</font><a name="_Toc500425989"></a><font face="Arial"><b><i>Conclusion:<br>
</i></b></font><font face="Times Roman">In the foregoing article
we presented an STL centric paradigm for reading, writing and
updating table data from an ODBC data source. The library we
presented is centered around the notion of representing database
table operations via standard STL iterators and containers. Our
presentation was at an overview level for these iterators and
containers; full technical details have been left to the
reference documentation that we provide with the library. The
advantage of following the STL iterator and container paradigm is
that we are able to plug our database abstractions into a wide
variety of STL algorithms for data storage, indexing and
manipulation. In addition, the C++ reflection mechanism that we
introduced to bind iterators to database tables allows us to add
powerful automatic indexing and lookup features to our container
representations.<br>
<br>
<br>
</font></p>

<hr align="left">

<p><a name="FNT1"></a></p>

<p><font face="Times Roman">[1] Our variant row type uses a
template mechanism to be able to hold values of common database
types. It is loosely based on the variant_t class proposed by
Fernando Cacciola. See F. Cacciola (2000). &quot;An Improved
Variant Type Based on Member Templates,&quot; <i>C++ Users
Journal</i> Oct 2000, p. 10.</font> </p>

<p>
<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright  2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body> </p>
</html>
