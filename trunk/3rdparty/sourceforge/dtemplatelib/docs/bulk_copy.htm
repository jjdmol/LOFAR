<html>  
<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>bulk_copy</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p> 
<h1>bulk_copy</h1>


















<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td><img src="functors.gif" width="194" height="38"></td>
        <td align="right"><img src="concept.gif" width="194"
        height="39"></td>
    </tr>
    <tr>
        <td valign="top"><b>Category</b>: functors</td>
        <td align="right" valign="top"><b>Component type</b>:
        concept</td>
    </tr>
</table><h3>Prototypes</h3>
<h4><font face="Courier New, Courier, mono" size="2">SELECT</font></h4>
<p><font face="Courier New, Courier, mono" size="2">template&lt;class </font><font face="Courier New, Courier, mono"><font face="Courier New, Courier, mono" size="2">ItType</font><font size="2"></font></font><font face="Courier New, Courier, mono" size="2">, 
  class DataObj&gt; void bulk_copy(</font><font face="Courier New, Courier, mono"><font face="Courier New, Courier, mono"><font face="Courier New, Courier, mono" size="2">ItType</font></font><font size="2"></font></font><font face="Courier New, Courier, mono" size="2"> 
  &amp;</font><font face="Courier New, Courier, mono"><font size="2"><a href="select_iterator.htm">select_iterator</a></font></font><font face="Courier New, Courier, mono" size="2">, 
  DataObj *begin, DataObj *end, bool bValidate = true, size_t row_size = sizeof(DataObj));</font></p>
<h4><font face="Courier New, Courier, mono" size="2">INSERT</font></h4>
<p><font face="Courier New, Courier, mono" size="2">template&lt;class </font><font face="Courier New, Courier, mono"><font face="Courier New, Courier, mono"><font face="Courier New, Courier, mono" size="2">ItType</font></font><font size="2"></font></font><font face="Courier New, Courier, mono" size="2">, 
  class DataObj&gt; void bulk_copy(DataObj *begin, DataObj *end, </font><font face="Courier New, Courier, mono"><font face="Courier New, Courier, mono"><font face="Courier New, Courier, mono" size="2">ItType</font></font><font size="2"></font></font><font face="Courier New, Courier, mono" size="2"> 
  &amp;</font><font face="Courier New, Courier, mono"><font size="2"><a href="insert_iterator.htm">insert_iterator</a></font></font><font face="Courier New, Courier, mono" size="2"></font><font face="Courier New, Courier, mono" size="2">, 
  bool bValidate = true, size_t row_size = sizeof(DataObj)</font><font face="Courier New, Courier, mono" size="2">);</font></p>
<h3>Description</h3>

<p>This algorithm uses bulk ODBC operations to read or write records. If you have 
  many records that you need to read or insert, consider using this routine. The 
  standard DTL iterators operate on one record at a time which is slower than 
  working on many records at once. Bulk operations work on an array of records, 
  saving time in both function calls and database access since the data can be 
  buffered more efficiently. DTL supports bulk inserts and bulk fetches through 
  the use of<font face="Courier New, Courier, mono" size="2"> bulk_copy()</font>. 
  The<font face="Courier New, Courier, mono" size="2"> bValidate</font> parameter 
  specifies whether to call a validation routine when reading or writing records. 
  <font face="Courier New, Courier, mono" size="2">When bValidate is set to true, 
  SelValidate() is called </font> on each element for bulk selects and <font size="2" face="Courier New, Courier, mono">InsValidate()</font>is 
  called on each element for bulk inserts. To increase the speed of <font face="Courier New, Courier, mono" size="2">bulk_copy()</font>, 
  use char arrays or <font face="Courier New, Courier, mono" size="2">tcstring&lt;N&gt;</font> 
  to represent strings instead of <font size="2" face="Courier New, Courier, mono">std::string</font>; 
  this is because<font face="Courier New, Courier, mono" size="2"> std::string 
  <font size="3"> <font face="Times New Roman, Times, serif">really hurts performance 
  since it must make many ODBC</font></font> GetData()</font> and <font face="Courier New, Courier, mono" size="2">PutData()</font> 
  calls to support arbitrary length strings. DTL provides a special <a href="IOHandler.htm"><font face="Courier New, Courier, mono" size="2">IOHandler</font></a><font face="Courier New, Courier, mono" size="2"> 
  </font>for bulk fetches called <a href="BulkFetchHandler.htm"><font face="Courier New, Courier, mono" size="2">BulkFetchHandler</font></a> 
  which records the indexes of which elements read failed validation. <b> NOTE! 
  The bulk insert function uses an ODBC 3.0 feature called row-wise arrays of 
  parameters to provide fast inserts. Not all drivers are fully ODBC 3.0 compliant 
  so some ODBC drivers will fail when you attempt to use this method. For this 
  reason, if your code needs to be portable across multiple driver types you will 
  want to provide some kind of failover logic when you use this method.</b></p>
<h3>Helper Functions</h3>
<p>The raw <font face="Courier New, Courier, mono" size="2">bulk_copy()</font> 
  algorithms that DTL provides come with several inconveniences or restrictions:</p>
<ul>
  <li>The input/output range for the data in memory must always be a contiguous 
    block, restricting the passed in range to be pointers into a C array or a 
    <font size="2"> <font face="Courier New, Courier, mono">std::vector</font></font>. 
    This makes the interface of the bulk algorithms not as flexible as standard 
    STL algorithms which always accept iterators of certain categories.</li>
  <li>Due to restrictions in ODBC for bulk operations, <font face="Courier New, Courier, mono" size="2">sizeof(DataObj)</font> 
    must always be greater than both the <font face="Courier New, Courier, mono" size="2">sizeof(SQLINTEGER)</font> 
    and <font face="Courier New, Courier, mono" size="2">sizeof(TIMESTAMP_STRUCT)</font>. 
    This means the user needs to pad his <font face="Courier New, Courier, mono" size="2">DataObj</font> 
    with extra bytes at the end of the object for the bulk copy to work. Otherwise, 
    he'll get a surprising exception saying that he needs to pad his object. The 
    <font size="2"> <font face="Courier New, Courier, mono">bulk_copy()</font></font> 
    algorithms allow the user to pass in a row size to tell the algorithm how 
    big the object plus padding actually is to aid the processing of the bulk 
    operation, but this doesn't make life much easier for the user. Thus, trying 
    to bulk copy a <font face="Courier New, Courier, mono" size="2">DBView&lt;int&gt;</font> 
    would be impossible without wrapping the<font face="Courier New, Courier, mono" size="2"> 
    int </font>along with padding in a struct and then bulk copying a view of 
    that wrapper object. </li>
</ul>
<p>DTL provides helpers both for bulk fetch and bulk insert that resolve both 
  of these problems:</p>
<pre><font face="Courier New, Courier, mono" size="2">// buffer_size is the number of objects to copy in</font><font face="Courier New, Courier, mono" size="2">
// each call to bulk_copy() within the helper</font></pre>
<pre><font face="Courier New, Courier, mono" size="2">template&lt;class SelectIterator, class OutputIterator&gt; 
   void bulk_fetch_helper(SelectIterator read_it, 
   size_t buffer_size, OutputIterator output);</font></pre>
<pre><font face="Courier New, Courier, mono" size="2">template&lt;class InputIterator, class InsertIterator&gt; 
   void bulk_insert_helper(InputIterator beg, InputIterator end, 
   size_t buffer_size, InsertIterator ins_it);</font></pre>
<p>The bulk fetch helper writes out to any output iterator while the bulk insert 
  helper reads from any half-open range specified by two input iterators. The 
  helpers also take care of padding the <font face="Courier New, Courier, mono" size="2">DataObj</font>'s 
  with extra bytes internally so that the user doesn't have to clutter up the 
  actual object structure with filler or worry about the padding exception from 
  being thrown. For example, copying from a list of ints to the database is now 
  as simple as creating a <font face="Courier New, Courier, mono" size="2">DBView&lt;int&gt;</font> 
  and calling <font face="Courier New, Courier, mono" size="2">bulk_insert_helper()</font>:</p>
<pre><font face="Courier New, Courier, mono" size="2">list&lt;int&gt; int_list;

// ... insert ints into int_list ...

// now write the ints to the DB in bulk
// write to table which has just single column INT_VALUE
// (will copy 100 ints in each internal bulk_copy() call in the helper)
int myInt;</font><font face="Courier New, Courier, mono" size="2">
DBView&lt;int&gt; i</font><font face="Courier New, Courier, mono" size="2">nt_view("INT_EXAMPLE",  BCA(myInt, COLS["INT_VALUE"] == myInt)); 
DBView&lt;int&gt;::insert_iterator ins_it(int_view);
bulk_insert_helper(int_list.begin(), int_list.end(), 100, ins_it);</font>  </pre>
<p>The helpers have a lot of extra overhead than the raw <font face="Courier New, Courier, mono" size="2">bulk_copy()</font> 
  algorithms because the helpers must call the constructors and destructors manually 
  for each object in the internal buffer it uses for its calls to <font face="Courier New, Courier, mono" size="2">bulk_copy()</font> 
  and the copying of objects into or out of the buffer into the input/output range 
  passed in to the helper. So if you know you don't need the extra capabilities 
  provided by the helpers, just use the raw <font face="Courier New, Courier, mono" size="2">bulk_copy()</font> 
  algorithms as they are much more efficient than the helpers.</p>
<h3>Definition</h3>
<p>Defined in the <font size="2" face="Courier New">dtl_algo.h </font><font size="3">header 
  file with calls appropriately forwarded to<font face="Courier New, Courier, mono" size="2"> 
  bulk_copy() </font>members in <font size="2" face="Courier New, Courier, mono">select_iterator.h</font> 
  and <font size="2" face="Courier New, Courier, mono">insert_iterator.h</font>.</font></p>

<h3>Refinement of</h3>

<p>None.</p>

<h3>Associated types</h3>

<p> <font face="Courier New, Courier, mono"> <font size="2"><a href="select_iterator.htm">select_iterator</a>, 
  <a href="insert_iterator.htm">insert_iterator</a>, <a href="BulkFetchHandler.htm">BulkFetchHandler</a></font></font></p>

<h3><font face="Times New Roman, Times, serif">Template parameters</font></h3>
<table border="1">
  <tr> 
    <th>Parameter </th>
    <th>Description </th>
    <th>Default </th>
  </tr>
  <tr> 
    <td valign="top"><tt>ItType</tt></td>
    <td valign="top">The type of the <font face="Courier New, Courier, mono" size="2">DBView</font> 
      iterator to use for the bulk operation. For a bulk fetch, this type must 
      be a<font face="Courier New, Courier, mono" size="2"> select_iterator <font face="Times New Roman, Times, serif" size="3">and 
      the iterator's</font> <font face="Times New Roman, Times, serif" size="3">value 
      type</font> <font face="Times New Roman, Times, serif" size="3">must be 
      a</font> DataObj</font>. For bulk insert, the iterator type needs to be 
      an<font size="2" face="Courier New, Courier, mono"> insert_iterator <font face="Times New Roman, Times, serif" size="3">and 
      <font size="2"> <font face="Courier New, Courier, mono">DataObj </font></font>must 
      be the iterator's value type</font></font>.</td>
    <td valign="top">&nbsp; </td>
  </tr>
  <tr>
    <td valign="top"><font face="Courier New, Courier, mono" size="2">DataObj</font></td>
    <td valign="top">The data object type being read or written through the bulk 
      operation. <font face="Courier New, Courier, mono" size="2">DataObj</font> 
      must not be <font face="Courier New, Courier, mono" size="2">variant_row</font>.</td>
    <td valign="top">&nbsp;</td>
  </tr>
</table>
<h3>Preconditions</h3>
<ul>
  <li>The range specified by<font face="Courier New, Courier, mono" size="2"> 
    [begin, end)</font> is a contiguous array of <font face="Courier New, Courier, mono" size="2">DataObj</font>'s 
    in memory.</li>
  <li>After the first call to<font face="Courier New, Courier, mono" size="2"> 
    bulk_copy() </font>using a particular <font face="Courier New, Courier, mono" size="2">DataObj 
    </font>range, all future <font face="Courier New, Courier, mono" size="2">bulk_copy() 
    </font>calls using the same DTL iterator must use a <font size="2" face="Courier New, Courier, mono">DataObj</font> 
    range containing the same number of elements as in the initial call. Note 
    that the actual range itself can be a different block of memory than passed 
    to the first call.</li>
  <li>In general, you must have <font face="Courier New, Courier, mono" size="2">sizeof(DataObj) 
    &gt; sizeof(SQLINTEGER) * # columns in view</font>. This restriction is in 
    place because of how DTL implements <font face="Courier New, Courier, mono" size="2">bulk_copy()</font>. 
    If your <font face="Courier New, Courier, mono" size="2">DataObj</font> doesn't 
    meet this preconditon, pad it with extra bytes at the end of the object.</li>
  <li>Similarly, you must also have <font face="Courier New, Courier, mono" size="2">sizeof(DataObj) 
    &gt; sizeof(TIMESTAMP_STRUCT) * # of dates in view</font>.</li>
</ul>
<h3>Example</h3>
<h3></h3>
<h3></h3>
<h3></h3>
<pre><code>// bulk select
Example examples[20]; // buffer used to hold example objects read from DB
DBView&lt;Example&gt; view(&quot;DB_EXAMPLE&quot;);
DBView&lt;Example&gt;::select_iterator sel_it = view.begin();
bulk_copy(sel_it, &amp;examples[0], &amp;examples[20]); <span class="codeComment">// read 20 Examples
// ... do something with those 20 example objects ...
// ...</span>
bulk_copy(sel_it, &amp;examples[0], &amp;examples[20]); <span class="codeComment">// read 20 more Examples

// bulk insert</span>
Example ins_examples[20]; <span class="codeComment">// example objects to insert into the DB</span>
DBView&lt;Example&gt; view2(&quot;DB_EXAMPLE&quot;);
DBView&lt;Example&gt;::insert_iterator ins_it = view;
<span class="codeComment">// ... populate ins_examples with some data ...
// ...</span>
bulk_copy(&amp;examples[0], &amp;examples[20], ins_it); <span class="codeComment">// insert 20 Examples</span>

</code></pre>

<h3>Further Examples</h3>
<p>One limitation of the raw <font face="Courier New, Courier, mono" size="2">bulk_copy</font> 
  algorithm when reading records is that it will read all records into a range 
  regardless of whether they have passed validation or not. </p>
<p>Often what happens when using <font face="Courier New, Courier, mono" size="2">bulk_copy</font> 
  is that one wants to bulk fetch records into an intermediate buffer, then copy 
  them into a final container if they have passed validation via SelValidate. 
  We have written an algorithm to facilitate this common task called <font size="2" face="Courier New, Courier, mono">bulk_fetch_helper(<font face="Courier New, Courier, mono"><font face="Courier New, Courier, mono">ItType</font></font> 
  </font><font face="Courier New, Courier, mono"><font size="2"> <a href="select_iterator.htm">select_iterator</a></font></font><font face="Courier New, Courier, mono" size="2">, 
  size_t buffer_size, OutputIterator output). </font> 
  To use this algorithm, your DBView must use 
  <a href="BulkFetchHandler.htm"><font face="Courier New, Courier, mono" size="2">BulkFetchHandler</font></a> 
  for the IOHandler. Here is an example of how to use this, <font size="2" face="Courier New, Courier, mono">see 
  dtl_algo.h</font> for details:</p>


<pre><code><span class="codeComment">// Read the contents of the DB_EXAMPLE table and return a vector of the resulting rows
// Use DTL bulk fetch helper (to validate records along with the read)</span>
vector&lt;Example&gt; ReadData() {
	vector&lt;Example&gt; results;
	typedef DBView&lt;Example&gt; DBV;
 	DBV view(DBV::Args().tables(&quot;DB_EXAMPLE&quot;)
		.handler(BulkFetchHandler&lt;Example&gt;())
   	);
 	<span class="codeComment">// bulk fetch *all* records into the results container 
   	// use a buffer 128 rows long </span>
   	bulk_fetch_helper(view.begin(), 128, back_inserter(results));
   
   return results;
}
</pre></code>

<h3><font face="Times New Roman, Times, serif">See also</font></h3>

<p><a href="BCA.htm"></a> <font face="Courier New, Courier, mono"> <font face="Courier New, Courier, mono"><font size="2"><a href="select_iterator.htm">select_iterator</a>, 
  <a href="insert_iterator.htm">insert_iterator</a>, <a href="BulkFetchHandler.htm">BulkFetchHandler</a></font></font></font><a
href="IndexedDBView.htm"><font size="2"><!--start footer--></font></a></p>

<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright © 2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body> </html>
