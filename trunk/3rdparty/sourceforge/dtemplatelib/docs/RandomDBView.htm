<html>


<head>
<style>
CODE {COLOR: #990000;}
.code{COLOR: #990000}
.codeComment{COLOR: #008000}
.codeHighlight{BACKGROUND-COLOR: #FFFF00}
.codeFileName{FONT-WEIGHT: bold;}
</style>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Author" content="Mike Gradman">
<meta name="KeyWords"
content="DTL, Oracle, ODBC, database API, C++, Template Library">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<!--
  -- Copyright 2001
  -- Michael Gradman & Corwin Joy
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Corwin Joy & Michael Gradman make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  --
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<!-- Generated by htmldoc -->
<title>RandomDBView&lt;DataObj, ParamObj&gt;</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><font size="6" face="Bookman Old Style"><em><strong><u>dtl</u></strong></em></font></p>

<p><img src="stat.gif" width="6" height="6"> <!--end header--> <br>
</p>
<h1>RandomDBView&lt;DataObj, ParamObj&gt;</h1>



















<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td><img src="containers.gif" width="194" height="38"></td>
        <td align="right"><img src="type.gif" width="194"
        height="39"></td>
    </tr>
    <tr>
        <td valign="top"><b>Category</b>: containers</td>
        <td align="right" valign="top"><b>Component type</b>:
        type</td>
    </tr>
</table>
<h3>Description</h3>

<p><font size="2" face="Courier New">RandomDBView </font>is a <a
href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">Random Access Container</a> with the property 
  that elements are bound to an underlying database. Rows in the table can be accessed and modified using
  random access iterators provided by the container.  To provide random access to the elements in the table,
  the container uses an <a  href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/odbc/htm/odch11pr_12.asp"> ODBC static cursor</a> to guarantee a particular ordering for the rows.
  Rows can be inserted or deleted from the table by using
  the insert() and erase() methods.  The specifics of how rows are updated or deleted
  can be controlled by the user via the SetKey() method which specifies what kind of key to use when updating or
  deleting rows.  Please note that when making changes to the table via insert(), erase() or the non-const iterator,
  these changes will not be visible until the ReQuery() method is called (see <a href="RandomDBView.htm#foot1">[1]</a> for details).</p>

<h3>Definition</h3>

<p>Defined in the <font size="2" face="Courier New">RandomDBView.h</font>
header file.</p>

<h3>Refinement of</h3>

<p><a
href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">Random Access Container</a>
</p>

<h3>Associated types</h3>

<p>The types defined by <a
href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">Random Access Container</a>
.</p>

<h3>Example 1 :</h3>
<pre><code><span class="codeComment">//Create a quick DBView called db_example.
//Rows in this view will be of type db_example_row.
//See <a href="table.htm">DTL_TABLE</a> for details.</span>
DTL_TABLE3(db_example,
   int, int_value,
   string, string_value,
   double, double_value
);


<span class="codeComment">// Random access container example</span>
void RandomDBViewExample()
{
   RandomDBView&lt;db_example_row&gt; view(db_example);

   cout &lt;&lt; &quot;Objects read from DB:&quot; &lt;&lt; endl;
   copy(view.begin(), view.end(), ostream_iterator&lt;db_example_row&gt;(cout, &quot;\n&quot;));

   cout &lt;&lt; &quot;\nElements in reverse order:&quot; &lt;&lt; endl;
   copy(view.rbegin(), view.rend(), ostream_iterator&lt;db_example_row&gt;(cout, &quot;\n&quot;));

   <span class="codeComment">// modify the third row in the table</span>
   RandomDBView&lt;db_example_row&gt;::iterator it = view.begin();
   db_example_row row(it[2]);
   row.int_value++;
   *it = row;
   
   <span class="codeComment">// NOTE THAT FOR THE MODIFIED ROW TO SHOW UP WE MUST CALL ReQuery().
   // Note that there is no guarantee that the third row will show the updated record,
   // since other users may have modified the database or the DB may return records in a different
   // order.  See the ReQuery() function for details.</span>
   cout &lt;&lt; &quot;Show updated result row:&quot; &lt;&lt; endl;
   view.ReQuery();
   cout &lt;&lt; it[2] &lt;&lt; endl;
 
   <span class="codeComment">// show distance functions </span>
   cout &lt;&lt; &quot;Distance from first to last: &quot; &lt;&lt; view.end() - view.begin() &lt;&lt; endl;
   cout &lt;&lt; &quot;Container size: &quot; &lt;&lt; view.size() &lt;&lt; endl;

   <span class="codeComment">// insert and delete rows</span>
   db_example_row row_insert(it[2]);
   row_insert.int_value = 666;
   view.insert(row_insert);
   view.erase(it+(ptrdiff_t)2);
   cout &lt;&lt; &quot;Show result set with inserted/deleted row:&quot; &lt;&lt; endl;
   view.ReQuery();
   copy(view.begin(), view.end(), ostream_iterator&lt;db_example_row&gt;(cout, &quot;\n&quot;));

   <span class="codeComment">// show container comparison operators</span>
   RandomDBView&lt;db_example_row&gt; view2(view);
   cout &lt;&lt; boolalpha;
   cout &lt;&lt; &quot;view == view2 : &quot; &lt;&lt; (view == view2) &lt;&lt; endl;
   cout &lt;&lt; &quot;view &lt; view2 : &quot; &lt;&lt; (view &lt; view2) &lt;&lt; endl;
}
</code></pre>

<h3>Example 2 :</h3>
<pre><code><span class="codeComment">// Random access DBView built from a <a href="DynamicDBView.htm">DynamicDBView</a></span>
void RandomDynamicDBView()
{
	DynamicDBView&lt;&gt; dynamic_view(&quot;DB_EXAMPLE&quot;, &quot;*&quot;);
	RandomDBView&lt;variant_row&gt; random_view(dynamic_view);

	cout &lt;&lt; &quot;Items from DB:&quot; &lt;&lt; endl;
	copy(random_view.begin(), random_view.end(), ostream_iterator&lt;variant_row&gt;(cout, &quot;\n&quot;));
	cout &lt;&lt; &quot;\n\n&quot;;

	cout &lt;&lt; &quot;Items from DB in reverse order:&quot; &lt;&lt; endl;
	copy(random_view.rbegin(), random_view.rend(), ostream_iterator&lt;variant_row&gt;(cout, &quot;\n&quot;));

	<span class="codeComment">// insert and delete rows</span>
	variant_row row_insert(random_view[2]);
	row_insert[&quot;INT_VALUE&quot;] = 666;
	random_view.insert(row_insert);
	random_view.erase(random_view.begin()+(ptrdiff_t)2);
	cout &lt;&lt; &quot;Show result set with inserted/deleted row:&quot; &lt;&lt; endl;
	random_view.ReQuery();
    	copy(random_view.begin(), random_view.end(), ostream_iterator&lt;variant_row&gt;(cout, &quot;\n&quot;));
}
</code></pre>


<h3>Public Base Classes</h3>

<p>RandomDBView</p>

<h3>Template parameters</h3>

<table border="1">
    <tr>
        <th>Parameter </th>
        <th>Description </th>
        <th>Default </th>
    </tr>
    <tr>
        <td valign="top"><tt>DataObj</tt> </td>
        <td valign="top">The type of object that will be written
        to the <font size="2" face="Courier New">RandomDBView</font>.
        This object will be bound through use of the <font
        size="1" face="Courier New">BCA</font><font size="2"> </font>to
        the appropriate columns in the database.
        </td>
        <td valign="top">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top"><tt>ParamObj</tt> </td>
        <td valign="top">The type of object that will be used to
        specify the postfix parameters to the <font size="2"
        face="Courier New">RandomDBView</font>.</td>
        <td valign="top"><font size="2" face="Courier New">DefaultParamObj&lt;DataObj&gt;</font>&nbsp;
        </td>
    </tr>
</table>

<p>&nbsp;</p>

<h3>Associated types</h3>

<p>As defined in a 
<a href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">Random Access Container</a>
.</p>


<p>&nbsp;</p>

<h3>Expression semantics</h3>

<table border="1">
  <tr> 
    <th>Name </th>
    <th>Expression </th>
    <th>Precondition </th>
    <th>Semantics </th>
    <th>Postcondition </th>
  </tr>
  <tr> 
    <td valign="top">Main constructor </td>
    <td valign="top" width="110"> 
      <pre>RandomDBView(const DBView&lt;DataObj, ParamObj&gt;)</pre>
    </td>
    <td valign="top">&nbsp; </td>
    <td valign="top" width="781">Creates a random access container bound to a table as specified
	using a <a href="DBView.htm">DBView</a> to control the paramaters.
    </td>
    <td valign="top">&nbsp;</td>
  </tr>
</table>

<p>&nbsp;</p>

<h3>New Members</h3>
These members are not defined in the <a href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">Random Access Container </a>
requirements but are specific to RandomDBView.
<table border="1">
  <tr> 
    <th>Member </th>
    <th>Where defined </th>
    <th>Description </th>
  </tr>
  <tr> 
    <td valign="top"><pre>RandomDBView(const DBView&lt;DataObj, ParamObj&gt;)</pre> </td>
    <td valign="top">RandomDBView</td>
    <td valign="top">Creates a random access container bound to a table as specified
	using a <a href="DBView.htm">DBView</a> to control the paramaters.</td>
  </tr>

  <TR>
    <TD vAlign=top><TT>void insert(const DataObj&amp; x)</TT></TD>
    <TD vAlign=top>RandomDBView</TD>
    <TD vAlign=top>Inserts <TT>x</TT>. The inserted element will not be visible until ReQuery() is called.</TD>
  </TR>

  <TR>
    <TD vAlign=top><TT>template &lt;class <A href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</A>&gt;
void insert(InputIterator first, InputIterator last)</TT></TD>
    <TD vAlign=top>RandomDBView</TD>
    <TD vAlign=top>Inserts the range <TT>[first, last)</TT>. The inserted elements will not be visible until ReQuery() is called.</TD>
  </TR>

  <TR>
    <TD vAlign=top><TT>void erase(iterator pos)</TT> </TD>
    <TD vAlign=top>RandomDBView</TD>
    <TD vAlign=top>Erases the element at position <TT>pos</TT>. The erased element will not be removed until ReQuery() is called.</TD>
  </TR>

  <TR>
    <TD vAlign=top><TT>void erase(iterator first, iterator last)</TT> </TD>
    <TD vAlign=top>RandomDBView</TD>
    <TD vAlign=top>Erases the elements in the range <TT>[first, last)</TT>. The erased elements will not be removed until ReQuery() is called.</TD>
  </TR>

  <TR>
    <TD vAlign=top><TT>void ReQuery()</TT> </TD>
    <TD vAlign=top>RandomDBView</TD>
    <TD vAlign=top>Close the static ODBC cursor used by the random access iterators. Force re-query of the database to reflect updated/inserted/deleted
    records by this and other users. Note that ReQuery() will affect any copies made of the RandomDBView since these copies will point 
    to the same ODBC cursor.  After a ReQuery() operation any active iterators against the container will be invalidated in the following sense.
    Iterators that were created prior to a ReQuery() will continue to point to the same row number in the recordset, but this does not gurantee that 
    they will have the same meaning as before.  Why?  Because after a ReQuery(), rows may be added/deleted/updated in the result set.  Also, after a 
    ReQuery(), there is no guarantee that the database will return records in the same order that it did before (although it most likely will, 
    but if you need to guarantee an order then it would be best to add a unique ORDER BY clause to your query).</TD>
  </TR>

  <TR>
    <TD vAlign=top><TT>void SetKey(const tstring &amp;KeyFields)</TT> </TD>
    <TD vAlign=top>RandomDBView</TD>
    <TD vAlign=top>Set the key fields to use when updating or erasing records from the table. Argument is a comma delimited list of fields 
     <font size="2" face="Courier New, Courier, mono">&quot;field1, field2, ..., fieldN&quot;</font>.  
     Note that this will override the default set of key fields that were specified in the <TT>DBView</TT> that was used to create the 
     <TT>RandomDBView</TT>.  By default, the container will attempt to automatically determine a unique identifier for rows in the table using the autokeys functionality.
     See <a href="KeyMode.htm">Key Mode</a> for more details.</TD>
  </TR>

Set the list of fields which represents the key 
      for the row. All rows which match the key fields for the old value of 
      the row get updated if the iterator is assigned a new value. (i.e. typical output iterator behaviour 
<code>*output_iterator = new_value; output_iterator++;</code>  In this case
assignment triggers an update operation against the database. )<font face="Courier New, Courier, mono" size="2"> 
      KeyFields </font><font face="Courier New, Courier, mono"><font face="Times New Roman, Times, serif">is 
      a comma separated list of the key fields that the iterator is to use when updating the table: <font size="2" face="Courier New, Courier, mono">&quot;field1, 
      field2, ..., fieldN&quot;</font>. If this function is not called on the 
      <tt>select_update_iterator, <font face="Arial, Helvetica, sans-serif"><font face="Times New Roman, Times, serif" size="3">then</font></font></tt></font></font> 
      the <font size="2" face="Courier New, Courier, mono">select_update_iterator</font> 
      will attempt to automatically determine a unique identifier for rows in the table using the autokeys functionality.
      See <a href="KeyMode.htm">Key Mode</a> for more details.


 
</table>


<h3>Members</h3>
<table border="1">
  <tr> 
    <th>Member </th>
    <th>Where defined </th>
    <th>Description </th>
  </tr>
 <TR>
    <TD vAlign=top><TT>value_type</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>The type of object, <TT>DataObj</TT>, stored in the RandomDBView. 
</TD></TR>
  <TR>
    <TD vAlign=top><TT>pointer</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>Pointer to <TT>DataObj</TT>. </TD></TR>
  <TR>
    <TD vAlign=top><TT>reference</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>Reference to <TT>DataObj</TT> </TD></TR>
  <TR>
    <TD vAlign=top><TT>const_reference</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>Const reference to <TT>DataObj</TT> </TD></TR>
  <TR>
    <TD vAlign=top><TT>size_type</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>An unsigned integral type. </TD></TR>
  <TR>
    <TD vAlign=top><TT>difference_type</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>A signed integral type. </TD></TR>
  <TR>
    <TD vAlign=top><TT>iterator</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>Iterator used to iterate through a <TT>RandomDBView</TT>. 
     Please note that if changes are made to the table via this iterator, the
     changes will not be visible until the ReQuery() method is called.
     This means that algorithms which read back changes they have made to the container 
     will not work with this iterator.  See <a href="RandomDBView.htm#foot1">[1]</a></TD></TR>
  <TR>
    <TD vAlign=top><TT>const_iterator</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>Const iterator used to iterate through a <TT>RandomDBView</TT>. 
    </TD></TR>
  <TR>
    <TD vAlign=top><TT>reverse_iterator</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</A> </TD>
    <TD vAlign=top>Iterator used to iterate backwards through a 
      <TT>RandomDBView</TT>. Please note that if changes are made to the table via this iterator, the
     changes will not be visible until the ReQuery() method is called.
     This means that algorithms which read back changes they have made to the container 
     will not work with this iterator.  See <a href="RandomDBView.htm#foot1">[1]</a></TD></TR>
  <TR>
    <TD vAlign=top><TT>const_reverse_iterator</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</A> </TD>
    <TD vAlign=top>Const iterator used to iterate backwards through a 
      <TT>RandomDBView</TT>. </TD></TR>
  <TR>
    <TD vAlign=top><TT>iterator begin()</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>Returns an <TT>iterator</TT> pointing to the beginning of 
      the <TT>RandomDBView</TT>. </TD></TR>
  <TR>
    <TD vAlign=top><TT>iterator end()</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>Returns an <TT>iterator</TT> pointing to the end of the 
      <TT>RandomDBView</TT>. </TD></TR>
  <TR>
    <TD vAlign=top><TT>const_iterator begin() const</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>Returns a <TT>const_iterator</TT> pointing to the beginning 
      of the <TT>RandomDBView</TT>. </TD></TR>
  <TR>
    <TD vAlign=top><TT>const_iterator end() const</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>Returns a <TT>const_iterator</TT> pointing to the end of 
      the <TT>RandomDBView</TT>. </TD></TR>
  <TR>
    <TD vAlign=top><TT>reverse_iterator rbegin()</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</A> </TD>
    <TD vAlign=top>Returns a <TT>reverse_iterator</TT> pointing to the 
      beginning of the reversed RandomDBView. </TD></TR>
  <TR>
    <TD vAlign=top><TT>reverse_iterator rend()</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</A> </TD>
    <TD vAlign=top>Returns a <TT>reverse_iterator</TT> pointing to the end of 
      the reversed RandomDBView. </TD></TR>
  <TR>
    <TD vAlign=top><TT>const_reverse_iterator rbegin() const</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</A> </TD>
    <TD vAlign=top>Returns a <TT>const_reverse_iterator</TT> pointing to the 
      beginning of the reversed RandomDBView. </TD></TR>
  <TR>
    <TD vAlign=top><TT>const_reverse_iterator rend() const</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/ReversibleContainer.html">Reversible 
      Container</A> </TD>
    <TD vAlign=top>Returns a <TT>const_reverse_iterator</TT> pointing to the 
      end of the reversed RandomDBView. </TD></TR>
  <TR>
    <TD vAlign=top><TT>size_type size() const</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>Returns the size of the <TT>RandomDBView</TT>. </TD></TR>
  <TR>
    <TD vAlign=top><TT>size_type max_size() const</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>Same as size(). 
    </TD></TR>
  <TR>
    <TD vAlign=top><TT>bool empty() const</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top><TT>true</TT> if the <TT>RandomDBView</TT>'s size is <TT>0</TT>. 
    </TD></TR>
  <TR>
    <TD vAlign=top><TT>const_reference operator[](size_type n) const</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">Random 
      Access Container</A> </TD>
    <TD vAlign=top>Returns the <TT>n</TT>'th element. </TD></TR>
  <TR>
    <TD vAlign=top><TT>RandomDBView(const DBView &amp view)</TT> </TD>
    <TD vAlign=top>RandomDBView </TD>
    <TD vAlign=top>Creates a RandomDBView using the table and parameters specified by the given <TT>DBView</TT>. 
  </TD></TR>
  <TR>
    <TD vAlign=top><TT>RandomDBView(const RandomDBView&amp;)</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>The copy constructor. </TD></TR>
  <TR>
    <TD vAlign=top><TT>~RandomDBView()</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>The destructor. </TD></TR>
  <TR>
    <TD vAlign=top><TT>RandomDBView&amp; operator=(const RandomDBView&amp;)</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>The assignment operator </TD></TR>
  
  <TR>
    <TD vAlign=top><TT>void swap(RandomDBView&amp;)</TT> </TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/Container.html">Container</A> </TD>
    <TD vAlign=top>Swaps the contents of two RandomDBViews. </TD></TR>
  
  <TR>
    <TD vAlign=top><PRE>bool operator==(const RandomDBView&amp;, 
                const RandomDBView&amp;)
</PRE></TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/ForwardContainer.html">Forward 
      Container</A> </TD>
    <TD vAlign=top>Tests two RandomDBViews for equality. </TD></TR>

  <TR>
    <TD vAlign=top><PRE>bool operator&lt;(const RandomDBView&amp;, 
               const RandomDBView&amp;)
</PRE></TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/ForwardContainer.html">Forward 
      Container</A> </TD>
    <TD vAlign=top>Lexicographical comparison.</TD></TR>

 <TR>
    <TD vAlign=top><PRE>bool operator&gt;(const RandomDBView&amp;, 
               const RandomDBView&amp;)
</PRE></TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/ForwardContainer.html">Forward 
      Container</A> </TD>
    <TD vAlign=top>Lexicographical comparison.</TD></TR>

 <TR>
    <TD vAlign=top><PRE>bool operator&lt;=(const RandomDBView&amp;, 
               const RandomDBView&amp;)
</PRE></TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/ForwardContainer.html">Forward 
      Container</A> </TD>
    <TD vAlign=top>Lexicographical comparison.</TD></TR>

  <TR>
    <TD vAlign=top><PRE>bool operator&gt;=(const RandomDBView&amp;, 
               const RandomDBView&amp;)
</PRE></TD>
    <TD vAlign=top><A 
      href="http://www.sgi.com/tech/stl/ForwardContainer.html">Forward 
      Container</A> </TD>
    <TD vAlign=top>Lexicographical comparison.</TD></TR>


  <TR>
    <TD vAlign=top><TT>void insert(const DataObj&amp; x)</TT></TD>
    <TD vAlign=top>RandomDBView</TD>
    <TD vAlign=top>Inserts <TT>x</TT>. The inserted element will not be visible until ReQuery() is called.</TD>
  </TR>

  <TR>
    <TD vAlign=top><TT>template &lt;class <A href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</A>&gt;
void insert(InputIterator first, InputIterator last)</TT></TD>
    <TD vAlign=top>RandomDBView</TD>
    <TD vAlign=top>Inserts the range <TT>[first, last)</TT>. The inserted elements will not be visible until ReQuery() is called.</TD>
  </TR>

  <TR>
    <TD vAlign=top><TT>void erase(iterator pos)</TT> </TD>
    <TD vAlign=top>RandomDBView</TD>
    <TD vAlign=top>Erases the element at position <TT>pos</TT>. The erased element will not be removed until ReQuery() is called.</TD>
  </TR>

  <TR>
    <TD vAlign=top><TT>void erase(iterator first, iterator last)</TT> </TD>
    <TD vAlign=top>RandomDBView</TD>
    <TD vAlign=top>Erases the elements in the range <TT>[first, last)</TT>. The erased elements will not be removed until ReQuery() is called.</TD>
  </TR>

  <TR>
    <TD vAlign=top><TT>void ReQuery()</TT> </TD>
    <TD vAlign=top>RandomDBView</TD>
    <TD vAlign=top>Close the static ODBC cursor used by the random access iterators. Force re-query of the database to reflect updated/inserted/deleted
    records by this and other users. Note that ReQuery() will affect any copies made of the RandomDBView since these copies will point 
    to the same ODBC cursor.  After a ReQuery() operation any active iterators against the container will be invalidated in the following sense.
    Iterators that were created prior to a ReQuery() will continue to point to the same row number in the recordset, but this does not gurantee that 
    they will have the same meaning as before.  Why?  Because after a ReQuery(), rows may be added/deleted/updated in the result set.  Also, after a 
    ReQuery(), there is no guarantee that the database will return records in the same order that it did before (although it most likely will, 
    but if you need to guarantee an order then it would be best to add a unique ORDER BY clause to your query).</TD>
  </TR>

  <TR>
    <TD vAlign=top><TT>void SetKey(const tstring &amp;KeyFields)</TT> </TD>
    <TD vAlign=top>RandomDBView</TD>
    <TD vAlign=top>Set the key fields to use when updating or erasing records from the table. Argument is a comma delimited list of fields 
     <font size="2" face="Courier New, Courier, mono">&quot;field1, field2, ..., fieldN&quot;</font>.  
     Note that this will override the default set of key fields that were specified in the <TT>DBView</TT> that was used to create the 
     <TT>RandomDBView</TT>.  By default, the container will attempt to automatically determine a unique identifier for rows in the table using the autokeys functionality.
     See <a href="KeyMode.htm">Key Mode</a> for more details.</TD>
  </TR>

 
</table>

<h4><a name="foot1">[1]</a> RandomDBView design</h4>
<p>When we designed RandomDBView we built the container to work against a <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/odbc/htm/odch11pr_12.asp">"static ODBC scrollable cursor"</a> as the
underlying cursor for retrieving rows.  Using such a cursor gives us a defined and repeatable ordering for the
records which was what we needed to obtain random access iterators.  Unfortunately, static ODBC cursors have the
limitation that if you try to update records directly via the cursor, some ODBC drivers will show the updated records but other drivers will not.  To avoid amiguity, we had the container apply updates via an independently executed query so that we could specify how changes would show up rather than having the behavior be ODBC
driver dependent.  Unfortunately, this means that our non-const
random iterators are not quite standard compliant since changes don't show up until a special ReQuery() method is called.</p>
<p>One possible solution to this problem would be to add logging to the container.  The idea
here would be that when users make a change to a row, we log the updated row.  Then, when the iterator goes
to retrieve a row via <TT>operator *</TT> we would simply check whether a more recent version of the row exists 
in the change log and show it rather than the original.  The problems with this approach are twofold:
<ol>
<li>It slows down record access for users that don't want logging.</li>
<li>If a lot of records are changed, potentially the log could become as large as the entire table.
This sort of defeats the idea of RandomDBView because if the table can be easily held in memory why
not just fetch the whole thing into a container or an IndexedDBView?</li>
</ol>
So, we might eventually add logging to the container, but if we do it would be as an optional template
paramter where the code/overhead would not be compiled into the container for users that don't want it.
</p>
</p>

<h3>See also</h3>

<p><a href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">Random Access Container,</a>
 <a href="DBView.htm">DBView</a>
</p>


<hr>

<p align="left"><a href="index.htm"><img src="dtl_home.gif" alt="[DTL Home]"
width="54" height="54"></a> <br>
</p>

<p>Copyright © 2002, Michael Gradman and Corwin Joy. <script
language="JavaScript"><!-- hide from old browsers
 var modDate = new Date(document.lastModified)
 document.write("<i> Last Updated:</i> " + (modDate.getMonth()+1) + "/" + 
                modDate.getDate() + "/" + modDate.getYear()+".");
 //-->
 </script> </p>

<p><i>Permission to use, copy, modify, distribute and sell this software and its 
  documentation for any purpose is hereby granted without fee, provided that the 
  above copyright notice appears in all copies and that both that copyright notice 
  and this permission notice appear in supporting documentation. Corwin Joy and 
  Michael Gradman make no representations about the suitability of this software 
  for any purpose. It is provided &quot;as is&quot; without express or implied 
  warranty. </i></p>
<A href="http://sourceforge.net"> <IMG src="http://sourceforge.net/sflogo.php?group_id=17082&amp;type=5" width="210" height="62" border="0" alt="SourceForge Logo"></A> 
<p align="right">This site written using the ORB. <a href="http://www.cinenet.net/~cberry/orbinfo.html"><img src="http://www.cinenet.net/~cberry/orb_icon.gif" alt="[The ORB]"
width="54" height="54"></a></p>
</body>
</html>
